{"author":"","clickNumber":0,"content":"\r\n<div class=\"ibm-columns\">\r\n<div class=\"ibm-col-1-1\">\r\n\r\n<p>每个人都在谈论虚拟化。根据宣传，虚拟化将引发 IT 革命（众所周知），优化稀缺资源，并节省每个人的钱。服务器虚拟化有望成为 10 年内最重要的发展之一。但是，虚拟化已经存在了很长时间，而且 IBM 已借助 IBM&#174; System z&#174; 和 Power Systems&#8482; 平台成为这一领域的领导者。在过去几年中，System x&#174; 和基于 Intel 的 x86 架构上的虚拟化技术已发展成熟并变得更加普遍。只要使用得当，虚拟化是 IT 工具箱中一个不可或缺的部分。毋庸置疑，虚拟化已有牢固的根基。<\/p><p>但每种技术都存在风险。管理不良的虚拟化可能导致应用程序运行得更慢，这可能导致最终用户厌烦和不满。IBM 为其部署在虚拟化环境中的产品提供了全面支持。或许由于它的普遍性和诱人的承诺，我们看到客户深受管理不良的虚拟化环境所害，导致他们未能获得任何承诺的收益。<\/p><p>这个由两部分组成的文章系列将通过具体示例探讨虚拟化的优缺点。在第 1 部分中，我们将从总体上解释虚拟化，尤其是它与 IBM Rational 软件的关系。我们将讨论管理良好的虚拟化环境的主要要求，展示 IBM&#174; Rational&#174; ClearCase&#174; 和 IBM&#174; Rational Team Concert&#8482; 在配置不良的虚拟化环境中的行为的示例。我们将提供正确管理虚拟化基础架构的建议和技巧，总结我们测试 Rational 软件和为客户提供咨询的经验。<\/p><p>第 2 部分将继续讨论建议和技巧，包括故障排除和特定于供应商的示例。<\/p><div class=\"dw-sidebar ibm-inset\"><h2 id=\"N10094\">虚拟化的简史<\/h2><p>尽管在过去几年，服务器虚拟化以一种富有吸引力的必要技术的形式出现，但它实际上已经存在了很久。上世纪 90 年代，IBM 在 System z 和 System i&#174; 产品线中引入了虚拟机管理程序技术。2000 年，在 System p&#174; 上实现了逻辑分区 (LPAR)。早在 1999 年，就已经在 System x 和基于 Intel 的 x86 硬件上实现了虚拟机。但仅在最近几年，虚拟化才开始在 Microsoft Windows 和 Linux 环境中变得不可或缺。<\/p><\/div><h2 id=\"1.Cloudsintheforecast|outline\">关于云的预测<\/h2><p>虚拟化通常与云技术密不可分。认识二者的关系至关重要。最宽泛地讲，云技术致力于以服务的形式提供服务器功能。虚拟化是一项管理提供该功能的服务器资源的关键技术。<\/p><p>我们还需要区分公有云和私有云。简单地讲，私有云是隔离的，可在一个公司内管理和托管，有时也可以在外部管理和托管。私有云受防火墙、身份验证、VPN\n                等保护。公有云通常没有这么安全，可以高效地由任何人共享和访问。许多流行的公共服务都是 “在云中” 提供的，比如电子邮件、文件和照片存储。公有云模型吸引了一些组织，因为在理论上，组织或个人仅需要为他们所需的内容付费，服务始终可在任何地方享受，而且云提供商处理了大部分 IT 管理任务。<\/p><p>我们发现，一些 IBM Rational 客户对公有云环境的不稳定性和安全问题呲之以鼻。他们喜欢在内部托管、管理更紧密的私有云方法，在这里，他们可以控制服务器资源分配的所有方面，设置特定的服务质量目标，并采用成熟的高可用性和灾难恢复解决方案。<\/p><p>但是，一些客户喜欢基于 IBM 云的解决方案，因为它们是使用软件开发和托管战略最佳实践来设计和管理的。IBM 也在私有云中提供了 Rational 软件。（参见 <a href=\"#resources\">参考资料<\/a> 部分，获取这些选项的更多信息。）<\/p><h2 id=\"2.Basicconcepts|outline\">基本概念<\/h2><p>简单地讲，虚拟化允许将一个较大的服务器（主机或虚拟机管理程序）分割为更小的服务器（Guest、客户端或虚拟机），并共享组合的资源池。众所周知，大多数服务器都不会始终以全容量运行。因此，为什么不共享和组合它们？两个平均剩余 25% 的容量的服务器可变成虚拟机 (VM) 并托管在单个虚拟机管理程序上，这样该虚拟机管理程序就拥有平均大约 50% 的容量。当然，主机操作系统和虚拟机管理程序软件占用了大量的开销，而且还涉及到其他细节。<\/p><p>主机通过软件或模拟来管理客户端的资源。一般而言，虚拟机中没有任何信息能表明它实际上是虚拟的。在大多数情况下，在虚拟机上安装软件的管理员无法确定他们是否在使用虚拟服务器。最新的创新，比如内置于虚拟机管理程序的芯片组中的虚拟化技术，允许更准确地使用优化过的方式来处理硬件资源，比如外围设备驱动程序。<\/p><h2 id=\"3.TheRationalperspectiveonvirtualization|outline\">Rational 视角下的虚拟化<\/h2><p>IBM <a href=\"http://www-01.ibm.com/software/support/virtualization_policy.html\">支持虚拟化<\/a>，因此 IBM Rational 产品受虚拟化的服务器支持。但是，我们坚信虚拟化的基础架构可适当地进行管理和监视。至关重要的是理解您的虚拟化基础架构如何使用<strong>关联性 (affinity)<\/strong> 和<strong>过度承诺 (overcommitment)<\/strong>，而且还要确保您使用关联性和过度承诺的方式可获得 IBM Rational 软件的最佳性能。<\/p><h3 id=\"3.1.Whatisthisthingcalledaffinity?|outline\">何为 “关联性”？<\/h3><p><strong>关联性（Affinity）<\/strong>（也称为<em>entitlement<\/em>、<em>pinning<\/em> 和<em>dedication<\/em>）是将一个虚拟机上的一种或多种资源（例如内存或处理器）专门用于虚拟机管理程序上的相应资源的能力。主机会在虚拟机需要时分配资源。关联性可确保专用于该虚拟机的已请求资源在虚拟机需要时始终可用。<\/p><p>请记住，相同主机上的所有虚拟机都会共享系统资源。<\/p><p><strong>过度承诺<\/strong> 是指虚拟镜像资源分配总量超过硬件的物理资源（一定要计算虚拟机资源）。为了满足虚拟机的峰值需求，虚拟机管理程序可从其他虚拟机获取资源。有时，所有虚拟机的组合需求可能超过虚拟机管理程序的实际资源量。有时，过度承诺可能导致主机上的所有虚拟机都受到影响。<\/p><h2 id=\"4.Virtualization'sfourdimensions|outline\">虚拟化的 4 个维度<\/h2><p>与任何可配置的技术一样，虚拟化也需要进行权衡。从 Rational 产品角度讲，如果使用虚拟化，我们建议您留意 4 个重要维度。这些维度或许是任何服务器最重要的特征：<\/p><ul class=\"ibm-bullet-list\"><li>CPU 和内存<\/li><li>磁盘输入/输出 (I/O)<\/li><li>存储<\/li><li>网络<\/li><\/ul><h5 id=\"4.0.1.Table1.Fourdimensionsofvirtualization|outline\">表 1. 虚拟化的 4 个维度<\/h5><table border=\"0\" cellpadding=\"0\" cellspacing=\"0\" class=\"ibm-data-table\" summary=\"\"><thead xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"><tr><th>&#160;<\/th><th>最差的（未管理的）虚拟化特征<\/th><th>最佳的（受管理的）虚拟化特征<\/th><\/tr><\/thead><tbody xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"><tr><td><strong>CPU<\/strong><\/td><td><ul class=\"ibm-bullet-list\"><li>芯片组没有 VT 或 V-chip 支持<\/li><li>共享资源池<\/li><li>没有授权的、有保障的或有优先级的调度<\/li><li>其他 VM 的容量未知<\/li><li>vCPU 是物理 CPU 的一小部分<\/li><li>模拟超线程或多线程（非 Nehalem 类）<\/li><\/ul><\/td><td><ul class=\"ibm-bullet-list\"><li>芯片组具有 VT 支持<\/li><li>CPU 关联性允许 VM 具有专用的 vCPU<\/li><li>在与物理 CPU 相等的水平上分配 vCPU<\/li><\/ul><\/td><\/tr><tr><td><strong>内存<\/strong><\/td><td><ul class=\"ibm-bullet-list\"><li>内存和 CPU 不在同一位置<\/li><li>过度承诺导致过量交换（包括跨其他 VM 交换）<\/li><\/ul><\/td><td><ul class=\"ibm-bullet-list\"><li>设置了关联性<\/li><li>内存和 CPU 在同一位置<\/li><\/ul><\/td><\/tr><tr><td><strong>磁盘 I/O 和存储<\/strong><\/td><td><ul class=\"ibm-bullet-list\"><li>具有低 IOPS 的单一的本地 SATA 或 IDE 磁盘<\/li><li>本地 RAID，但驱动器槽有限<\/li><li>访问相同存储的通道数量未知<\/li><\/ul><\/td><td><ul class=\"ibm-bullet-list\"><li>光纤通道连接的存储<\/li><li>文件存储<\/li><\/ul><\/td><\/tr><tr><td><strong>网络<\/strong><\/td><td><ul class=\"ibm-bullet-list\"><li>一个 1G（或更少）网络端口由所有 VM 共享<\/li><\/ul><\/td><td><ul class=\"ibm-bullet-list\"><li>专用网络端口<\/li><li>10G 或更好的网络<\/li><li>链接聚合<\/li><\/ul><\/td><\/tr><\/tbody><\/table><h3 id=\"4.1.CPU|outline\">CPU<\/h3><p>现代 CPU 的设计已考虑了虚拟化。例如，Intel 的 VT 和 AMD 的 V 芯片技术可确保 x86 CPU 最佳地处理虚拟化的负载。其他平台可使用硬件协助的虚拟化，这有望通过对主机 CPU 的直接寻址实现更高效的虚拟化。<\/p><p>在管理最差的虚拟化环境中，实际硬件和 CPU 不支持虚拟化，或者仅通过模拟和较慢的软件层来提供非常有限的支持。在管理最差的环境中，没有投入精力来跟踪其他 VM。事实上，其他 VM 可随意地从其他 VM 轻松地盗走 CPU 周期。零散的 CPU 有时可能会出现，或者是不可避免的，但在经过理想管理的虚拟化环境中，VM 可访问所有物理 CPU。<\/p><h3 id=\"4.2.Memory|outline\">内存<\/h3><p>在管理最差的虚拟化环境中，服务器内存和 CPU 未在同一个总线上。现代硬件利用了非一致内存访问 (NUMA)，因此，处理器访问本地内存的速度比访问位于另一个总线上的远程内存的速度更快。在现代硬件上，与专为高速和可伸缩性而设计的 NUMA 架构背道而驰是毫无意义的。<\/p><p>请提防您的虚拟化软件可能提供的选项和设置，因为它常常很容易与本来高效的 NUMA 架构相抵触。让位于位置 A 的内存引用位于位置 B 的 CPU 似乎很有用，但这种安排会为服务器带来额外的工作，可能导致性能下降。在理想的托管 VM 中，内存和 CPU 位于同一个总线上。<\/p><h3 id=\"4.3.DiskI/Oandstorage|outline\">磁盘 I/O 和存储<\/h3><p>在管理最差的虚拟化环境中，单个本地驱动器支持所有 VM。由于多个服务器共享同一个磁盘，所以实际的 I/O 活动现在发生在磁盘上的多个位置。本地硬盘驱动器可能因为活动量增加而更快地遇到故障。理想情况下，VM 被分配到特定的驱动器上，每个驱动器都有自己的 I/O 和机制。在一些理想环境中，存储可能位于 filer 上，它们非常适合虚拟化的需求并可通过光纤通道进行访问。<\/p><h3 id=\"4.4.Network|outline\">网络<\/h3><p>可能很容易想到一种糟糕的虚拟化网络配置。网卡是根据它们的容量（例如 1 Gb/秒）来度量的。当由 VM 共享时，它们的容量就会被细分（2 个 VM 共享 1 Gb 将得到最大 500 Mb/秒）。管理最差的虚拟化环境中，环境中托管的所有 VM 都共用一个网卡或端口，总吞吐量会由 VM 瓜分。在管理非常理想的虚拟化环境中，每个 VM 都有一个专用的网络端口，或者 VM 共享一个 10 Gb 或更快的网络连接。<em>链路聚合<\/em> 是一种网络技术，其中结合使用了多个网络连接来实现冗余和吞吐量优化。<\/p><h2 id=\"5.Best(managed)virtualizationcharacteristics|outline\">（管理）最佳的虚拟化特征<\/h2><p>对于管理最佳、最理想的虚拟化环境，我们可将前面的要点简单地总结为：<\/p><ul class=\"ibm-bullet-list\"><li>虚拟 CPU 的数量绝不会超过物理 CPU 的数量。<\/li><li>每个 VM 的 CPU 分配与实际的物理 CPU 对应。<\/li><li>虚拟 RAM 量绝不会超过实际 RAM 量。<\/li><li>有充足的存储和网络可供访问。<\/li><\/ul><p>一些人可能会争辩说，此建议违背了虚拟化的宗旨，或者我们有些担忧过度。在理想的世界中，每个 VM 能够按需访问无限多的资源。但是，在实际中，VM 必须共享资源。我们发现，在通过严格管理资源以确保始终有专用的 CPU、内存和其他资源时，Rational 软件在虚拟化服务器上的运行效率是最高的，且操作行为最有效。<\/p><p>如果管理得当，过量使用的资源分配可能是一种可行的虚拟化战略，但这只在实际资源得到紧密监视时才会有效。当确实出现过量使用时，组织必须愿意接受缓慢或无法预测的性能与优化的管理成本之间的折衷方案。<\/p><h2 id=\"6.Itslikemusicalchairs|outline\">就像一种抢椅游戏<\/h2><p>在管理糟糕的虚拟化环境中，虚拟机可任意地共享主机的资源。任何 VM 都可以请求获得比分配给它的更多的内存或 CPU，管理较差的虚拟机管理程序会提供这些资源，对来自其他 VM 的那些请求进行时间分片（time-slicing）。<\/p><p>这实际上就像抢椅游戏。一个 16 处理器、64 GB RAM 服务器可能托管 5 个不同的 4 处理器、16 GB RAM 服务器。当虚拟机 A 需要处理器周期时，它会向主机请求它们。主机将从任何其他 4 个 VM 获取任何未用的处理器时间，或者将其他 VM 的数据写入磁盘以释放资源。<\/p><p>如果 5 个服务器决不会同时以较高容量运行，那么此模型可能会完美地运行。最终用户决不会看到的后端进程可能运行得更慢，存在更多的中断。但是，在应用程序停止或变得缓慢时，最终用户接触的任务关键型应用程序可能会受到过量使用的影响。<\/p><h2 id=\"7.CaseStudyNo.1.TheMysteryMenu,RationalTeamConcertinthreebadlymanagedclouds|outline\">案例分析 1. “The Mystery Menu”，3 个管理较差的云中的 Rational Team Concert<\/h2><p>IBM&#174; Rational&#174; Performance Engineering 团队分析了来自某个云提供商的 3 个 VM 镜像。每个镜像都是不同的，就像我们从一个菜单中选择了小、中和大的分区大小。除了知道每个 VM 所提供的虚拟 CPU 和内存的理论容量之外，我们对 VM 的实际规格知之甚少（存储类型、网络、处理器速度等）。<\/p><p>VM A 有 4 个虚拟 CPU 和 8GB RAM；VM B 有 8 个虚拟 CPU 和 16GB RAM；VM C 有 16 个虚拟 CPU 和 16GB RAM。我们打算向每个镜像提供相同的负载量，查看不同大小的镜像的行为。<\/p><p>我们向 VM A（4 个 vCPU、8GB）提供了一个模拟的多用户负载，CPU 和内存容量使用率很快达到了 100%。性能还可以接受，但我们希望改进它。如果使用物理机器，我们可以立即增加核心数量和 RAM 量，我们过去就是这么做的。<\/p><p>我们向 VM B（8 个 vCPU，16GB）提供了相同的负载，结果令我们大吃一惊：性能显著下降，但与使用的 CPU 和内存成比例。CPU 和内存不再是瓶颈。相反，磁盘 I/O 成为了瓶颈。<\/p><p>当向 VM C（16 个 vCPU，18GB）提供相同的负载时，性能变得更糟糕，而且使用的 CPU 比例进一步降低。瓶颈仍然是磁盘 I/O。（澄清一下，我们将磁盘 I/O 平均分配到每个测试上，以 25% 的增量表示平均值。）<\/p><h5 id=\"N101A7\">图 1. 未管理的云中的 3 个 VM<\/h5><img alt=\"条形图显示了各个 VM 的 CPU、内存和磁盘结果\" src=\"/sunshine_new/images/负624275932/image001.jpg\" width=\"574\" /><p>我们的解释是，这些镜像托管在一个未管理的云上，更大的 VM（B 和 C）事实上从其他 VM 盗取了核心和内存。由于不知道虚拟机管理程序的管理方式，所以我们只能推测过量使用的资源导致了磁盘交换。由于系统将大部分时间用于将其他镜像写入磁盘中，以获取我们的 VM 请求的资源，所以 CPU 未得到充分利用。（在其他 VM 请求周期和 RAM 时，我们的镜像可能也正写入磁盘中。）<\/p><p>图 2 提供了另一种查看相同的数据的方式，显示了未用和已用的内存、未用和已用的 CPU、未用和已用的磁盘的结果。这可以更清楚地解释所发生的事情。<\/p><h5 id=\"N101B5\">图 2. 同样的 3 个 VM 的另一种分析<\/h5><img alt=\"条形图显示了结果\" src=\"/sunshine_new/images/负624275932/image002.jpg\" width=\"576\" /><p>对于图 2，我们描绘了 3 个 VM，以便 CPU 和内存量彼此成比例，我们在图表中使用了 <em>wicket<\/em> 或未填充的条来表示 3 个 VM 未用的 CPU 和内存容量。VM A 使用了分配给它的所有 CPU 和内存，但没有使用太多磁盘。VM B 访问了更多的 CPU 和内存，但无法完全使用它们，因为增多的磁盘活动成为了它的瓶颈。VM C 提供了更多的 CPU，该 VM 仅使用了其中的一少部分，因为像 VM B 一样，VM C 的瓶颈也在磁盘上。<\/p><p>记得管理物理环境的人们可能对这些结果感到惊讶。在大多数具有物理硬件的情况下，增加 CPU 和内存也会提高性能。但是，在管理较差的虚拟化环境中，CPU 和内存是不受限制的，增加 VM 的 CPU 和内存有时可能导致更慢的性能。<\/p><h3 id=\"7.1.Ourconclusions|outline\">我们的结论<\/h3><p>我们的第一个结论是确认，在管理得当的 VM 中，Rational 软件将会正确地执行。案例分析 1 提供了未管理的云中行为不当的应用程序的示例。<\/p><p>第二，我们重申，VM 必须在<em>托管的<\/em> 环境中使用。在此案例分析中，我们没有环境中的虚拟机管理程序或其他 VM 的任何知识。我们相信性能取决于相同环境中其他 VM 的配置和行为，但我们无法确认这一点。<\/p><p>第三，我们告诫不要假设适用于物理硬件的原则也同样适用于 VM 环境。如果拥有过量的 CPU 和内存资源，那么增加 VM 的大小可能会带来提高，但我们实际上会过量使用资源。<\/p><p>最后，我们重申过量使用资源会得到糟糕的 VM，进而导致糟糕的应用程序性能的观点。在此示例中，我们的应用程序是 Rational Team Concert，但我们观察到，无论采用何种虚拟化技术和操作系统，其他 Rational 软件在管理较差的环境中的性能也很差。<\/p><h2 id=\"Sojusthowimportantisaffinity\">案例分析 2.\n                “那么，关联性有多重要？”ClearCase 具有异常负载，并运行在会产生“过量使用”的云中<\/h2><p>我们的下一个示例是在一次会议中实时演示的。我们演示了设置关联性（有时称为<em>授权<\/em> 或<em>专用资源<\/em>）可稳定 IBM Rational 应用程序，而不使用关联性可能导致其他 VM 镜像能够接管资源，并严重减缓您的应用程序性能。<\/p><p>我们使用了一个具有 32 个虚拟 CPU 和 32GB RAM 的 Intel Sandy Bridge 服务器，它托管着两个独立的 IBM&#174; Rational&#174; ClearCase&#174; 部署。每个 ClearCase 部署包含同等的 Red Hat Enterprise Linux (RHEL) 5.5 VM（4 个 vCPU、8GB RAM），以及一个 ClearCase VOB 服务器和托管 Web 视图的 ClearCase CM 服务器。我们使用了 VMware ESX 来托管 VM。部署 A 中托管 ClearCase 的 VM 未使用关联性，而部署 B 中的 ClearCase VM 同时拥有 CPU 和内存关联性。在云外部，在物理硬件上，我们使用了两个 IBM&#174; Rational&#174; Performance Tester 工作台对每个部署进行 100 个用户的负载模拟。<\/p><p>在 ESX 服务器上，我们创建了几个 VM，它们什么都不做，只创造 CPU、内存和磁盘需求。这些 VM 包含执行数学运算和分配所有空闲内存的简单程序，这会得到 100% 的内存使用率和 100% 的 CPU 使用率。我们启动了这些程序，以便以过量使用 ESX 服务器，使其使用率达到 300%。（我们要求这些行为异常的 VM 在虚拟机管理程序上使用 3 倍的物理 CPU 和内存量。）<\/p><p>图 3 和图 4 是从 Rational Performance Tester 获取的。它们展示了部署 A 和部署 B 所执行的 ClearCase 事务的平均响应时间（以毫秒度量）。两种部署的行为一致，直到到达 1,200 秒标记后我们在这些行为异常的 VM 上激活这些程序时。部署 A（其中 ClearCase VM 没有使用关联性运行）的响应时间迅速增加。部署 B（其中 ClearCase VM 使用关联性运行）偶尔会变得缓慢，但是，除了几个峰值外，它一直表现得很稳定。在到达 4000 秒标记时，这些行为异常的镜像停止了，部署 A 返回到正常状态。（请注意，y 轴上的刻度（它显示以毫秒度量的平均事务响应时间）在两个图表中是不同的。）<\/p><h5 id=\"N101F3\">图 3. 没有关联性的部署 A<\/h5><img alt=\"该图表显示了糟糕的 ClearCase 响应时间\" src=\"/sunshine_new/images/负624275932/image003.jpg\" width=\"580\" /><h5 id=\"N101FD\">图 4. 具有 CPU 和内存关联性的部署 B<\/h5><img alt=\"该图表显示了可接受的 ClearCase 响应时间\" src=\"/sunshine_new/images/负624275932/image004.jpg\" width=\"580\" /><p>对比这些测试，没有关联性的部署 A 上的 ClearCase 操作平均花费了 118 秒才完成，而具有关联性的部署 B 平均仅花费了 18 秒。平均而言，具有关联性的部署 B 快 6 到 7 倍。<\/p><h3 id=\"8.1.Ourconclusions|outline\">我们的结论<\/h3><p>案例分析 2 可能是一种极端情况，因为我们创建了一个可能不切实际的行为异常的 VM。但是，我们能够清晰地表明，如果不知道虚拟机管理程序在做什么或者其他 VM 需要请求资源，那么应用程序的性能可能降低。<\/p><p>设置处理器和内存关联性，允许我们关注的 VM 上的应用程序保持一致的性能和行为，甚至在环境中的剩余 VM 执行极端负载时也是如此。<\/p><p>请注意，在没有关联性的部署 A 中，在行为异常的 VM 停止后，性能会恢复正常。如果您的环境中有 VM 允许过量使用资源或不受限制地运行，那么您可能会在自己的 VM 中看到类似的行为。<\/p><p>在此示例中，我们的 Rational 应用程序是 ClearCase，但我们已在管理较差的类似环境中的其他 Rational 软件中看到了类似的糟糕性能，无论采用何种虚拟化技术和操作系统。<\/p><h2 id=\"9.Virtualizationisheretostay,solearntouseitwisely|outline\">虚拟化建立牢固根基，所以请学习如何聪明地使用它<\/h2><p>毋庸置疑，虚拟化已建立牢固根基。越来越多的 IBM Rational 客户开始使用它和依赖它。但是，正如我们所展示的，如果使用不当，虚拟化会给软件的操作带来不利影响。<\/p><p>重要的是理解虚拟化和知道如何管理它。我们希望，我们的案例分析展示了管理较差的虚拟化环境的一些可能的负面影响。在考虑我们的案例分析后，您有可能会识别管理较差的虚拟化环境的症状。在第 2 部分中，我们将探索虚拟化异常的更多症状。我们还会提供故障排除技巧并展示特定于供应商的示例。<\/p><CMA ID: 953009><Site ID: 10><XSLT stylesheet used to transform this file: dw-document-html-7.0.xsl>\r\n\r\n\r\n<\/div>\r\n<\/div>\r\n","createTime":"2014-06-19 00:00:00","deployTime":"2014-06-19 00:00:00","id":0,"intro":"如果您目前正在 IBM Rational 软件上使用虚拟化方法，是否一切都像您预期的一样顺利？三位 IBM 专家将介绍 Rational 视角下的虚拟化，以及虚拟化环境从 Rational 应用程序中获取最优性能的关键要求。他们还将分享两个案例分析的细节和故障排除技巧。","keyword":"","recommend":false,"source":"http://www.ibm.com/developerworks/cn/rational/smart-virtualization-1/index.html","title":"利用虚拟化成就智慧: 第 1 部分：IBM Rational 软件最佳实践","typeId":0,"updateTime":"2014-06-19 00:00:00"}
{"author":"","clickNumber":0,"content":"\r\n<div class=\"ibm-columns\">\r\n<div class=\"ibm-col-1-1\">\r\n\r\n<div class=\"dw-sidebar ibm-inset\"><h2 id=\"N10073\">虚拟化的四个维度<\/h2><p>CPU<br />内存<br />磁盘输入/输出（I/O）及存储<br />网络<\/p><\/div><p>这个由两部分组成的系列文章将通过具体示例探讨虚拟化的优缺点。在<a href=\"http://www.ibm.com/developerworks/cn/rational/smart-virtualization-1/\">第 1 部分<\/a>中，我们将从总体上解释虚拟化，尤其是它与 IBM Rational 软件的关系。我们将覆盖虚拟化的四个维度，CPU、内存、磁盘输入/输出（I/O）及存储、网络等应如何通过关联性（专用资源）被恰当地管理而不会过度承诺。我们所给出的例子展示了被恰当管理的虚拟化是如何彻底影响  IBM&#174; Rational&#174; 产品。尤其是我们所展示的两个案例分析，其中的 IBM&#174; Rational Team Concert&#8482; 及 IBM&#174; Rational&#174; ClearCase&#174; 托管在没有关联性配置的虚拟机中，虚拟环境配置欠佳，从而使之性能糟糕。<\/p><p>在第 2 部分中，我们将更加深入探究针对过度承诺的折中考虑。基于我们在 Rational 产品和曾服务客户身上测试得来的经验，我们将提供建议和技巧，故障排除和特定于供应商的示例来帮助您更好地管理您的虚拟化基础设施。所有提及的故障排除场景和建议都来自 <a href=\"https://jazz.net/wiki/bin/view/Deployment/VirtualizationTroubleshooting\">jazz.net Deployment wiki<\/a>。<\/p><h2 id=\"casestudyno3\">案例分析 3. 结合 ClearCase\n                探索过度承诺（overcommitment）<\/h2><p>案例分析 2 演示了当托管在没有专用资源的虚拟机（VM）上时，IBM Rational ClearCase 是如何糟糕。我们建议要为 IBM Rational 产品配置关联性和专用资源，来避免可能存在的过度承诺。然而，我们也认识到受管理的过度承诺对于虚拟化而言仍然具有显著的价值。案例分析 3 着眼于不同程度的过度承诺。<\/p><p>在我们其中之一的测试中，我们考察了一台拥有 4 个八核 CPU 及 64 GB内存的 Intel Westmere-EX 服务器。这台服务器启用了超线程，对于虚拟机管理程序（hypervisor）而言，这台拥有 32 个核心的服务器就如同拥有 64 个逻辑处理器（64 vCPU）。ClearCase CM 服务器安装在其中一个拥有 4 vCPU 和 8 GB RAM 的 VM 上，但没有专用资源或关联性。<\/p><p>在同一个虚拟机管理程序上我们还创建了 96 个拥有 4 vCPU 和 4 GB RAM 的 VM（64-位 RHEL 5.5）。这些 96 个镜像被用于产生背景负载。这 96 个镜像被组织成六组 16 VM 群组。每一个 16-VM 群组包括 64 vCPU 和 64 GB RAM，这与 Westmere-EX 自身的硬件维度是相符合的。因此每一个 16-VM 群组都 100%　体现了 Westmere-EX 服务器的硬件配给。<\/p><p>为了捕获基线平均响应时间数据（如表 1 a 行所示），我们仿真了 100 个用户的 UCM 负载并传递给 ClearCase CM 服务器。所有六组\n                VM 则处于挂起状态。<\/p><p>在下一个测试（表 1 中 b 行到 g 行），我们使用了六组 16 VM 的群组来创建背景负载。每一个 VM 都托管一个本机程序，运行多线程的平方根数学计算并分配了内存。这一“贪婪”程序确保每一个 VM 客户端将会 100% 消耗为它分配的处理器和内存。每一个测试以 16 个 VM 或 100% 相应的 Westmere-EX 服务器物理硬件为单位增加背景负载。<\/p><p>行 b 显示了 100 个用户 CC CM 服务器测试的平均响应时间数据，以及相应的 100% 的 Westmere-EX 负载（一组 16 VM 都运行“贪婪”程序）。行 c 到行 g 显示了 100 用户 CC CM 服务器测试随着逐步增加每一组 16 VM 的平均响应时间数据（每一步都逐步增加 100% 相应的 Westmere-EX 服务器负载）。<\/p><p>行 g 显示了在所有 96 个 VM 都在运行“贪婪”程序，即 600% 物理 Westmere-EX 服务器容量的情况下，我们的 100 个用户 CC CM 服务器测试的平均响应时间。响应时间非常糟糕。我们过度承诺的服务器无法在合理的响应时间内为 100 个用户 CC 负载提供服务。<\/p><p>让我们的服务器保证合理的性能的唯一办法是运行在一个具有专用资源的 VM 上。行 h 显示了与行 g 相同的测试，但 CC CM 服务器具有关联性和专用资源。在 600% 的负载下，CC CM 服务器以可接受的性能进行了响应。<\/p><h5 id=\"Table1\">表 1：使用 ClearCase 来展示关联性效果的性能测试<\/h5><table border=\"0\" cellpadding=\"0\" cellspacing=\"0\" class=\"ibm-data-table\" summary=\"9 column table with heading row and center-aligned content\"><thead xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"><tr><th>&#160;<\/th><th>a<br />物理机器<\/th><th>b<br />100% 无关联性的负载<\/th><th>c<br />200% 无关联性的负载<\/th><th>d<br />300% 无关联性的负载<\/th><th>e<br />400% 无关联性的负载<\/th><th>f<br />500% 无关联性的负载<\/th><th>g<br />600% 无关联性的负载<\/th><th>h<br />600% 有关联性的负载<\/th><\/tr><\/thead><tbody xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"><tr><td><strong>产生流<\/strong><\/td><td><strong>1.03<\/strong><\/td><td> 1.57 <\/td><td><strong>1.87<\/strong><\/td><td> 3.48 <\/td><td> 29.81 <\/td><td> 39.76 <\/td><td> 153.29 <\/td><td><strong>1.88<\/strong><\/td><\/tr><tr><td><strong>产生活动<\/strong><\/td><td><strong>0.33<\/strong><\/td><td> 0.50 <\/td><td><strong>0.55<\/strong><\/td><td> 1.64 <\/td><td> 24.84 <\/td><td> 44.35 <\/td><td> 176.21 <\/td><td><strong>0.61<\/strong><\/td><\/tr><tr><td><strong>集活动<\/strong><\/td><td><strong>0.59<\/strong><\/td><td> 0.92 <\/td><td><strong>1.04<\/strong><\/td><td> 3.59 <\/td><td> 68.55 <\/td><td> 69.45 <\/td><td> 159.14 <\/td><td><strong>0.99<\/strong><\/td><\/tr><tr><td><strong>产生目录<\/strong><\/td><td><strong>1.98<\/strong><\/td><td> 2.78 <\/td><td><strong>3.04<\/strong><\/td><td> 4.93 <\/td><td> 64.72 <\/td><td> 70.43 <\/td><td> 161.33 <\/td><td><strong>3.35<\/strong><\/td><\/tr><tr><td><strong>检出目录<\/strong><\/td><td><strong>0.72<\/strong><\/td><td> 0.91 <\/td><td><strong>0.97<\/strong><\/td><td> 2.08 <\/td><td> 30.82 <\/td><td> 38.17 <\/td><td> 125.30 <\/td><td><strong>1.12<\/strong><\/td><\/tr><tr><td><strong>检入目录<\/strong><\/td><td><strong>0.61<\/strong><\/td><td> 0.78 <\/td><td><strong>0.82<\/strong><\/td><td> 1.35 <\/td><td> 11.86 <\/td><td> 13.73 <\/td><td> 68.03 <\/td><td><strong>0.91<\/strong><\/td><\/tr><tr><td><strong>产生文件<\/strong><\/td><td><strong>1.40<\/strong><\/td><td> 1.78 <\/td><td><strong>1.93<\/strong><\/td><td> 3.23 <\/td><td> 33.10 <\/td><td> 37.54 <\/td><td> 95.58 <\/td><td><strong>2.28<\/strong><\/td><\/tr><tr><td><strong>检出文件<\/strong><\/td><td><strong>0.91<\/strong><\/td><td> 1.25 <\/td><td><strong>1.45<\/strong><\/td><td> 1.51 <\/td><td> 3.81 <\/td><td> 5.42 <\/td><td> 68.12 <\/td><td><strong>1.47<\/strong><\/td><\/tr><\/tbody><\/table><p>这个例子展示了多个情况。没有关联性，产品的性能会大幅度降低到不可用的程度。更进一步，仅仅拥有 CC CM 服务器访问权限的 ClearCase 管理员无法理解甚至无法猜测究竟发生了什么情况。这个背景负载也许过于极端，但非常清晰地演示了过度承诺的影响。<\/p><p>不过，虚拟化并不是一个无助的命题。比较表 1 中的 c 和 h 行，这两行显示了 CC CM 服务器在没有关联性而虚拟机管理程序承担 200% 负载时，以及 CC CM 服务器有关联性而虚拟机管理程序承担 200% 负载时的情形。两种情形相似的响应时间足以表明，如果不可能有专用资源时虚拟机管理程序的能力无法承担超过 200% 负载，而对于资源有关联性的配置则可以提供可接受的响应时间。这个事实表明，如果管理得当的话，过度承诺可以成为一个切实可行的选择。<\/p><h2 id=\"casestudyno4\">案例分析 4. 过度承诺或低于承诺：性能 vs. 能力<\/h2><p>案例分析 4 比较了两个不同 VM 配置在同一台 ESX 服务器，即一台 32 vCPU 及 32 GB RAM 的 Intel SandyBridge 服务器（E5-2680 @\n                2.70GHz）上时 ClearCase 的响应时间。配置 A 使用了 100% 的 VMware ESX 的能力，而配置 B 则使用了 150%。<\/p><p>在配置 A 中，ESX 服务器托管 VOB 服务器，一个 ClearCase Remote Client（CCRC）服务器以及两个 VM 运行案例 3 中描述的“贪婪”程序。每一个 ESX 服务器上的 VM 运行 RHEL 5.6，并分配了 8 vCPU 和 8 GB RAM。配置 A 拥有  100% 专用的 ESX 硬件资源。<\/p><p>配置 B 使用配置 A 相同的四个 VM；不过，额外的两个 VM 被增加到 ESX 服务器上。这两个额外的 VM 具有 8 vCPU 及 8 GB\n                RAM 来和其他四个 VM 对齐。当所有六个镜像都在使用时（48 vCPU 及 46 GB RAM），ESX 服务器被分配了 150% 的能力。两个额外的 VM 创建了一个二级 CC 区域，并执行在两个 CC 区域之间的活动来创建在 ESX 服务器上的负载。这些活动包括导入、mklabel 及构建操作，并在测试期间持续运行。<\/p><p>在本案例的背景负载中有两台其他的 ClearCase 虚拟机组成：一台 VOB 服务器及一台 ClearCase 客户端来作为视图（view）和构建服务器，也同样执行 mklabel 和导入操作。一个专用的 1 GB 网络连接着这些服务器和其他镜像。<\/p><p>这一 ClearCase 测试环境是实际 ClearCase 开发 VOB 的一个备份。100 VOB 被散布到两台服务器上。10 个最高容量的 VOB 被托管在 VM 镜像（VOB 服务器）上。剩余的 90 个 VOB 被托管在一个分离的物理服务器上，在此服务器上还有许可证服务器（license server）和注册服务器（registry server）。<\/p><p>这一用于比较的工作负载仿真了在一个 12 小时的时间段内大约 250 个并发用户。背景工作负载由以下方面组成：<\/p><ul class=\"ibm-bullet-list\"><li>200 个 CCRC 用户每小时执行 15 次事务<\/li><li>50 个动态视图用户用户每小时执行 15 次事务<\/li><li>38 个持续 clearmake 构建运行在 12 个不同的额外构建主机上（Unix 及 Windows）<\/li><li>1 台独立的 Unix 客户端运行集成任务<\/li><\/ul><h5 id=\"Table2\">表 2. 两个 ESX 服务器配置<\/h5><table border=\"0\" cellpadding=\"0\" cellspacing=\"0\" class=\"ibm-data-table\" summary=\"\"><thead xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"><tr><th>&#160;<\/th><th> 配置 A<br /> （运行 100% 能力的 ESX 服务器）<\/th><th> 配置 B<br /> （运行 150% 能力的 ESX 服务器）<\/th><\/tr><\/thead><tbody xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"><tr><td> ESX 服务器 <br />(32 vCPU，32 GB RAM) <\/td><td> 服务器托管 4 个镜像: <ul class=\"ibm-bullet-list\"><li>1 台 VOB 服务器<\/li><li>1 台 CCRC 服务器<\/li><li>2 台“贪婪”服务器<\/li><\/ul><\/td><td> 服务器托管 6 个镜像: <ul class=\"ibm-bullet-list\"><li>1 台 VOB 服务器<\/li><li>1 台 CCRC 服务器<\/li><li>2 台“贪婪”服务器<\/li><li>2 台 CC 服务器在分离的区域<\/li><\/ul><\/td><\/tr><\/tbody><\/table><p>图 1 比较了两个配置在超过 12 个小时的平均相应时间。相比配置 A，对于基本 ClearCase 操作配置 B 慢了 35%，UCM 操作慢了 25%。构建时间也慢了 22%。<\/p><h5 id=\"fig01\">图 1. 比较两种 ClearCase 环境<\/h5><img alt=\"当 ESX 服务器能力被分配在 150% 时 ClearCase 慢了\" src=\"/sunshine_new/images/1555978846/image001.jpg\" width=\"815\" /><p><strong>进一步探讨关联性和预订<\/strong><\/p><p>在第 1 部分，我们定义了关联性来作为在一台虚拟机上专用一个或更多资源的能力，这些资源来自虚拟机管理程序的相应资源。在一些虚拟机管理程序中，还有预订（reservation）的概念。预订在含义上与我们用来表达关联性的概念相一致。在这些系统中关联性标志着更多的是一个 VM 的 CPU 可以恰好指派给多少个物理核心。如果您指派您的专用 VM 到特定的 CPU，您也应同样分配您其余的 VM 到不同的 CPU 上。具有 CPU 关联性的 VM 或许性能更糟糕，因为他们也许无法被安排到多线程任务上。<\/p><p>我们建议 VM 拥有对虚拟机管理程序专用资源的访问。对于虚拟机管理程序是超线程，或者虚拟机管理程序被设计用于执行资源的自动化加载平衡的情形，还有一些额外的概念需要记住。<\/p><h3 id=\"2.1.CPUaffinityconsiderations|outline\">CPU 关联性注意事项<\/h3><p>如果使用 CPU 关联性，考虑以下问题：<\/p><ul class=\"ibm-bullet-list\"><li>如果您的虚拟机管理程序使用自动化加载平衡，CPU 关联性将会阻止虚拟机管理程序有效地工作。<\/li><li>在一个 VM 上的 CPU 关联性可能会阻止同一个虚拟机管理程序上的其他 VM 虚拟机管理程序。<\/li><li>在从一个虚拟机管理程序上将一个具有 CPU 关联性的 VM 移动到另外一个虚拟机管理程序上时，有可能会需要不同的处理器配置。<\/li><li>在多核或超线程机器上的 CPU 关联性将有可能阻止 VM 安排多线程任务，因为它对指定核心的请求是有限的。<\/li><\/ul><h2 id=\"summaryandconclusions\">总结和结论<\/h2><p>这一由两部分组成的系列文章探讨了虚拟化的优点和缺点，并使用了两个特定于 IBM Rational 产品的示例。<\/p><p>在第 1 部分中，我们覆盖了四个重要的维度，这些参数在使用虚拟化时必须被恰好判断：CPU、内存、磁盘 I/O 和存储，以及网络。我们强调了关联性（专用资源）的重要性，以及演示了当资源被过度承诺时有可能会发生的情况。<\/p><p>我们还提供了关于管理较差的虚拟化可能会大幅影响 IBM Rational 产品性能的示例。我们也展示了两个案例，其中的 IBM Rational Team Concert 和 IBM Rational ClearCase 当它们被托管在没有配置关联性，配置较差的虚拟环境上时性能很糟糕。<\/p><p>在第 2 部分中，我们更深入地了解了对过度承诺的权衡。<\/p><p>根据我们测试 IBM Rational 产品以及我们以往建议客户的经验，我们提供了建议和提示，故障排除策略和特定用户的示例，来帮助管理您的虚拟化基础设施。故障排除情形和建议可以从 <a href=\"https://jazz.net/wiki/bin/view/Deployment/VirtualizationTroubleshooting\">jazz.net Deployment wiki<\/a> 上看到。<\/p><h3 id=\"3.1.Virtualization’skeyadvantages|outline\">虚拟化的关键优势<\/h3><ul class=\"ibm-bullet-list\"><li>当前市场上所提供的硬件倾向于使它们自身更好地被分割和被虚拟机管理程序所使用，来托管多虚拟机。这些新机器节省空间和电力消耗，而且更加有效利用资源。<\/li><li>虚拟化基础设施可以增加部署新 VM 的速度（复制已有的 VM 或新的可立即使用的 VM）。<\/li><li>高可用（High-availability，HA）以及灾难恢复（Disaster Recovery，DR）解决方案可以与虚拟化一起集成，来获得更完整和有效成本的企业级配置。然而，需要注意的是，在一个单独的虚拟机管理程序上托管多个 VM 可能会导致一个单点失败。您可以了解这一特定领域，并使用 SAN 或 NAS 存储来为 VM 镜像和/或在一个备用的虚拟机管理程序上部署已准备要用的 VM。<\/li><li>VM 及它们的虚拟机管理程序可以从任何地点通过终端被管理（而不仅仅是在一个实验室中），从而可以优化和减少管理成本。<\/li><\/ul><p>了解完所给出关于较差管理的虚拟化可能出现的陷阱，您可能仍旧疑问这是否真的值得投资和劳神。但答案是非常值得！虚拟化是一个值得的投资，但我们也强调，虚拟化必须被恰当管理。在一些组织里，虚拟化是必然和永久的。消失的是专用的物理硬件、专用于托管一个单独应用的单台服务器。那些硬件厂商都在趋向于生产能增加更多处理器和内存的平台，切分新的硬件给虚拟机是最佳的方式来确保资源的有效性。<\/p><h3 id=\"3.2.Keyprinciplesdiscussedinthisseries|outline\">这一系列所讨论的关键原则<\/h3><ul class=\"ibm-bullet-list\"><li>尽可能分配 CPU、内存和网络作为专用资源。确保可以通过专用的 I/O 访问充足的共用存储。<\/li><li>只要可能，考虑 CPU 及内存关联性。在某些案例中，这将导致同一台主机上的其他 VM 性能变差。在某些案例中，虚拟机管理程序会作为集群的一部分，牵制资源可能会阻止整个家族的 VM 得以优化运行。这些是针对所有 VM 在 CPU 和内存资源无法被专用或预订时的一些性能权衡策略。<\/li><li>只要可能，通过监管资源消耗来管理您的虚拟化资源。了解有哪些其他的产品被托管在同一台 VM 上，以及那些被同一个虚拟机管理程序所托管的其它 VM 在做些什么。<\/li><li>只要可能，避免资源过度承诺。也就是说，任何 VM 或 VM 组合的资源永远不应超过虚拟机管理程序的物理资源。<\/li><li>如果您怀疑有与虚拟化相关的问题，收集关于 VM 配置、虚拟机管理程序和其他被同一个虚拟机管理程序托管的 VM 的特定数据。避免有偏见的信息，并使用脚本来收集特定，也许是定期的度量信息。<\/li><\/ul><h3 id=\"3.3.SpecialIBMRationalproductconsiderations|outline\">IBM Rational 产品应特别考虑的因素<\/h3><p>不同的软件产品的表现很不同。在某一个 VM 上的某一个产品上使用得很好虚拟化参数不一定对其他的产品有效。在这一系列文章中，我们检验了 Rational Team Concert 及 Rational ClearCase。其他 Rational 产品也许会表现得类似，也或许完全不同，这就是我们强调要理解虚拟化的各个关键维度的原因。<\/p><p>例如复杂多层应用程序，例如 Rational 协作化生命周期管理（Rational Collaborative Lifecycle Management）产品或 Rational ClearCase 要求就近访问专用资源。我们曾一起工作过的客户就曾遇到过由于并未强制执行上诉所列出的关键原则，而导致其在虚拟环境中的 Rational 产品性能很差的情形。<\/p><h2 id=\"creditsandacknowledgements\">致谢<\/h2><p>本文作者感谢我们的同事 Tim Lee、Chetna Warade、David Schlegel、Paul Weiss、Matthias Lee、Samir Shah、Harry Abadi 及 Poornima Seetharamaiah，我们在 Rational 支持和开发团队的同事，以及我们在 Intel、NetApp 和 VMware 的业务合作伙伴。<\/p><CMA ID: 974968><Site ID: 10><XSLT stylesheet used to transform this file: dw-document-html-7.0.xsl>\r\n\r\n\r\n<\/div>\r\n<\/div>\r\n","createTime":"2014-06-19 00:00:00","deployTime":"2014-06-19 00:00:00","id":0,"intro":"如果您目前正在 IBM Rational 软件上使用虚拟化方法，是否一切都像您预期的一样顺利？三位 IBM 专家将介绍 Rational 视角下的虚拟化，以及虚拟化环境从 Rational 应用程序中获取最优性能的关键要求。在第 2 部分，他们将展现更多的案例及和故障排除技巧。","keyword":"","recommend":false,"source":"http://www.ibm.com/developerworks/cn/rational/smart-virtualization-2/index.html","title":"利用虚拟化成就智慧: 第 2 部分 使用 IBM 软件的最佳实践","typeId":0,"updateTime":"2014-06-19 00:00:00"}
{"author":"","clickNumber":0,"content":"\r\n<div class=\"ibm-columns\">\r\n<div class=\"ibm-col-1-1\">\r\n\r\n<div class=\"dw-sidebar ibm-inset\"><div class=\"ibm-video\"><div class=\"ibm-video-container\" itemscope=\"video\" itemtype=\"http://schema.org/VideoObject\"><meta itemprop=\"thumbnailURL\" content=\"csp0265.Still002-620x350.png\"/><meta itemprop=\"description\" content=\"观看此视频，了解该主题的更深入的信息： 使用 Node.js 和 Redis&#10;                        构建一个实时聊天应用程序.\"/><meta itemprop=\"name\" content=\"使用 Node.js 和 Redis&#10;                        构建一个实时聊天应用程序\"/><meta itemprop=\"contentURL\" content=\"http://v.youku.com/v_show/id_XNzI4NTY1OTk2.html\"/><meta itemprop=\"uploadDate\" content=\"2014-06-19\"/><a class=\"ibm-media\" href=\"http://v.youku.com/v_show/id_XNzI4NTY1OTk2.html\"><img src=\"/sunshine_new/images/2084715008/csp0265.Still002-620x350.png\" width=\"300\" height=\"200\" alt=\"Video: 使用 Node.js 和 Redis&#10;                        构建一个实时聊天应用程序\"/><span class=\"ibm-play-button-large\">< - ><\/span><\/a><\/div><\/div><span class=\"item-left\"><a class=\"ibm-forward-link\" href=\"csp0265.pdf\">抄本<\/a><\/span><\/div><p>IBM Bluemix 是一款 <strong>beta 级<\/strong>产品，随着我们不断让其功能更加完善和更易于使用，它也将不断改进。我们会竭尽全力保持本文最新，但并不总是完全跟得上现状。感谢大家的理解！<\/p><p>使用 Bluemix 运行您的应用程序的最有吸引力的原因之一是，它快速且轻松地扩展您的应用程序的能力。使用传统的基础设施即服务 (IaaS)\n                产品，伸缩您的应用程序需要购买额外的虚拟映像，配置这些映像，在映像上部署您的应用程序，以及配置某种类型的负载平衡器来在新映像上分布负载。使用\n                Bluemix 和它满是服务的目录，所有这些操作只需单击一个按钮即可完成。<\/p><p>尽管在 Bluemix\n                中使用扩展功能非常简单，但并不意味着每个应用程序在伸缩后都能正常工作。常常，在内部运行的应用程序会将状态存储在内存中或本地文件系统中。这些类型的应用程序在扩展到云中时常常会发生故障，因为客户端请求将随机分配给该应用程序在云中运行的不同实例。一个实例上的应用程序状态与任何其他应用程序实例都不同。要解决此问题，Bluemix\n                等平台即服务 (PaaS) 产品提供了一些服务，可供应用程序用于跨多个实例共享状态。<\/p><p>我将介绍如何构建一个聊天应用程序，允许用户实时将消息发送给其他用户，跨多个实例扩展应用程序来处理负载。<\/p><ul class=\"ibm-bullet-list\"><li><a href=\"http://bluechatter.ng.Bluemix.net?cm_mmc=developerWorks-_-dW%20CloudOE%20content-_-cl-Bluemix-node-redis-_-article\">运行应用程序<\/a><\/li><li><a href=\"https://hub.jazz.net/project/rjbaxter/bluechatter/overview?utm_source=developerWorks&amp;utm_medium=article&amp;utm_content=cl-Bluemix-node-redis&amp;utm_campaign=dW%20CloudOE%20content\">获取代码<\/a><\/li><\/ul><h3 id=\"1.1.GettingStarted|outline\">开始<\/h3><p>要构建此应用程序，您需要以下前提条件。<\/p><ol type=\"1\"><li>基本熟悉 HTML、JavaScript、CSS 和 Node.js。<\/li><li>已安装 <a href=\"http://nodejs.org/\">Node.js<\/a> 和 NPM。NPM 将随 Node.js\n                    一起安装。<\/li><\/ol><h3 id=\"1.2.CreatingTheProject|outline\">创建项目<\/h3><p>将您希望执行工作的目录转到本地文件系统上，创建一个名为 bluechatter 的新文件夹。<\/p><div class=\"codesection\"><pre class=\"displaycode\">$ mkdir bluechatter<\/pre><\/div><h4 id=\"1.2.1.App.js|outline\">App.js<\/h4><p>在 bluechatter 目录中，创建一个名为 app.js 的文件。在 app.js 内，粘贴以下代码来创建一个基本的 Web\n                服务器，其中包含流行的 Node.js 库 <a href=\"http://expressjs.com/\">Express JS<\/a>。<\/p><div class=\"codesection\"><pre class=\"displaycode\">var express = require(\"express\");\nvar fs = require('fs');\nvar http = require('http');\nvar path = require('path');\n\nvar app = express();\napp.set('port', 3000);\napp.use(express.static(path.join(__dirname, 'public')));\napp.use(express.json());\n\n// Serve up our static resources\napp.get('/', function(req, res) {\n  fs.readFile('./public/index.html', function(err, data) {\n    res.end(data);\n  });\n});\n\nhttp.createServer(app).listen(app.get('port'), function(){\n  console.log('Express server listening on port ' + app.get('port'));\n});<\/pre><\/div><p>Node.js 应用程序使用一个名为 package.json 的文件描述应用程序的基本元数据，以及提供一个依赖关系列表。在 bluechatter\n                文件夹内，创建一个名为 package.json 的文件并粘贴以下代码。<\/p><div class=\"codesection\"><pre class=\"displaycode\">{\n  \"name\": \"BlueChatter\",\n  \"version\": \"0.0.1\",\n  \"scripts\": {\n    \"start\": \"node app.js\"\n  },\n  \"dependencies\": {\n    \"express\": \"3.4.8\"\n  }\n}<\/pre><\/div><p>这会给您的应用程序分配一个名称、版本和启动版本。它还会指定该应用程序目前仅有的依赖关系：Express。稍后，您将向该应用程序添加依赖关系。<\/p><h4 id=\"1.2.2.index.html|outline\">index.html<\/h4><p>在 bluechatter 目录中，创建一个名为 public 的文件夹。在 public 文件夹内，创建一个名为 index.html\n                的文件并将以下代码粘贴到其中。<\/p><div class=\"codesection\"><pre class=\"displaycode\">&lt;html lang=\"en\"&gt;\n  &lt;head&gt;\n    &lt;meta charset=\"utf-8\"&gt;\n    &lt;meta http-equiv=\"X-UA-Compatible\" content=\"IE=edge\"&gt;\n    &lt;meta name=\"viewport\" content=\"width=device-width, initial-scale=1\"&gt;\n    &lt;title&gt;BlueChatter&lt;/title&gt;\n\n    &lt;!-- Bootstrap --&gt;\n    &lt;link rel=\"stylesheet\" href=\"//netdna.bootstrapcdn.com/bootstrap/3.1.1/css/bootstrap.min.css\"&gt;\n    &lt;link href=\"stylesheets/style.css\" rel=\"stylesheet\"&gt;\n\n    &lt;!-- HTML5 Shim and Respond.js IE8 support of HTML5 elements and media queries --&gt;\n    &lt;!-- WARNING: Respond.js doesn't work if you view the page via file:// --&gt;\n    &lt;!--[if lt IE 9]&gt;\n      &lt;script src=\"https://oss.maxcdn.com/libs/html5shiv/3.7.0/html5shiv.js\"&gt;&lt;/script&gt;\n      &lt;script src=\"https://oss.maxcdn.com/libs/respond.js/1.4.2/respond.min.js\"&gt;&lt;/script&gt;\n    &lt;![endif]--&gt;\n  &lt;/head&gt;\n  &lt;body&gt;\n    &lt;div id=\"main-container\"&gt;\n      &lt;h1&gt;BlueChatter&lt;/h1&gt;\n      &lt;div class=\"user-form center\"&gt;\n        &lt;h3 class=\"form-signin-heading\"&gt;Enter a username to get started&lt;/h3&gt;\n        &lt;input id=\"user-name\" class=\"form-control\" placeholder=\"Username\" required=\"\" autofocus=\"\"&gt;\n        &lt;button class=\"btn btn-lg btn-primary btn-block go-user\" type=\"submit\"&gt;Go!&lt;/button&gt;\n      &lt;/div&gt;\n    &lt;/div&gt;\n    &lt;div class=\"footer center\"&gt;\n    &lt;/div&gt;\n    &lt;script src=\"https://ajax.googleapis.com/ajax/libs/jquery/1.11.0/jquery.min.js\"&gt;&lt;/script&gt;\n    &lt;script src=\"javascripts/client.js\"&gt;&lt;/script&gt;\n  &lt;/body&gt;\n&lt;/html&gt;<\/pre><\/div><p>从这段 HTML 可以看到，我们使用了 <a href=\"http://getbootstrap.com/\">Bootstrap<\/a> 和 <a href=\"http://jquery.com/\">jQuery<\/a>，二者都是从一个内容传送网络 (content delivery\n                network, CDN) 获取的。此外，还存在对 style.css 和 client.js\n                的引用。这些是我们将用于向应用程序添加自定义样式和业务逻辑的文件。<\/p><p>首先创建 style.css。<\/p><h4 id=\"1.2.3.style.css|outline\">style.css<\/h4><p>在 public 文件夹中，创建一个名为 stylesheets 的文件夹。在 stylesheets 文件夹中，创建一个名为 style.css\n                的文件并将以下 CSS 代码粘贴到其中。<\/p><div class=\"codesection\"><pre class=\"displaycode\">#main-container {\n  margin: 0 auto;\n}\n\n#main-container h1 {\n  text-align: center;\n}\n\n.center {\n  text-align: center;\n  max-width: 430px;\n  padding: 15px;\n  margin: 0 auto;\n}\n\n.go-user {\n  margin-top: 10px;\n}\n\n.chat-box {\n  max-width: 930px;\n  padding: 15px;\n  margin: 0 auto;\n}\n\n.message-area {\n  max-height: 500px;\n  overflow: auto;\n}\n\n.footer {\n  padding-top: 19px;\n  color: #777;\n  border-top: 1px solid #e5e5e5;\n}<\/pre><\/div><p>现在创建 client.js。<\/p><h4 id=\"1.2.4.client.js|outline\">client.js<\/h4><p>在 public 文件夹中，创建一个名为 javascripts 的文件夹。在 javascripts 文件夹中，创建一个名为 client.js\n                的文件。将以下代码添加到其中并保存该文件，稍后将填入剩余代码。<\/p><div class=\"codesection\"><pre class=\"displaycode\"> $(document).ready(function() {\n\n });<\/pre><\/div><h4 id=\"1.2.5.TestingTheApp|outline\">测试应用程序<\/h4><p>此刻，您已拥有服务器端和客户端代码来测试应用程序。运行该应用程序之前，必须在 bluechatter 目录内运行\n                <code>npm install<\/code> 命令来安装必要的依赖关系。打开一个终端窗口并执行以下命令。<\/p><div class=\"codesection\"><pre class=\"displaycode\">$ cd bluechatter\n$ npm install<\/pre><\/div><p>运行 <code>npm install<\/code> 时，您必须有一个有效的 Internet 连接，因为 npm 将下载需要的代码依赖关系。npm\n                完成安装依赖关系后，即可启动服务器。从 bluechatter 目录内运行以下命令。<\/p><div class=\"codesection\"><pre class=\"displaycode\">$ node app.js<\/pre><\/div><p>如果一切正常，将会看到终端窗口显示 “Express server listening on port 3000”。在您最喜欢的浏览器中访问 http://localhost:3000。在浏览器中，将会看到类似下图的内容。<\/p><h5 id=\"N100CB\">图 1. <\/h5><img alt=\"该图显示了浏览器结果示例\" src=\"/sunshine_new/images/2084715008/image001.jpg\" width=\"600\" /><h3 id=\"1.3.ClientSideCode|outline\">客户端代码<\/h3><h4 id=\"1.3.1.MakingtheGo!buttongo|outline\">实现\n                Go! 按钮<\/h4><p>此刻，如果单击应用程序中的 <strong>Go!<\/strong> 按钮，什么都不会发生。这是因为我们还未定义它的单击处理函数。<\/p><p>在您最喜爱的文本编辑器中打开 bluechatter 目录中的\n                public/javascripts/client.js。我们在这个适合归档的回调中添加一个函数，如下所示：<\/p><div class=\"codesection\"><pre class=\"displaycode\">  var name = '';\n  function go() {\n    name = $('#user-name').val();\n    $('#user-name').val('');\n    $('.user-form').hide();\n    $('.chat-box').show();\n  };<\/pre><\/div><p>这部分代码非常简单明了。我们真正所做的只是操作 DOM。我们获得了用户在 UI 的 username\n                字段中输入的名称并将它保存在一个变量中，因为稍后将需要它。接下来，隐藏表单和按钮，显示聊天框，用户可在其中看到和发送聊天消息。（聊天框还未在我们的\n                HTML 中定义；稍后将完成此任务。）我们仍需要从按钮单击监听器调用此函数。为此，将此代码添加到这个适合归档的回调中。<\/p><div class=\"codesection\"><pre class=\"displaycode\">  $('#user-name').keydown(function(e) {\n    if(e.keyCode == 13){ //Enter pressed\n      go();\n    }\n  });\n  $('.go-user').on('click', function(e) {\n    go();\n  });<\/pre><\/div><p>此代码不仅向 <strong>Go!<\/strong> 按钮添加了一个单击监听器，还向 username\n                字段添加了一个键监听器，所以如果用户在该字段中按回车键，将实现与单击 <strong>Go!<\/strong> 相同的目的。<\/p><p>最后，我们需要添加一些 HTML 来查看和发送聊天消息。打开 bluechatter/public 文件夹中的 index.html 文件。找到 ID\n                为 main-container 的 div，将以下 HTML 代码段添加到 main-container div 中已有内容的后面。<\/p><div class=\"codesection\"><pre class=\"displaycode\">      &lt;div class=\"chat-box well well-lg\" style=\"display: none;\"&gt;\n        &lt;div class=\"jumbotron\"&gt;\n          &lt;h1&gt;It Is Quiet In Here!&lt;/h1&gt;\n          &lt;p&gt;No one has said anything yet, type something insightful in the \ntext box below and press enter!&lt;/p&gt;\n        &lt;/div&gt;\n        &lt;div class=\"message-area\"&gt;\n        &lt;/div&gt;\n      &lt;/div&gt;\n      &lt;div class=\"chat-box\" style=\"display: none;\"&gt;\n        &lt;textarea id=\"message-input\" placeholder=\"Type something insightful!\" \nclass=\"form-control\" rows=\"3\"&gt;&lt;/textarea&gt;\n      &lt;/div&gt;<\/pre><\/div><p>现在如果节点服务器仍在运行，则按 <strong>Ctrl+c<\/strong> 停止它，运行以下命令来再次启动该服务器。<\/p><div class=\"codesection\"><pre class=\"displaycode\">node app.js<\/pre><\/div><p>如果返回到 http://localhost:3000，<strong>Go!<\/strong> 按钮应已发挥实际作用。输入一个用户名并单击\n                    <strong>Go!<\/strong>。您应看到此界面。<\/p><h5 id=\"1.3.2.SendingChatMessages|outline\">图 2. 发送聊天消息<\/h5><img alt=\"该图显示了发送聊天消息的过程\" src=\"/sunshine_new/images/2084715008/image002.jpg\" width=\"600\" /><p>如果打算尝试在文本区域中 “键入一些有意义的内容” 并按<strong>回车键<\/strong>，就像 UI\n                    告诉您做的一样，您同样会发现什么都不会发生。我们需要定义在按<strong>回车键<\/strong>时应发生的操作。应发生什么？在发送一条消息时，我们需要告诉服务器两种信息：发送消息的用户和发送的消息。<\/p><p>要告诉服务器此信息，我们将调用一个 REST API。REST API 还未在服务器代码中定义。所以现在，我们将假设 REST API 端点为\n                /msg 并接受 JSON。我们向文本区添加一个键监听器，它将调用我们虚构的 REST API。<\/p><div class=\"codesection\"><pre class=\"displaycode\">  $('.chat-box textarea').keydown(function(e) {\n    if(e.keyCode == 13){\n      $.ajax({\n        type: \"POST\",\n        url: \"/msg\",\n        data: JSON.stringify({\"username\" : name, \"message\" : $('#message-input').val().trim()}),\n        contentType: \"application/json\"\n      });\n      $(this).val('');\n      $('.jumbotron').hide();\n      e.preventDefault()\n    }\n  });<\/pre><\/div><p>可以看到，此代码向文本区添加了一个按键监听器。按下<strong>回车键<\/strong>（键代码 13）时，我们将使用 jQuery Ajax\n                API 调用一个对 /msg 的 <code>POST<\/code> 请求。我们在 Ajax 请求中发送的数据是一个 JSON\n                对象，其中包含用户名和消息。在监听器末尾，我们还做了一些清理工作。我们清除文本区，隐藏显示 “it is quiet in here” 的\n                UI（因为它不再是安静不动的），然后调用 preventDefault 来阻止事件弹出。<\/p><p>我们运行 <code>node app.js<\/code> 命令并访问 http://localhost:3000，测试一下这个监听器。输入一个用户名，键入一条消息并按<strong>回车键<\/strong>。看起来什么都没发生，对吧？不完全是这样。打开您使用的浏览器的开发人员工具（比如\n                Firefox 中的 Firebug），转到 console\n                选项卡。现在键入另一条消息并按<strong>回车键<\/strong>。在控制台中，您应看到向 /msg 端点发送了一条请求。以下是此结果在\n                Firefox 中的 Firebug 内的显示效果示例。<\/p><h5 id=\"N10134\">图 3. <\/h5><img alt=\"该图显示了 Firefox Firebug 示例\" src=\"/sunshine_new/images/2084715008/image003.jpg\" width=\"600\" /><p>但是，请求失败了，因为我们的节点服务器没有定义 /msg。我们稍后再解决此问题，因为客户端 JavaScript 中还有一些事要做。 <\/p><h4 id=\"1.3.3.Letstakeapoll|outline\">让我们进行一次轮询<\/h4><p>客户端代码中的最后一部分是获取来自其他用户的聊天消息的代码。为了创建此代码，我们利用一种称为 <em><a href=\"http://en.wikipedia.org/wiki/Push_technology#Long_polling\">长轮询<\/a>\n                的技术<\/em>长轮询的含义与它的字面意思并不完全相同：它轮询服务器，有时需要很长时间才能获得轮询的响应。对于我们的应用程序，客户端将向服务器发出一个请求，服务器将等待响应该请求，直到它有一些数据发送回客户端。服务器响应后，客户端立即向服务器发回另一个轮询请求，所以它可获得传入的下一条聊天消息。为此，我们将向服务器上的一个\n                REST API 发送一个 <code>GET<\/code> 请求。服务器将使用一个包含用户名和该用户发送的聊天消息的 JSON\n                对象作为响应。<\/p><p>将以下代码段添加到适合归档的回调的 client.js 中。<\/p><div class=\"codesection\"><pre class=\"displaycode\">  function poll() {\n    $.getJSON('/poll/' + new Date().getTime(), function(response, statusText, jqXHR) {\n      if(jqXHR.status == 200) {\n        $('.jumbotron').hide();\n        msg = response;\n        var html = '&lt;div class=\"panel \\\npanel-success\"&gt;&lt;div class=\"panel-heading\"&gt;&lt;h3 class=\"panel-title\"&gt;' +\nmsg.username + \\\n'&lt;/h3&gt;&lt;/div&gt;&lt;div class=\"panel-body\"&gt;' + msg.message + '&lt;/div&gt;&lt;/div&gt;';\n        var d = $('.message-area');\n        d.append(html);\n        d.scrollTop(d.prop(\"scrollHeight\"));\n      }\n      poll();\n    });\n  };<\/pre><\/div><p>同样地，我们使用 jQuery 帮助执行 REST API 调用。<a href=\"http://api.jquery.com/jquery.getjson/\">getJSON<\/a> API 向 /poll\n                发出一个请求。您将注意到，我们还附加了当前时间。这么做是因为，浏览器将对发送给同一个端点的请求排队；我们不希望这么做，所以我们通过附加当前时间来唯一地标识端点。在回调中，我们首先检查以确保响应为\n                200，表明它是一个成功请求。再次隐藏 “jumbotron” 安静消息（因为它不再安静），向聊天区附加一些 HTML\n                    代码，其中包含用户名和消息。最后，我们将聊天区滚动到底部，以便始终可以看到新消息。您还会注意到，该函数是递归性的，因为它会调用自身。这是一种具有<em>长轮询模式<\/em>\n                    的<em>轮询<\/em>。<\/p><p>善于观察的开发人员将注意到，我们还没有任何东西调用轮询函数来开始轮询。我们希望何时开始轮询？只要用户按下 <strong>Go!<\/strong>\n                按钮。我们已有一个函数来处理 <strong>Go!<\/strong> 按钮单击，所以可从该监听器调用我们的轮询函数。在\n                <code>go<\/code> 函数末尾添加一个轮询函数调用。<\/p><div class=\"codesection\"><pre class=\"displaycode\">  function go() {\n    name = $('#user-name').val();\n    $('#user-name').val('');\n    $('.user-form').hide();\n    $('.chat-box').show();\n    poll();\n  };<\/pre><\/div><p>是时候再次测试我们的应用程序了。在终端运行 <code>node app.js<\/code>。在浏览器中，确保您已打开开发人员控制台并访问 http://localhost:3000。输入一个用户名并单击\n                    <strong>Go!<\/strong>。您应看到我们的轮询请求已发送 &#8212; 但失败了，如下所示。<\/p><h5 id=\"N10177\">图 4. <\/h5><img alt=\"该图显示轮询请求失败了\" src=\"/sunshine_new/images/2084715008/image004.jpg\" width=\"600\" /><p>同样的原因，我们还未在服务器上实现该 REST API，所以此结果在预料之中。 <\/p><h3 id=\"1.4.ServerSideCode|outline\">服务器端代码<\/h3><p>现在我们的客户端代码已能按预期运行，我们需要开始在服务器上构建客户端要使用的 REST API。<\/p><h4 id=\"1.4.1.Thepollresultsarein|outline\">轮询结果已在其中<\/h4><p>首先实现我们的轮询端点。前面已提到，我们的应用程序使用的是长轮询，所以轮询端点将处理来自客户端的轮询请求，使用它们发送到服务器的新聊天消息作为响应。<\/p><p>打开 app.js 并添加以下代码。<\/p><div class=\"codesection\"><pre class=\"displaycode\">var clients = [];\n// Poll endpoint\napp.get('/poll/*', function(req, res) {\n  clients.push(res);\n});<\/pre><\/div><p>这里没有发生太多事情。我们所做的只是处理 /poll 端点上的请求，获取响应，然后将它放在一个数组对象中。这就是长轮询中的<em>长<\/em>\n                的部分。我们将等待响应轮询请求，直到有一条消息用作响应。<\/p><h4 id=\"1.4.2.Sendmeyourmessages|outline\">向我发送您的消息<\/h4><p>现在，我们只需要处理发送给服务器的消息，向等待接收响应的任何客户端发送响应。将以下代码添加到 app.js 中来处理 /msg 端点。<\/p><div class=\"codesection\"><pre class=\"displaycode\">// Msg endpoint\napp.post('/msg', function(req, res) {\n  message = req.body;\n  var msg = JSON.stringify(message);\n  while(clients.length &gt; 0) {\n    var client = clients.pop();\n    client.end(msg);\n  }\n  res.end();\n});<\/pre><\/div><p>我们的 /msg 端点接收 <code>POST<\/code>\n                主体中包含的消息，然后处理客户端数组中的所有轮询请求，使用从客户端发来的消息作为响应。此过程非常简单。<\/p><h4 id=\"1.4.3.Testingtheserversidecode|outline\">测试服务器端代码<\/h4><p>我们现在已有能正常运行的客户端和服务器端代码，现在测试一下它们。返回到您的终端，运行 <code>node app.js<\/code>\n                来启动我们服务器，在您最喜爱的浏览器中打开 http://localhost:3000。我们实际需要两个浏览器来测试我们的应用程序，所以请打开您的第二个最喜欢的浏览器并访问同一个\n                URL。在每个浏览器窗口中输入一个不同的用户名并开始键入消息。您应看到这些消息同时显示在两个浏览器窗口中。非常棒！我们已有一个能正常运行的聊天应用程序。<\/p><h5 id=\"N101B2\">图 5. <\/h5><img alt=\"该图显示了聊天应用程序\" src=\"/sunshine_new/images/2084715008/image005.jpg\" width=\"850\" /><h3 id=\"1.5.TakingIttothecloud|outline\">将它部署到云中<\/h3><p>我们的应用程序似乎在本地运行良好，接下来将它部署到云中。使用 Bluemix 可轻松完成此工作。但是首先，我们需要对服务器端代码稍作更改。<\/p><h4 id=\"1.5.1.UsingTheRightPort|outline\">使用正确的端口<\/h4><p>现在我们是在端口 3000 上启动的 Express 服务器。该端口已硬编码在 app.js\n                中：<code>app.set('port', 3000);<\/code>。<\/p><p>这在本地运行时没什么问题，但在 Bluemix 上运行应用程序时，我们需要使用 Bluemix 平台开放的端口，它很可能不是 3000。Bluemix\n                通过在环境变量 <code>VCAP_APP_PORT<\/code> 中设置端口，让应用程序知道要使用哪个端口。但是，我们可使用一个 Node\n                    库来获取该端口：<a href=\"https://www.npmjs.org/package/cf-env\">cf-env<\/a>。将此库添加到 package.json 文件中，以便我们可在服务器代码中使用它。<\/p><p>打开 package.json，在依赖关系对象中，为 cf-env 添加一个属性。<\/p><div class=\"codesection\"><pre class=\"displaycode\">  \"dependencies\": {\n    \"express\": \"3.4.8\",\n    \"cf-env\": \"*\"\n  }<\/pre><\/div><p>现在打开 app.js，在收到其他 <code>require<\/code> 调用后，为 cf-env 和您的 package.json 文件添加一个\n                <code>require<\/code>。 <\/p><div class=\"codesection\"><pre class=\"displaycode\">var cfEnv = require(\"cf-env\");\nvar pkg   = require(\"./package.json\");<\/pre><\/div><p>我们将需要实例化 cf-env 库，将一个名称传递到它的 <code>getCode<\/code> 方法中，并在 package.json\n                文件中使用该名称。<\/p><div class=\"codesection\"><pre class=\"displaycode\">var cfCore = cfEnv.getCore({name: pkg.name});<\/pre><\/div><p>最后，我们需要更改设置 Express 所使用的端口的代码。找到 app.js 中类似于\n                <code>app.set('port', 3000)<\/code> 的代码，将它更改为\n                <code>app.set('port', cfCore.port || 3000);<\/code>。<\/p><p>请注意，此代码即允许我们在本地运行该应用程序，也允许在云中运行它。如果 cfCore.port 未定义，我们将像之前一样使用 3000。<\/p><h4 id=\"1.5.2.PushthecodetoBluemix|outline\">将代码推送到 Bluemix<\/h4><p>要使用 Bluemix，您必须有一个帐户。访问 <a href=\"http://www.Bluemix.net/\">Bluemix<\/a>\n                来注册一个帐户。有了帐户后，我们可安装 <a href=\"http://docs.cloudfoundry.org/devguide/installcf/whats-new-v6.html\">Cloud Foundry Command Line Interface<\/a> (CLI)，稍后将使用它部署我们的应用程序。要安装\n                CLI，请按照 <a href=\"http://www.ng.Bluemix.net/docs/BuildingWeb.jsp#install-cf\">Bluemix 文档<\/a> 中的说明操作。<\/p><p>完成了吗？接下来的工作比较有趣。<\/p><p>首先，我们需要将 CLI 指向 Bluemix 并登录。在终端窗口中运行以下命令。<\/p><div class=\"codesection\"><pre class=\"displaycode\">cf login -a <a href=\"https://api.ng.Bluemix.net/\">https://api.ng.Bluemix.net<\/a><\/pre><\/div><p>在提示输入用户名和密码时，输入您的 IBM 用户名和密码。成功验证后，我们将应用程序推送到云中。确保您在包含所有应用程序代码的 bluechatter\n                文件夹的根目录下，在终端窗口执行以下代码，将命令的 bluechatter 部分替换为您自己的应用程序名称，比如\n                my-bluechatter。<\/p><div class=\"codesection\"><pre class=\"displaycode\">cf push bluechatter -m 128M<\/pre><\/div><p>提示：如果推送应用程序时看到一个错误显示 “Bluemix could not create a route for your\n                application”，表明您选择的名称已被用。挑选一个不同的名称并再次运行该命令。<\/p><p>如果推送成功，CLI 将打印出运行的应用程序所在的 URL。在两个最喜爱的浏览器中打开此 URL，确保您的应用程序按预期运行。<\/p><div class=\"codesection\"><pre class=\"displaycode\">App started\n\nShowing health and status for app bluechatter in org rjbaxter@us.ibm.com / \nspace dev as rjbaxter@us.ibm.com...\nOK\n\nrequested state: started\ninstances: 5/5\nusage: 128M x 5 instances\nurls: bluechatter.ng.Bluemix.net<\/pre><\/div><h4 id=\"1.5.3.Optional:Excludingunnecessaryfilesfromyourdeployment|outline\">可选：从部署中排除不必要的文件<\/h4><p>您可能在执行 <code>cf push<\/code> 命令时已注意到，上传的文件非常大（在我的例子中为 4.2 MB）。尽管 4.2 MB\n                不是太大，但它与我们编写的代码量相比很大。为了了解我们为什么上传了 4.2 MB 文件，我们需要了解 <code>cf push<\/code>\n                的工作原理。<code>cf push<\/code> 命令会将它执行的所有文件部署在该目录中。回想一下我们第一次在本地运行应用程序时，我们运行\n                <code>npm install<\/code> 来安装运行我们的应用程序所需的所有依赖关系。这些依赖关系安装在 bluechatter\n                文件夹中一个名为 node_modules 的文件夹中。因为 <code>cf push<\/code>\n                会部署所有内容，所以它也会部署依赖关系。您可能会说，“但我们需要这些，不是吗？”是的，我们需要，但 Bluemix\n                将负责为我们安装这些依赖关系，因为它在部署过程中将运行 <code>npm install<\/code>。<\/p><p>解决方案很简单：我们只需在 bluechatter 目录中创建一个文件，告诉 <code>cf push<\/code> 命令不要上传哪些文件和目录。在\n                bluechatter 目录中创建一个名为 .cfignore 的文件并在最喜爱的文本编辑器中打开它。在 .cfignore\n                文件中，添加以下代码并保存它。<\/p><div class=\"codesection\"><pre class=\"displaycode\">node_modules<\/pre><\/div><p>这里，我们告诉 <code>cf push<\/code> 命令忽略 node_modules\n                目录中的所有内容。换句话说，所有依赖关系都不要推送。现在运行以下代码。<\/p><div class=\"codesection\"><pre class=\"displaycode\">cf push bluechatter -m 128M<\/pre><\/div><p>您应注意到部署内容的大小发生了显著变化。在我的例子中，<code>cf push<\/code> 命令仅上传了 11.4K，此一次小得多\n                &#8212; 而且更重要的是，快得多的 &#8212; 部署。<\/p><h4 id=\"1.5.4.Warning:Potentialgotcha!|outline\">警告：可能的麻烦！<\/h4><p>如果现在尝试在本地运行 <code>node app.js<\/code>，您可能会遇到以下错误。<\/p><div class=\"codesection\"><pre class=\"displaycode\">$ node app.js\n\nmodule.js:340\n    throw err;\n          ^\nError: Cannot find module 'cf-env'\n    at Function.Module._resolveFilename (module.js:338:15)\n    at Function.Module._load (module.js:280:25)\n    at Module.require (module.js:364:17)\n    at require (module.js:380:17)\n    at Object.&lt;anonymous&gt; (/Users/ryanjbaxter/temp/bluechatter/app.js:5:13)\n    at Module._compile (module.js:456:26)\n    at Object.Module._extensions..js (module.js:474:10)\n    at Module.load (module.js:356:32)\n    at Function.Module._load (module.js:312:12)<\/pre><\/div><p>这是因为我们向 package.json 文件添加了一个依赖关系，但还未安装此依赖关系。为了解决此问题，只需从 bluechatter 目录中运行\n                <code>npm install<\/code>，然后运行 <code>node app.js<\/code>。每次对 package.json\n                的依赖关系部分进行更改后，都需要运行 <code>npm install<\/code>。<\/p><h4 id=\"1.5.5.Scalingfail!!!|outline\">扩展失败<\/h4><p>使用像 Bluemix 这样的 PaaS 的一个优势是，它能够轻松地水平扩展您的应用程序。我们说的<em>水平扩展<\/em>\n                是何含义？基本而言，这意味着创建多个服务器，它们都运行您的应用程序，都处理来自登录用户的请求。您可在 <a href=\"http://en.wikipedia.org/wiki/Scalability#Horizontal_and_vertical_scaling\">Wikipedia<\/a> 上查阅更多信息。<\/p><p>因为我们确定我们的 BlueChatter 应用程序将适用于所有人，所以需要确保我们的应用程序可在云中扩展。我们可使用可靠的 CLI\n                来从终端窗口扩展应用程序；运行以下命令来将 BlueChatter 应用程序扩展到 5 个实例。<\/p><div class=\"codesection\"><pre class=\"displaycode\">cf scale bluechatter -i 5<\/pre><\/div><p>只需几秒钟，该命令就应返回结果，表明一切正常。我们检查一下这些实例的状态，以确保它们在运行。在终端窗口中运行以下命令。<\/p><div class=\"codesection\"><pre class=\"displaycode\">cf app bluechatter<\/pre><\/div><p>得到的结果应类似于以下代码。<\/p><div class=\"codesection\"><pre class=\"displaycode\">requested state: started\ninstances: 5/5\nusage: 128M x 5 instances\nurls: bluechatter.ng.Bluemix.net\n\n     state     since                    cpu    memory          disk          \n#0   running   2014-05-05 11:58:05 AM   0.0%   55.1M of 128M   25.5M of 1G   \n#1   running   2014-05-05 11:58:33 AM   0.0%   55M of 128M     25.5M of 1G   \n#2   running   2014-05-05 11:58:32 AM   0.0%   54.9M of 128M   25.5M of 1G   \n#3   running   2014-05-05 11:58:33 AM   0.0%   54.8M of 128M   25.5M of 1G   \n#4   running   2014-05-05 11:58:32 AM   0.0%   55.9M of 128M   25.5M of 1G<\/pre><\/div><p>如果一些实例在状态栏中显示为仍在启动，请等待片刻并再次执行 <code>cf app bluechatter<\/code>。<\/p><p>很简单，对吗？<\/p><h4 id=\"1.5.6.IDyourself|outline\">标识自己<\/h4><p>您在 Bluemix 中运行的应用程序的每个实例都有一个唯一的实例 ID。对我们自己而言，通过在 BlueChatter 应用程序的 UI\n                中显示相关信息，获知我们连接到哪个实例，这会很不错。我们向 index.html 添加一些 HTML 并创建一个 REST API，后者将返回实例\n                ID，以便我们可向用户显示该信息。<\/p><h5 id=\"1.5.6.1.Index.html|outline\">index.html<\/h5><p>打开 public 文件夹中的 index.html 文件，找到包含类 footer 的 div。将以下 HTML 添加到该 div 中。<\/p><div class=\"codesection\"><pre class=\"displaycode\">&lt;p id=\"instance-id\" style=\"display: none;\"&gt;Instance ID: &lt;span id=\"instance-id-value\"&gt;&lt;/span&gt;&lt;/p&gt;<\/pre><\/div><p>这是我们在 UI 中显示实例 ID 的地方。<\/p><h5 id=\"1.5.6.2.client.js|outline\">client.js<\/h5><p>打开 public/javascripts 文件夹中的 client.js 文件。在这个适合归档的回调函数中，添加以下 JavaScript\n                代码段：<\/p><div class=\"codesection\"><pre class=\"displaycode\">  $.getJSON('/instanceId', function(response, statusText, jqXHR) {\n    if(jqXHR.status == 200) {\n      $('#instance-id').show();\n      $('#instance-id-value').html(response.id);\n    }\n  });<\/pre><\/div><p>类似于轮询函数的工作原理，我们使用 jQuery 向一个名为 /instanceId 的 REST 端点执行一个 Ajax 请求。这将返回一个简单的\n                JSON 对象，其中包含实例 ID。<\/p><h5 id=\"1.5.6.3.app.js|outline\">app.js<\/h5><p>最后一步是为我们的新 REST 端点添加服务器代码。打开 app.js 并将以下代码添加到该文件中。<\/p><div class=\"codesection\"><pre class=\"displaycode\">var instanceId = cfCore.app &amp;&amp; cfCore.app != null ? cfCore.app.instance_id : undefined;\napp.get('/instanceId', function(req, res) {\n  if(!instanceId) {\n    res.writeHeader(204);\n    res.end();\n  } else {\n    res.end(JSON.stringify({\n      id : instanceId\n    }));\n  }\n});<\/pre><\/div><p>请注意，我们再次使用了 cf-env 库来获取实例\n                ID。我们在这么做时非常谨慎，因为我们也可能在本地运行该应用程序，所以我们执行了检查，确保定义了合适的属性。如果我们在本地运行，REST 端点将返回\n                204（无内容），而且我们没有实例 ID。如果我们有一个实例 ID，它将返回一个包含该 ID 的简单 JSON 对象。<\/p><h5 id=\"1.5.6.4.TestingOnBluemix|outline\">在\n                Bluemix 上测试<\/h5><p>接下来部署新代码并试用我们的新功能。从 bluechatter 目录内，再次运行：<\/p><div class=\"codesection\"><pre class=\"displaycode\">cf push bluechatter -m 128M<\/pre><\/div><p>部署新代码后，打开您最喜爱的浏览器并访问您的应用程序的 URL。您现在应注意到在页脚打印出了实例 ID。<\/p><h5 id=\"N102C4\">图 6. <\/h5><img alt=\"该图显示了实例 ID\" src=\"/sunshine_new/images/2084715008/image006.jpg\" width=\"600\" /><p>打开您的第二个喜欢的浏览器，再次访问您应用程序的 URL。尝试连接到您应用程序的一个不同实例。（换句话说，两个浏览器窗口中应拥有不同的实例\n                ID）。如果最终连接到同一个实例，只需刷新您的浏览器，直到在浏览器中看到一个不同的 ID。<\/p><h5 id=\"N102CE\">图 7. <\/h5><img alt=\"该图显示了不同的浏览器实例 ID\" src=\"/sunshine_new/images/2084715008/image007.jpg\" width=\"850\" /><p>像之前一样，输入两个不同的用户名，尝试聊天。您应注意到一个问题，我们的应用程序不再工作。为什么？<\/p><h3 id=\"1.6.Backtothedrawingboard|outline\">返回到最初阶段<\/h3><p>哪里出错了？在扩展我们的应用程序时失败了？线索位于有关扩展的工作原理的细节中。在应用程序在 Bluemix 中扩展时，Bluemix\n                将为您的应用程序创建多个实例。将每个实例视为位于不同机器上的不同服务器。所有实例都不共享内存，或者甚至共享同一个文件系统。现在我们回头看看我们是如何实现长轮询的。我们如何存储对\n                /poll\n                端点的响应？不记得了？我们将它们存储在内存中的一个数组中。如果每个实例拥有自己的内存，这意味着每个实例有自己的一组客户端在轮询服务器。任何服务器都不知道彼此的客户端。<\/p><p>不要慌张。有一个解决方案。实际上，此问题或许有许多解决方案，但我仅详细介绍一种。我们可向其他实例告知从客户端发送的消息，以便服务器可进而通知它们的客户端。一种类似\n                    <a href=\"http://en.wikipedia.org/wiki/PublishCsubscribe_pattern\">发布-订阅<\/a> 架构的东西可派上用场。幸运的是，Bluemix 目录中有一个服务将为我们提供所需的发布-订阅功能。<\/p><h3 id=\"1.7.Redistotherescue!|outline\">Redis\n                就是解决办法<\/h3><p><a href=\"http://redis.io/\">Redis<\/a>\n                是一个非常快的键-值存储。这只是它的主要用途；它还可做其他许多事情，包括实现一个 <a href=\"http://redis.io/topics/pubsub\">发布-订阅<\/a> 系统。在 Bluemix 目录中，有一个由\n                Redis Cloud 提供的 Redis 服务，它应可用于我们的应用程序。此外，还有一个 <a href=\"https://github.com/mranney/node_redis\">针对 Node.js 的 Redis\n                库<\/a>，我们可使用它与我们的 Redis Cloud 服务通信。<\/p><h4 id=\"1.7.1.MayIhaveaRedisservice,please?|outline\">能给我来一份 Redis 服务吗？<\/h4><p>我们创建 Redis Cloud 的一个实例，以将其用于我们的 BlueChatter 应用程序。在这里，Bluemix\n                可提供帮助。我们只需知道其他一些有关 Redis Cloud 服务的细节。可从我们可靠的 CLI 工具找到它们。在终端窗口中运行以下命令。<\/p><div class=\"codesection\"><pre class=\"displaycode\">cf marketplace<\/pre><\/div><p>此命令将为我们提供一些信息 &#8212; 服务名称、计划和描述、有关 Bluemix 目录中的每个服务的信息等。您应看到一个称为\n                rediscloud 的服务，它具有以下信息。<\/p><div class=\"codesection\"><pre class=\"displaycode\">rediscloud                 25mb                          Enterprise-Class Redis for Developers<\/pre><\/div><p>这是我们为 BlueChatter 应用程序，从 Redis Cloud 创建一个 Redis 实例所需知道的全部信息。<\/p><p>运行以下命令来获得一个 Redis 实例。<\/p><div class=\"codesection\"><pre class=\"displaycode\">cf create-service rediscloud 25mb redis-chatter<\/pre><\/div><p>如果该命令成功完成，您就会有一个 Redis 实例可供使用。这比部署我们的应用程序更容易。可以看到\n                <code>create-service<\/code> 命令接受 3 个参数：服务名称、计划和您选择的 Redis Cloud\n                服务的特定实例的名称。它可以是您想要的任何名称：在本例中，我选择了\n                redis-chatter。可选择任何您想要的名称，但请记下它，因为稍后将需要它。<\/p><h4 id=\"1.7.2.require(redis);|outline\"><code>require('redis');<\/code><\/h4><p>现在是时候在应用程序代码中使用 Redis 了。打开 bluechatter 目录中的 package.json。我们需要将 Redis\n                库添加到我们的依赖关系中。将 dependencies 属性替换为下面的代码段，保存 package.json 文件。<\/p><div class=\"codesection\"><pre class=\"displaycode\">  \"dependencies\": {\n    \"express\": \"3.4.8\",\n    \"cf-env\": \"*\",\n    \"redis\": \"*\"\n  }<\/pre><\/div><p>现在打开 bluechatter 目录中的 app.js。我们需要对 Redis 库执行\n                require，所以我们可在服务器代码中使用它。将以下行添加到 app.js 中其他 require 语句的末尾。<\/p><div class=\"codesection\"><pre class=\"displaycode\">var redis = require('redis');<\/pre><\/div><h5 id=\"1.7.2.1.RedisServiceDetails|outline\">Redis 服务细节<\/h5><p>继续之前，我们需要一些细节，比如主机、端口和密码，才能连接到 Redis Cloud 为我们提供的 Redis 服务器。这些细节是我们在上一节中创建的\n                Redis 实例提供给我们的。它们在一个名为 <code>VCAP_SERVICES<\/code> 的变量中存储为一个 JSON\n                对象。我们的方法是访问该环境变量，解析 JSON 并提取出该信息。但是，我们可使用 cf-env 库为我们执行所有麻烦工作。将以下两行代码添加到\n                app.js 中。<\/p><div class=\"codesection\"><pre class=\"displaycode\">var redisService = cfEnv.getService('redis-chatter');\nvar credentials = !redisService || redisService == null ?  \n{\"host\":\"127.0.0.1\", \"port\":6379} : redisService.credentials;<\/pre><\/div><p>如上所示，我们使用了 cf-env 库的 <code>getService<\/code> API 来访问服务细节。请注意，我们传递了服务器名称\n                (redis-chatter)，所以该库可识别我们想要其细节的服务的具体特定实例。返回给我们的对象中是一个 credentials\n                属性，它包含我们连接到 Redis 服务所需的主机、端口和密码。再一次，我们在获取该属性时很谨慎，因为如果在本地运行应用程序，将没有\n                <code>VCAP_SERVICES<\/code> 环境变量，所以 redisService\n                变量将不会定义。如果它未定义，我们假设用户有一个通过默认端口 (6379) z在本地运行的 Redis 服务器。要在本地运行应用程序，可从 <a href=\"http://redis.io/download\">Redis 网站<\/a> 下载并安装一个本地 Redis 服务器。<\/p><h5 id=\"1.7.2.2.CreatingRedisclients|outline\">创建\n                Redis 客户端<\/h5><p>此刻，我们已准备好创建一些客户端，供我们用于与 Redis 服务器通信。我们需要两个客户端 &#8212;\n                一个用于处理聊天消息的发布，另一个用于监听新聊天消息。将以下代码段添加到 app.js 中。<\/p><div class=\"codesection\"><pre class=\"displaycode\">var subscriber = redis.createClient(credentials.port, credentials.hostname);\nsubscriber.on(\"error\", function(err) {\n  console.error('There was an error with the redis client ' + err);\n});\nvar publisher = redis.createClient(credentials.port, credentials.hostname);\npublisher.on(\"error\", function(err) {\n  console.error('There was an error with the redis client ' + err);\n});\nif (credentials.password != '') {\n  subscriber.auth(credentials.password);\n  publisher.auth(credentials.password);\n}<\/pre><\/div><p>可以看到，我们创建了两个 Redis 客户端，它们包含我们使用 cf-env 库获取的主机和端口，并向它们分配变量名 subscriber 和\n                publisher。此外，如果我们有一个密码（同样请记住，如果在本地运行，我们可能不需要密码），会对两个客户端进行身份验证。<\/p><h5 id=\"1.7.2.3.Letmeknowifthereisanychatter|outline\">如果有任何聊天消息，请告诉我<\/h5><p>让我们使用 subscriber 客户端并监听其他服务器实例发布的任何聊天消息。将以下代码添加到 app.js 中创建 subscriber\n                客户端后的某个位置。<\/p><div class=\"codesection\"><pre class=\"displaycode\">subscriber.on('message', function(channel, msg) {\n  if(channel === 'chatter') {\n    while(clients.length &gt; 0) {\n      var client = clients.pop();\n      client.end(msg);\n    }\n  }\n});\nsubscriber.subscribe('chatter');<\/pre><\/div><p>此代码向 subscriber 客户端添加一个事件监听器来监听任何消息事件。只要通过发布-订阅模式向 redis-chatter\n                实例发布了一些内容，就会触发一个消息事件。处理该事件的函数会获取一个频道和发布的消息。该频道类似于订阅者监听的\n                ID。它标识发布的消息的类型。发布者发布消息，就会指定频道 ID。我们的事件处理函数仅处理频道 “chatter”\n                上的消息，所以我们做的第一件事是确保 channel 变量等于\n                chatter。如果相等，我们对客户端数组执行循环（请记住，这些是我们的长轮询请求），使用发布给它们的消息来响应请求。最后，我们告诉\n                subscriber 客户端，我们希望订阅 chatter 频道。（您可能会自言自语，“因为我仅在 chatter\n                频道上订阅和发布事件，为什么还要检查事件处理函数中的 channel\n                变量？从技术上讲我们不需要这么做，但我们是出色的程序员。我们应预料到，在未来我们也可在其他频道上发布事件。）<\/p><h5 id=\"1.7.2.4.Broadcastingchatter|outline\">广播聊天消息<\/h5><p>此刻，我们的订阅者绝不会被调用，因为没有人在广播任何聊天消息。广播聊天消息的完美场所是客户端向我们发送消息的地方：/msg REST 端点。将\n                bluechatter/app.js 中当前的 /msg 端点实现替换为这个新实现。<\/p><div class=\"codesection\"><pre class=\"displaycode\">app.post('/msg', function(req, res) {\n  message = req.body;\n  publisher.publish(\"chatter\", JSON.stringify(message));\n  res.end();\n});<\/pre><\/div><p>在我们的新实现中，我们不再对客户端数组执行循环并发送聊天消息（此工作现在在 Redis 订阅者事件处理函数中三成。）我们仅从 POST\n                主体获取聊天消息并发布在 chatter 频道上供其他服务器以及我们自己用于发送给客户端。<\/p><h3 id=\"1.8.Scalablechatter|outline\">可扩展的聊天消息<\/h3><p>此刻，我们的应用程序能轻松扩展，但我们的部署已变得更加复杂，因为引入了 Redis 服务的需求。（只有捆绑了 Redis 服务，我们的应用程序才能在\n                Bluemix 中运行。）部署应用程序之前，我们使用一个清单文件来简化部署流程。<\/p><h4 id=\"1.8.1.Nothinglikesimplifyingyourpush|outline\">什么也比不上工作的简化<\/h4><p><a href=\"http://docs.cloudfoundry.org/devguide/deploy-apps/manifest.html\">清单文件<\/a> 可将非常冗长且容易出错的 Bluemix 部署变得简单且一致。在 bluechatter 目录中，创建一个名为\n                manifest.yml 的新文件并向其中添加以下内容。<\/p><div class=\"codesection\"><pre class=\"displaycode\">applications:\n- name: bluechatter\n  memory: 128M\n  command: node app.js\n  services:\n  - redis-chatter<\/pre><\/div><p>可以看到，我们在 <code>cf push<\/code> 命令中指定的大部分参数都已转移到此文件。此外，我们还有一个 services\n                属性，其内容为我们的 Redis 服务的实例的名称。这告诉 Bluemix 在部署我们的应用程序时，将 redis-chatter\n                服务实例绑定到该应用程序。<\/p><h4 id=\"1.8.2.Takingourmanifestforaspin|outline\">试用我们的清单文件<\/h4><p>我们试用一下这个新的有用功能。从 bluchatter 目录内，运行 <code>cf push<\/code>。如果看到 “App\n                started”，则 <code>cf push<\/code> 命令已成功完成，我们已准备好看看是否修复了我们的问题。您的应用程序应该仍有 5\n                个实例在运行，所以请打开您最喜欢的两个浏览器，连接到两个不同的实例。现在在测试应用程序时，您应注意到所有一切又恢复正常了。<\/p><h5 id=\"N10389\">图 8. <\/h5><img alt=\"该图显示测试成功\" src=\"/sunshine_new/images/2084715008/image008.jpg\" width=\"755\" /><p>提示：也在您最喜爱的移动设备上试用该应用程序。<\/p><h5 id=\"N10393\">图 9. <\/h5><img alt=\"该图显示了移动测试\" src=\"/sunshine_new/images/2084715008/image009.jpg\" width=\"338\" /><h4 id=\"1.8.3.Optional:DealingWithtimeouts|outline\">可选：处理超时<\/h4><p>我们需要留心的一个问题是，轮询请求上的超时。假设浏览器向服务器发送了一个请求，但由于很长一段时间都没有发送聊天消息，所以服务器从未响应浏览器。浏览器将会让请求超时。我们希望抢先阻止此情况发生。<\/p><p>一个简单的解决方案是，遍历客户端的数组，每分钟向服务器未响应的任何请求发送 204 作为响应。这可保证服务器绝不会在一个请求上停留超过 1\n                分钟，解决了超时问题。与此同时，可能在一些情况下，浏览器发送一个我们会立即使用 204\n                作为响应的轮询请求，因为它刚好在一分钟结束前发来。我们可提出一个复杂的算法来提高此过程的效率，但对于这个简单的示例，没必要这么做。打开 app.js\n                并添加以下 <code>setInterval<\/code> 调用。<\/p><div class=\"codesection\"><pre class=\"displaycode\">// This interval will clean up all the clients every minute to avoid timeouts\nsetInterval(function() {\n  while(clients.length &gt; 0) {\n    var client = clients.pop();\n    client.writeHeader(204);\n    client.end();\n  }\n}, 60000);<\/pre><\/div><h3 id=\"1.9.Conclusion|outline\">结束语<\/h3><p>我们最终得到了一个可扩展到云中的应用程序。可以看到，我们需要更改它的设计，才能确保它可以扩展，但我们需要更改的代码很少。我们的应用程序中用于允许它扩展的模式，可应用于您想要使用的任何语言\n                &#8212; Java&#8482; 编程语言、Ruby、PHP\n                等。从本文中得到的启事是，编写代码时要考虑到扩展。这样，在将应用程序部署到云中并需要扩展时，您就会自信您的应用程序将继续工作，而不会崩溃。 <\/p><CMA ID: 974584><Site ID: 10><XSLT stylesheet used to transform this file: dw-document-html-7.0.xsl>\r\n\r\n\r\n<\/div>\r\n<\/div>\r\n","createTime":"2014-06-19 00:00:00","deployTime":"2014-06-19 00:00:00","id":0,"intro":"使用 IBM Bluemix 的最有吸引力的原因之一是，它快速且轻松地扩展您的应用程序的能力。使用传统的 IaaS 产品，伸缩您的应用程序需要购买额外的虚拟映像，配置这些映像，部署您的应用程序，以及配置某种类型的负载平衡器来在新映像上分布负载。使用 Bluemix 和它满是服务的目录，所有这些操作只需单击一个按钮即可完成。","keyword":"","recommend":false,"source":"http://www.ibm.com/developerworks/cn/cloud/library/cl-bluemix-node-redis/index.html","title":"使用 Node.js 和 Redis 构建高度可扩展的应用程序","typeId":0,"updateTime":"2014-06-19 00:00:00"}
{"author":"","clickNumber":0,"content":"\r\n<div class=\"ibm-columns\">\r\n<div class=\"ibm-col-1-1\">\r\n\r\n<h2 id=\"2.前言 |outline\">前言<\/h2><p>文章主要描述了基于 IBM System Director 对高可用性集群环境（PowerHA SystemMirror）集中化的管理。（用户可能会对以前的 HACMP 和\n    PowerHA 的名称比较熟悉，这些同类产品的最新名称是：PowerHA SystemMirror。在此说明一下。）对于需要搭建容灾环境的用户来说 PowerHA\n    SystemMirror 企业版可以灵活地满足他们的对于不同环境架构的要求。PowerHA SystemMirror 企业版与 PowerHA SystemMirror 标准版不同，PowerHA SystemMirror 企业版引入了 site 的概念，因此 PowerHA SystemMirror 企业版拥有更为复杂的拓扑结构和配置步骤。但是通过 IBM System Director 可以轻松地完成 site 和 cluster 的创建。本文使用 PowerHA SystemMirror 版本的新功能可以通过图形化界面来管理数据共享磁盘，这样使用户更为直观地管理数据磁盘。文章通过了具体的应用环境，从安装的步骤、配置的过程、操作的规范为您详细地展现了每一步文字界面和图形界面操作的含义。希望通过图片加文字的行文模式给您带来一个比较直观的认识，并给您带来帮助和启发。<\/p><h2 id=\"3.实验环境的描述描述和准备 |outline\">实验环境的描述描述和准备<\/h2><h3 id=\"3.1.一些概念的讲解 |outline\">一些概念的讲解<\/h3><p>由于文中涉及到一些专业的术语和专业知识，在此加以说明。文中出现的专业名词请参考本文作者的其他作品：<a href=\"http://www.ibm.com/developerworks/cn/aix/library/1302_liqiang_powerhaisd/\">基于 IBM Systems Director 对于 PowerHA 高可用性集群资源组进行管理<\/a> 文中的章节\"实验中所用到的术语的解释\"，这一章节对相关的专业术语做出了解释说明。为避免冗余，本文将不重复解释。<\/p><p>特别的需要说明的概念：<\/p><ul class=\"ibm-bullet-list\"><li><strong>Site<\/strong><\/li><\/ul><p>中文的翻译是站点，一个站点是可以拥有多个节点(node)。不同的 Site 可以是存在于不同的物理位置（城东与城西，上海与北京）也可以在同一个机房内。<\/p><h3 id=\"3.2.三种不同类型的 Cluster 的介绍 |outline\">三种不同类型的 Cluster 的介绍<\/h3><a id=\"3.2.1.NoSiteCluster(NSC)|outline\"><\/a><p><strong>No Site Cluster (NSC)<\/strong><\/p><p>第一种类型的集群是没有\"站点\"(site)的\"集群\"(cluster)。同时也被称为是 Standard Cluster（标准集群）。对于建立这个集群，是 PowerHA SystemMirror 标准版中的基本集群。对于企业版来说，必须要兼容标准版中的建立的集群格式，因此本文将不会对此类集群做过多的描述。文中会在一些图片中涉及到这种集群，所以在此做简单的说明。如果您有兴趣的话可以参考：<br /><a href=\"http://www.ibm.com/developerworks/cn/aix/library/1302_liqiang_powerhaisd/\">基于 IBM Systems Director 对于 PowerHA 高可用性集群资源组进行管理<\/a><\/p><a id=\"3.2.2.StretchedCluster(SC)|outline\"><\/a><p><strong>Stretched Cluster (SC)<\/strong><\/p><p>第二类集群，称为延展型的集群。此类集群引入了站点的规划，可以理解为是标准集群(NSC)的增强型配置。该集群由至少两个站点组成，而每一个站点至少由一个节点(node)组成。最为重要的一点，这也是区分 Stretched Cluster 和 Linked Cluster 关键的一点。Stretched Cluster 所有的站点共享同一块心跳盘。因此从这里就可以看出当且仅当，Stretched Cluster 的每一个站点只有一个节点的时候，这个集群的架构就\"退化\"成(NSC)类型的集群。<\/p><a id=\"3.2.3.LinkedCluster(LC)|outline\"><\/a><p><strong>Linked Cluster (LC)<\/strong><\/p><p>第三类集群，也是结构最为复杂的一个集群。这个集群称为链路型的集群。此类集群需要至少两个的站点，并且每个站点需要至少两个节点。最为重要的是，该集群的每一个站点都拥有自己独立的心跳磁盘。从集群配置的角度上来说这个集群如果使用手工配置的话是相当麻烦的，而通过 IBM System Director 来配置将会很简洁。<\/p><h3 id=\"3.3.环境设备的描述 |outline\">环境设备的描述<\/h3><p>本次环境将分别为您展示上述 3 种 cluster 在 IBM Director Server 管理界面中的管理方式。其中 NSC\n    类型的集群将没有具体配置过程，只做配置完之后的展示。文中使用的硬件主要有 IBM Power750、IBM storage 5020、IBM SAN Switch\n    B24。同一个站点中的节点来自同一台物理主机上的 LPAR，而 LPAR 被 VIOS 所管理。VIOS 连接着外部的存储。通过存储为各个站点提供所需要的共享磁盘。Director Server 使用的是 IBM System Director6.3.2GA 版本。<\/p><h2 id=\"4.实验环境的准备 |outline\">实验环境的准备<\/h2><h3 id=\"4.1.软件安装 |outline\">软件安装<\/h3><a id=\"4.1.1.安装 PowerHASystemMirror|outline\"><\/a><p><strong>安装 PowerHA SystemMirror<\/strong><\/p><p>软件需要在所有的节点(node)上进行安装，也就是分别安装在所有的 LPAR 上。<\/p><p>PowerHA SystemMirror 企业版基本安装包一共可以分为两个部分。其中一部分为软件必须安装的包，另一部分为可选的安装包。可选安装包是根据用户需要建立预定义资源组（smart assistant）时用到的安装包。为了避免文章冗长，这里不会把具体安装包罗列出来。请您参考 IBM 官方网站进行软件安装。<\/p><p>（请参考 PowerHA SystemMirror information Center:）http://pic.dhe.ibm.com/infocenter/aix/v7r1/index.jsp?topic=%2Fcom.ibm.aix.powerha.navigation%2Fhacmp.htm<\/p><a id=\"4.1.2.插件安装 |outline\"><\/a><p><strong>插件安装<\/strong><\/p><p>请在 IBM Director Server 上安装 IBM PowerHA SystemMirror 的 plug-in，在所有的节点(node)上安装 IBM PowerHA SystemMirror 的 Sub-Agent。<\/p><p>通过执行 BIN 文件来安装 plug-in。<\/p><div class=\"codesection\"><pre class=\"displaycode\">#IBMSystemsDirector-PowerHA_SystemMirror-AIX.bin -i console<\/pre><\/div><p>Sub-Agent 需要安装一个文件包就可以了<\/p><div class=\"codesection\"><pre class=\"displaycode\">cluster.es.director.agent.rte<\/pre><\/div><p>您可以在下面的网站上获取软件下载信息。<\/p><p><a href=\"http://www-03.ibm.com/systems/software/director/downloads/plugins.html\">http://www-03.ibm.com/systems/software/director/downloads/plugins.html<\/a><\/p><h3 id=\"4.2.共享磁盘的分配 |outline\">共享磁盘的分配<\/h3><p>前文中已经提及关于不同类型集群对于心跳磁盘的要求是不一样的，因此在集群规划阶段需要将共享磁盘做出有效的分配。<\/p><a id=\"4.2.1.SC 集群共享盘的分配 |outline\"><\/a><p><strong>SC 集群共享盘的分配<\/strong><\/p><p>在 VIOS1 上的分配情况：<\/p><div class=\"codesection\"><pre class=\"displaycode\">$ lspv\nNAME PVID VG\n……hdisk28 00f610c747f54be0 None……<\/pre><\/div><p>为 VIOS1 上的所有节点分配这块心跳盘<\/p><div class=\"codesection\"><pre class=\"displaycode\">$ mkvdev -f -vdev hdisk28 -vadapter vhost14\nvtscsi10 Available\n$ mkvdev -f -vdev hdisk28 -vadapter vhost15\nvtscsi11 Available<\/pre><\/div><p>通过命令查看具体磁盘分配的情况。<\/p><div class=\"codesection\"><pre class=\"displaycode\">$ lsmap -vadapter vhost14\n\nSVSA Physloc Client Partition ID\n\n--------------- -------------------------------------------- ------------------\n\nVhost14 U8233.E8B.1010C7P-V2-C21 0x000000e\n……\n\nVTD vtscsi10\n\nStatus Available\n\nLUN 0x8400000000000000\n\nBacking device hdisk28\n\nPhysloc U78A0.001.DNWHR6C-P1-C3-T1-W20150080E518BEAA-L85000000000000\n\nMirrored false\n$ lsmap -vadapter vhost15\n\nSVSA Physloc Client Partition ID\n\n--------------- -------------------------------------------- ------------------\n\nVhost15 U8233.E8B.1010C7P-V2-C22 0x000000f\n……\n\nVTD vtscsi11\n\nStatus Available\n\nLUN 0x8400000000000000\n\nBacking device hdisk28\n\nPhysloc U78A0.001.DNWHR6C-P1-C3-T1-W20150080E518BEAA-L85000000000000\n\nMirrored false<\/pre><\/div><p>按照上述的方法为 VIOS2 进行磁盘分配，同样分配的磁盘的 PVID 为\"00f610c747f54be0\"<\/p><a id=\"4.2.2.LC 集群共享盘分配 |outline\"><\/a><p><strong>LC 集群共享盘分配<\/strong><\/p><p>Linked Cluster 的每一个站点即一台 VIOS 上都拥有自己的心跳磁盘，因此需要为需要分配两块不同的磁盘给两台不同的 VIOS。<\/p><p>分配的方法和 SC 集群相同。在这里 VIOS1 使用的磁盘的 PVID 是\"00f610c73ee5684e\"，VIOS2 的共享盘的 PVID 是\"00f610c73ee6bc98\"。<\/p><h3 id=\"4.3.各个节点配置前的准备工作 |outline\">各个节点配置前的准备工作<\/h3><a id=\"4.3.1.AIX 系统的版本 |outline\"><\/a><p><strong>AIX 系统的版本<\/strong><\/p><p>本次行文的使用的 PowerHA SystemMirror 的版本是 7.1.2。IBM 官方要就 AIX 的版本必须高于 AIX 6.1 TL8 或者 AIX 7.1 TL2。<\/p><a id=\"4.3.2.对于系统软件的要求 |outline\"><\/a><p><strong>对于系统软件的要求<\/strong><\/p><p>・RCST 的版本必须高于 3.1.4<\/p><p>・bos.cluster.rte 这个软件对于 AIX 6.1 来说，版本必须高于 6.1.8。如果是 AIX 7.1 的话，则需要高于 7.1.2。<\/p><a id=\"4.3.3.相关文件的编辑 |outline\"><\/a><p><strong>相关文件的编辑<\/strong><\/p><p>编辑/etc/hosts 文件，在所有节点上加入参加集群的所有节点主机名(hostname)和 IP 地址，每个节点中的这个文件必须相同。<\/p><p>编辑/etc/cluster/rhosts 文件，同样加入所有参加集群节点的 IP 地址。<\/p><a id=\"4.3.4.启动相应的服务 |outline\"><\/a><p><strong>启动相应的服务<\/strong><\/p><p>当修改过/etc/cluster/rohsts 之后必须刷新 clcomd 这个服务来更行所做的修改。<\/p><p>通过以下的命令停止 clcomd 服务。<\/p><div class=\"codesection\"><pre class=\"displaycode\">#stopsrc Cs clcomd; sleep 10; startsrc Cs clcomd<br />#refresh Cs clcomd<\/pre><\/div><a id=\"4.3.5.检查 IBMSystemDirector 的状态 |outline\"><\/a><p><strong>检查 IBM System Director 的状态<\/strong><\/p><div class=\"codesection\"><pre class=\"displaycode\">#/opt/ibm/director/bin/smstatus\nActive<\/pre><\/div><p>在 director server 通过使用命令来确定。<\/p><p>状态是 Active，说明 IBM System Director 运行正常。<\/p><a id=\"4.3.6.检查 Plug-In 和 Sub-Agent 的通信 |outline\"><\/a><p><strong>检查 Plug-In 和 Sub-Agent 的通信<\/strong><\/p><p>首先检查 Plug-In 的安装是否正确，在 director server 上执行如下命令。<\/p><div class=\"codesection\"><pre class=\"displaycode\">#smcli lsversion -sv\nIBM PowerHA SystemMirror 7.1.2.1\nInstallation Date: Wed Mar 27 23:12:15 CDT 2013\nBuild Date: Wednesday October 31, 2012 at 02:24:33 PM CDT<\/pre><\/div><p>安装正确的话，系统会显示出 Plug-In 的信息，包括版本，安装时间，和版本发布的时间。<\/p><p>接下来检查一下 Sub-Agent 和 Plug-In 的通信状态，同样在 director server 操作。<\/p><div class=\"codesection\"><pre class=\"displaycode\">#smcli lsversion Cav\n\n……\n\nNode on prve64\n\nHALevel: 7.1.2.1\n\nOsLevel: 6100-08-01-1245\n\nHAEdition: ENTERPRISE\n\nPlugin Build Date: Wednesday October 31, 2012 at 02:08:45 PM CDT\n\nPlugin Installation Date: Thu Mar 14 00:02:26 CST6CDT 2013\n\nPlugin version: 7.1.2.1\n\nMEID: 5291\n\nAccess State: Unlocked\n\nComm State (Director): OK\n\nComm State (PowerHA): OK\n\n……\n\nNode on prve68\n\nHALevel: 7.1.2.1\n\nOsLevel: 6100-08-01-1245\n\nHAEdition: ENTERPRISE\n\nPlugin Build Date: Wednesday October 31, 2012 at 02:08:45 PM CDT\n\nPlugin Installation Date: Wed Mar 27 01:22:54 CST6CDT 2013\n\nPlugin version: 7.1.2.1\n\nMEID: 5986\n\nAccess State: Unlocked\n\nComm State (Director): OK\n\nComm State (PowerHA): OK\n\n……<\/pre><\/div><p>从运行的结果中可以看到\"Comm State (PowerHA)\"的状态是 OK。这就说明了，Plug-In 和 Sub-Agent 之间的通信已经建立了。<\/p><p>还需要注意的是\"Comm State (Director)\"是本 director server 于 director client 之间的通行状态，必须是正常的状态，这是前提条件。并且\"Access State\"是指 director server 是否已经获得了管理该 director client 的权限。如果是\"unlocked\"的状态说明权限已经获得。<\/p><p>对于获得管理权限的方法，请参考(IBM Systems Director 6.3.x Information Center)：<br />http://pic.dhe.ibm.com/infocenter/director/pubs/index.jsp<\/p><h2 id=\"5.通过 IBMSystemDirector 建立不同种类的集群 |outline\">通过 IBM System Director 建立不同种类的集群<\/h2><h3 id=\"5.1.创建 StretchedCluster 类型的集群 |outline\">创建 Stretched Cluster 类型的集群<\/h3><h5 id=\"5.1.1.图 1.实验环境的拓扑图 |outline\">图 1.\n    实验环境的拓扑图<\/h5><img alt=\"实验环境的拓扑图\" src=\"/sunshine_new/images/1253504293/image001.png\" width=\"563\" /><p>这里需要强调的共享磁盘的位置，建立 SC 集群是要求心跳磁盘需要被所有的节点识别到。<\/p><h5 id=\"5.1.2.图 2.开始创建 |outline\">图 2. 开始创建<\/h5><img alt=\"开始创建\" src=\"/sunshine_new/images/1253504293/image002.jpg\" width=\"755\" height=\"311\" /><p><a href=\"#N10178\" class=\"ibm-popup-link\" onclick=\"ibmweb.overlay.show('N10178',this);return false;\">点击查看大图<\/a><\/p><div id=\"N10178\" class=\"dw-sidefile-overlay ibm-common-overlay ibm-overlay-alt-two\"><div class=\"ibm-head\"><p><a href=\"#close\" class=\"ibm-common-overlay-close\">关闭 [x]<\/a><\/p><\/div><div class=\"ibm-body\"><div class=\"ibm-main\"><div class=\"ibm-title\"><h2>图 2. 开始创建<\/h2><\/div><div class=\"ibm-container ibm-alternate\"><div class=\"ibm-container-body\"><img alt=\"开始创建\" src=\"/sunshine_new/images/1253504293/image002.jpg\" width=\"1002\" /><\/div><\/div><\/div><\/div><div class=\"ibm-footer\"><><\/div><\/div><p>如何通过游览器访问 director server 管理页面请参考：<br />http://pic.dhe.ibm.com/infocenter/director/pubs/index.jsp<\/p><p>点击位于 IBM System Director 左侧的导航界面中的\"PowerHA SystemMirror\"按钮之后，再点击\"Create Cluster\"按钮就可以看到配置向导的欢迎界面了，点击 next 进入下一步配置。<\/p><h5 id=\"5.1.3.图 3.选择创建集群的类型和基本属性。|outline\">图 3. 选择创建集群的类型和基本属性。<\/h5><img alt=\"选择创建集群的类型和基本属性。\" src=\"/sunshine_new/images/1253504293/image003.jpg\" width=\"850\" height=\"409\" /><p><a href=\"#N1018C\" class=\"ibm-popup-link\" onclick=\"ibmweb.overlay.show('N1018C',this);return false;\">点击查看大图<\/a><\/p><div id=\"N1018C\" class=\"dw-sidefile-overlay ibm-common-overlay ibm-overlay-alt-two\"><div class=\"ibm-head\"><p><a href=\"#close\" class=\"ibm-common-overlay-close\">关闭 [x]<\/a><\/p><\/div><div class=\"ibm-body\"><div class=\"ibm-main\"><div class=\"ibm-title\"><h2>图 3. 选择创建集群的类型和基本属性。<\/h2><\/div><div class=\"ibm-container ibm-alternate\"><div class=\"ibm-container-body\"><img alt=\"选择创建集群的类型和基本属性。\" src=\"/sunshine_new/images/1253504293/image003.jpg\" width=\"1128\" /><\/div><\/div><\/div><\/div><div class=\"ibm-footer\"><><\/div><\/div><p>首先需要为集群起名字，这里命名为\"main_cluster\"。<\/p><p>选择建立有站点的集群，并且选择集群的类型为\"stretched\"。<\/p><p>为两个站点命名，这里命名为\"alpha\"站点和\"bravo\"站点。<\/p><h5 id=\"5.1.4.图 4.选择将要参加集群的节点 |outline\">图 4. 选择将要参加集群的节点<\/h5><img alt=\"选择将要参加集群的节点\" src=\"/sunshine_new/images/1253504293/image004.jpg\" width=\"849\" height=\"435\" /><p><a href=\"#N101A0\" class=\"ibm-popup-link\" onclick=\"ibmweb.overlay.show('N101A0',this);return false;\">点击查看大图<\/a><\/p><div id=\"N101A0\" class=\"dw-sidefile-overlay ibm-common-overlay ibm-overlay-alt-two\"><div class=\"ibm-head\"><p><a href=\"#close\" class=\"ibm-common-overlay-close\">关闭 [x]<\/a><\/p><\/div><div class=\"ibm-body\"><div class=\"ibm-main\"><div class=\"ibm-title\"><h2>图 4. 选择将要参加集群的节点<\/h2><\/div><div class=\"ibm-container ibm-alternate\"><div class=\"ibm-container-body\"><img alt=\"选择将要参加集群的节点\" src=\"/sunshine_new/images/1253504293/image004.jpg\" width=\"1127\" /><\/div><\/div><\/div><\/div><div class=\"ibm-footer\"><><\/div><\/div><p>选择将要加入集群的节点。这里是按照站点的位置来分类的。通 Plug-In 于 Sub-Agent 的通信，system director 还可以掌握节点的操作系统版本、HA 的版本和 HA 的版本类型。从上图可以看到版本类型是企业版。<\/p><h5 id=\"5.1.5.图 5.选择将要参加集群的节点 |outline\">图 5. 选择将要参加集群的节点<\/h5><img alt=\"选择将要参加集群的节点\" src=\"/sunshine_new/images/1253504293/image005.jpg\" width=\"700\" height=\"411\" /><p><a href=\"#N101B0\" class=\"ibm-popup-link\" onclick=\"ibmweb.overlay.show('N101B0',this);return false;\">点击查看大图<\/a><\/p><div id=\"N101B0\" class=\"dw-sidefile-overlay ibm-common-overlay ibm-overlay-alt-two\"><div class=\"ibm-head\"><p><a href=\"#close\" class=\"ibm-common-overlay-close\">关闭 [x]<\/a><\/p><\/div><div class=\"ibm-body\"><div class=\"ibm-main\"><div class=\"ibm-title\"><h2>图 5. 选择将要参加集群的节点<\/h2><\/div><div class=\"ibm-container ibm-alternate\"><div class=\"ibm-container-body\"><img alt=\"选择将要参加集群的节点\" src=\"/sunshine_new/images/1253504293/image005.jpg\" width=\"930\" /><\/div><\/div><\/div><\/div><div class=\"ibm-footer\"><><\/div><\/div><p>从上图可以看到，分类已经完成了。每一个站点都有两个节点。在分类过程中，系统会自动移除一个在其他站点的节点，因此说明一个节点只能存在于一个站点内。<\/p><h5 id=\"5.1.6.图 6.查看共享磁盘的情况。|outline\">图 6. 查看共享磁盘的情况。<\/h5><img alt=\"查看共享磁盘的情况。\" src=\"/sunshine_new/images/1253504293/image006.jpg\" width=\"510\" /><p>点击按钮任意站点中的\"view shared disks\"按钮，可以查看到共享的磁盘的分配情况，这些共享磁盘是作为心跳磁盘的候选磁盘。从图中可以看到所有的节点共有的一块磁盘，这块磁盘的 PVID 为\"00f610c747f54be0\"正是前文通过 VIOS 分配的磁盘。将这块磁盘作为 SC 集群的心跳磁盘。<\/p><h5 id=\"5.1.7.图 7.控制节点的选择 |outline\">图 7. 控制节点的选择<\/h5><img alt=\"控制节点的选择\" src=\"/sunshine_new/images/1253504293/image007.jpg\" width=\"850\" height=\"409\" /><p><a href=\"#N101CE\" class=\"ibm-popup-link\" onclick=\"ibmweb.overlay.show('N101CE',this);return false;\">点击查看大图<\/a><\/p><div id=\"N101CE\" class=\"dw-sidefile-overlay ibm-common-overlay ibm-overlay-alt-two\"><div class=\"ibm-head\"><p><a href=\"#close\" class=\"ibm-common-overlay-close\">关闭 [x]<\/a><\/p><\/div><div class=\"ibm-body\"><div class=\"ibm-main\"><div class=\"ibm-title\"><h2>图 7. 控制节点的选择<\/h2><\/div><div class=\"ibm-container ibm-alternate\"><div class=\"ibm-container-body\"><img alt=\"控制节点的选择\" src=\"/sunshine_new/images/1253504293/image007.jpg\" width=\"1128\" /><\/div><\/div><\/div><\/div><div class=\"ibm-footer\"><><\/div><\/div><p>选择控制节点，这里也可以设置集群的永久 IP 地址。关于永久 IP 地址的设定请参考：<br />http://www.redbooks.ibm.com/abstracts/sg247739.html?Open<\/p><h5 id=\"5.1.8.图 8.RepositoryDisk 的选择 |outline\">图 8. Repository Disk 的选择<\/h5><img alt=\"Repository Disk 的选择\" src=\"/sunshine_new/images/1253504293/image008.jpg\" width=\"850\" height=\"409\" /><p><a href=\"#N101E0\" class=\"ibm-popup-link\" onclick=\"ibmweb.overlay.show('N101E0',this);return false;\">点击查看大图<\/a><\/p><div id=\"N101E0\" class=\"dw-sidefile-overlay ibm-common-overlay ibm-overlay-alt-two\"><div class=\"ibm-head\"><p><a href=\"#close\" class=\"ibm-common-overlay-close\">关闭 [x]<\/a><\/p><\/div><div class=\"ibm-body\"><div class=\"ibm-main\"><div class=\"ibm-title\"><h2>图 8. Repository Disk 的选择<\/h2><\/div><div class=\"ibm-container ibm-alternate\"><div class=\"ibm-container-body\"><img alt=\"Repository Disk 的选择\" src=\"/sunshine_new/images/1253504293/image008.jpg\" width=\"1128\" /><\/div><\/div><\/div><\/div><div class=\"ibm-footer\"><><\/div><\/div><p>这里就可以选择刚才看到的磁盘作为心跳磁盘。<\/p><h5 id=\"5.1.9.图 9.上述操作的总结 |outline\">图 9. 上述操作的总结<\/h5><img alt=\"上述操作的总结\" src=\"/sunshine_new/images/1253504293/image009.jpg\" width=\"687\" /><p>对于上述环境的总结，之后点击\"Finish\"按钮就可以执行建立 stretched cluster 集群了。<\/p><h3 id=\"5.2.创建 LinkedCluster 类型的集群 |outline\">创建 Linked Cluster 类型的集群<\/h3><p>由于篇幅的限制和行文的方便，由于 LC 集群和 SC 集群在一些步骤上的操作是类似的，这里将不再重复描述，只是将建立 LC 集群中的关键步骤加以说明。在此告之您。<\/p><h5 id=\"5.2.1.图 10.实验环境的拓扑图 |outline\">图 10.\n    实验环境的拓扑图<\/h5><img alt=\"实验环境的拓扑图\" src=\"/sunshine_new/images/1253504293/image010.png\" width=\"542\" /><p>于 SC 集群不同的是 LC 集群每个站点都拥有自己独立的共享磁盘作为心跳磁盘。从拓扑图中就可以看到这两者之间的差异。<\/p><p>LC 集群的配置和 SC 集群几乎是相同的，需要为集群和集群的站点命名，并且选择集群的类型是\"Linked\"。对于在下文中出现的一些图片，您可能会有疑问，为什么本文中 SC 和 LC 集群都是用\"main_cluster\"来命名。这里需要说明一下。由于设备的限制，文中用于建立 SC 和 LC 集群的 LPAR 都是相同的，因此作者是建立完 SC 集群后将这个 SC 集群删除，然后再建立 LC 集群的，所以这里的\"main_cluster\"和前文中提到的 SC 集群没有任何关系。<\/p><h5 id=\"5.2.2.图 11.LC 集群共享磁盘的选择 |outline\">图 11. LC 集群共享磁盘的选择<\/h5><img alt=\"LC 集群共享磁盘的选择\" src=\"/sunshine_new/images/1253504293/image011.jpg\" width=\"512\" /><p>为站点选择完节点之后，分别点击各个站点中的\"View Shared Disks\"按钮查看。从上图 10 中可以看到，PVID 为\"00f610c73ee5684e\"和\"00f610c73ee6bc98\"分别独立属于各自的 VIOS。因此这两块磁盘为作为心跳磁盘的候选磁盘。而 PVID 为\"00f610c747f54be0\"的磁盘属于全部的 LPAR，正是前文中用于建立 SC 集群的心跳磁盘。<\/p><h5 id=\"5.2.3.图 12.LC 集群操作总结 |outline\">图 12. LC 集群操作总结<\/h5><img alt=\"LC 集群操作总结\" src=\"/sunshine_new/images/1253504293/image012.jpg\" width=\"682\" /><p>同样的，点击\"Finish\"按钮就可以完成操作，IBM System Director 将会按照配置建立相应的集群。<\/p><p>至此，基于 IBM System Director 用于建立不同类型集群的操作就结束了，接下来将会为您介绍对于这个集群的基本管理方法。<\/p><h2 id=\"6.通过 IBMSystemDirector 对于各种类型集群的管理 |outline\">通过 IBM System Director 对于各种类型集群的管理<\/h2><h3 id=\"6.1.对于 LC 集群的管理 |outline\">对于 LC 集群的管理<\/h3><p>对于刚刚建立好的 LC 集群，如果没有在建立集群的总览界面里选择启动集群的话，那么此时所有的节点状态都是\"offline\"。如果集群没有同步，或者同步出现问题的情况下状态则会变成\"Not_Config\"。接下来就需要对这个集群做启动的操作。<\/p><h5 id=\"6.1.1.图 13.启动 LC 集群 |outline\">图 13. 启动 LC 集群<\/h5><img alt=\"启动 LC 集群\" src=\"/sunshine_new/images/1253504293/image013.jpg\" width=\"819\" /><p>通过\"Actions\"的下来菜单选择\"Bring Cluster Services Online\"的选项来启动集群。启动的方式可以分为启动整个集群，和启动集群中的某一个站点。根据具体的需要可以随意改变启动的方式。<\/p><h5 id=\"6.1.2.图 14.按照不同站点启动的集群 |outline\">图 14. 按照不同站点启动的集群<\/h5><img alt=\"按照不同站点启动的集群\" src=\"/sunshine_new/images/1253504293/image014.jpg\" width=\"728\" /><p>比较图 14 的左右两幅图可以明显地看到不同的启动方式的不同结果。左侧的集群只是启动了一个节点，而右侧的集群可以看到出于完全启动的状态。这里需要告知您的是，右图是两个不同类型集群的混合界面，其中包括了 NSC(no-site cluster)集群和 LC 集群。NSC 集群建立和管理将不再文中介绍。<\/p><h5 id=\"6.1.3.图 15.LC 集群逻辑关系的拓扑图 |outline\">图 15. LC 集群逻辑关系的拓扑图<\/h5><img alt=\"LC 集群逻辑关系的拓扑图\" src=\"/sunshine_new/images/1253504293/image015.jpg\" width=\"524\" /><p>IBM System Director 为 PowerHA 提供方便的图形化管理界面。用户可以直观地从拓扑图上找到所有关于集群的信息，并且根据需求在各个节点或者站点上做操作。这样就可以为用户做出集群状态的描述，降低了在单节点上操作的风险。<\/p><h3 id=\"6.2.对于 SC 集群的管理 |outline\">对于 SC 集群的管理<\/h3><p>关于 SC 集群的基本管理，管理方式和 LC 集群相似，因此在这里不加赘述了。<\/p><h3 id=\"6.3.对于资源组的管理 |outline\">对于资源组的管理<\/h3><p>由于篇幅的限制，本文将不对如何建立资源做具体阐述，将已经建立好的资源作为实验环境。建立资源组的目的是为了下一章节中建立共享 volume group(VG)、logic volume(LV)和 file system(FS)做铺垫。<\/p><a id=\"6.3.1.建立共享数据 VG，LV，FS|outline\"><\/a><p><strong>建立共享数据 VG、LV、FS<\/strong><\/p><p>本文建立共享的数据 VG、LV、FS，是基于 NSC(no site cluster)的集群为基础的。由于受到硬件的限制并且 SC 和 LC 配置资源组的过程相当复杂，因此基于集群站点所建立的共享数据资源不在本文的讨论范围内，作者将会在其他作品里单独介绍这方面的知识，在此说明。<\/p><h5 id=\"6.3.2.图 16.创建共享数据资源 |outline\">图 16. 创建共享数据资源<\/h5><img alt=\"创建共享数据资源\" src=\"/sunshine_new/images/1253504293/image016.jpg\" width=\"838\" height=\"376\" /><p><a href=\"#N10285\" class=\"ibm-popup-link\" onclick=\"ibmweb.overlay.show('N10285',this);return false;\">点击查看大图<\/a><\/p><div id=\"N10285\" class=\"dw-sidefile-overlay ibm-common-overlay ibm-overlay-alt-two\"><div class=\"ibm-head\"><p><a href=\"#close\" class=\"ibm-common-overlay-close\">关闭 [x]<\/a><\/p><\/div><div class=\"ibm-body\"><div class=\"ibm-main\"><div class=\"ibm-title\"><h2>图 16. 创建共享数据资源<\/h2><\/div><div class=\"ibm-container ibm-alternate\"><div class=\"ibm-container-body\"><img alt=\"创建共享数据资源\" src=\"/sunshine_new/images/1253504293/image016.jpg\" width=\"1113\" /><\/div><\/div><\/div><\/div><div class=\"ibm-footer\"><><\/div><\/div><p>上文中已经说明，\"lucky_cluster\"是一个 NSC 的集群，她的资源组已经建立好了，名称是\"lucky_group\"。选择该资源组，点击\"Storage\"选择，可以看，所有的该资源里没有任何共享数据信息。然后点击\"Add a volume group\"进入创建共享数据资源的流程(wizard)。<\/p><h5 id=\"6.3.3.图 17.节点的选择 |outline\">图 17. 节点的选择<\/h5><img alt=\"节点的选择\" src=\"/sunshine_new/images/1253504293/image017.jpg\" width=\"850\" height=\"409\" /><p><a href=\"#N10295\" class=\"ibm-popup-link\" onclick=\"ibmweb.overlay.show('N10295',this);return false;\">点击查看大图<\/a><\/p><div id=\"N10295\" class=\"dw-sidefile-overlay ibm-common-overlay ibm-overlay-alt-two\"><div class=\"ibm-head\"><p><a href=\"#close\" class=\"ibm-common-overlay-close\">关闭 [x]<\/a><\/p><\/div><div class=\"ibm-body\"><div class=\"ibm-main\"><div class=\"ibm-title\"><h2>图 17. 节点的选择<\/h2><\/div><div class=\"ibm-container ibm-alternate\"><div class=\"ibm-container-body\"><img alt=\"节点的选择\" src=\"/sunshine_new/images/1253504293/image017.jpg\" width=\"1128\" /><\/div><\/div><\/div><\/div><div class=\"ibm-footer\"><><\/div><\/div><p>开始的欢迎提示我们浏览一下，然后点击\"next\"到图 19 的地方。选择需要创建共享数据资源的两个节点。随后继续下一步。<\/p><h5 id=\"6.3.4.图 18.VG 基本属性的配置 |outline\">图 18. VG 基本属性的配置<\/h5><img alt=\"VG 基本属性的配置\" src=\"/sunshine_new/images/1253504293/image018.jpg\" width=\"850\" height=\"407\" /><p><a href=\"#N102A5\" class=\"ibm-popup-link\" onclick=\"ibmweb.overlay.show('N102A5',this);return false;\">点击查看大图<\/a><\/p><div id=\"N102A5\" class=\"dw-sidefile-overlay ibm-common-overlay ibm-overlay-alt-two\"><div class=\"ibm-head\"><p><a href=\"#close\" class=\"ibm-common-overlay-close\">关闭 [x]<\/a><\/p><\/div><div class=\"ibm-body\"><div class=\"ibm-main\"><div class=\"ibm-title\"><h2>图 18. VG 基本属性的配置<\/h2><\/div><div class=\"ibm-container ibm-alternate\"><div class=\"ibm-container-body\"><img alt=\"VG 基本属性的配置\" src=\"/sunshine_new/images/1253504293/image018.jpg\" width=\"1128\" /><\/div><\/div><\/div><\/div><div class=\"ibm-footer\"><><\/div><\/div><p>为新建的 VG 命名并且选择 VG 的类型。选择 PP(physical partition)的大小。PP 的大小将会影响之后创建的 LV 中 LP(logical partition)的数量，因此需要提前计算清楚。这里作者选择的是 64MB。接下来选择并发磁盘的切换方式，用户可以根据具体的情况改变这些属性。<\/p><h5 id=\"6.3.5.图 19.LV 配置信息 |outline\">图 19. LV 配置信息<\/h5><img alt=\"LV 配置信息\" src=\"/sunshine_new/images/1253504293/image019.jpg\" width=\"850\" height=\"379\" /><p><a href=\"#N102B5\" class=\"ibm-popup-link\" onclick=\"ibmweb.overlay.show('N102B5',this);return false;\">点击查看大图<\/a><\/p><div id=\"N102B5\" class=\"dw-sidefile-overlay ibm-common-overlay ibm-overlay-alt-two\"><div class=\"ibm-head\"><p><a href=\"#close\" class=\"ibm-common-overlay-close\">关闭 [x]<\/a><\/p><\/div><div class=\"ibm-body\"><div class=\"ibm-main\"><div class=\"ibm-title\"><h2>图 19. LV 配置信息<\/h2><\/div><div class=\"ibm-container ibm-alternate\"><div class=\"ibm-container-body\"><img alt=\"LV 配置信息\" src=\"/sunshine_new/images/1253504293/image019.jpg\" width=\"1128\" /><\/div><\/div><\/div><\/div><div class=\"ibm-footer\"><><\/div><\/div><p>创建 LV，填写 LV 的名字。选择 LV 的数据类型，这里选择的是 JFS2 的类型。这里的 LP 数量之前提到过，说明一下 240 这个数字的由来。作者将要建立一个 15G 的 FS，PP 的大小是 64MB。一次 LP 的个数就是\"15*1024/64=240\"其他的选项包括 LV 位于磁盘的位置的选，这些则属于操作系统的范畴，在此不作说明，请您自行掌握这些知识。<\/p><h5 id=\"6.3.6.图 20.FS 的配置 |outline\">图 20. FS 的配置<\/h5><img alt=\"FS 的配置\" src=\"/sunshine_new/images/1253504293/image020.jpg\" width=\"534\" /><p>根据之前创建的 LV 继续创建 FS。从下拉菜单里选选择\"lv01\"，然后填写 FS 的大小，为 15G。填写挂载点。其他的部分，关于建立日志型的文件系统，同属 AIX 操作系统范畴，请您自行学习。<\/p><h5 id=\"6.3.7.图 21.Wizard 总览 |outline\">图 21. Wizard 总览<\/h5><img alt=\"Wizard 总览\" src=\"/sunshine_new/images/1253504293/image021.jpg\" width=\"598\" /><p>确认上述信息无误，可以点击\"Finish\"开始创建数据共享资源。<\/p><h5 id=\"6.3.8.图 22.SC 集群的总览 |outline\">图 22. SC 集群的总览<\/h5><img alt=\"SC 集群的总览\" src=\"/sunshine_new/images/1253504293/image022.jpg\" width=\"738\" /><p>当创建完成之后，选择资源组之后就可以看到，这些创建的信息。<\/p><a id=\"6.3.9.结束语 |outline\"><\/a><p><strong>结束语<\/strong><\/p><p>行文至此，本文将进入尾声。本文通过大量的真是环境的操作截图为您展示一个新的配置集群的方法。对于 PowerHA System Mirror 企业版来说，部署集群的复杂程度要高于标准版。但是 IBM System Director 简化了传统意义上 HA 配置的复杂步骤，通过图形界面引导用户使用简洁的方式完成部署和创建的操作。在管理集群的层面上，IDS 更为人性化，更为合理化，使用逻辑图形化的拓扑图来规避了一些在双机环境下的单机操作过程中会出现的一些常规错误，降低了用户在日常操作中的风险。并且用户也可以实时掌握集群的状态信息，使得操作更有针对性。<\/p><p>笔者很高兴再次与您分享 IBM System Director 和 IBM PowerHA SystemMirror 结合使用的相关文章。关于 IBM PowerHA SystemMirror 企业版，其功能相当强大。资源组的部署与应用较之前的几个版本也更为灵活。因此作者接下来可能会就企业版资源组的层面，继续致力于写出更多的关于 PowerHA 企业版的其他作品。最后，作者诚心希望本文能为您带启发和参考价值。<\/p><CMA ID: 974523><Site ID: 10><XSLT stylesheet used to transform this file: dw-document-html-7.0.xsl>\r\n\r\n\r\n<\/div>\r\n<\/div>\r\n","createTime":"2014-06-19 00:00:00","deployTime":"2014-06-19 00:00:00","id":0,"intro":"本文主要描述了基于 IBM System Director 对高可用性集群环境（PowerHA SystemMirror）集中化的管理。对于需要搭建容灾环境的用户来说 PowerHA SystemMirror 企业版可以灵活地满足他们的对于不同环境架构的要求。然而企业级的容灾环境的搭建十分复杂而繁琐，如果可以通过图形化界面的方式的话，那么搭建的过程变得相对简单而高效。本文便是通过了具体的应用环境，从安装的步骤、配置的过程、操作的规范为您详细地展现了每一步文字界面和图形界面操作的含义，通过图形化界面来搭建 PowerHA SystemMirror 企业级的环境。","keyword":"","recommend":false,"source":"http://www.ibm.com/developerworks/cn/aix/library/1406_liqiang_powerhamirror/index.html","title":"基于 IBM Systems Director 对于 PowerHA SystemMirror 7.1 企业版的部署及管理","typeId":0,"updateTime":"2014-06-19 00:00:00"}
{"author":"","clickNumber":0,"content":"\r\n<div class=\"ibm-columns\">\r\n<div class=\"ibm-col-1-1\">\r\n\r\n<h2 id=\"introduction\">引论<\/h2><p>在过去 20\n          年里，系统工程领域经历了重大的改变。尤其是，系统工程从基于文本文档描述分析转变为基于模型方法，从而实现抽象出系统的核心特性来更好地关注和应用严格的分析工作。这也就是说，很大程度上，得益于统一建模语言（Unified Modeling Language，UML）使用的日渐广泛，导致另一伴随衍生出的标准建模语言，系统建模语言（Systems Modeling Language，SysML）也得以发展。我曾有幸参与到制定这两项标准的工作当中。作为一名工作了很长一段时间的系统和嵌入式软件工程师，我为标准提供了来自系统工程师的分析性和代表性的需求。我的建议同样帮助确定这些建模语言在其制定目标上的适用性，即“支持和改善系统工程的实践现状”。<\/p><p>在我过去工作的几十年里，我曾工作在多种系统工程环境中，从小型可植入医疗设备到通讯系统，再到直升机航空电子设备和宇航设备。我曾见过多种不同精确度、完成度、正确性和价值的模型。这一经验和多样性帮助我形成那些适用于系统工程建模的重要观点，以及明确哪些，换句话说是“不那么有效”的观点。我与您分享我相信的，关于为系统工程有效进行建模的十大洞察。当然，这并不完全包括我关于这一主题所有想说的观点，不过还是让我们开始吧。<\/p><h2 id=\"forget72\">10：忘掉 7 ± 2<\/h2><p>打断我，如果您曾经听到过这句话：“所有模型图都应包括七个元素，或加减二。”（\"All diagrams should contain seven elements, plus or minus two.\"）<\/p><p>您是否曾经质疑这句话的出处？<\/p><p>在 1956 年，George Miller 曾在《心理学评论》（<em>Psychology Review<\/em>）期刊发表过一篇文章，题为“魔法的数字‘七’，或加减二：我们处理信息的极限能力。”（\"The magical number seven, plus or minus two: some limits on our capacity for processing information.\"）这篇文章研究关于刺激回忆（stimulus recall）的两个方面。第一方面称为<em>一维绝对判断（one-dimensional absolute judgment）<\/em>，这是关于我们区分一组在一维上发生变化的刺激（例如，尺寸或颜色），并返回一个先前已学会的反应（例如按下按钮）作为结果的能力的度量。另外一个方面的研究是<em>记忆广度（memory span）<\/em> C 我们回忆一系列展现过后即从眼前移走的物品的能力。巧合的是，这两方面都表明这些物品的数量是有限的（50% 准确度），即七个元素或加减二。<\/p><p>在本文这里一个有趣的问题是，“这跟现在要把多少东西放在一个模型图上有何关系？”<\/p><p>回答是，当然，“毫无关联。”<\/p><p>需要记住的是，与 Miller 博士所做的实验不同的是 C 在他的实验中他展现了一系列元素，随后移除该系列元素，然后在一段时间延迟后让实验参与者根据记忆复述该系列元素的清单 C 而在模型图上的元素<em>在您看图的时候它们仍然在您面前<\/em>。<\/p><p>另一方面，一个有任意合理尺寸的模型往往会有几百上千个元素。显然，您也同样无法将所有元素都放在一张模型图上。所以您应该怎么做？<\/p><p>作为 Harmony 过程（Harmony Process）的作者之一，我的建议是：每一个模型图都应有一个想要展示的单一概念或问题，并且把所有与该概念相关的元素都展示出来。这也被称为模型图的“任务”。<\/p><p>有些模型图拥有非常清晰的任务。例如一个 UML 或 SysML 的状态图，展现了系统中一个单独的类（class）或模块（block）的状态行为。其他模型图在其用途方面则更灵活。<\/p><table border=\"0\" cellpadding=\"0\" cellspacing=\"0\" class=\"ibm-data-table\" summary=\"two column table, left aligned with header row\"><thead xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"><tr><th> 序列图（Sequence diagram），例如，可以用于 <\/th><th> 目的 <\/th><\/tr><\/thead><tbody xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"><tr><td> 展示在一个用例（use case）的执行过程中，系统在其环境中如何与参与者（actor）进行交互 <\/td><td> 捕获围绕一个用例的场景（scenario）中的需求 <\/td><\/tr><tr><td> 展示一个特定案例中的内部设计元素之间如何交互 <\/td><td> 展示随着时间而展开的利益之间的协作 <\/td><\/tr><tr><td> 定义一个期待的输入-输出（input-output）转换序列 <\/td><td> 展示一个测试用例（test case） <\/td><\/tr><tr><td> 重现系统在某些特定测试用例里的真实行为 <\/td><td> 展示一个测试结果 <\/td><\/tr><\/tbody><\/table><p>类图（class diagram）或块图（block diagram）还可以更加灵活。类图或块图的常见任务陈述包括：<\/p><ul class=\"ibm-bullet-list\"><li>展示实现一个大规模行为的协作所涉及的设计元素，例如一个用例中的设计元素<\/li><li>展示需求分配到结构化元素或用例上的分配情况<\/li><li>展示一个一般化的分类学（generalization taxonomy）<\/li><li>展示一个模型的组织情况（或称为“包图”，\"package diagram\"）<br /><strong>注解：<\/strong><br />UML 及 SysML 标准在区分模型图的<em>类型（types）<\/em>及其<em>使用（uses）<\/em>的差别上做得很差。任务图（task diagram）是目的主要是用于展示并发架构的类图（class diagram），正如结构图是目的为了显示类内部结构的类图一样。但两者都是类图。<\/li><li>展示架构方面，例如：\n          <ul class=\"ibm-bullet-list\"><li>子系统及组件架构<\/li><li>部署架构（不同的工程实践规程的职责分配情况）<\/li><li>并发及资源管理架构<\/li><li>分布式架构<\/li><li>可靠性架构（包括安全性、可靠性及安全保护）<\/li><\/ul><\/li><li>展示设计模式抽象\n          <ul class=\"ibm-bullet-list\"><li>展示实例快照（也称为“对象图”，\"object diagram\"）<\/li><li>展示软件元素之间的接口<\/li><li>展示工程规程之间的接口<\/li><li>展示一个结构化类的结构（也称为“结构图”，\"structure diagram\"）<\/li><\/ul><\/li><\/ul><p>任务（mission）的概念表示每一个模型图只应尝试回答<strong>一个问题<\/strong>或支持<strong>一条特定原因<\/strong>。在我的经验里，多数很差劲的模型图都失败在它们不是没有清晰的任务，就是尝试去回答过多的问题。<\/p><p>我喜欢清晰，并且喜欢在模型图上标注注解来清晰地陈述模型图的任务。图 1-3 展示了一个典型例子。<\/p><h5 id=\"fig1\">图 1. 任务：展示用例被分配的需求<\/h5><img alt=\"个人的交通任务用例图\" src=\"/sunshine_new/images/1253253639/image001.jpg\" width=\"796\" /><h5 id=\"fig2\">图 2. 任务：展示实现一个用例所需要协调的设计元素<\/h5><img alt=\"描绘空间关系\" src=\"/sunshine_new/images/1253253639/image002.jpg\" width=\"850\" /><h5 id=\"fig3\">图 3. 任务：为用例展示一个使用场景（包括前置条件和后置条件）<\/h5><img alt=\"个人交通用例的使用场景\" src=\"/sunshine_new/images/1253253639/image003.jpg\" width=\"850\" /><p>这显然表明同样一个元素拥有在不同的图中展示的潜在可能，但这不是个问题。许多优秀的建模工具都会维护一个语义信息的存储库，来作为关于该模型的唯一可信信息来源，而模型图总是描绘许多围绕这些可信信息的子集。<\/p><p>这就是我的清单上的第十条建议。下面您将会了解到第九条，“所有模型都是抽象，但只有一部分是有用的”。敬请期待。<\/p><CMA ID: 974973><Site ID: 10><XSLT stylesheet used to transform this file: dw-document-html-7.0.xsl>\r\n\r\n\r\n<\/div>\r\n<\/div>\r\n","createTime":"2014-06-19 00:00:00","deployTime":"2014-06-19 00:00:00","id":0,"intro":"系统工程师正在响应要求更严格采用 UML 及 SysML 标准的需求。这些标准很复杂，而且既没有提供指导如何才是最佳建模技巧来使用这些建模语言有效定义需求和架构，也没有指导如何使用建模来演示交易案例，并且也没有系统工程所需的各种分析方法。Douglass 博士曾在几百个项目上提供过超过 30 年的咨询。在这一面向基于模型系统工程的十大建模建议清单里，他分享了他的观点及深度经验。","keyword":"","recommend":false,"source":"http://www.ibm.com/developerworks/cn/rational/top-10-modeling-hints-system-engineers-01/index.html","title":"针对系统工程师的十大建模建议: #10 忘掉 7 ± 2","typeId":0,"updateTime":"2014-06-19 00:00:00"}
{"author":"","clickNumber":0,"content":"\r\n<div class=\"ibm-columns\">\r\n<div class=\"ibm-col-1-1\">\r\n\r\n<h2 id=\"2.Linux 网络文件系统简介 |outline\">Linux 网络文件系统简介<\/h2><p>网络文件系统(NFS)协议是由 Sun MicroSystem 公司在 20 世纪 80 年代为了提供对共享文件的远程访问而设计和实现的，它采用了经典的客户机/服务器模式提供服务。为了达到如同 NFS 协议通过使用 Sun 公司开发的远在本机上使用本地文件系统一样便捷的效果，NFS 通过使用远程过程调用协议(RPC Protocol)来实现运行在一台计算机上的程序来调用在另一台远程机器上运行的子程序。同时，为了解决不同平台上的数据交互问题，它提供了外部数据表示(XDR)来解决这个问题。为了灵活地提供文件共享服务，该协议可以在 TCP 协议或者是 UDP 协议上运行，典型的情况是在 UDP 协议上运行。在此基础上，NFS 在数据的传送过程中需要 RPC 命令得到确认，而且在需要的时候会要重传，这样既可以通过 UDP 协议获得较高的通信效率，也能通过 RPC 来获得较高的通信可靠性。<\/p><p>由于 NFS 基于 C/S 模式提供服务，所以它的核心组件主要包括客户机和服务器两部分。图 1 详细说明了 NFS 的主要组件以及主要的配置文件。在服务器端，portmap、mountd、nfsd 三个监控程序将在后台运行。portmap 监控程序用来注册基于 RPC 的服务。当一个 RPC 的监控程序启动的时候，它告诉 portmap 监控程序它在哪一个端口进行侦听，并且它在进行什么样的 RPC 服务。当一个客户机向服务器提出一个 RPC 请求，那么它就会和 portmap 监控程序取得联系以确定 RPC 消息应该发往的端口号。而 Mountd 监控程序的功能是来读取服务器端的/etc/exportfs 文件并且创建一个将服务器的本地文件系统导出的主机和网络列表，因而客户机的挂接(mount)请求都被定位到 mountd 监控程序(daemon)。当验证了服务器确实具有挂接所请求的文件系统的权限以后，mountd 为请求的挂接点返回一个文件句柄。而 nfsd 监控程序则被服务器用来处理客户机端发送过来的请求。由于服务器需要同时处理多个客户机的请求，所以在缺省情况下，操作系统将会自动启动八个 nfsd 线程。当然，如果 NFS 服务器特别忙的时候，系统有可能根据实际情况启动更多的线程。<\/p><h5 id=\"N10050\">图 1 网络文件系统简图<\/h5><img alt=\"图 1 网络文件系统简图\" src=\"/sunshine_new/images/332605877/image003.jpg\" width=\"327\" /><p>NFS 的客户机与服务器之间通过 RPC 进行通信，通信过程如下所示：<\/p><ol type=\"1\"><li>用户将 NFS 服务器的共享目录挂载到本地文件系统中。<\/li><li>客户访问 NFS 目录中的文件时，NFS 客户端向 NFS 服务器端发送 RPC 请求。<\/li><li>NFS 服务端接收客户端发来的 RPC 请求，并将这个请求传递给本地文件访问程序，然后访问服务器主机上的一个本地的磁盘文件。NFS 服务器可以同时接收多个 NFS 客户端的请求，并对其进行并发控制。<\/li><li>NFS 客户端向服务器主机发出一个 RPC 调用，然后等待服务器的应答。NFS 客户端收到服务器的应答后，把结果信息展现给用户或应用程序。<\/li><\/ol><h2 id=\"1.NFS 下的数据备份、恢复的主要功能 |outline\">NFS 下的数据备份、恢复的主要功能<\/h2><p>对数据进行备份与恢复是保证数据安全和业务连续性的非常成熟的做法。在 Linux 下的本地文件系统（例如 Ext2、Ext3 等）中，数据备份和恢复一般采用常规的办法来进行操作，例如使用 Tar、Archive 等。而对于 NFS 来说，其数据备份需要采用量身定制的方法来进行。<\/p><p>为了保证数据在灾难环境中的可用性和业务连续性，针对它的数据备份、恢复方案应具备如下重要功能：<\/p><ul class=\"ibm-bullet-list\"><li>通过对系统重要数据的快速备份，切实保证系统数据的安全；<\/li><li>可以根据指令完成备份系统的实时切入，保证服务不被中断，保持系统持续运行的能力；<\/li><li>通过实时记录所有文件的操作日志，系统管理员能够在发生灾难的情况下对日志进行分析和取证，从而发现入侵者的蛛丝马迹。<\/li><\/ul><h2 id=\"1.NFS 多版本备份技术 |outline\">NFS 多版本备份技术<\/h2><p>为了保证服务器出现故障后能迅速恢复，要求系统数据能快速恢复到一个最近的正确状态，所有这些都需要多版本技术的支持，通过同步记录文件的在某些时刻的状态，在整个系统范围内建立起类似于数据库系统的\"检查点\"，以保证上述目标的实现。<\/p><p>对于多版本系统而言，需要较好地解决两个方面的问题：性能和空间利用率。对于前者，最主要的是保证在生成版本的时候能够快速完成，同时恢复时也具有较好的性能。此外，系统引入多版本造成的整体开销也应该比较理想。对于第二点，主要考虑是节约磁盘空间，虽然随着硬件技术的不断发展，磁盘空间越来越大，性价比也越来越高，但是当版本较多而且文件数量较多、较大时，引入多版本增加的开销也可能相当可观，同时，较大的空间也意味着版本生成时可能需要更多的写操作，这样也必将影响总体性能。<\/p><p>为了保证引入多版本特性后文件系统仍具有较好的性能，以及保证较高的空间利用率，我们开发了一种高效的惰性版本生成算法。主要思想是：生成版本时不进行文件的复制，仅复制目录结构，在新版本生成后到下一版本生成前，如果有文件需要修改，则第一次修改时对该文件进行复制，从而保证该文件状态与对应的版本保持一致。<\/p><p>在一般情况下，目录结构的数据量远远小于文件的数据量，因而这种方法可以大大降低版本生成时需要复制的数据量，因而具有较高的性能。同时，这种把单个文件版本生成的实际操作推后到非做不可的时候，并且任意文件在两次版本之间最多生成一次版本，因此这种惰性策略可以使需要实际生成版本的文件数量达到最少，同时还可以把多个文件版本生成操作分散到具体的文件操作中，从而避免了集中的一次性版本生成方法可能造成的服务暂时停顿的问题。<\/p><p>版本生成后的结构如图 2 所示。<\/p><h5 id=\"N10087\">图 2 多版本生成示意图<\/h5><img alt=\"图 2 多版本生成示意图\" src=\"/sunshine_new/images/332605877/image005.png\" width=\"500\" /><p>具体算法包括两个部分，即版本生成算法和文件第一次修改处理算法，版本生成算法主要完成版本生成工作，主要过程如下：<\/p><ol type=\"1\"><li>找到需要形成版本的最高层目录作为原目录；<\/li><li>利用文件系统提供的函数，生成新的目录节点，称为新目录；<\/li><li>把原目录中的结构复制到新目录；<\/li><li>在原目录中找到所有的子目录，重复 2、3 步；<\/li><li>把新的子目录对应的 inode 号替换上一层目录中的老 inode 号；<\/li><li>重复上述过程，及到目录树中的所有目录得到复制为止。<\/li><\/ol><p>在上述策略中，新版本并没有复制所有的文件，只是在复制的目录结构中记录下了该文件的 inode 号（即复制了目录的结构，而不是把文件都进行复制，从而节省了存储和计算资源)，因此，当有 NFS 请求需要对文件进行版本生成后的第一次修改时，需要复制该文件，生成新的版本。该实现过程参见如下流程图：<\/p><h5 id=\"N100A5\">图 3 写时复制算法示意图<\/h5><img alt=\"图 3 写时复制算法示意图\" src=\"/sunshine_new/images/332605877/image007.png\" width=\"661\" /><p>这种文件复制策略其实是一种惰性算法，也即我们常说的写时复制的方法，这个方法在 Linux 操作系统的子进程对父进程资源的继承中有所体现。这个策略一方面可以最大限度减少复制文件的数量，另一方面则可以避免瞬间过大的文件复制工作量，影响文件服务的性能。该算法的过程如下：当文件操作为写操作时，判断该文件是否版本生成后的第一次写操作；若是则利用文件系统提供的底层函数生成一个新的文件，复制源文件的数据到新生成的文件，同时把该文件当前版本的 inode 节点中的版本号置为当前版本号，这样新文件就成为该文件的最新版本。<\/p><p>虽然我们采用的算法可以有较好的性能，存储开销也是最优，但是，每次版本生成肯定会造成服务性能的下降和空间的占用，而这些代价在一个比较安全可靠的环境中是可以适当降低的，即当系统比较安全的时候，可以选择让系统以更低的频率进行版本生成，相反，当系统安全状况比较糟糕的时候，可以通过提高版本生成频率适当降低服务性能来获得更高的数据安全性能，当系统处于紧急状态时，甚至可以要求立即进行版本生成。<\/p><p>基于这些考虑，我们采用了自适应的备份策略，灾情评估系统可以动态评估系统的灾情程度，然后可以立即修改版本生成策略，以适应当时的安全要求。<\/p><h2 id=\"1.NFS 数据恢复技术 |outline\">NFS 数据恢复技术<\/h2><p>企业应用 NFS 的一个重要目标就是要保证系统的高可用性，即使在出现严重灾难、故障、攻击等情况下能具有较好的生存能力。因此，当一个系统出现故障时，如何快速地恢复系统，迅速投入到服务备份中去是相当重要的，所以，对于文件系统数据的恢复而言，也需要专门的考虑和设计。<\/p><p>本方案被配置成多个站点互为备份的情况，即平时只有一个主站点在服务，其他站点处于同步备份状态，当某个站点出现故障或灾难时，或者是被非法入侵者攻破时，系统可以立即分配新的主站点把被破坏的站点替换下来，进入恢复状态，其他正常的站点仍可提供正常的服务。<\/p><p>当然，也存在所有站点均出现故障的情况，但是由于我们采用了多种措施，如动态随机迁移、灾情评估与响应策略等，再配合传统的防火墙、IDS 等安全系统，可以极大限度地减少这种几率。因此，我们的数据恢复问题主要考虑上述这种情形，即个别服务器出现故障退出服务而其他系统依然正常的情况。<\/p><p>首先，我们来分析一下系统退出后数据的情形，主要涉及到退出的服务器和正常的主服务器与备份服务器，如图 4 所示：<\/p><h5 id=\"N100C4\">图 4 一个系统退出后数据状态示意图<\/h5><img alt=\"图 4 一个系统退出后数据状态示意图\" src=\"/sunshine_new/images/332605877/image009.png\" width=\"521\" /><p>在上图中，退出服务器最后生成的版本号为 i，系统退出后，一方面主文件服务器会察觉到同步数据无法从退出服务器返回结果，这样的话它就会重发同步请求，经过 3 次重发后，如果依然没有返回信息，则认为该服务器退出服务，因此会把同步数据备份到磁盘文件中，并记录下该服务器在同步数据文件中的起始位置，这当由多个文件服务器退出时可以分别识别出来。由于退出系统无法继续保持同步，因此其状态会与工作的文件服务器不一致，具体表现在以下几个方面：<\/p><ol type=\"1\"><li>当退出时间很短时，数据不一致仅存在于缓冲区中，这时如果退出服务器能立即重新投入使用，则不需要进行额外的数据恢复，数据同步可以通过主服务器同步请求的重试来达到。<\/li><li>当主服务器确认退出服务器退出后，会把未同步的数据写入特定的同步数据文件中，这时的不一致性包括了缓冲区中的数据和同步数据文件中的数据，这时的数据恢复需要做两方面的工作：<ul class=\"ibm-bullet-list\"><li>把同步数据文件中的正确数据一次性发送给退出服务器，退出服务器把它写入本地的同步数据文件；<\/li><li>建立本地的缓冲区，建立起同步机制，接收同步数据，同时启动数据同步进程，先同步数据文件中的数据，当缓冲区数据因没有处理而达到一定程度时，会自动把部分数据追加到同步数据文件的后面，这时，退出服务器已经恢复了正常工作，实际上也不需要过多的数据恢复工作。<\/li><\/ul><p>由于主文件服务器一般需要处理文件的读写请求，写请求仅占一部分，需要同步而执行的操作造成的负载要小于主服务器，因此可能在较短的时间内完成同步。当需要退出服务器（此时已经进入同步阶段）成为主服务器时，则必须等所有同步数据同步完成后才能开始服务。<\/p><\/li><li>如果退出服务器是因为较严重的故障或灾难而退出的，则可能需要较长时间的处理，如更换硬件、系统重启、甚至重装系统等，这时就可能出现一些困难的情况，一种是如上图所示的，工作正常的系统已经生成了新的版本，如服务器退出时的最新版本是 i，经过一段时间后，正常系统生成了新的版本，这时主系统会清空同步数据文件，重新从版本生成后进行记录。对于这种情况，可以有两种处理办法：<ul class=\"ibm-bullet-list\"><li>基于本地版本的快速恢复：当退出文件服务器本地至少存在一个版本与其他正常机器上的版本相同时，可以采用这种恢复策略。具体而言，先确定一个最新的正确版本，用本地版本恢复，这一过程非常简单快捷，仅涉及到两次 inode 的修改；然后选择一台正常服务器，请求它生成一个正常系统上最新版本与恢复版本的增量升级数据，这样的数据量不会很大，而且不需要象基于操作的同步那样逐步进行，同步效率非常高，因此可以大大提高恢复速度。同步到正常系统的最新版本后，然后就按照上述第 2 条的情况进行同步数据文件的同步。<\/li><li>基于分布版本的快速恢复：当停顿时间太长而不存在一个相同的版本，或文件服务器数据出现损坏（如磁盘故障造成数据损毁）时，需要采用此种方法。具体办法如下：直接把正常服务器上的最新版本传送到退出服务器，然后按照上述的第 2 种情况进行同步数据文件的同步。<\/li><\/ul><\/li><\/ol><p>正如上面所述，全部服务器均出现问题的概率是很小的，但是，不能简单的排除这种情况的出现，特别是本方案采用数据同步机制，即多个站点的数据是保持快速同步的，这虽然能保证动态迁移的顺利完成，但是也带来较大的风险，就是会出现数据\"污染\"的自动传播，当主文件服务器中的文件数据因为某些原因（主要是对文件的非法访问）造成数据非法修改时，会立即传播到其他备份节点，这样的话，不管服务迁移到哪台机器均会出现错误。<\/p><p>针对这种情况，我们采取了以下措施：当发现非法修改造成数据污染时，系统可以自动命令各站点恢复到指定的版本，如前一版本（可以由管理员配置成前一、二、三个版本）；管理员也可以干预这一过程，强制各站点恢复到同一指定的版本，从而保证全局文件系统使用同一正确版本。<\/p><h2 id=\"1.NFS 文件细粒度恢复技术 |outline\">NFS 文件细粒度恢复技术<\/h2><p>在传统恢复技术中，一方面由于数据备份不是实时进行的，当出现事故需要恢复时，最新的备份数据与最新数据之间存在一个时间差，这样就造成了该时间段内数据的丢失（见图 5）；同时，传统的数据备份是一定时间段后数据的增量备份，是一段时间内所有文件操作叠加后的结果，因而无法精确知道在这段时间内实际数据的变化过程，因而也无法从所有这些操作中定位非法操作，并进行选择性的恢复，以保证数据的正确性。<\/p><h5 id=\"N100F1\">图 5 因非实时备份造成恢复时的数据丢失示意图<\/h5><img alt=\"图 5 因非实时备份造成恢复时的数据丢失示意图\" src=\"/sunshine_new/images/332605877/image011.png\" width=\"595\" /><p>基于上述考虑，我们不但采用了增量方式的多版本备份恢复技术，同时还对文件的修改日志进行了实时的备份，这样就可以在事故发生后进行基于文件操作的精确恢复，并支持允许剔除非法操作的选择性恢复，这样既能尽量避免因事故造成的数据丢失问题，又能通过选择性恢复较好保证数据的正确性，同时，还可以通过对日志的分析，结合数据的精确恢复，达到发现犯罪线索、获得有效证据的目的，为打击网络犯罪提供有力的技术手段。在这里，精确性恢复指的是恢复某一时段的所有操作，一般是在某一版本后的所有操作，不由用户进行选择，而选择性恢复则指的是某一时间段内的所有操作构成的集合的子集，需要恢复的操作由用户通过查询、浏览等工具来进行选择。在我们的定义中，实际上可以认为精确恢复为选择性恢复的一个特例。<\/p><p>我们首先需要有相关的解决方法来记录下具体的操作信息，形成操作日志文件，从而作为分析的证据（参见图 6）。我们使用的策略是通过修改服务器操作系统内核调用 nfsd_write()、nfsd_create()……。从中取到调用处理对象的文件、目录的全路径名，写进文件，在内核中截获相应的文件操作请求。下面以 nfsd_rename()系统调用为例，进行扩充、修改而实现记录操作日志的功能。<\/p><div class=\"codesection\"><pre class=\"displaycode\">int nfsd_rename(struct svc_rqst *rqstp, struct svc_fh *ffhp, char *fname, \n    int flen,struct svc_fh *tfhp, char *tname, int tlen)\n{\n\tstruct dentry\t*fdentry, *tdentry, *odentry, *ndentry;\n\tstruct inode\t*fdir, *tdir;\n\tint\t\terr;\nchar *name;\n\tmem_segment_t oldfs;\n\tint fd;\n\terr = fh_verify(rqstp, ffhp, S_IFDIR, MAY_REMOVE);\n\tif (err)\n\t\tgoto out;\n\trqstp-&gt;rq_path1 = rqstp-&gt;rq_path2;\n\terr = fh_verify(rqstp, tfhp, S_IFDIR, MAY_CREATE);\n\tif (err)\n\t\tgoto out;\n\tfdentry = ffhp-&gt;fh_dentry;\n\tfdir = fdentry-&gt;d_inode;\n\ttdentry = tfhp-&gt;fh_dentry;\n\ttdir = tdentry-&gt;d_inode;\n\t……\n\t//加入的代码进行处理工作\n\tif((!rqstp-&gt;rq_recover)&amp;&amp;(!S_ISDIR(odentry-&gt;d_inode-&gt;i_mode))\n\t\t&amp;&amp;(odentry-&gt;d_inode-&gt;i_nlink&gt;1)){\n\t\trqstp-&gt;rq_copy-&gt;wait = 1;\n\t\trqstp-&gt;rq_copy-&gt;done = 0;\n\tname = get_total_name(dentry,NULL);\noldfs = get_fs();\nset_fs(KERNEL_DS);  //进入内核模式\nfd =\tsys_open(\"/backupserv/changfilename.c\",0,31681);\nsys_write(fd,name,strlen(name));\nsys_close(fd);\nset_fs(oldfs);   //从内核模式返回\n\t\twhile(!rqstp-&gt;rq_copy-&gt;done){\t\n\t\t\tschedule_timeout((HZ+99)/100);\n……\n\t\t}\n\t}<\/pre><\/div><p>该文件是在 nfs 服务器端执行 nfs 客户机发送过来的修改文件或者是目录的原函数。在这里，我们可以通过添加自己的代码，来将创建的目录和文件名存入一个磁盘文件当中，以备后面的备份和恢复操作。<\/p><h5 id=\"N10107\">图 6 NFS 文件细粒度恢复日志产生示意图<\/h5><img alt=\"图 6 NFS 文件细粒度恢复日志产生示意图\" src=\"/sunshine_new/images/332605877/image013.png\" width=\"575\" /><p>获得了操作日志信息，然后就可以进行精确恢复和选择性恢复时。首先由用户利用数据查询、浏览工具确定需要恢复的文件操作集，然后利用相应的日志数据按记录产生顺序逐条生成恢复请求，发送给文件服务器端的代理程序，由它通过 proc 文件请求 NFS 文件系统恢复模块进行恢复，恢复模块收到请求后，取出相关数据，然后通过调用底层 ext3 文件系统基本操作完成该次文件操作的\"重放\"，最后返回执行结果，通过 proc 文件通知代理程序，代理程序再通知管理端，管理端再发送下一条恢复请求，及到所有选中的操作全完成为止。具体实现模式请参看图 7：<\/p><h5 id=\"N10116\">图 7 恢复流程示意图<\/h5><img alt=\"图 7 恢复流程示意图\" src=\"/sunshine_new/images/332605877/image015.png\" width=\"499\" /><h2 id=\"1.数据快速同步技术 |outline\">数据快速同步技术<\/h2><p>在系统中，各文件服务器之间的数据需要及时同步更新，这样才能保证服务迁移后到新的环境后相关数据环境的一致性，从而保证服务迁移在语义上的正确性。在本方案中，每个文件服务器均采用 NFSv3 协议向外提供文件服务，当系统开始工作时，管理员会指定一台主服务器，由该服务器负责向外提供服务，其他文件服务器为备份服务器，接收同步数据，进行数据的同步更新，并不对外提供服务，只有当系统决定迁移后，选定的迁移目标对应的文件服务器才成为主文件服务器。<\/p><p>由于主文件服务器负责对外的文件服务，因此，数据同步的发起者应该是主文件服务器，而所有的备份服务器均为被动的同步数据接收者。因此，数据的快速同步包含两方面的工作：主文件服务器产生同步数据和备份文件服务器接收同步数据完成同步。具体的数据流向如图 8 所示：<\/p><h5 id=\"N1012B\">图 8 同步数据的产生与流动示意图<\/h5><img alt=\"图 8 同步数据的产生与流动示意图\" src=\"/sunshine_new/images/332605877/image017.jpg\" width=\"508\" /><p>为了达到数据快速同步的目的，我们采用了记录文件写操作（包括创建、修改、删除、改名、属性修改等所有的改变文件或目录属性、内容的操作）的具体参数的方法来生成同步数据，这样每次生成的数据量比较少，而且可以满足及时更新的目的。同步数据的格式及相关代码段如下：<\/p><div class=\"codesection\"><pre class=\"displaycode\">struct Log {\nint length;\t//整个数据包的长度\nint ops;\t\t//操作的类型\nchar* data;\t//与操作相关数据\n};\n//下面代码段从内核将同步数据包发往其他文件服务器\nlong send(struct socket* sock, void * buff,size_t len)\n{\n \tint err;\n\tmm_segment_t oldfs;\n\tstruct msghdr msg;\n\tstruct iovec iov;\n\tstatic int total = 0;\n\tdown(&amp;log_sem);\n\tiov.iov_base=buff;\n\tiov.iov_len=len;\n\tmsg.msg_name=NULL;\n\tmsg.msg_iov=&amp;iov;\n\tmsg.msg_iovlen=1;\n\tmsg.msg_control=NULL;\n\tmsg.msg_controllen=0;\n\tmsg.msg_namelen=0;\n\ttotal += len;\n\tmsg.msg_flags = MSG_SYN;//DONTWAIT;\n\toldfs=get_fs();\n\tset_fs(KERNEL_DS);\n\terr = sock_sendmsg(sock, &amp;msg, len);\n\tset_fs(oldfs);\n   if(err&lt;0){\n\t\tdprintk(\"send err(errNo=%d len = %d)\\n\",err,len);\t\n\t\tnetbroken = 1;\n\t}\n……\n\tup(&amp;log_sem);\n\treturn(err);\n}<\/pre><\/div><p>同步数据产生后，先放入一个缓冲区中，而不是立即发送到备份文件服务器，这样可以较大程度改善系统的总体性能。缓冲区中的数据由同步管理进程管理，当达到一定数据量时，同步管理程序负责把缓冲区中的数据发送到备份文件服务器上，并根据返回的应答结果决定是否需要把重发数据，当确认某个服务器无法响应后，自动把同步数据定期写入一个仅可追加的文件，以便于随后可能需要的恢复阶段同步的需要，当这个写入的文件数据量超出一定限制时，并且系统确认已经至少有一个新的版本生成，可以把该文件清空。<\/p><p>当数据到达备份文件服务器时，由独立的接收进程负责把数据放入接收缓冲区，经核对数据无误后给主服务器发送确认信号，另一个独立进程即更新管理进程把接收缓冲区作为输入，从中解析出一个个的顺序的操作日志，从每个日志中得到操作类型，然后在剩余的数据中按照特定的操作类型提取所需的参数，利用文件系统调用完成相应操作。<\/p><h2 id=\"1.总结 |outline\">总结<\/h2><p>Linux 网络文件系统已经为企业在数据备份和共享领域得到了广泛应用。如何保证其多版本备份、实时恢复是一个非常关键的问题，本文将详细介绍针对该网络文件系统的数据备份、恢复及同步机制在内核的具体实现，给广大系统管理员和研发人员提供技术参考。<\/p><CMA ID: 974533><Site ID: 10><XSLT stylesheet used to transform this file: dw-document-html-7.0.xsl>\r\n\r\n\r\n<\/div>\r\n<\/div>\r\n","createTime":"2014-06-19 00:00:00","deployTime":"2014-06-19 00:00:00","id":0,"intro":"Linux 网络文件系统已经为企业在数据备份和共享领域得到了广泛应用。如何保证其多版本备份、实时恢复是一个非常关键的问题，本文将详细介绍针对该网络文件系统的数据备份、恢复及同步机制在内核的具体实现，给广大系统管理员和研发人员提供技术参考。","keyword":"","recommend":false,"source":"http://www.ibm.com/developerworks/cn/linux/1406_liyang_nfsbackuprestore/index.html","title":"Linux 网络文件系统的数据备份及恢复机制实现","typeId":0,"updateTime":"2014-06-19 00:00:00"}
{"author":"","clickNumber":0,"content":"\r\n<div class=\"ibm-columns\">\r\n<div class=\"ibm-col-1-1\">\r\n\r\n<h2 id=\"introduction\">简介<\/h2><p>在提供一个服务以便在组织中重用时，服务提供者通常会提供许多工件，服务使用者可使用这些工件来实现客户应用程序或服务。这些工件通常包含一个或多个 WSDL 或 XML 模式文档。尽管这些工件提供了服务使用者开发人员所需的信息，但它们未提供与服务使用者期望从该服务获得的非功能性或服务质量 (QoS) 特征的任何信息。<\/p><p>IBM WebSphere Service Registry and Repository（下文简称 WSRR）中提供的 Governance Enablement Profile (GEP) 是一个完整的 WSRR 配置文件，包含所有业务模型、生命周期、本体和治理策略，您需要它们才能快速掌握面向服务的架构 (SOA) 的治理。它使服务提供者可以使用服务水平定义 (SLD) 捕获服务的 QoS 特征。它还使服务提供者与服务使用者之间存在的协议可以使用服务水平协议 (SLA) 来表示。<\/p><p>本文介绍一个示例消息流，它在运行时执行 WSRR 中定义的 SLA，以确保服务使用者有权调用目标服务。<\/p><h2 id=\"business_scenario\">SLA 检查业务场景<\/h2><p>这篇文章中描述的示例流将重点关注 <a href=\"http://www.ibm.com/developerworks/cn/websphere/library/techarticles/1404_smithson1/1404_smithson1.html#slacheck\">第 1 部分：场景和配置<\/a> 中描述的 SLA 检查场景，如下所示：<\/p><ul class=\"ibm-bullet-list\"><li><p><strong>业务问题<\/strong><\/p><p>您的 SOA 中部署了许多服务，而且它们都已在 WSRR 中注册。但是，您无法在 WSRR 中注册这些服务的使用者。结果，您不知道哪些服务使用者可能在任何给定时间点调用每个服务。您希望确保 SOA 中的所有服务使用者都已在 WSRR 中注册，而且只有有权调用目标服务的使用者被允许这么做。<\/p><\/li><li><p><strong>解决方案<\/strong><\/p><p>WSRR 允许您在 SOA 中注册服务使用者和服务提供者。它还支持使用服务水平协议 (SLA) 表示服务提供者和服务使用者之间的协议或契约。消息流可在运行时动态地从 WSRR 检索此信息，使用它确定服务使用者是否有权调用目标服务。如果服务使用者有权调用目标服务，它可将请求转发给协商一致的端点。如果服务使用者无权调用目标服务，会返回一个恰当的错误。<\/p><\/li><li><p><strong>好处<\/strong><\/p><p>此方法允许您控制纳西服务使用者调用实际的后端服务，使您能够在 SOA 中执行一定水平的运行时治理。一种附加好处是，只要服务使用者和提供者已经在 WSRR 中注册，就可以在 <strong>Service Registry Dashboard<\/strong> 用户界面直观地表示这些关系，并使用它来评估您计划对服务所做的任何更改会带来的影响。<\/p><\/li><\/ul><h2 id=\"ModelingServiceProviders\">建模服务提供者<\/h2><p>GEP 中包含的业务模型定义了所有必要的对象类型，您需要使用它们来表示服务提供者、服务使用者和它们之间的协议。用于建模服务提供者和服务使用者的核心类型如  中所述。<\/p><h5 id=\"table1\">Governance Enablement Profile (GEP) 中的主要对象类型<\/h5><table border=\"0\" cellpadding=\"0\" cellspacing=\"0\" class=\"ibm-data-table\"><thead xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"><tr><th>对象类型<\/th><th>描述<\/th><\/tr><\/thead><tbody xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"><tr><td><img alt=\"组织图标\" src=\"/sunshine_new/images/1580908927/images/Organization.jpg\" width=\"54\" /><strong>组织（Organization）<\/strong><\/td><td>在任何治理流程中，都必须存在所有权。组织对象体现了这种所有权。其他每个对象都必须归某个组织所有，无论是直接还是间接所有。<\/td><\/tr><tr><td><img alt=\"业务能力图标\" src=\"/sunshine_new/images/1580908927/images/Business_Capability.jpg\" width=\"54\" /><strong>业务能力（Business Capability）<\/strong><\/td><td>业务能力对象表达了对您企业中需要的某种能力的业务观点。该对象将会描述业务需求和关注点，而不是实现。可以从广义的业务视角来看待该能力。有许多类型的业务能力。举例而言，一种能力可与其他能力结合使用，从而建立一种更大的能力。在这种情况下，该能力课作为一种业务服务来考虑和表示。业务服务、业务应用程序和业务流程都是具体的业务能力类型。<\/td><\/tr><tr><td><img alt=\"能力版本图标\" src=\"/sunshine_new/images/1580908927/images/Capability_Version.jpg\" width=\"54\" /><strong>能力版本（Capability Version）<\/strong><\/td><td>能力版本是业务能力的实现。能力版本指示了如何提供业务能力，举例而言，它是否是 Web 服务，它是否需要消息，等等。该实现的各个方面（比如 Web 服务定义或 SCA 模块）可从能力版本中引用。业务能力具有特定的类型，能力版本也是如此。举例而言，从其他能力构建的能力或者用于构建其他能力的能力均可视为服务版本。服务版本、应用程序版本和流程版本都是具体的能力版本类型。能力版本对象的一个重要方面是，它们具有版本号。一个能力版本可能具有许多实现了同一种业务能力的版本。<\/td><\/tr><tr><td><img alt=\"服务水平定义图标\" src=\"/sunshine_new/images/1580908927/images/Service_Level_Definition.jpg\" width=\"54\" /><strong>服务水平定义（Service Level Definition，SLD）<\/strong><\/td><td>SLD 描述一种能力的非功能性或服务质量特征。这些特征包括该能力一天有多少小时可用，或者与该能力的交互所需的安全保护类型，等等。您可以考虑一个可部署到许多不同服务器上、为不同类型的客户或不同地区服务的能力版本。每个服务器可能无法提供相同的服务质量，而且需要惟一的 SLD。但是，每个使用者以相同方式与该能力交互。<\/td><\/tr><tr><td><img alt=\"服务水平协议图标\" src=\"/sunshine_new/images/1580908927/images/Service_Level_Agreement.jpg\" width=\"54\" /><strong>服务水平协议（Service Level Agreement）<\/strong><\/td><td>如果提供了一个可在您企业中重用的能力版本，则必须创建 SLA 来描述使用者和提供者之间的协议的细节。SLA 通常是提供的能力版本的 SLD 所提供的服务质量的子集。例如，SLD 可能规定某个服务在星期一到星期五可用，但 SLA 可能定义仅在星期三需要该服务。<\/td><\/tr><tr><td><img alt=\"服务端点图标\" src=\"/sunshine_new/images/1580908927/images/Service_Endpoint.jpg\" width=\"54\" /><strong>服务端点（Service Endpoint）<\/strong><\/td><td>将一个能力版本部署在运行时系统上时，它拥有一个或多个可通过网络访问的端点。这些端点由服务端点表示。服务端点对象通知服务的使用者，该服务在网络上的何处可用。<\/td><\/tr><tr><td><img alt=\"策略附件图标\" src=\"/sunshine_new/images/1580908927/images/Policy_Attachment.jpg\" width=\"48\" /><strong>策略附件（Policy Attachment）<\/strong><\/td><td>策略指定为让一个服务可供一个客户端使用而必须满足的需求。例如，一个 Web 服务可能要求所有消息都使用数字签名和加密，或者仅在某些时刻可用，或者只能处理一定数量的消息。策略对象包含策略文档、策略表达和策略附件。<\/td><\/tr><\/tbody><\/table><p> 中的示例描绘了一个服务提供者。它演示了上述 WSRR 对象彼此之间的关联。<strong>MathService<\/strong><code>Business Service<\/code> 归 <strong>IT Department<\/strong><code>Organization<\/code> 所有。此业务服务有一个 <strong>MathService (1.0)<\/strong><code>Service Version<\/code> 形式的真实实现，它已部署在 3 个地理位置。每个地理位置在不同的服务器上托管该服务，所以每个安装具有不同的 <code>Service Level Definition<\/code>。每个 SLD 可为服务提供一组不同的 <code>Service Endpoint<\/code>。<\/p><h5 id=\"fig1\">建模服务提供者<\/h5><img alt=\"建模服务提供者\" src=\"/sunshine_new/images/1580908927/images/serviceProvider.jpg\" width=\"580\" /><h2 id=\"SLDs\">服务水平定义<\/h2><p>如上所述，服务提供者使用 SLD 捕获服务的 QoS 特征。更具体地讲，每个 SLD 捕获服务的一组端点的 QoS 特征。如果可以使用不同端点来调用某个服务，而且这些端点表现出不同的服务质量，那么服务提供者应定义不同的 SLD 来引用相关端点。<\/p><p>GEP 还定义了 <code>Extended Service Level Definition <\/code> 类型。Extended SLD 类型定义了可为服务指定的额外的 QoS 属性，比如 <strong>Average Response Time<\/strong> 和 <strong>Maximum Messages Per Day<\/strong>。它通过示例展示了如何扩展模型中默认的 SLD 类型，以包含与您相关的 QoS 属性。<\/p><h3 id=\"N10138\">可用端点关系<\/h3><p><strong>可用端点<\/strong>关系用于将服务的 SLD 与可用于调用服务的端点集相关联。如果多个端点与一个 SLD 有关联，则表明该 SLD 上定义的非功能性特征适用于每个端点。 用红色显示了可用端点的关系。当您尝试以编程方式获取可用端点关系的目标时，需要使用名称 <code>gep63_availableEndpoints<\/code> 来引用它。<\/p><h5 id=\"fig2\">可用端点关系<\/h5><img alt=\"可用端点关系\" src=\"/sunshine_new/images/1580908927/images/AvailableEndpointsRelationship.jpg\" width=\"452\" /><h2 id=\"ModelingServiceConsumers\">建模服务使用者<\/h2><p>服务使用者在 WSRR 中的建模方式与服务提供者完全相同。这源于以下事实：在许多情况下，一个服务提供者还可以是 SOA 中的其他服务的使用者。但是，一些重要的属性和关系在设计时和运行时都在服务使用关系中发挥着重要作用。以下各节将讨论这些属性和关系。<\/p><h3 id=\"N10157\">使用者标识属性<\/h3><div class=\"dw-sidebar ibm-inset\"><h2 id=\"N1015C\">能力版本属性<\/h2><p>有关 <code>Capability Version<\/code> 对象的属性和关系的更多信息，请参见 <a href=\"#resources\">参考资料<\/a> 部分中的<strong>能力版本<\/strong>链接。<\/p><\/div><p><strong>使用者标识<\/strong>属性用于惟一地标识它与另一个服务提供者之间的任何交互中的服务使用者。服务使用者在调用其他服务时，应在它发送的任何服务请求中包含它的使用者标识。下面给出了一个从 <strong>Calculator Application<\/strong> 发送到 <strong>Math Service<\/strong> 的服务请求示例。<strong>Calculator Application<\/strong> 的使用者标识包含在 SOAP 标头中包含的 <code>consumerID<\/code> 元素中（已加粗显示）。<\/p><h5 id=\"listing1\">示例 Math Service 请求<\/h5><div class=\"codesection\"><pre class=\"displaycode\">&lt;soapenv:Envelope xmlns:soapenv=\"http://schemas.xmlsoap.org/soap/envelope/\" \n                     xmlns:math=\"http://math.pot.ibm.com\"&gt;\n  &lt;soapenv:Header&gt;\n    &lt;math:MathHeader&gt;\n      <strong>&lt;consumerID&gt;CalculatorApplication&lt;/consumerID&gt;<\/strong>\n      &lt;contextID&gt;CTX_1&lt;/contextID&gt;\n    &lt;/math:MathHeader&gt;\n   &lt;/soapenv:Header&gt;\n   &lt;soapenv:Body&gt;\n      &lt;math:add&gt;\n         &lt;augend&gt;1&lt;/augend&gt;\n         &lt;addend&gt;1&lt;/addend&gt;\n      &lt;/math:add&gt;\n   &lt;/soapenv:Body&gt;\n&lt;/soapenv:Envelope&gt;<\/pre><\/div><p>使用者标识可供 SOA 环境中的各种组件用于确定服务使用者是否有权调用目标服务。上述<strong>业务问题<\/strong>的建议解决方案是，在 IIB 中使用一个消息流来执行此检查。该消息流需要查询 WSRR，以便寻找具有指定使用者标识的 <code>Capability Version<\/code>。该消息流需要使用使用者的程序化属性名 <code>gep63_consumerIdentifier<\/code> 来引用使用者标识。<\/p><h3 id=\"slasrelationship\">服务水平协议关系<\/h3><p><strong>服务水平协议<\/strong>关系用于将服务使用者与它和其他服务提供者之间拥有的 SLA 相关联。因为一个服务使用者可使用多个其他服务，所以此关系可以有多个目标。一个服务使用者可能与同一个服务提供者有多个 SLA。例如，使用  中所示的场景，<strong>MathService<\/strong> 服务的一个使用者针对目标服务在不同地理位置的每个安装提供了不同的 SLA。<\/p><p>在本系列文章所提供的示例数据中，<strong>Calculator Application<\/strong> 的<strong>版本 1.0<\/strong> 与 <strong>Math Service<\/strong> 的每个版本有一个 SLA，如  中所示。服务水平协议关系是用红色显示的。处理 WSRR 查询结果时，消息流需要检查服务使用者的 SLA。为了找到服务水平协议关系的目标，它需要使用它的程序化名称 <code>gep63_consumes<\/code> 来引用服务水平协议关系。<\/p><h5 id=\"fig3\">Calculator Application SLA<\/h5><img alt=\"Calculator Application SLA\" src=\"/sunshine_new/images/1580908927/images/ServiceLevelAgreementsRelationship.jpg\" width=\"447\" /><h2 id=\"SLAs\">服务水平协议<\/h2><p>当服务使用者希望使用一个服务时，它们必须与服务提供者就其可使用该服务总能力的多大比例达成协议。使用 WSRR 时，此信息封装在 SLA 中。SLA 是正式契约，也是可量化地定义服务提供者与服务使用者之间协商一致的服务质量的契约。<\/p><p>对于上面描述的核心 GEP 类型，SLA 位于使用的能力版本和服务提供者的 SLD 之间，如下所示：<\/p><h5 id=\"fig4\">服务使用<\/h5><img alt=\"服务使用\" src=\"/sunshine_new/images/1580908927/images/ServiceConsumption.png\" width=\"580\" /><p>将服务提供者与服务使用者之间的协议的细节捕获到 SLA 中后，此信息即可用于帮助在 SOA 中制定决策，无论是在设计时还是在运行时。一个如何在设计时使用此信息的示例就是 <strong>Service Consumption Visualizer<\/strong> 小部件，它可以在 WSRR 所提供的 <strong>Service Registry Dashboard<\/strong> 用户界面中找到。此小部件可用于可视化：<\/p><ol><li>一个特定服务的所有使用者。<\/li><li>一个特定服务使用的所有服务。<\/li><li>服务提供者和服务使用者之间存在的协议。<\/li><\/ol><p>此信息可在设计时，在您计划对现有服务执行更改时使用。它可以帮助您识别其他所有可能受计划的更改影响的服务。此信息在 Service Consumption Visualizer 小部件中的显示方式的示例如下所示：<\/p><h5 id=\"fig5\">Service Consumption Visualizer<\/h5><img alt=\"Service Consumption Visualizer\" src=\"/sunshine_new/images/1580908927/images/ServiceConsumptionVisualizer.jpg\" width=\"580\" /><h3 id=\"N101E6\">上下文标识属性<\/h3><div class=\"dw-sidebar ibm-inset\"><h2 id=\"N101EB\">服务水平协议属性<\/h2><p>有关 <code>Service Level Agreement<\/code> 对象的属性和关系的更多信息，请参阅 <a href=\"#resources\">参考资料<\/a> 部分中的<strong>服务水平协议<\/strong>链接。<\/p><\/div><p><strong>上下文标识<\/strong>属性用于在 WSRR 中惟一地标识 SLA。在服务使用者有多个 SLA 的情形下，上下文标识可用于识别应用于给定服务请求的具体 SLA。服务使用者应在它发送给特定目标服务的任何服务请求中包含相关的上下文标识。从 <strong>Calculator Application<\/strong> 发送到 <strong>Math Service<\/strong> 的服务请求示例（如  中所示）在 SOAP 标头中包含的 <code>contextID<\/code> 元素中显示了相关 SLA 的上下文标识。<\/p><p>为了找到应用于当前服务请求的 SLA，消息流需要将输入消息中指定的上下文标识与相关服务使用者的每个 SLA 上的上下文标识相比较。它需要使用程序化名称 <code>gep63_contextIdentifier<\/code> 来引用 SLA 上的上下文标识属性。<\/p><h3 id=\"N10210\">约定的端点关系<\/h3><p><strong>约定的端点<\/strong>关系用于将 SLA 与被使用的服务的 SLD 相关联。它是服务使用关系的中心，因为它将代表服务使用者的对象集链接到代表服务提供者的对象集。它称为约定的端点关系，是因为指向的 SLD 指定了可在使用协议中由服务使用者调用的端点集。<\/p><p> 用红色显示了约定的端点关系。为了确定要将服务请求路由到哪个约定的端点，消息流需要找到相关 SLA 所指向的 SLD。它需要使用程序化名称 <code>gep63_agreedEndpoints<\/code> 来引用约定的端点关系。<\/p><h5 id=\"fig6\">约定的端点关系<\/h5><img alt=\"约定的端点关系\" src=\"/sunshine_new/images/1580908927/images/AgreedEndpointsRelationship.jpg\" width=\"447\" /><h3 id=\"N10229\">SLA 生命周期<\/h3><p>GEP 中的 SLA 生命周期（如下面的   中所示）用于管理一个 SLA，从它最初被识别到被激活，到最后不需要时被终止。有一种活动/不活动循环，支持您根据需要来打开或关闭 SLA。通过让它处于活动或不活动状态，运行时可以检查相关 SLA 是否处于正确的状态，从而确定某个特定的使用者是否被允许调用特定的端点。<\/p><h5 id=\"fig7\">SLA 生命周期<\/h5><img alt=\"SLA 生命周期\" src=\"/sunshine_new/images/1580908927/images/LifeCycleDefinition_LifeCycleDiagram.png\" width=\"580\" /><p>为了确保相关 SLA 是处于活动状态的，消息流需要检查它是否已被正确分类。SLA 生命周期中的 <strong>SLAActive<\/strong> 状态的 OWL URI 为 <code>http://www.ibm.com/xmlns/prod/serviceregistry/lifecycle/v6r3/LifecycleDefinition#SLAActive<\/code>。此状态和 SLA 生命周期中定义的其他状态如  中所述：<\/p><h5 id=\"table2\">SLA 生命周期<\/h5><table border=\"0\" cellpadding=\"0\" cellspacing=\"0\" class=\"ibm-data-table\"><thead xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"><tr><th>过渡<\/th><th>目标状态<\/th><th>描述<\/th><\/tr><\/thead><tbody xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"><tr><td>（初始状态）<\/td><td>SLA 已识别<\/td><td>只要使用者（由一个能力版本表示）请求为某个服务版本或其他服务版本提供他们需要的服务水平定义 (SLD) 的能力版本上的依赖关系，就会立即进入此状态。<\/td><\/tr><tr><td>请求 SLA<\/td><td>SLA 已请求<\/td><td>约定的端点关系的目标已与需要的 SLA 属性和策略的细节一起选择。选择的 SLD 的提供者必须批准请求、拒绝它或要求对它进行修订。<\/td><\/tr><tr><td>批准 SLA 请求<\/td><td>SLA 不活动<\/td><td>想要使用该服务的开发团队，可基于这个特定 SLA 的使用情况而继续开发，但他们还没有权利访问任何端点。<\/td><\/tr><tr><td>修订 SLA 请求<\/td><td>SLA 已识别<\/td><td>作为 SLA 协商的一部分，服务提供者请求服务使用者对 SLA 的细节进行返工。这可以通过将 SLA 转移回已识别状态（准备重新提交）来完成。<\/td><\/tr><tr><td>激活 SLA<\/td><td>SLA 已激活<\/td><td>所有与 SLD 关联的已获得批准的在线端点都可以使用 SLA 的条款来调用。可能在某些情形下，SLA 已被取消激活，在这种情况下，SLA 会进入 SLA 不活动状态，在重新激活它之前，任何进一步交互都会被拦截。<\/td><\/tr><tr><td>取消激活 SLA<\/td><td>SLA 处于不活动状态<\/td><td>遇到操作问题时，SLA 会通过返回到不活动状态来临时暂停操作。消除操作问题后，可重新激活 SLA。<\/td><\/tr><tr><td>终止 SLA<\/td><td>SLA 已终止<\/td><td>不允许来自此 SLA 的任何交互。<\/td><\/tr><\/tbody><\/table><h2 id=\"message_flow_description\">消息流描述<\/h2><div class=\"dw-sidebar ibm-inset\"><h2 id=\"N1028F\">找到消息流<\/h2><p>本文中描述的消息流在 <code>RegistryLookup_SLACheck.msgflow<\/code> 文件中定义。该文件包含在 <a href=\"#download\">下载<\/a> 部分提供的 <strong>WSRRIntegrationDemos.zip<\/strong> 压缩文件中。<\/p><\/div><p>SLA 检查消息流（如  中所示）使用服务请求中指定的使用者标识，从 WSRR 获取服务使用者的元数据。它使用此元数据确定指定的服务使用者是否有权调用目标服务。如果服务使用者有权调用目标服务，则将请求转发给协商好的端点。如果服务使用者无权调用目标服务，则会返回一个恰当的错误。以下各节详细介绍此消息流中的每个节点，以及用来执行 SLA 检查的任何设置或代码。<\/p><h5 id=\"fig8\">SLA 检查消息流<\/h5><img alt=\"SLA 检查消息流\" src=\"/sunshine_new/images/1580908927/images/MessageFlow.jpg\" width=\"580\" /><h3 id=\"N102AD\">Service Request 节点<\/h3><p>该消息流始于 <code>Service Request<\/code> SOAP Input 节点。关于此节点，一定要注意的是，它被配置为公开 <strong>Math Service<\/strong> 的接口。该接口是在节点的 <strong>Properties<\/strong> 编辑器的 <strong>Basic<\/strong> 选项卡上指定的，如  中所示。您可以看到，<code>MathServerServiceDummyEndpoint.wsdl<\/code> 已在 <strong>WSDL file name<\/strong> 字段中指定。该节点的其他基本属性会在选择 WSDL 文件后自动填入。通过配置来公开一个特定的 WSDL 接口时，<code>SOAP Input<\/code> 节点将验证它收到的所有服务请求，确保它们符合 WSDL 中包含的服务的定义。还可以配置此节点，以便使用带 URL 后缀 <strong>/MathServer/Services/MathServer/slacheck1<\/strong> 的 <strong>HTTP<\/strong> 传输。在调用此消息流公开的服务时，使用者需要使用这个值。Service Request 节点使用 <strong>out<\/strong> 终端连接到 SLA 检查消息流中的下一个节点。<\/p><h5 id=\"fig9\">公开的 WSDL 接口<\/h5><img alt=\"公开的 WSDL 接口\" src=\"/sunshine_new/images/1580908927/images/SOAPInput_WSDLProps.jpg\" width=\"580\" /><h3 id=\"N102DE\">Extract SOAP Headers 节点<\/h3><p><code>Extract SOAP Headers<\/code> 节点是 <code>Java Compute<\/code> 节点的一个实例。顾名思义，此节点可处理 <code>Service Request<\/code> 节点传递给它的服务请求，从 SOAP 标头中提取<strong>使用者标识<\/strong>和<strong>上下文标识<\/strong>属性。然后，它会检查提取的值是否有效。 中的代码显示了执行的任务。<\/p><h5 id=\"listing2\">提取使用者标识和上下文标识<\/h5><div class=\"codesection\"><pre class=\"displaycode\">MbMessage inMessage = inAssembly.getMessage();\nMbElement rootElement = inMessage.getRootElement();\n\nMbElement consumerIdElement =\n    rootElement.getFirstElementByPath(\"/SOAP/Header/MathHeader/consumerID\");\n\nMbElement contextIdElement =\n    rootElement.getFirstElementByPath(\"/SOAP/Header/MathHeader/contextID\");\n    \nif (  consumerIdElement != null &amp;&amp; consumerIdElement.getValue() != null\n   &amp;&amp; contextIdElement != null &amp;&amp;contextIdElement.getValue() != null)\n   {\n        ...\n}<\/pre><\/div><p>如果服务请求中指定的一个标识<strong>无效<\/strong>，那么 <code>Extract SOAP Headers<\/code> 节点会生成一个 SOAP 错误，并将该消息传递给 <strong>failure<\/strong> 终端。这个终端与 <code>SOAP Reply<\/code> 节点直接相连，后者将 SOAP 错误传回给客户端。此检查很重要，而且在消息流的最初极端执行，因为消息流需要能够识别服务使用者和应用于服务请求的相关 SLA。<\/p><div class=\"dw-sidebar ibm-inset\"><h2 id=\"N1030B\">以编程方式覆盖节点属性<\/h2><p>以编程方式覆盖 IIB 消息流中的 WSRR 节点上的属性的过程已在 <a href=\"http://www.ibm.com/developerworks/websphere/library/techarticles/1404_smithson2/1404_smithson2.html\" onmouseover=\"linkQueryAppend(this)\">第 2 部分：IIB 中的 WSRR 节点<\/a> 中介绍。<\/p><\/div><p>最初检查获得通过后，<code>Extract SOAP Headers<\/code> 节点会将相关的字段插入到本地环境树中，以编程方式覆盖 Registry Lookup 节点上的属性。 中所示的代码可配置 Registry Lookup 节点，以便检索其 <code>gep63_consumerIdentifier<\/code> 属性与 SOAP 标头中指定的使用者标识匹配的对象。在 GEP 中，<code>gep63_consumerIdentifier<\/code> 属性是 <code>Capability Version<\/code> 抽象类型和它的子类型所独有的，所以 Registry Lookup 节点将仅返回此类型的对象。该节点随后将消息传递给 <strong>out<\/strong> 终端，后者连接到 Registry Lookup 节点。<\/p><h5 id=\"listing3\">覆盖 Registry Lookup 节点变量的 Java 代码<\/h5><div class=\"codesection\"><pre class=\"displaycode\">MbMessage environment = new MbMessage(inAssembly.getLocalEnvironment());\nMbElement environmentRoot = environment.getRootElement();\n\nenvironmentRoot.evaluateXPath(\n    \"?ServiceRegistryLookupProperties/?UserProperties/?gep63_consumerIdentifier[\n    set-value('\" + consumerIdElement.getValue() + \"')]\");<\/pre><\/div><div class=\"dw-sidebar ibm-inset\"><h2 id=\"N10330\">上下文标识怎么办？<\/h2><p>Registry Lookup 节点执行的查询中不需要上下文标识，所以此阶段不会对它执行更多操作。在这里，执行检查只是为了确保在允许在消息流中进一步传递服务请求之前，指定了一个有效的上下文标识。它将用在消息流的 SLA 检查操作中。\n<\/p><\/div><p>正如 <a href=\"http://www.ibm.com/developerworks/websphere/library/techarticles/1404_smithson2/1404_smithson2.html\" onmouseover=\"linkQueryAppend(this)\">第 2 部分：IIB 中的 WSRR 节点<\/a> 中所讨论的，为了部署包含 Registry Lookup 节点的流，在定义消息流时必须为节点上的 <strong>Name<\/strong>、<strong>Namespace<\/strong> 或 <strong>Version<\/strong> 属性中的一个属性指定一个值。在本例中，我们对 <strong>Name<\/strong> 使用了一个虚假值，在使用该节点之前，必须在运行时以编程方式清除该值。<code>Extract SOAP Headers<\/code> 节点中的代码使用了  中所示的代码来完成此任务。<\/p><h5 id=\"listing4\">以编程方式清除 name 属性<\/h5><div class=\"codesection\"><pre class=\"displaycode\">environmentRoot.evaluateXPath(\"?ServiceRegistryLookupProperties/?Name[set-value('')]\");<\/pre><\/div><h3 id=\"N10355\">Registry Lookup 节点<\/h3><div class=\"dw-sidebar ibm-inset\"><h2 id=\"N1035B\">RegistryLookup 节点<\/h2><p>IIB 中的 Registry Lookup 节点已在 <a href=\"http://www.ibm.com/developerworks/websphere/library/techarticles/1404_smithson2/1404_smithson2.html\" onmouseover=\"linkQueryAppend(this)\">第 2 部分：IIB 中的 WSRR 节点<\/a> 中介绍。<\/p><\/div><p><code>Registry Lookup<\/code> 节点的行为取决于前一个节点以编程方式在本地环境树中创建的条目。前面已经提到，这将返回一个或多个 <code>Capability Version<\/code> 对象，它们的使用者标识与从服务请求提取的值匹配。该节点将所有匹配对象的表示插入到本地环境树中的 <strong>ServiceRegistry<\/strong> 条目中，然后将消息传递给 <strong>out<\/strong> 终端。<\/p><p>即使一个使用者标识会惟一地标识 WSRR 中注册的单个服务使用者，该节点的 <strong>Match Policy<\/strong> 也会被设置为 <strong>All<\/strong>。指定 <strong>All<\/strong> 作为 <strong>Match Policy<\/strong>，使 SLA 检查消息流能够验证是否属于这种情况。<\/p><p>一定要注意的是，<strong>Depth Policy<\/strong> 被设置为 <strong>Return matched plus all related entities.(Depth = -1)<\/strong>。指定此 <strong>Depth Policy<\/strong> 后，<code>Registry Lookup<\/code> 节点将获取所有具有匹配的使用者标识的 <code>Capability Version<\/code> 对象和所有与下游有关联的对象的表示。这包括它们的 SLA，这些 SLA 指向的 SLD，以及 SLD 指向的任何端点。因为只需对 WSRR 执行一次查询就会返回所有这些信息，所以这是的 SLA 检查消息能够验证服务使用者是否有权调用目标服务，从而将请求路由到相关端点，无需从 WSRR 获取额外的元数据。<\/p><p>如果 <code>Registry Lookup<\/code> 节点执行的查询未返回结果，那么该节点会将错误消息传递给 <strong>NoMatch<\/strong> 终端。此终端连接到 <code>No Match Fault<\/code> 节点。<\/p><h3 id=\"slachecknode\">SLA Check 节点<\/h3><p><code>SLA Check<\/code> 节点是 <code>Java Compute<\/code> 节点的另一个实例，它是此消息流中的主要工作执行的地方。此节点处理前一个 <code>Registry Lookup<\/code> 节点执行的查询的结果，使用返回的元数据来检查服务使用者与服务提供者之间是否存在有效的 SLA。<\/p><p>前面已经提到过，查询的结果将包含所有具有匹配的使用者标识的 <code>Capability Version<\/code> 对象的表示。因为使用者标识应惟一地标识 WSRR 中注册的一个服务使用者，所以 <code>SLA Check<\/code> 节点执行的第一次检查是验证是否仅返回了一个 <code>Capability Version<\/code>。如果返回了多个具有匹配的使用者标识的 <code>Capability Version<\/code>，那么该节点将会生成一个 SOAP 错误，并将错误消息传递给 <strong>failure<\/strong> 终端。这个终端与 <code>SOAP Reply<\/code> 节点直接相连，后者将 SOAP 错误传回给客户端。 中的代码显示了执行的任务。<\/p><h5 id=\"listing5\">检查是否返回了单个服务使用者<\/h5><div class=\"codesection\"><pre class=\"displaycode\">MbElement rootElement = inAssembly.getLocalEnvironment().getRootElement();\nMbElement serviceRegistry = rootElement.getFirstElementByPath(\"/ServiceRegistry\");\n\nList&lt;MbElement&gt; consumingVersions =\n    (List &lt;MbElement&gt;)serviceRegistry.evaluateXPath(\"Entity\");\n\nif (consumingVersions != null &amp;&amp; consumingVersions.size() == 1) {\n    MbElement consumer = consumingVersions.get(0);\n        ...\n} else {        \n    outAssembly = MessageUtils.createSOAPFault(inAssembly\n                , \"ERROR_SLA_003\"\n                , \"Multiple CapabilityVersions found with the specified consumer id.\"\n                , \"The consumer id specified does not resolve to a unique\"\n                  + \" CapabilityVersion in WSRR.\"\n                );\n    outputTerminal = getOutputTerminal(\"failure\");\n}<\/pre><\/div><p><code>SLA Check<\/code> 节点需要执行的下一个任务是，找到具有与服务请求中指定的标识相匹配的上下文标识的服务使用者的 SLA。此任务包含多个步骤：<\/p><ol><li><code>SLA Check<\/code> 节点需要获取服务使用者的 <code>gep63_consumes<\/code> 关系的所有目标。这些目标将是为服务使用者定义的 SLA 的实例，而且如  中所讨论的那样，可能有多个目标。<\/li><li><code>SLA Check<\/code> 节点随后将会检查 SLA 列表，确保它不是空的。<\/li><li>如果至少有一个 SLA，<code>SLA Check<\/code> 节点然后会从最初的服务请求获取上下文标识，使用它找到具有匹配的 <code>gep63_contextIdentifer<\/code> 的 SLA，验证是否能找到它。<\/li><\/ol><div class=\"dw-sidebar ibm-inset\"><h2 id=\"N103E5\">检查空上下文标识<\/h2><p>该代码检查来自服务请求的上下文标识是否不为空。绝不会出现此情况，因为已经在 <code>Extract SOAP Headers<\/code> 节点中检查了上下文标识。但是，为了以防万一，可以再检查一次。<\/p><\/div><p> 中的代码显示了执行的任务。每个 <code>else<\/code> 语句的代码块生成一个 SOAP 错误和合适的错误消息，然后将错误消息传递给 <strong>failure <\/strong> 终端。为了保持简洁，这些代码块的代码已被省略。<\/p><h5 id=\"listing6\">找到指定的 SLA<\/h5><div class=\"codesection\"><pre class=\"displaycode\">List&lt;MbElement&gt; slas = (List&lt;MbElement&gt;)consumer.evaluateXPath(\n    \"userDefinedRelationships[@name='gep63_consumes']/targetEntities/Entity\"); \n\nif (slas != null &amp;&amp; !slas.isEmpty()) {\n    String contextId = getContextId(inMessage);\n    if (contextId != null) {\n        MbElement sla = getSLAByContextId(slas, contextId);\n        if (sla != null) {\n            ...\n        } else {\n            ...\n        }\n    } else {\n        ...\n    }\n} else {\n    ...\n}\n\nprivate MbElement getSLAByContextId(List&lt;MbElement&gt; slas, String contextId)\n    throws MbException {\n        \n    MbElement matchingSla = null;\n    for (MbElement sla : slas) {\n        if ((Boolean)sla.evaluateXPath(\n            \"userDefinedProperties[@name='gep63_contextIdentifier']/attribute::value ='\"\n            + contextId + \"'\")) {\n            \n            matchingSla = sla;\n            break;\n        }\n    }\n        \n    return matchingSla;\n}<\/pre><\/div><p>在找到服务请求的相关 SLA 后，<code>SLA Check<\/code> 节点执行的下一次检查是验证 SLA是否处于<strong>活动<\/strong>状态。将一个生命周期应用于 WSRR 中的对象时，WSRR 将当前生命周期状态的 OWL URI 添加到对象上的分类列表中。因此，为了检查对象是否处于给定状态，只需查看是否使用了该状态的相关 OWL URI 对它进行了分类。 中的代码显示了执行的任务。如果 SLA 未处于<strong>活动<\/strong>状态，则会生成一个包含适当错误消息的 SOAP 错误，并将该错误消息传递到 <strong>failure<\/strong> 终端。<\/p><h5 id=\"listing7\">检查 SLA 是否处于活动状态<\/h5><div class=\"codesection\"><pre class=\"displaycode\">protected static final String OWL_URL_SLA_ACTIVE = \n    \"http://www.ibm.com/xmlns/prod/serviceregistry/lifecycle/v6r3/LifecycleDefinition#\"\n    + \"SLAActive\";\n\nif (isActive(sla)) {\n} else {\n    ...\n}\n\nprivate boolean isActive(MbElement sla) throws MbException {\n    return (Boolean)sla.evaluateXPath(\"classificationURIs='\" + OWL_URL_SLA_ACTIVE + \"'\");\n}<\/pre><\/div><p>确定 SLA 处于<strong>活动<\/strong>状态之后，下一个任务是获取服务使用者在调用服务时有权使用的端点的列表。如上所述，要从 SLA 导航到约定的端点列表，需要反转两种关系，如下所述：<\/p><ol><li><strong>约定的端点<\/strong>关系将一个 SLA 与使用的服务的 SLD 相关联。回想一下，此关系的程序化名称为 <code>gep63_agreedEndpoints<\/code>。<\/li><li><strong>可用端点<\/strong>关系将服务提供者的 SLD 与可用于调用该服务的端点集相关联。回想一下，此关系的程序化名称为 <code>gep63_availableEndpoints<\/code>。<\/li><\/ol><p> 幸运的是，因为所有这些信息已从 WSRR 获取，所以可以使用单个 XPath 表达式反转这两种关系。 显示了导航这些关系所需的代码。如果未返回任何端点，则会生成一个包含适当错误消息的 SOAP 错误，并将该错误消息传递到 <strong>failure<\/strong> 终端。<\/p><h5 id=\"listing8\">获取可用的端点<\/h5><div class=\"codesection\"><pre class=\"displaycode\">List&lt;MbElement&gt; availableEndpoints = (List&lt;MbElement&gt;)sla.evaluateXPath(\n    \"userDefinedRelationships[@name='gep63_agreedEndpoints']/targetEntities/Entity/\"\n    + \"userDefinedRelationships[@name='gep63_availableEndpoints']/targetEntities/Entity\");\n    \nif (availableEndpoints != null &amp;&amp; !availableEndpoints.isEmpty()) {\n    ...\n} else {\n    ...\n}<\/pre><\/div><p>执行的下一个任务是从列表中选择第一个处于<strong>在线<\/strong>状态的端点。再次申明，这是通过检查是否使用此状态的相关 OWL URI 来分类该端点来实现的。 显示了选择第一个在线端点所需的代码。如果 WSRR 中目前没有任何可用端点处于<strong>在线<\/strong>状态，则会生成一个包含适当错误消息的 SOAP 错误，并将该错误消息传递到 <strong>failure<\/strong> 终端。<\/p><h5 id=\"listing9\">选择在线端点<\/h5><div class=\"codesection\"><pre class=\"displaycode\">protected static final String OWL_URL_ONLINE =\n    \"http://www.ibm.com/xmlns/prod/serviceregistry/lifecycle/v6r3/LifecycleDefinition#\"\n    + \"Online\";\n\nString addressUrl = selectEndpoint(availableEndpoints, inAssembly);\nif (addressUrl != null) {\n    ...\n} else {\n    ...\n}\n\nprotected boolean isOnline(MbElement endpoint) throws MbException {\n    return (Boolean)endpoint.evaluateXPath(\"classificationURIs='\" + OWL_URL_ONLINE + \"'\");\n}\n    \npublic String selectEndpoint(List&lt;MbElement&gt; availableEndpoints, MbMessageAssembly \ninAssembly) throws MbException {\n        \n    String addressUrl = null;\n        \n    for (MbElement availableEndpoint : availableEndpoints) {\n        if (isOnline(availableEndpoint)) {\n            addressUrl = (String)availableEndpoint.evaluateXPath(\n                \"string(userDefinedRelationships[@name='sm63_soapAddress']\"\n                + \"/targetEntities/Entity/attribute::location)\");\n            break;\n        }\n    }\n        \n    return addressUrl;\n}<\/pre><\/div><p>现在已经验证了 SLA 检查消息流，服务使用者与服务提供者之间存在一种<strong>活动<\/strong>的 SLA，而且 WSRR 中为目标服务注册了至少一个在线端点。该消息流现在已准备好将服务请求转发到目标服务上。为此，SLA 检查消息流将会使用一个名为 <code>Forward Request<\/code> 的 <code>SOAP Request<\/code> 节点。为了以编程方式覆盖已在 <code>Forward Request<\/code> 节点上配置的 <strong>Web Service URL<\/strong>，<code>SLA Check<\/code> 节点需要将端点地址插入本地环境树的 <code>Destination.SOAP.Request.Transport.HTTP.WebServiceURL<\/code> 字段中。 给出了执行此任务所需的代码。<code>SLA Check<\/code> 节点然后将消息传递给 <strong>out<\/strong> 终端，后者连接到 <code>Forward Request<\/code> 节点。<\/p><h5 id=\"listing10\">以编程方式指定 Web 服务 URL<\/h5><div class=\"codesection\"><pre class=\"displaycode\">MbMessage environment = new MbMessage(inAssembly.getLocalEnvironment());\nMbElement environmentRoot = environment.getRootElement();\n\nenvironmentRoot.evaluateXPath(\n    \"?Destination/?SOAP/?Request/?Transport/?HTTP/?WebServiceURL[set-value('\"\n    + addressUrl + \"')]\");<\/pre><\/div><h3 id=\"soapNodes\">Forward Request 和 SOAP Reply 节点<\/h3><p><code>Forward Request<\/code> 节点负责调用目标服务，在本例中为 <strong>Math Service<\/strong> 的<strong>版本 1.0<\/strong>。在定义消息流时，必须为此节点上的 <strong>Web Service URL<\/strong> 属性指定一个值（即使该值将在运行时被 <code>SLA Check<\/code> 节点以编程方式覆盖）。因此，我们为此属性指定了一个虚拟值 <code>http://tempuri.org/MathServer/services/MathServer<\/code>。需要注意的另一点是，节点的 <strong>Operation mode<\/strong> 必须设置为 <strong>Invoke a generic web service<\/strong>。该接口是在节点的 <strong>Properties<\/strong> 编辑器的 <strong>Basic<\/strong> 选项卡上指定的。它是的消息流能代理 <strong>Math Service<\/strong> 上定义的任何操作的请求，而不是被迫代理单个操作。<code>Forward Request<\/code> 节点使用它的所有终端直接连接到 <code>SOAP Reply<\/code> 节点：<strong>out<\/strong>、<strong>fault<\/strong> 和 <strong>failure<\/strong>。<\/p><h5 id=\"N104AA\">SOAP Request 和 SOAP Reply 节点<\/h5><img alt=\"SOAP Request 和 SOAP Reply 节点\" src=\"/sunshine_new/images/1580908927/images/SOAPReqAndRep.jpg\" width=\"238\" /><p><code>SOAP Reply<\/code> 节点将一个 SOAP 请求传递回服务使用者。成功经过该消息流后，返回的响应将是来自实际目标服务的响应。如果出现错误，响应将是由消息流中的一个 Java Compute 节点或目标服务本身生成的 SOAP 错误。<\/p><h3 id=\"noMatchFault\">No Match Fault 节点<\/h3><p><strong>Extract SOAP Headers<\/strong> 或 <strong>SLA Check<\/strong> Java Compute 节点中发生错误时，这些节点会以编程方式生成合适的 SOAP 错误，并将它传递给它们的 <strong>failure<\/strong> 终端。这些终端直接连接到 <code>SOAP Reply<\/code> 节点。但是，如果 <code>Registry Lookup<\/code> 节点执行的查询没有返回任何结果，它不会自动生成 SOAP 故障。为此，<code>Registry Lookup<\/code> 节点的 <strong>NoMatch<\/strong> 终端将会连接到 <code>No Match Fault<\/code> Java Compute 节点。此节点以编程方式生成一个 SOAP 故障，该故障使用 <code>SOAP Reply<\/code> 节点返回到服务使用者。<\/p><h2 id=\"testing_the_flow\">测试消息流<\/h2><div class=\"dw-sidebar ibm-inset\"><h2 id=\"N104DD\">基本配置<\/h2><p>在尝试测试消息流之前，确保您执行了 <a href=\"http://www.ibm.com/developerworks/websphere/library/techarticles/1404_smithson1/1404_smithson1.html\" onmouseover=\"linkQueryAppend(this)\">第 1 部分：场景和配置<\/a> 中介绍的所有配置步骤。<\/p><\/div><p>下面的步骤介绍了如何使用 <strong>Calculator<\/strong> 应用程序验证 SLA 检查消息流是否在正常工作。<\/p><h3 id=\"N104EC\">基本测试<\/h3><ol><li>确保您的 IIB 执行组正在运行，已部署并启动 <strong>RegistryLookup_SLACheck<\/strong> 流。<\/li><li>启动 Calculator 应用程序，如第 1 部分中的 <a href=\"http://www.ibm.com/developerworks/websphere/library/techarticles/1404_smithson1/1404_smithson1.html#calculator_app\" onmouseover=\"linkQueryAppend(this)\">运行 Calculator 应用程序<\/a> 中所述。<\/li><li>为运行 IIB 的服务器输入<strong>主机名<\/strong>和<strong>端口号<\/strong>。例如，如果在与 <strong>Calculator<\/strong> 应用程序相同的机器上运行 IIB，而且使用了默认端口，那么这些值将为 <em>localhost<\/em> 和 <em>7800<\/em>。<\/li><li>修改服务路径，将它的值设置为 <strong>/MathServer/services/MathServer/slacheck1<\/strong>。这是 <strong>RegistryLookup_SLACheck<\/strong> 流的端点。<\/li><li>将 <strong>Consumer ID<\/strong> 设置为 <strong>CalculatorApplication<\/strong>。这是在 WSRR 中的 <code>Application Version<\/code> 上指定的使用者标识，表示 <strong>Calculator<\/strong> 应用程序。<\/li><li>将 <strong>Context ID<\/strong> 设置为 <strong>CTX_1<\/strong>。这是在 SLA 上指定的上下文标识，表示 <strong>Calculator<\/strong> 应用程序与 <strong>Math Service<\/strong> 之间的使用协议。<\/li><li>使用数字字段和运算符下拉菜单输入您希望执行的计算。输入所有信息后，<strong>Calculator<\/strong> 应用程序看起来应类似于：\n<h5 id=\"fig10\">Calculator 应用程序被设置为使用 SLA 检查消息流<\/h5><img alt=\"Calculator 应用程序被设置为使用 SLA 检查消息流\" src=\"/sunshine_new/images/1580908927/images/calcApp.png\" width=\"454\" /><\/li><li>单击 <strong>=<\/strong>（等号）。<strong>Calculator<\/strong>应用程序将一个服务请求发送到 SLA 检查消息流，后者将该请求路由到实际的 <strong>Math Service<\/strong>。结果最终返回到 <strong>Calculator<\/strong> 应用程序，然后被显示出来。<\/li><\/ol><p>如果从应用程序收到一个错误，那么请检查以下方面：<\/p><ol><li>您已经执行 <a href=\"http://www.ibm.com/developerworks/websphere/library/techarticles/1404_smithson1/1404_smithson1.html\" onmouseover=\"linkQueryAppend(this)\">第 1 部分：场景和配置<\/a> 中的所有配置步骤。<\/li><li>已为消息流指定了正确的路径 (<strong>/MathServer/services/MathServer/slacheck1<\/strong>)。<\/li><li>已指定了正确的使用者标识 (<strong>CalculatorApplication<\/strong>)。<\/li><li>已指定了正确的上下文标识 (<strong>CTX_1<\/strong>)。<\/li><\/ol><h3 id=\"N10568\">高级测试<\/h3><p>为了验证消息流执行的检查是否在正常运行，需要在 WSRR 中修改相关对象的状态，然后测试对消息流行为的影响。以下各节介绍如何执行这些测试。<\/p><h3 id=\"N1056F\">取消激活并再次激活 SLA<\/h3><ol><li>启动 <strong>Calculator<\/strong> 应用程序并执行一次计算，检查消息流是否正常工作。<\/li><li>在 Web 浏览器中，登录到您 WSRR 实例的 <strong>Service Registry Dashboard<\/strong>。<\/li><li>更改到 <strong>SOA Governance<\/strong> 视图，然后选择 <strong>Overview<\/strong> 页面。<\/li><li>在 <strong>Collection<\/strong> 小部件中选择 <strong>SLA - CalculatorApplication 1.0 to MathService 1.0<\/strong>，如下所示：\n<h5 id=\"fig11\">SOA Governance 视图<\/h5><img alt=\"SOA Governance 视图\" src=\"/sunshine_new/images/1580908927/images/soa_overview.jpg\" width=\"580\" /><\/li><li>您将被带到 <strong>Browse<\/strong> 页面上，在该页面中，将会在 <strong>Detail<\/strong> 小部件中显示 <strong>SLA - CalculatorApplication 1.0 to MathService 1.0<\/strong> 服务水平协议的详细信息。这是 <strong>Calculator<\/strong> 应用程序与 WSRR 中的 <strong>Math Service<\/strong> 之间的使用协议的一种表示。选择 <strong>Action =&gt; Deactivate SLA<\/strong>，如下所示：\n<h5 id=\"fig12\">取消激活 SLA<\/h5><img alt=\"取消激活 SLA\" src=\"/sunshine_new/images/1580908927/images/DeactivateSLA.jpg\" width=\"580\" /><\/li><li>该操作完成后，将会显示一个 <strong>Operation Successful<\/strong> 对话框。单击 <strong>OK<\/strong>。SLA 的治理状态已更改为 <strong>SLA Inactive<\/strong>。<\/li><li>转到 <strong>Calculator<\/strong> 应用程序，尝试执行另一次计算。在应用程序底部，会显示消息 <strong>Error:Unable to invoke math service.<\/strong>。<\/li><li>返回到 <strong>Service Registry Dashboard<\/strong>，选择 <strong>Action =&gt; Activate SLA<\/strong> 来重新激活 SLA。操作完成后单击 <strong>OK<\/strong>。SLA 现在的治理状态为 <strong>SLA Active<\/strong>。<\/li><li>转到 <strong>Calculator<\/strong> 应用程序，尝试执行另一次计算。这一次操作会成功完成。<\/li><\/ol><h3 id=\"N105DA\">将端点离线<\/h3><ol><li>启动 <strong>Calculator<\/strong> 应用程序并执行一次计算，检查消息流是否正常工作。<\/li><li>在 Web 浏览器中，登录到您 WSRR 实例的 <strong>Service Registry Dashboard<\/strong>。<\/li><li>更改到 <strong>SOA Governance<\/strong> 视图，然后选择 <strong>Overview<\/strong> 页面。<\/li><li>选择 <strong>Approved Business Capabilities<\/strong> 集合中的 <strong>MathService<\/strong>。<\/li><li>您将被带到 <strong>Browse<\/strong> 页面上，其中将在 <strong>Detail<\/strong> 小部件中显示 <strong>MathService<\/strong> 业务服务的详细信息。这是 WSRR 中的 <strong>Math Service<\/strong> 的一种业务表示。在此小部件中的 <strong>Versions <\/strong> 下，选择 <strong>MathService ?(1.0)<\/strong>。<\/li><li><strong>Detail<\/strong> 小部件将被更新，以显示 <strong>MathService (1.0)<\/strong> 服务版本的详细信息。这是 <strong>Math Service<\/strong> 在 WSRR 中的实现（即 1.0 版）的一种表示形式。在 <strong>Detail<\/strong> 小部件中的 <strong>Service Level Definitions<\/strong> 下，选择 <strong>SLD - MathService v1.0<\/strong>。<\/li><li><strong>Detail<\/strong> 小部件将被更新，以便显示 <strong>SLD - MathService v1.0<\/strong> SLD 的详细信息。在 <strong>Detail <\/strong> 小部件中的 <strong>Available Endpoints<\/strong> 下，选择 <strong>http://localhost:7800/MathServer1/services/MathServer ?(1.0)<\/strong>。如果您的 IIB 实例未使用默认端口来监听 HTTP 请求，那么端点的端口号可能有所不同。<\/li><li><strong>Detail<\/strong> 小部件将被更新，以便显示 <strong>http://localhost:7800/MathServer1/services/MathServer ?(1.0)<\/strong> 端点的详细信息。选择 <strong>Action =&gt; Revoke from use<\/strong>。<\/li><li>操作完成后单击 <strong>OK<\/strong>。该端点现在的治理状态为 <strong>Offline<\/strong>。1.0 版 <strong>Math Service<\/strong> 的两个端点现在都应为 <strong>Offline<\/strong> 状态。<\/li><li>转到 <strong>Calculator<\/strong> 应用程序，尝试执行另一次计算。在应用程序底部会显示消息 <strong>Error:Unable to invoke math service.<\/strong>。<\/li><li>返回到 <strong>Service Registry Dashboard<\/strong> 中，选择 <strong>Action =&gt; Approve For Use<\/strong> 将 <strong>http://localhost:7800/MathServer1/services/MathServer ?(1.0)<\/strong> 端点切换为在线。操作完成后单击 <strong>OK<\/strong>。该端点现在的治理状态为 <strong>Online<\/strong>。<\/li><li>转到 <strong>Calculator<\/strong> 应用程序，尝试执行另一次计算。这一次操作会成功完成。<\/li><\/ol><h2 id=\"N10666\">结束语<\/h2><p>本文介绍了一个在运行时执行 WSRR 中定义的 SLA 的示例消息流。该消息流使用了 Registry Lookup 节点来获取服务使用者的元数据。然后，它使用此元数据验证服务使用者是否有权调用目标服务，通过检查来确认它拥有与服务提供者的有效 SLA，而且目标服务至少拥有一个在 WSRR 中注册的在线端点。<\/p><p>此业务问题的一个备用解决方案将在 <a href=\"http://www.ibm.com/developerworks/cn/websphere/library/techarticles/1404_smithson8/1404_smithson8.html\">第 8 部分：使用 HTTP Request 节点执行 SLA 检查<\/a> 中介绍。该解决方案使用 HTTP Request 节点，使用 WSRR REST API 执行 SLAEndpointLookup 命名的查询。这个命名查询验证服务使用者是否有权调用目标服务，通过检查来确认它拥有与服务提供者的有效 SLA。然后，它会返回目标服务的在 WSRR 中注册的任何在线端点。<\/p><p>使用 Registry Lookup 节点的好处包括：<\/p><ul class=\"ibm-bullet-list\"><li>它在 IIB 中提供了对查询 WSRR 的具体支持，而且在调用节点前不需要在计算节点中执行任何额外的编码。<\/li><li>它自动在 IIB 中使用 WSRR Cache，无需进一步编码。<\/li><li>用户可以在实际消息流中基于获取的元数据来执行所有验证。因此，消息流非常准确地给出了它拒绝一个请求的原因，并会在 SOAP 错误中返回合适的错误消息。<\/li><\/ul><p>当然，使用 Registry Lookup 节点有一些缺点，如下所示：<\/p><ul class=\"ibm-bullet-list\"><li>不能对节点生成的 XPath 表达式执行太多控制。因此，无法生成能购反转多种关系并在查询中的各个阶段应用断言的 XPath 表达式。这使得您能够对 WSRR 执行比您想象的更深入的查询，或者在单个流中对 WSRR 执行多个查询。<\/li><li>您无法控制对 WSRR 执行的查询类型。IIB 中的 Endpoint Lookup 和 Registry Lookup 节点都对 WSRR 执行图形查询，这可能会返回大量数据，而不会在 WSRR 服务器上执行属性查询。<\/li><\/ul><h2 id=\"N10683\">致谢<\/h2><p>感谢以下人员帮助开发本系列中的示例消息流：<\/p><ul class=\"ibm-bullet-list\"><li>John Hosie<\/li><li>Ben Thompson<\/li><li>Matt Golby-Kirk<\/li><li>Trevor Dolby<\/li><li>Andreas Martens<\/li><li>Graham Haxby<\/li><li>Andrew Coleman<\/li><li>John Reeve<\/li><\/ul><p>还要感谢以下人员帮助审阅本文：<\/p><ul class=\"ibm-bullet-list\"><li>David Seager<\/li><li>Arnauld Desprets<\/li><li>Anna Maciejkowicz<\/li><\/ul><CMA ID: 974626><Site ID: 10><XSLT stylesheet used to transform this file: dw-document-html-7.0.xsl>\r\n<h2 id=\"download\">下载<\/h2><table class=\"ibm-data-table dw-download-table\" cellpadding=\"0\" cellspacing=\"0\" border=\"0\"><thead><tr><th scope=\"col\">描述<\/th><th scope=\"col\">名字<\/th><th scope=\"col\">大小<\/th><\/tr><\/thead><tbody><tr><th scope=\"row\" class=\"ibm-table-row\">代码示例<\/th><td nowrap=\"nowrap\"><a href=\"http://www.ibm.com/developerworks/apps/download/index.jsp?contentid=974626&amp;filename=WSRRIntegrationDemos.zip&amp;method=http&amp;locale=zh_CN\">WSRRIntegrationDemos.zip<\/a><\/td><td nowrap=\"nowrap\">304 KB<\/td><\/tr><\/tbody><\/table>\r\n\r\n<\/div>\r\n<\/div>\r\n","createTime":"2014-06-17 00:00:00","deployTime":"2014-06-17 00:00:00","id":0,"intro":"IBM Integration Bus (IIB) 自 2008 年开始通过 Endpoint Lookup 和 Registry Lookup 节点提供与 WebSphere Service Registry and Repository (WSRR) 的开箱即用的集成。这些节点允许您在 IIB 中实现消息流，动态地从 WSRR 中检索服务元数据，并在运行时使用这些数据来修改消息流行为。该集成为众多重大的业务问题提供了解决方案。本系列的第 5 部分将介绍如何使用 Registry Lookup 节点动态地从 WSRR 检索服务元数据，并使用此元数据检查服务使用者是否有权调用目标服务。","keyword":"","recommend":false,"source":"http://www.ibm.com/developerworks/cn/websphere/library/techarticles/1404_smithson5/1404_smithson5.html","title":"集成 IBM Integration Bus 与 WebSphere Service Registry and Repository: 第 5 部分：在运行时执行 SLA 检查与注册表查找场景","typeId":0,"updateTime":"2014-06-17 00:00:00"}
{"author":"","clickNumber":0,"content":"\r\n<div class=\"ibm-columns\">\r\n<div class=\"ibm-col-1-1\">\r\n\r\n<div class=\"dw-sidebar ibm-inset\"><h2 id=\"N10055\">关于本系列<\/h2><p>Java&#8482; 传承的是平台，而不是语言。有超过 200 种语言可以在 JVM 上运行，它们之中不可避免地会有一种语言最终取代\n                    Java 语言，成为编写 JVM 程序的最佳方式。本系列将探讨三种下一代 JVM 语言：Groovy、Scala 和\n                    Clojure，比较并对比新的功能和范例，让 Java 开发人员对自己近期的未来发展有大体的认识。<\/p><\/div><p> 在所有 Java 下一代语言中，Clojure 拥有最激进的并发性机制和功能。Groovy 和 Scala\n                都为并发性提供了改善的抽象和语法糖的一种组合，而 Clojure 坚持了它始终在 JVM 上提供独一无二的行为的强硬立场。在本期 <a href=\"https://www.ibm.com/developerworks/cn/views/global/libraryview.jsp?sort_by=&amp;amp;show_abstract=true&amp;amp;show_all=&amp;amp;search_flag=&amp;amp;contentarea_by=Java+technology&amp;amp;search_by=Java+下一代&amp;amp;product_by=-1&amp;amp;topic_by=-1&amp;amp;type_by=所有类别&amp;amp;ibm-search=搜索\"><em>Java 下一代<\/em><\/a> 中，我将介绍 Clojure 中众多并发性选项的一部分。首先是为 Clojure\n                    中易变的引用提供支撑的基础抽象：<em>epochal 时间模型<\/em>。<\/p><h2 id=\"N10066\">Epochal 事件模型<\/h2><p> 或许 Clojure 与其他语言最显著的区别与易变的状态和<em>值<\/em> 密切相关。Clojure 中的<em>值<\/em>\n                可以是任何用户感兴趣的数据：数字 42、映射结构\n                <code>{:first-name \"Neal :last-name \"Ford\"}<\/code>\n                或某些更大型的数据结构，比如 Wikipedia。基本来讲，Clojure 语言对待所有值就像其他语言对待数字一样。数字 42\n                    是一个值，您不能重新定义它。但可对该值应用一个<em>函数<\/em>，返回另一个值。例如，<code>(inc 42)<\/code> 返回值\n                <code>43<\/code>。 <\/p><p>在 Java 和其他基于 C 的语言中，<em>变量<\/em> 同时持有身份和值，这是让并发性在 Java\n                语言中如此难以实现的因素之一。语言设计人员在线程抽象之前创建了变量抽象，变量的设计没有考虑为并发性增加的复杂性。因为 Java\n                中的变量假设只有单个线程，所以在多线程环境中，需要像同步块这样麻烦的机制来保护变量。Clojure 的设计人员 Rich Hickey\n                    让<em>交织（complect）<\/em> 这个古老的词汇恢复了活力（交织这个词被定义为 “缠绕或编织”），用于描述 Java\n                变量中的设计缺陷。 <\/p><p> Clojure 将<em>值<\/em> 与<em>引用<\/em> 分开。在 Clojure 世界观中，数据以一系列不变的值的形式存在，如图 1\n                所示。 <\/p><h5 id=\"fig1\">图 1. epochal 时间模型中的值<\/h5><img alt=\"该图演示了 epochal 时间模型中的值\" src=\"/sunshine_new/images/507004525/Fig1.png\" width=\"482\" /><p> 图 1 显示，像 <code>v1<\/code> 这样的独立的值表示 42 或 Wikipedia\n                    等数据，使用方框表示。与值独立的是<em>函数<\/em>，它们获取值作为参数并生成新值，如图 2 所示。 <\/p><h5 id=\"fig2\">图 2. epochal 时间模型中的函数<\/h5><img alt=\"该图演示了 epochal 时间模型中的函数\" src=\"/sunshine_new/images/507004525/Fig2.png\" width=\"466\" /><p> 图 2 将函数显示为与值独立的圆圈。函数调用会生成新值，使用值作为参数和结果。一连串的值保存在一个<em>引用<\/em>\n                    中，它表示变量的<em>身份<\/em>。随着时间的推移，此身份可能指向不同的值（由于函数应用），但身份从不更改，如图 3 中的虚线所示。 <\/p><h5 id=\"fig3\">图 3. epochal 时间模型中的引用<\/h5><img alt=\"该图演示了 epochal 时间模型中的引用\" src=\"/sunshine_new/images/507004525/Fig3.png\" width=\"580\" /><p> 在图 3\n                中，整幅图表示一个引用随时间的变化。虚线是一个引用，它持有其生存期内的一连串的值。可在某个时刻向引用分配一个新的不变值；引用指向的目标可更改，而无需更改该引用。 <\/p><p>\n                在引用的生存期中，一个或多个<em>观察者<\/em>（其他程序、用户界面、任何对该引用持有的值感兴趣的对象）将解除引用它，查看它的值（或许还执行某种操作），如图\n                4 所示。 <\/p><h5 id=\"fig4\">图 4. 解除引用<\/h5><img alt=\"该图演示了解除引用\" src=\"/sunshine_new/images/507004525/Fig4.png\" width=\"516\" /><p> 在图 4\n                中，观察者（有两种楔形表示）可持有引用本身（由来自虚线引用的箭头表示），或者可解除引用它，检索它的值（由来自该值的箭头表示）。例如，您可能有一个函数，它以一个传递给您的数据库连接作为参数，您进而将该参数传递给一个更低级的持久性函数。在此情况下，您持有该引用，但从不需要它的值；持久性函数可能会解除引用它，以获取它的值来连接到一个数据库。 <\/p><p> 请注意，<a href=\"#fig4\">图 4<\/a> 中的观察者不会<em>进行协调 <\/em>&#8212; 它们完全不依赖彼此。此结构使得\n                Clojure\n                运行时能够在整个语言中保证了一些有用的属性，比如决不允许读取程序阻塞，这使得读取操作变得非常高效。如果您希望更改一个引用（也就是说，将它指向一个不同的值），可使用\n                Clojure 的一个 API 来执行更新，这会采用 epochal 时间模型。 <\/p><p> epochal 时间模型为整个 Clojure\n                中的引用更新提供了支持。因为运行时控制所有更新，所以它可防御线程冲突，开发人员在不太复杂的语言中必须争用线程。 <\/p><p> Clojure 拥有广泛的方式来更新引用，具体依赖于您想要何种特征。接下来，我将讨论两种方式：简单的<em>原子<\/em>\n                    和复杂的<em>软件事务内存<\/em>。 <\/p><h4 id=\"N100E4\">原子<\/h4><p> Clojure 中的<em>原子<\/em> 是对数据一个原子部分的引用，无论该部分有多大。您创建一个 <code>atom<\/code>\n                并初始化它，然后应用一个突变函数。这里，我为一个原子创建了一个称为 <code>counter<\/code> 的引用，将它初始化为\n                0。如果我希望将引用更新到一个新值，我可使用 <code>(swap!)<\/code> 这样的函数，它原子化地为该引用换入一个新值： <\/p><div class=\"codesection\"><pre class=\"displaycode\">(def counter  (atom 0))\n(swap! counter + 10)<\/pre><\/div><p> 根据 Clojure 中的惯例，突变函数的名称以一个感叹号结尾。<code>(swap!)<\/code> 函数接受该引用、要应用的函数（在本例中为\n                <code>+<\/code> 运算符）和任何其他参数。 <\/p><p> Clojure 原子持有任何大小的数据，而不只是原始值。例如,我可围绕一个 <code>person<\/code> 映射创建一个原子引用，并使用\n                <code>map<\/code> 函数更新它。使用 <code>(create-person)<\/code> 函数（未显示），我在一个原子中创建一个\n                <code>person<\/code> 记录，然后使用 <code>(swap!)<\/code> 和 <code>(assoc )<\/code>\n                更新该引用，这会更新一个映射关联： <\/p><div class=\"codesection\"><pre class=\"displaycode\">(def person (atom (create-person)))\n(swap! person assoc :name \"John\")<\/pre><\/div><p> 原子还会通过 <code>(compare-and-set!)<\/code> 函数，使用原子实现一个通用的乐观<code/>锁定模式： <\/p><div class=\"codesection\"><pre class=\"displaycode\">(compare-and-set! a 0 42)\n=&gt; false\n\n(compare-and-set! a 1 7)\n= true<\/pre><\/div><p><code>(compare-and-set!)<\/code> 函数接受 3\n                个参数：原子引用、想要的现有值和新值。如果原子的值与想要的值不匹配，更新不会发生，函数会返回 <code>false<\/code>。 <\/p><p> Clojure\n                有各种各样的机制都遵循引用语义。例如，<code>promise<\/code>（是一种不同的引用）承诺在以后提供一个值。这里，我创建对一个名为\n                <code>number-later<\/code> 的 promise 的引用。此代码不会生成任何值，就像它对最终会这么做的承诺一样。调用\n                <code>(deliver )<\/code> 函数时，一个值会绑定到 <code>number-later<\/code>：<\/p><div class=\"codesection\"><pre class=\"displaycode\">(def number-later (promise))\n(deliver number-later 42)<\/pre><\/div><p>尽管此示例使用了 Clojure 中的 futures 库，但引用语义与简单的原子保持一致。 <\/p><h4 id=\"N1013D\">软件事务内存<\/h4><p> 没有其他任何 Clojure 特性获得了比软件事务内存 (STM) 更多的关注，这是 Clojure 以 Java\n                语言封装垃圾收集的方式来封装并发性的内部机制。换句话说，您可编写高性能的多线程 Clojure 应用程序，而从不考虑同步块、死锁、线程库等。 <\/p><p> Clojure 封装并发性的方式是，通过 STM 控制引用的所有突变。更新一个引用（惟一的易变抽象）时，必须在一个事务中执行，以使 Clojure\n                运行时能够管理更新。考虑一个经典的银行问题：向一个帐户中存款，同时向另一个帐户贷款。清单 1 显示了一个简单的 Clojure 解决方案。 <\/p><h5 id=\"listing1\">清单 1. 银行交易<\/h5><div class=\"codesection\"><pre class=\"displaycode\">(defn transfer\n  [from to amount]\n  (dosync\n   (alter from - amount)\n   (alter to + amount)))<\/pre><\/div><p> 在 <a href=\"#listing1\">清单 1<\/a> 中，我定义了一个 <code>(transfer )<\/code> 函数，它接受 3\n                个参数：<code>from<\/code> 和 <code>to<\/code> 帐户 &#8212; 二者都是引用 &#8212;\n                以及金额。我从 <code>from<\/code> 帐户中减去该金额，将它添加到 <code>to<\/code> 帐户中，但此操作必须与\n                <code>(dosync )<\/code> 事务一起发生。如果我在事务块的外部尝试一个 <code>(alter )<\/code>\n                调用，更新会失败并抛出一个 <code>IllegalStateException<\/code>： <\/p><div class=\"codesection\"><pre class=\"displaycode\">(alter from - 1)\n=&gt;&gt; IllegalStateException No transaction running<\/pre><\/div><p> 在 <a href=\"#listing1\">清单 1<\/a> 中，<code>(alter )<\/code> 函数仍然遵守 epochal\n                时间模型，但使用 STM 来确保两个操作都完成或都未完成。为此，STM &#8212; 非常像一个数据库服务器 &#8212;\n                临时重试阻塞的操作，所以您的更新函数在更新之外不应有任何副作用。例如，如果您的函数还写入一个日志，由于不断重试，您可能会看到多个日志条目。STM\n                还会随未解决事务的时长增长而逐步提高它们的优先级，显示数据库引擎中的其他更常见的行为。 <\/p><p> STM 的使用很简单，但底层机制很复杂。从名称可以看出,STM 是一个事务系统。STM 实现了 <em>ACID<\/em> 事务标准的\n                    <em>ACI<\/em> 部分：所有更改都是<em>原子性<\/em>、<em>一致<\/em> 和<em>隔离的<\/em>。ACID\n                    的<em>耐久<\/em> 部分在这里不适用，因为 STM 在内存中操作。很少看到将像 STM 这样的高性能机制内置于一种语言的核心中；<a href=\"http://haskell.org/\">Haskell<\/a> 是惟一认真实现了 STM 的另一种主流语言 &#8212;\n                不要奇怪，因为 Haskell（像 Clojure 一样）非常喜欢不变性。（.NET 生态系统曾尝试构建一个 STM\n                管理器，但最终放弃了，因为处理事务和不变性变得太复杂了。） <\/p><h2 id=\"N10198\">缩减程序（reducer）和数字分类<\/h2><p> 如果不讨论 <a href=\"http://www.ibm.com/developerworks/cn/java/j-jn13/index.html\">上一期<\/a> 中的数字分类器问题的替代实现，并行性介绍都是不完整的。清单 2 显示了一个没有并行性的原子版本。 <\/p><h5 id=\"listing2\">清单 2. Clojure\n                中的数字分类器<\/h5><div class=\"codesection\"><pre class=\"displaycode\">(defn classify [num]\n  (let [facts (-&gt;&gt; (range 1 (inc num))\n           (filter #(= 0 (rem num %))))\n   sum (reduce + facts)\n      aliquot-sum (- sum num)]\n         (cond\n         (= aliquot-sum num) :perfect\n         (&gt; aliquot-sum num) :abundant\n         (&lt; aliquot-sum num) :deficient)))<\/pre><\/div><p><a href=\"#listing2\">清单 2<\/a> 中的分类器版本浓缩为单个函数，它返回一个 Clojure\n                关键字（由一个前导冒号表示）。<code>(let )<\/code> 块使我能够建立局部绑定。为了确定因数，我使用\n                    <em>thread-last<\/em> 运算符来过滤数字范围，让代码更有序。<code>sum<\/code> 和\n                <code>aliquot-sum<\/code> 的计算都很简单；一个数字的<em>真因数和<\/em>\n                是它的因数之和减去它本身，这使我的比较代码更简单。该函数的最后一行是 <code>(cond )<\/code> 语句，它针对计算的值来计算\n                <code>aliquot-sum<\/code>，返回合适的关键字枚举。此代码的一个有趣之处是，我以前的实现中的方法在这个版本中折叠为简单的赋值。在计算足够简单和简洁时，您通常需要创建的函数更少。 <\/p><p> Clojure 包含一个称为 <a href=\"http://clojure.com/blog/2012/05/08/reducers-a-library-and-model-for-collection-processing.html\"><em>缩减程序<\/em><\/a> 的强大的并发性库。（有关缩减程序库的开发过程的解释 &#8212; 包括为利用最新的 JVM\n                原生的 fork/join 工具而进行的优化 &#8212; 是一个吸引人的故事。）缩减程序库提供了常见运算的就地替换，比如 <code>map<\/code>、<code>filter<\/code> 和\n                <code>reduce<\/code>，使这些预算能够自动利用多个线程。例如，将标准的 <code>(map )<\/code> 替换为\n                <code>(r/map )<\/code>（<code>r/<\/code> 是缩减程序的命名空间），会导致您的映射操作自动被运行时并行化。 <\/p><p> 清单 3 给出了一个利用了缩减程序的数字分类器版本。 <\/p><h5 id=\"listing3\">清单 3. 使用了缩减程序库的分类器<\/h5><div class=\"codesection\"><pre class=\"displaycode\">(ns pperfect.core\n  (:require [clojure.core.reducers :as r]))\n\n(defn classify-with-reducer [num]\n  (let [facts (-&gt;&gt; (range 1 (inc num))\n\t\t   (r/filter #(= 0 (rem num %))))\n\tsum (r/reduce + facts)\n\t    aliquot-sum (- sum num)]\n               (cond\n               (= aliquot-sum num) :perfect\n               (&gt; aliquot-sum num) :abundant\n               (&lt; aliquot-sum num) :deficient)))<\/pre><\/div><p> 必须仔细观察，才能找出 <a href=\"#listing2\">清单 2<\/a> 和 <a href=\"#listing3\">清单 3<\/a>\n                之间的区别。惟一的区别是引入了缩减程序命名空间和别名，向 <code>filter<\/code> 和 <code>reduce<\/code>\n                都添加了 <code>r/<\/code>。借助这些细微的更改，我的过滤和缩减操作现在可自动使用多个线程。 <\/p><h2 id=\"N101FB\">结束语<\/h2><p>本期介绍了 Clojure 中的一些并发性选项，这是一个内容丰富的主题区域。我讨论了核心的底层抽象 &#8212; epochal 时间模型\n                &#8212; 展示了原子和 STM 如何使用此概念。我还演示了一种简单的就地替换库，它使现有的应用程序能够使用高级并发性功能，比如\n                fork/join。<\/p><p> Clojure 中还有其他许多并发性选项，包括更简单的并行函数，比如 <code>pmap<\/code> (parallel\n                map)。Clojure 还包含代理 &#8212; 绑定到一个池中的线程上的自主工作者（由系统或用户定义），与 Scala 的 actor\n                大体相似。Clojure 还融入了 Java 语言中所有现在的并发性进步，使它能轻松地使用 fork/join 等现代库。 <\/p><p> 或许比任何其他 Clojure 特性都更明显，并发性工具显示了 Clojure\n                生态系统的工程设计重点：充分利用语言特性来构建强大的抽象。Clojure 没有尝试创建一个 Lispy 版的\n                Java。设计者从根本上重新思考了核心基础设施和实现。 <\/p><p> 在下一期中，我将介绍 Java 下一代语言中的 Java 8。<\/p><CMA ID: 974534><Site ID: 10><XSLT stylesheet used to transform this file: dw-document-html-7.0.xsl>\r\n\r\n\r\n<\/div>\r\n<\/div>\r\n","createTime":"2014-06-16 00:00:00","deployTime":"2014-06-16 00:00:00","id":0,"intro":"Clojure 拥有所有 Java 下一代语言中最激进的并发性方法。本期将深入探讨 Clojure 中的并发性的一些方面，包括 epochal 时间模型和软件事务内存。","keyword":"","recommend":false,"source":"http://www.ibm.com/developerworks/cn/java/j-jn14/index.html","title":"Java\n            下一代: Clojure 中的并发性","typeId":0,"updateTime":"2014-06-16 00:00:00"}
{"author":"","clickNumber":0,"content":"\r\n<div class=\"ibm-columns\">\r\n<div class=\"ibm-col-1-1\">\r\n\r\n<p>开源 <a href=\"http://www.openstack.org/\">OpenStack<\/a>\n                云操作系统是一个功能丰富且可以大规模扩展的平台，适用于所有类型的云计算。一些公共云服务基于 OpenStack，许多组织内的私有云实现也是如此。但\n                OpenStack 仍缺乏一些针对私有云的特性，尤其是针对开发和测试环境的特性。例如，映像构建就不是一个简单的过程。本文为 OpenStack\n                私有云提供一种全新且改进的映像创建方法。我们在 QEMU/KVM 平台上验证了这种新方法，但在理论上该方法也适用于其他虚拟机管理程序平台。<\/p><p>介绍这个新方法之前，我们将概述目前在 OpenStack 中如何创建映像。<\/p><h2 id=\"N10065\">目前在 OpenStack 中创建映像的方式<\/h2><p>在 OpenStack 中创建 Linux 或 Windows 映像的过程由多个耗时的步骤组成。 <\/p><h3 id=\"N1006B\">基于 Linux 的映像<\/h3><p>官方 <a href=\"http://docs.openstack.org/image-guide/content/\">OpenStack\n                    虚拟机映像指南<\/a> 详细介绍了 7 种 <a href=\"http://docs.openstack.org/image-guide/content/ch_openstack_images.html\">要求<\/a>，必须满足这些要求，基于 Linux 的映像才能在 OpenStack 云中完全正常工作（可通过安装\n                <code>cloud-init<\/code>\n                包来满足一些要求）。该映像指南建议用户在创建自己的映像之前阅读指南中很长一节的内容，确保映像支持他们计划使用的 OpenStack 特性。<\/p><p>对于一些特定的发行版，可手动或使用工具创建 Linux 映像 &#8212; 比如 VMBuilder、Oz 或\n                imagefactory。无论使用哪种方法，在创建自己的 Linux 映像之前都需要以下材料： <\/p><ul class=\"ibm-bullet-list\"><li>OS 安装 CD/DVD 或 ISO 映像文件。<\/li><li>一个启用了 KVM/QEMU 虚拟机管理程序的 Linux 机器。一些发行版可能需要\n                    <code>virt-manager<\/code>/<code>virt-viewer<\/code> GUI 实用程序。<\/li><li><code>cloud-init<\/code> 或针对操作系统自行编写的等效脚本。<\/li><li><code>guestfish<\/code>、<code>guestmount<\/code> 或 <code>virt-*<\/code>\n                    工具，用于修改映像。<\/li><\/ul><p>满足所有必须的条件后，即可开始根据下面总结的步骤创建自己的 Linux 映像：<\/p><ol><li>使用 <code>virt-manager<\/code> 或 <code>virt-install<\/code> 创建一个虚拟机 (VM)\n                    并安装操作系统。<\/li><li>配置操作系统，以满足您自己的需求（例如通过安装所需的中间件），或者安装 <code>cloud-init<\/code> 或等效的脚本来满足\n                    OpenStack 的要求。<\/li><li>使用 <code>guestfish<\/code>、<code>guestmount<\/code> 或\n                    <code>virt-*<\/code> 修改映像，以满足 OpenStack 的要求。<\/li><li>将新映像上传到 OpenStack 映像服务并验证该映像。<\/li><\/ol><h3 id=\"N100B6\">基于 Windows 的映像<\/h3><p>OpenStack 网站上没有详细的示例介绍如何创建基于 Windows 的映像。但要让您创建的基于 Windows\n                的映像能正常运行，您必须至少：<\/p><ul class=\"ibm-bullet-list\"><li>安装一个 VirtIO 驱动程序。<\/li><li>启用远程桌面协议 (Remote Desktop Protocol, RDP) 并配置它以通过防火墙。<\/li><li>配置 Internet 控制消息协议 (Internet Control Message Protocol, ICMP)\n                    以通过防火墙。<\/li><li>将磁盘分区并（使用 <code>cloudbase-init<\/code>）调整引导磁盘上的根分区大小。<\/li><li>处理用户数据和其他元数据（使用 <code>cloudbase-init<\/code>）。<\/li><li>启用 Windows System Preparation (Sysprep) 工具，以自定义来宾操作系统。<\/li><\/ul><p>对于大多数私有云用例，本列表中的最后两个要求是可选的。而且您可以手动或使用脚本将磁盘分区，并调整引导磁盘上的根分区大小。但必须安装一个 VirtIO\n                驱动程序，Windows 映像才能在 OpenStack 云中工作。此外，您需要拥有 VirtIO-Win 驱动程序包。<\/p><p>满足最低要求后，构建 Windows 映像的过程是：<\/p><ol><li>使用一个 Internet Drive Electronics (IDE) 磁盘和一个 AMD PCnet32 或 Realtek\n                    rt8139 网络接口卡 (NIC) 创建一个虚拟机。<\/li><li>安装操作系统。<\/li><li>配置操作系统以满足您自己的要求（例如通过安装所需的中间件），或者安装 <code>cloudbase-init<\/code>\n                    或等效的脚本来满足 OpenStack 要求。<\/li><li>关闭虚拟机。<\/li><li>添加一个小 VirtIO 磁盘和一个 VirtIO NIC。<\/li><li>启动虚拟机并安装 VirtIO 磁盘和 NIC 的 VirtIO 驱动程序。<\/li><li>重新启动虚拟机，检查操作系统，然后关闭虚拟机。<\/li><li>将映像上传到 OpenStack 映像服务并验证该映像。<\/li><\/ol><p>也可执行以下步骤：<\/p><ol><li>创建一个包含以下部分的虚拟机： \n<ul class=\"ibm-bullet-list\"><li>一个 VirtIO 磁盘<\/li><li>一个 PCnet32 或 rt8139 NIC<\/li><li>一个额外的 CD-ROM，包含用于比 Windows Vista 或 Windows Server 2008 更高版本的\n                            Windows 的 VirtIO 磁盘驱动程序，或者一个额外的软盘，包含用于比 Windows server 2003 R2\n                            更低版本的 Windows 的 VirtIO 磁盘驱动程序<\/li><\/ul><\/li><li>在操作系统中安装所需的 VirtIO 磁盘驱动程序。<\/li><li>配置操作系统，以满足您自己的要求（例如通过安装所需的中间件），或者安装 <code>cloudbase-init<\/code>\n                    或运行等效的脚本来满足 OpenStack 的要求。<\/li><li>关闭虚拟机。<\/li><li>添加一个 VirtIO NIC。<\/li><li>启动虚拟机并安装 VirtIO NIC 的 VirtIO 驱动程序。<\/li><li>重新启动虚拟机，检查操作系统，然后关闭虚拟机。<\/li><li>将映像上传到 OpenStack 映像服务并验证该映像。<\/li><\/ol><h3 id=\"N10104\">不足<\/h3><p>尽管目前为 OpenStack 创建映像的方法有一些好处（如创建基于 Linux 的映像的开源工具的广泛可用性），但该方法并不容易。创建基于\n                Windows 的映像看起来可能比创建 Linux 映像简单一些，因为不需要使用 <code>guestfish<\/code>\n                等工具修改映像。但目前还没有自动化工具来为 OpenStack 创建全功能的 Windows\n                映像，所以最终用户或操作人员还必须手动创建它们。如果一个全球化团队的测试人员或开发人员需要 Windows 映像，这些映像必须有不同的语言版本\n                &#8212; 而且团队可能使用数十种语言。云操作人员准备所有请求的语言版本的 Windows 映像，这是不可能完成的任务。<\/p><p>为私有云创建 Linux 和 Windows 映像对最终用户而言是一个耗时的工作 &#8212;\n                甚至对经验丰富的云操作人员也是如此。而且，组织可能缺乏资源让最终用户创建映像 &#8212; 例如，创建 Linux 映像所需的额外\n                KVM/QEMU 虚拟机管理程序。在这种情况下，创建最终用户请求的所有映像，对云操作人员而言是一项艰巨的任务。<\/p><p>最后，需要将新映像上传到 OpenStack 映像服务，根据映像来源与 OpenStack\n                映像服务之间的网络性能，这个过程可能要花很长的时间。出于相同的原因，反复验证新映像也可能会花很长的时间。<\/p><h2 id=\"N10117\">新的 OpenStack 映像创建方法<\/h2><p>如果启用了 OpenStack 的用户要在线创建映像，创建能满足其需求的映像要容易得多。我们提出了一种新的映像创建方法，其中用户通过云服务所提供的\n                OpenStack 仪表板在线创建新映像。借助此功能，最终用户无需额外的虚拟机管理程序，不需要自行将映像上传到 OpenStack\n                映像服务。他们所需的只是操作系统安装 CD/DVD ISO 映像文件。<\/p><h3 id=\"N1011D\">概念设计<\/h3><p>在概念上，为 OpenStack 创建一个新映像的理想过程是，最终用户：<\/p><ol><li>将操作系统安装 CD/DVD ISO 映像文件上传到 OpenStack 映像服务。<\/li><li>通过已上传的 ISO 映像启动一个新实例。<\/li><li>通过 OpenStack 仪表板中的 Virtual Networking Computing (VNC)/Simple Protocol\n                    for Independent Computing Environments (SPICE) 控制台安装操作系统。<\/li><li>执行特殊需要所要求的必要配置并安装所需的软件包。<\/li><li>手动或运行服务操作人员提供的脚本来执行 OpenStack 所要求的修改 &#8212; 例如，安装\n                    <code>cloud-init<\/code>、获取公共 SSH 密钥、启用 SSHD 远程登录/RDP 等的脚本。<\/li><li>创建实例的快照。<\/li><li>根据需要在快照上运行 <code>glance image-update<\/code> 命令，将快照转换为映像并添加其他元数据。<\/li><\/ol><h3 id=\"N1013A\">前提条件<\/h3><p>必须满足一些条件才能确保新的映像创建方法取得成功：<\/p><ul class=\"ibm-bullet-list\"><li>一个可供所有最终用户使用的有效仪表板或 Web UI。<\/li><li>VNC 代理或 SPICE 代理运行正常且可用于所有最终用户。<\/li><li>一个 <code>cloud-init<\/code> 或等效的脚本工具存储库可供所有最终用户使用。<\/li><li>OpenStack 映像服务中拥有 VirtIO-win 驱动程序的一个 ISO 映像可供所有最终用户使用。<\/li><\/ul><p>下面我们演示新方法的可行性。<\/p><h2 id=\"N1014E\">可行性分析<\/h2><p>该新方法最重要的两个方面是：如何支持 ISO 映像以及如何为从 ISO 映像启动的实例组装块设备。<\/p><h3 id=\"iso_current\">目前对 ISO 映像的支持<\/h3><p>OpenStack 支持 ISO 映像。也支持从 ISO 映像启动实例。但是，将来宾操作系统从 ISO 映像安装到从 ISO\n                映像启动的实例中，对此并未提供良好的支持。要想成功安装，必须满足一些严格的条件：<\/p><ul class=\"ibm-bullet-list\"><li>ISO 映像中的来宾操作系统必须默认已启用 VirtIO 设备驱动程序。<\/li><li>必须设置临时磁盘风格，它的大小必须满足来宾操作系统的要求。<\/li><li>仪表板和 OpenStack novncproxy 服务器必须在正常运行。<\/li><\/ul><p>如果所有这些条件都已满足，即可从 ISO 映像成功地将来宾操作系统安装到从这个 ISO\n                映像启动的实例的临时磁盘上。当然，在来宾操作系统上也可像使用其他实例一样工作。但是，由于 OpenStack\n                中目前的实例快照机制，您无法成功地将实例转换为实例快照或映像。实例快照将仅包含实例的根磁盘。其他块设备（包括临时磁盘和卷）将被忽略。<\/p><h3 id=\"N10163\">实例块设备目前的组装工作流<\/h3><p>图 1 显示了在从 ISO 映像引导一个 KVM/QEMU 实例时，OpenStack Nova 中块设备的组装工作流。<\/p><h5 id=\"fig1\">图 1. 组装块设备的现有工作流<\/h5><img alt=\"组装块设备的现有工作流\" src=\"/sunshine_new/images/负1053554772/figure1.png\" width=\"647\" /><p>在图 1 中的工作流中：<\/p><ol><li>Nova 从 Glance 获取 ISO 映像并将它设置为一个虚拟机实例的根磁盘，以 CD-ROM 作为设备类型，IDE\n                    作为总线类型。<\/li><li>Nova 创建一个临时磁盘并将它设置为虚拟机实例的第二个磁盘，以 disk 作为设备类型，VirtIO\n                    作为总线类型。但只有在所设置的临时磁盘大小符合实例的风格时，这一步才能完成。<\/li><li>用户将来宾操作系统从根磁盘（实例的 CD-ROM）安装到临时磁盘（实例的第二个磁盘）并通过 VNC 逐步配置它。<\/li><li>用户从这个虚拟机实例创建一个快照，Nova 将快照保存到 glance 服务。<\/li><\/ol><p>此工作流似乎适合从头创建一个新虚拟机映像。但您获得的是最初的 ISO 映像的副本。原因是快照中仅包含根磁盘（实例的第一个块设备，如果从 ISO\n                映像启动，实际上是实例的 CD-ROM），临时磁盘已被忽略。所以，在目前的 OpenStack 中，您可从 ISO 映像启动实例，也可将 ISO\n                映像中的操作系统安装到已配置临时磁盘且已启动的实例中，但不能创建已安装了操作系统的临时磁盘的快照。要解决此问题，需要调整实例的各个块设备的组装工作流。<\/p><h3 id=\"N1017F\">新的组装工作流 <\/h3><p>您可以更改块设备组装流程，创建一个临时磁盘，其大小设置适当且一定会设置为从 ISO\n                映像启动的各个实例的根磁盘。更改之后，实例快照中包含的根磁盘将是已安装了操作系统的临时磁盘 &#8212; 完全满足您的要求。<\/p><p>图 2 显示了在对 <code>libvirt<\/code> 驱动程序进行修改（将在本文的 <a href=\"#poc\">概念证明<\/a>\n                一节中介绍）后，您从一个 ISO 映像启动一个实例时块设备的组装工作流。<\/p><h5 id=\"fig2\">图 2. 修改后的块设备组装工作流<\/h5><img alt=\"修改后的块设备组装工作流\" src=\"/sunshine_new/images/负1053554772/figure2.png\" width=\"573\" /><p>下面是在从 ISO 映像启动实例时，修改块设备组装工作流的过程：<\/p><ol><li>Nova 创建一个虚拟机磁盘文件并将它设置为虚拟机实例的根磁盘。设备总线默认设置为 VirtIO。<\/li><li>Nova 从 Glance 获取来宾操作系统的 ISO 映像并将它设置为第二个磁盘设备，这是一个 CD-ROM。<\/li><li>Nova 从 Glance 获取 VirtIO 驱动程序的一个 ISO 映像并将它设置为第三个磁盘设备，这是另一个 CD-ROM。<\/li><li>用户从第二个磁盘设备（第一个 CD-ROM）安装来宾操作系统并根据需要配置它。<\/li><li>如果 VirtIO 驱动程序默认未包含在来宾操作系统中，会使用第三个磁盘设备（第二个 CD-ROM）安装来宾操作系统的 VirtIO\n                    驱动程序。<\/li><li>用户创建该实例的一个快照，Nova 将它保存到 Glance 服务。<\/li><\/ol><p><a href=\"#iso_current\">目前对 ISO 映像的支持<\/a>\n                中已介绍，实例快照仅包含实例的根磁盘，无论根磁盘的类型是什么都是如此。使用修改后的组装工作流，根磁盘是 Nova\n                创建的一个新磁盘文件，包含从作为操作系统映像的 CD-ROM（实例的第二个磁盘）所安装的来宾操作系统。<\/p><p>正如我们所构想的，结果是一个从操作系统 ISO 映像安装的新实例的实例快照 &#8212; 而不是最初的 ISO 映像的副本。<\/p><h2 id=\"poc\">概念证明<\/h2><p>要确保新的映像创建方法符合我们的设计目的，我们对 Nova 的代码进行了一些修改 &#8212; 主要修改了\n                <code>libvirt<\/code> 驱动程序。请参见 <a href=\"#download\">下载<\/a> 获取相关代码。我们修改的\n                python 模块是 libvirt/driver.py 和\n                libvirt/blockinfo.py。这些文件中的注释标识了我们所修改的类方法和实例。<\/p><p>我们用于概念证明的环境包含：<\/p><p>硬件：<\/p><ul class=\"ibm-bullet-list\"><li>2U 机架服务器<\/li><li>2 个 4 核 Xeon 处理器<\/li><li>12 个 8GB RAM<\/li><li>4 个 900GB SAS 硬盘且配置了 RAID10<\/li><li>4 个 1Gps 以太网卡<\/li><\/ul><p>软件：<\/p><ul class=\"ibm-bullet-list\"><li>Red Hat Enterprise Linux 6 update 4 作为虚拟机管理程序<\/li><li><a href=\"http://openstack.redhat.com/Main_Page\">RDO<\/a> Grizzly\n                    版本<\/li><\/ul><p>我们在 RDO Grizzly 独立环境、RDO Grizzly 的多节点安装环境和官方 OpenStack Grizzly\n                版本上测试了修改后的代码。<\/p><h2 id=\"N101DB\">测试和结果<\/h2><p>本节介绍了我们为使用新方法创建虚拟机映像而修改的 Nova 代码，执行的简单测试过程以及一些测试示例。<\/p><h3 id=\"N101E1\">测试过程<\/h3><p>测试过程为：<\/p><ol><li>为 Glance 创建操作系统 ISO 映像。<\/li><li>检查现有的风格，确保根磁盘大小满足您的要求。如果没有适用的风格，可创建一种新风格。<\/li><li>使用适用的风格，从这个操作系统 ISO 映像启动一个实例。<\/li><li>实例启动后，按照屏幕上的安装步骤，通过仪表板所提供的 VNC 控制台完成操作系统的安装工作。<\/li><li>根据需要安装应用程序并根据 OpenStack 的需要配置操作系统，例如安装 <code>cloud-init<\/code>\n                    或等效的脚本，启用 SSHD 远程登录/RDP 服务等。<\/li><li>创建这个新安装实例的一个实例快照。<\/li><li>运行 <code>glance image-update<\/code>，或者如果仪表板提供了相关的功能，从仪表板更新快照信息，将映像类型改为\n                    image。<\/li><\/ol><h3 id=\"N101FC\">测试结果<\/h3><p>修改 <code>libvirt<\/code> 驱动程序后，从 ISO 映像启动的实例的块设备如清单 1 所示。<\/p><h5 id=\"N10206\">清单 1. 从 ISO\n                映像启动的实例的块设备映射<\/h5><div class=\"codesection\"><pre class=\"displaycode\">&lt;disk type='file' device='disk'&gt;\n &lt;driver name='qemu' type='qcow2' cache='none'/&gt;\n &lt;source file='/var/lib/nova/instances/290124e3-a267-4223-bd69-661fac2035eb/disk.newos'/&gt;\n &lt;target dev='vda' bus='virtio'/&gt;\n &lt;address type='pci' domain='0x0000' bus='0x00' slot='0x04' function='0x0'/&gt;\n&lt;/disk&gt;\n&lt;disk type='file' device='cdrom'&gt;\n &lt;driver name='qemu' type='qcow2' cache='none'/&gt;\n &lt;source file='/var/lib/nova/instances/290124e3-a267-4223-bd69-661fac2035eb/disk'/&gt;\n &lt;target dev='hda' bus='ide'/&gt;\n &lt;readonly/&gt;\n &lt;address type='drive' controller='0' bus='0' target='0' unit='0'/&gt;\n&lt;/disk&gt;\n&lt;disk type='file' device='cdrom'&gt;\n &lt;driver name='qemu' type='qcow2' cache='none'/&gt;\n &lt;source file='/var/lib/nova/instances/290124e3-a267-4223-bd69-661fac2035eb/disk.virtio'/&gt;\n &lt;target dev='hdb' bus='ide'/&gt;\n &lt;readonly/&gt;\n &lt;address type='drive' controller='0' bus='0' target='0' unit='1'/&gt;\n&lt;/disk&gt;<\/pre><\/div><p>表 1 显示了几种主流操作系统的测试结果。<\/p><h5 id=\"table1\">表 1. 测试结果<\/h5><table border=\"0\" cellpadding=\"0\" cellspacing=\"0\" class=\"ibm-data-table\" summary=\"Two column table with the operating system in the first column and the         test results in the second column.\" width=\"75%\"><thead xmlns:dw=\"http://www.ibm.com/developerWorks/\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"><tr><th scope=\"col\">来宾操作系统<\/th><th scope=\"col\">结果<\/th><\/tr><\/thead><tbody xmlns:dw=\"http://www.ibm.com/developerWorks/\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"><tr><td>Windows XP<\/td><td>失败*<\/td><\/tr><tr><td>Windows Server 2003 R2<\/td><td>失败*<\/td><\/tr><tr><td>Windows 7<\/td><td>成功<\/td><\/tr><tr><td>Windows 8<\/td><td>成功<\/td><\/tr><tr><td>Windows Server 2012<\/td><td>成功<\/td><\/tr><tr><td>RHEL5.9<\/td><td>成功<\/td><\/tr><tr><td>RHEL6.4<\/td><td>成功<\/td><\/tr><tr><td>SLES10 sp4<\/td><td>成功<\/td><\/tr><tr><td>SLES11 sp3<\/td><td>成功<\/td><\/tr><tr><td colspan=\"2\">*备注：对 Windows XP 和 Windows Server 2003 R2\n                            的测试失败了，因为没有找到包含 VirtIO 驱动程序的软盘。根源是早于 Windows Server 2003 R2 的\n                            Windows 版本仅支持从软盘加载额外的磁盘驱动程序。在本文中，我们仅添加了一个用于 VirtIO 驱动程序的\n                            CD-ROM，如 <a href=\"#fig2\">图 2<\/a> 中所示，但可以在更早 Windows\n                            版本的块设备组装工作流中添加一个额外的软盘驱动程序。<\/td><\/tr><\/tbody><\/table><h2 id=\"N10255\">结束语<\/h2><p>我们新的映像创建方法的优点包括：<\/p><ul class=\"ibm-bullet-list\"><li>可轻松为 OpenStack 创建新映像。<\/li><li>可轻松验证新创建的映像。<\/li><li>为所有最终用户提供了一种自助服务机制。<\/li><\/ul><p>缺点包括：<\/p><ul class=\"ibm-bullet-list\"><li>映像可能无法支持全部功能 &#8212; 具体来讲，分区磁盘和调整引导磁盘上根分区的大小。<\/li><li>不支持早于 Windows Server 2003 R2 的 Windows 版本。（但如果通过支持旧 Windows\n                    版本的软盘驱动程序来创建更复杂的组装工作流，也可支持这些版本。）<\/li><li>不支持缺少 VirtIO 设备驱动程序支持的旧 Linux 版本。<\/li><\/ul><p>目前为止，大多数基于 OpenStack 的公共 IaaS 云服务都提供在基础映像中具有固定根磁盘大小的实例，以及 &#8212; 通过卷服务\n                &#8212;\n                为实例提供额外的磁盘空间。在私有云中，实例的大部分需求主要与所安装的中间件、来宾操作系统的主要版本/次要版本、实例风格等相关。与公共云服务中一样，可通过提供固定的平均根磁盘大小和足够的卷来满足磁盘大小要求。所以，分区磁盘和调整引导磁盘上根分区大小的功能对大多数私有云而言不是必需的。<\/p><p>OpenStack\n                已成长为一种适合开源云操作系统的全球流行平台。它使各种各样的云解决方案易于实施、可大规模扩展且包含丰富的功能。我们在本文中介绍的工作证明，可以基于\n                OpenStack 平台来实现新功能 &#8212; 而且 OpenStack 是一个开放且灵活的框架，而不仅仅是一个软件产品。<\/p><CMA ID: 974575><Site ID: 10><XSLT stylesheet used to transform this file: dw-document-html-7.0.xsl>\r\n<h2 id=\"download\">下载<\/h2><table class=\"ibm-data-table dw-download-table\" cellpadding=\"0\" cellspacing=\"0\" border=\"0\"><thead><tr><th scope=\"col\">描述<\/th><th scope=\"col\">名字<\/th><th scope=\"col\">大小<\/th><\/tr><\/thead><tbody><tr><th scope=\"row\" class=\"ibm-table-row\">示例代码<\/th><td nowrap=\"nowrap\"><a href=\"http://www.ibm.com/developerworks/apps/download/index.jsp?contentid=974575&amp;filename=sample_code.zip&amp;method=http&amp;locale=zh_CN\">sample_code.zip<\/a><\/td><td nowrap=\"nowrap\">39KB<\/td><\/tr><\/tbody><\/table>\r\n\r\n<\/div>\r\n<\/div>\r\n","createTime":"2014-06-16 00:00:00","deployTime":"2014-06-16 00:00:00","id":0,"intro":"本文提出用一种新方式来使用 OpenStack 云操作系统为私有云构建 Linux 和 Windows 映像。OpenStack 环境目前的映像创建方法麻烦且耗时。作者提出了一种在线自助服务方法，使映像创建对私有云的操作人员和最终用户而言更快且更轻松。","keyword":"","recommend":false,"source":"http://www.ibm.com/developerworks/cn/cloud/library/cl-openstack-images/index.html","title":"为 OpenStack 私有云创建 Linux 和 Windows 映像","typeId":0,"updateTime":"2014-06-16 00:00:00"}
{"author":"","clickNumber":0,"content":"\r\n<div class=\"ibm-columns\">\r\n<div class=\"ibm-col-1-1\">\r\n\r\n<h2 id=\"major1\">摘要<\/h2><p>在<a href=\"http://www.ibm.com/developerworks/cn/data/library/techarticle/dm-1405-ecm-insurance1/index.html\">上一篇文章<\/a>中，我们了解了使用 ECM 产品解决汽车保险业务的智能分派与优化的项目背景。在这篇文章中，我们将主要介绍如何使用 Android\n                平台实现基于位置信息的服务。这部分包括手机客户端的主要功能实现，以及后台对应服务的实现。通过基于业务员位置信息的手机服务，后台 ECM\n                系统可以精确的定位每一名业务员的当前位置并通过 JRules 的一系列定制规则自动将任务分派给最适合处理此任务的业务人员。<\/p><p>在这次的解决方案中，手机客户端部分我们采用的是 Android\n                系统作为手机客户端应用的开发平台。这个客户端应用中的相关功能只是一个参考，我们将重点介绍如何与后台 ICM\n                服务的接口进行通讯。客户可以自己开发适合自己企业的客户端应用，当然也可以使用 iOS 来开发自己的手机客户端。<\/p><p>关于 ECM 产品和 ICM 产品，这两个产品信息请参照文章末尾列出的参考资料部分。<\/p><h2 id=\"major2\">Android 平台位置服务简介<\/h2><p>智能手机的位置服务功能可以再后台自动维护用户的当前位置信息，所以我们自己开发的应用所要做的就是获取到这个位置信息。在 Android\n                平台中，关于位置服务这一部分，最重要的两个类就是 LocationManager 和 LocationProvider。<\/p><p><strong>LocationManager<\/strong><\/p><p>LocationManager 是 Android 平台提供给我们关于位置服务的核心\n                API，它为我们访问系统的位置服务提供了途径。LocationManager\n                提供了一系列服务可以使我们开发的应用得到移动设备的位置更新信息，也可以在设备输入指定位置时发出一个特定的 Intent。用户可以直接通过\n                getSystemService(Context.LOCATION_SERVICE) 生成一个 LocationManager\n                的实例而不需要自己去创建这个类。<\/p><p>下面是 LocationManager 的几个比较常用的方法。<\/p><p>getBestProvider(Criteria criteria, boolean\n                enabledOnly)：通过一个给定的标准作为参数，返回一个最符合标准的 provider\n                的名字。通常情况下我们可以通过这个方法来找到一个最符合我们需要的定位方式的名字。<\/p><p>getLastKnownLocation(String provider)：返回上一次通过制定的 provider\n                得到的位置信息。这种方式会马上返回给用户一个可用的位置信息，但不用当前最新的位置信息。<\/p><p><code>requestLocationUpdates<\/code>(String provider, long minTime, float\n                minDistance, LocationListener\n                listener)：使用这个方法可以在得到位置更新的时候执行我们设定的操作。这个方法的四个参数分别是：定义了我们所要使用的\n                provider、定义发出位置更新通知的最小时间、设定更新的距离、绑定一个监听器来执行操作。当位置发生变化时，这个监听器就会监听到这个变化，进而执行我们的操作，例如我们这个解决方案中，我们就会在一定的时间间隔向服务器上传业务人员的位置信息变化。<\/p><p><strong>LocationProvider<\/strong><\/p><p>LocationProvider 是我们了解移动设备位置信息变化的提供者。最常用的获取位置信息的定位方式有两种：GPS 和\n                NETWORK，用户可以为每个 provider 都可以设置一些自定义的标准来进行选择。使用 GPS\n                的定位方式的优点是定位更加精准，缺点是比较费电，只能在室外使用，并且耗电量较高。NETWORK 通过基站和 Wi-Fi\n                信号来获取位置信息，室内室外均可用，速度更快，耗电更少。为了获取用户位置信息，我们可以使用其中一个，也可以同时使用两个。<\/p><h2 id=\"major3\">利用 Android\n                手机客户端实现基于位置信息的定位服务<\/h2><p>位置服务有两个最重要的作用，一个是获取用户的位置信息，另外一个就是追踪用户的移动信息。在我们提供的这个解决方案中，用到的也正是这两个功能。上传的业务人员位置信息会及时的上传到服务器端，以供服务器端作为分派任务的参考。<\/p><p>这个解决方案在手机客户端的需求是这样的：<\/p><ul class=\"ibm-bullet-list\"><li> 1. 业务员可以使用自己的 ID 登陆应用。<\/li><li> 2. 手机客户端可以一直在后台运行并根据一定的时间间隔或活动距离改变将业务员的位置信息上传到服务器端。<\/li><li> 3. 登陆到应用的业务员可以到任务栏中查看自己的当前任务。<\/li><li> 4. 在任务完成后，可以将任务设置成完成状态，此时这条任务也会从任务栏中去除。<\/li><\/ul><p>客户端演示：<\/p><p>在这个解决方案中，我们使用的不是最新的 Android 平台，而是出于对兼容性的考虑使用了 Andriod2.3.3 平台，API 等级是\n                10。<\/p><p>来看下位置信息上传功能的实现。这一块的实现需要有对网络和 GPS 访问的权限，这些权限都需要在 AndroidMainfest.xml\n                中事先声明。<\/p><h5 id=\"listing1\">清单 1. 在 AndroidMainfest.xml\n                    中事先声明对网络和 GPS 访问的权限<\/h5><div class=\"codesection\"><pre class=\"displaycode\">&lt;uses-permission android:name=<em>\"android.permission.INTERNET\"<\/em> /&gt; &lt;!--访问网络权限\n--&gt;\n&lt;uses-permission android:name=<em>\"android.permission.ACCESS_FINE_LOCATION\"<\/em> /&gt;&lt;!--\n访问位置信息权限 --&gt;<\/pre><\/div><h5 id=\"listing2\">清单 2. 功能实现的主要代码<\/h5><div class=\"codesection\"><pre class=\"displaycode\">//定义获得 locationManager 实例\nlocationManager = (LocationManager)getSystemService(Context.LOCATION_SERVICE);\n\t//尝试从 GPS provider 获得上一次的位置信息\n\tlocation = locationManager.getLastKnownLocation(LocationManager.GPS_PROVIDER);\n\tif(location == null){\n//尝试从 Network provider 获得上一次的位置信息\n\tlocation = locationManager.getLastKnownLocation(LocationManager.NETWORK_PROVIDER);\n\t}\n\tif (location != null){\n\t//使用监听函数此处选择的是 10 分钟更新一次或位置变化大于 2 公里时获取并上传最新的位//\n\t置信息。\tlocationManager.requestLocationUpdates(LocationManager.GPS_PROVIDER , \n\t10*60*1000, 2*1000, new TestLocationListener());\n\t}\n\telse\n\t\tlocationManager.requestLocationUpdates(LocationManager.NETWORK_PRO-\n\t\tVIDER, 10*60*1000, 2*1000, new TestLocationListener());\n\treturn super.onStartCommand(intent, flags, startId);\n\t}<\/pre><\/div><p>当监听到位置信息的变化时，就进行上传操作。此处上传的是经度和纬度值，也包括当前任务的负载量。负载量是提供给后台的 JRules\n                作为分发规则使用的。监听器实现的是 LocationListener 接口，实现这个接口必须要继承它的 4 个方法。在这里我们使用的是\n                onLocationChanged(Location location) 这个方法，也就是监听当位置变化时执行操作。<\/p><h5 id=\"listing3\">清单 3. 监听当前位置变化<\/h5><div class=\"codesection\"><pre class=\"displaycode\">private class TestLocationListener implements LocationListener{\n\t\t@Override\n\t\tpublic void onLocationChanged(Location location) {\n\t\t\t//添加此方法的中文注释\n\t\t\tupdateToNewLocation(location);\n\t\t}\n\t\t@Override\n\t\tpublic void onProviderDisabled(String provider) {\n\t\t\t//添加此方法的中文注释\n\t\t}\n\t\t@Override\n\t\tpublic void onProviderEnabled(String provider) {\n\t\t\t//添加此方法的中文注释\n\t\t}\n\t\t@Override\n\t\tpublic void onStatusChanged(String provider, int status, Bundle extras) {\n\t\t\t//添加此方法的中文注释\n\t\t}<\/pre><\/div><p>下面是监听器里使用的方法。通过服务器端发布的 Web service，我们将位置信息的经度和纬度、负载量作为参数传给后台。<\/p><h5 id=\"listing4\">清单 4.\n                    将位置信息的经度和纬度、负载量作为参数传给后台<\/h5><div class=\"codesection\"><pre class=\"displaycode\">private void updateToNewLocation(Location location) {\n\t\tif (location != null) { \n//得到经度和纬度值\n\t\t\tlatitude = location.getLatitude(); \n\t\t\tlongitude = location.getLongitude(); \n\t\t\tString urlstr = URL + \"LocationEMPUpdate?id=\" + id + \"&amp;name=\" + \nname + \"&amp;locationDesc=\" + locaDes + \"&amp;locationX=\" + longitude + \"&amp;locationY=\" +\nlatitude + \"&amp;workload=\" + workload;\n\t\t\turlstr = urlstr.replace(\" \", \"%20\");\n\t\t\tSystem.out.println(urlstr);\n//建立 http 连接，将数据发送到服务器端。\n\t\t\tHttpPost request = new HttpPost(urlstr);\n\t\t\tDefaultHttpClient client = new DefaultHttpClient();\n\t\t\ttry {\n\t\t\tHttpResponse response = client.execute(request);\n\t\t\tint status = response.getStatusLine().getStatusCode();\n\t\t\t\t\t\tif (status == HttpStatus.SC_OK) {\n\t\t\t\tIntent intent=new Intent();\n\t\t\t\tintent.putExtra(\"message\", \"已经成功上传当前位置信息！\");\n\t\t\t\tintent.putExtra(\"lat\", latitude);\n\t\t\t\tintent.putExtra(\"lng\", longitude);\n\t\t\t\tintent.setAction(\"android.intent.action.locationStatus\");\n\tsendBroadcast(intent);\n\t\t\t} else {\n\t\t\t}\n\t\t} catch (ClientProtocolException e) {\n\t\t\te.printStackTrace();\n\t\t} catch (IOException e) {\n\t\t\te.printStackTrace();\n\t\t} finally {\n\t\t\tclient.getConnectionManager().shutdown();\n\t\t}\n\t\t} else {\n\t\t\t//获取不到位置时，发广播通知 MainTaskActivity\n\t\t\tIntent intent=new Intent();\n\t\t\tintent.putExtra(\"message\", \"目前无法获取位置信息！请稍后重试！\");\n\t\t\tintent.setAction(\"android.intent.action.locationStatus\");\n\tsendBroadcast(intent);\n\t\t}\n\t}<\/pre><\/div><p>下面这个方法的主要功能是从 ICM 服务器端获取分配给当前业务人员的任务。通过 JRules\n                自动分派的任务都会到达每个业务人员的任务栏中，手机客户端的数据也是从任务栏获取的。在这个演示中，ICM 服务器端会把每个业务员的任务封装在 JSON\n                数组中传给客户端。<\/p><h5 id=\"listing5\">清单 5. 将每个任务封装在 JSON\n                    数组中并传给客户端<\/h5><div class=\"codesection\"><pre class=\"displaycode\">private List&lt;String&gt; getData(){\n //访问 ICM server\n String urlstr = URL + \"WorkItemList?queueName=\" + queueName + \"&amp;inbasket=\" + inbasket \n+ \"&amp;username=\" + username + \"&amp;password=\" + pwd + \"&amp;pecp=\" + pecp;\n urlstr = urlstr.replace(\" \", \"%20\");//空格是非法字符，要转换\n System.out.println(urlstr);\n HttpPost request = new HttpPost(urlstr);\n HttpClient httpClient = new DefaultHttpClient();\n// List&lt;String&gt; data = new ArrayList&lt;String&gt;();\n data = new ArrayList&lt;String&gt;();\n try {\n \t\tHttpResponse httpResponse = httpClient.execute(request);\n int status = httpResponse.getStatusLine().getStatusCode();\n System.out.println(status);\n StringBuilder builder = new StringBuilder();\n BufferedReader reader = new BufferedReader(new InputStreamReader(\n httpResponse.getEntity().getContent()));\n for (String s = reader.readLine(); s != null; s = reader.readLine()) {\n builder.append(s);\n }\n //去除空格\n String result = builder.toString().replace(\" \", \"\");\n JSONObject json = new JSONObject(result);\n System.out.println(json);\n JSONArray array = json.getJSONArray(\"WorkItems\");\n workItems = JsonUtil.parseJson(array.toString());\n if (!workItems.isEmpty()){\n for (Iterator&lt;WorkItems&gt; iterator = workItems.iterator(); iterator.hasNext();) {\n \t\t\tWorkItems task = (WorkItems) iterator.next();\n System.out.println(task.getFCresteTime());\n System.out.println(task.getCARIN_AccidentDescription());\n System.out.println(task.getCARIN_AccidentType());\n \t\t\tString date = task.getFCresteTime();\n date = date.replace(\"T\", \" \");//去除无用字符\n date = date.replace(\"Z\", \" \");//去除无用字符\n String subject = date+ \" \" + task.getCARIN_ClientName();\n data.add(subject);\n \t\t}\n }else{\n Toast.makeText(this, \"当前没有任务！\", Toast.LENGTH_SHORT).show();\n setTitle(\"恭喜你！当前没有新任务。\");\n }\n } catch (Exception e) {\n e.printStackTrace();\n }\n return data;\n}<\/pre><\/div><p>当业务员完成任务后，他需要点击页面上的完成按钮来完成这条任务，相当于从 ICM 的收件篮中完成一个任务。这时还需要向后台传送这条任务的\n                wobNumber 和相应的 connection point。<\/p><h5 id=\"listing6\">清单 6. 向后台传送 wobNumber 和 connection\n                    point<\/h5><div class=\"codesection\"><pre class=\"displaycode\">class MyButtonListener implements OnClickListener{\n@Override\npublic void onClick(View v) {\n//处理 complete 事件\nString urlstr = URL + \"WorkItemDispatch?queueName=\" + queueName + \"&amp;wobNumber=\" + wobNumber \n+ \"&amp;username=\" + username + \"&amp;password=\" + password + \"&amp;pecp=\" + pecp;\nurlstr = urlstr.replace(\" \", \"%20\");//空格是非法字符，要转换\nSystem.out.println(urlstr);\nHttpPost request = new HttpPost(urlstr);\nDefaultHttpClient client = new DefaultHttpClient();\ntry {\n\t\t\tHttpResponse response = client.execute(request);\nint status = response.getStatusLine().getStatusCode();\nSystem.out.println(status);\nif (status == HttpStatus.SC_OK) {\nToast.makeText(CaseDetail.this, \"任务已完成！\", Toast.LENGTH_SHORT).show();\nSystem.out.println(\"发送成功！\");\n\t\t\t\tfinish();\n} else {\nSystem.out.println(\"发送失败！\");\nToast.makeText(CaseDetail.this, \"完成失败！请检查网络！\", Toast.<em>LENGTH_SHORT<\/em>).show();\n\t\t\t}\n} catch (ClientProtocolException e) {\n\t\t\te.printStackTrace();\n} catch (IOException e) {\n\t\t\te.printStackTrace();\n} finally {\n\t\t\tclient.getConnectionManager().shutdown();\n\t\t}\n\t\t}\n\t}<\/pre><\/div><h2 id=\"major4\">后台服务实现<\/h2><p>后台为移动客户端提供一系列的 Rest service 服务，移动客户端通过这些 service 与后台进行交互从而完成理赔人员的日常业务。这些\n                Rest service 如下：<\/p><p><strong>位置信息的接收<\/strong><\/p><p>后台为移动客户端提供了接收地理位置信息的接口/ICMMCRest/resources/LocationEMPUpdate。当移动客户端提交请求时，后台获取数据并将地理位置信息保存到数据库中。下面是部分代码：<\/p><h5 id=\"listing7\">清单 7. 将地理位置信息保存到数据库中<\/h5><div class=\"codesection\"><pre class=\"displaycode\">// 1.collect the data in map\n\t\t\tmap.put(\"EMP_ID\", id);\n\t\t\tmap.put(\"EMP_NAME\", name);\n\t\t\tmap.put(\"LOCATION_DESC\", locationDesc);\n\t\t\tmap.put(\"LOCATION_X\", locationX);\n\t\t\tmap.put(\"LOCATION_Y\", locationY);\n\t\t\tmap.put(\"WORKLOAD\", workload);\n\t\t\tSystem.out.println(\"map:\"+map.toString());\n\t\t\t// 2.update\n\t\t\ttry {\n\t\t\t\tif (GlobalShareData.dm.updateEMP(map)) {\n\t\t\t\t\tStringBuffer okJson = new StringBuffer();\n\t\t\t\t\tokJson.append(\"{\");\n\t\t\t\t\tokJson.append(\"\t\\\"returnCode\\\": 200,\");\n\t\t\t\t\tokJson.append(\"\t\\\"returnMsg\\\": \\\"Update successfully!\\\", \");\n\t\t\t\t\tokJson.append(\"StepHttpReturnCode: 200, \");\n\t\t\t\t\tokJson.append(\"}\");\n\t\t\t\t\tjsonData = okJson.toString();\n\t\t\t\t}\n\t\t\t} catch (Exception e) {\n\t\t\t\tSystem.out.println(\"============== Update location data, failed! \");\n\t\t\t\te.printStackTrace();\n\t\t\t\tthrow new Exception(\"fail to update,\"+e.getMessage());\n\t\t\t}<\/pre><\/div><p><strong>地图应用<\/strong><\/p><p>在上一章节中，客服人员设计案例时显示的地图应用，也是后台提供的服务/ICMMCRest/resources/LocationRetrieve。页面\n                Web Widget 访问这个服务时，后台进行处理，读取数据库获取业务人员的地理位置信息并跳转到位置数据处理页面，从而显示地图，如清单 8\n                所示。<\/p><h5 id=\"listing8\">清单 8. 显示地图应用<\/h5><div class=\"codesection\"><pre class=\"displaycode\">try {\n\t\t\t\temps = GlobalShareData.dm.getEmp();\n\t\t\t\temps = emps.substring(0,emps.lastIndexOf(\"|\")); \n\t\t\t\tSystem.out.println(\"employees are :\" + emps);\n\t\t\t} catch (Exception e1) {\n\t\t\t\t// TODO Auto-generated catch block\n\t\t\t\te1.printStackTrace();\n\t\t\t\tthrow new Exception(\"can not get employees,\"+e1.getMessage());\n\t\t\t}\n\t\t\t//redirect\n\t\t\turl = GlobalShareData.ICM_SERVER_URL + \"/ICMMCRest/GetPointByLoca-\n\t\t\ttion.jsp?emps=\"+emps;\n\t\t\t//url = \"http://localhost:8080/ICMMCRest/GetPointByLocation.jsp?\n\t\t\temps=\"+emps;\n\t\t\tSystem.out.println(\"usl is : \" +url);\n\t\t\tresponse.sendRedirect(url);<\/pre><\/div><p>后台使用百度的 JavaScript 地图 API，为业务人员提供了地图页面 GetPointByLocation.jsp 进行显示，如清单 9\n                所示。<\/p><h5 id=\"listing9\">清单 9.\n                    GetPointByLocation.jsp<\/h5><div class=\"codesection\"><pre class=\"displaycode\">&lt;script type=\"text/javascript\" src=\"http://api.map.baidu.com/api?v=1.4\"&gt;&lt;/script&gt;\n&lt;script type=\"text/javascript\"&gt;\n\tvar map = new BMap.Map(\"allmap\");\n\tvar point = new BMap.Point(116.331398, 39.897445);\n\tmap.centerAndZoom(point, 12);\n\tfunction parse(){\n\t\tconsole.log(\"*************parsing*****************\");\n\t\tvar location = document.getElementById(\"location\").value;\n\t\tconsole.log(\"The current location is :\" + location);\n\t\t// 创建地址解析器实例\n\t\tvar myGeo = new BMap.Geocoder();\n\t\t// 将地址解析结果显示在地图上, 并调整地图视野\n\t\tmyGeo.getPoint(location, function(point) {\n\t\t\tconsole.dir([ \"point\", point ]);\n\t\t\tdocument.getElementById(\"lat\").value = point.lat;\n\t\t\tdocument.getElementById(\"lng\").value = point.lng;\n\t\t\tif (point) {\n\t\t\t\tmap.centerAndZoom(point, 12);\n\t\t\t\tmap.addOverlay(new BMap.Marker(point));\n\t\t\t}\n\t\t\tvar lat = document.getElementById(\"lat\").value;\n\t\t\tvar lng = document.getElementById(\"lng\").value;\n\t\t\tconsole.log(\"The latitude is \" + lat+\", and the longitude is \"+lng);\n\t\t}, \"北京市\");\n\t}\n\tfunction addMarker(point){\n\t\tvar marker = new BMap.Marker(point);\n\t\tmap.addOverlay(marker);\n\t\tmarker.setAnimation(BMAP_ANIMATION_BOUNCE); //跳动的动画\n\t}\n\tfunction addEmps() {\n\t\tvar emps = document.getElementById(\"emps\").value;\n\t\tvar empArr = emps.split(\"|\");\n\t\tvar length = empArr.length;\n\t\tconsole.dir([\"emparray\",empArr,length]);\n\t\tfor(var i=0;i&lt;length;i++) {\n\t\t\t var user = empArr[i].split(\",\");\n\t\t\t console.dir([\"user\",user]);\n\t\t\t var point = new BMap.Point(user[1],user[2]);\n\t\t\t addMarker(point);\n\t\t}\n\t}\n\taddEmps();\n&lt;/script&gt;<\/pre><\/div><p>其中，addMarker 用跳跃的红点在地图上标记业务人员的实时地理位置，parse 用静止的红点表示页面中输入的地理位置。<\/p><p><strong>任务的发布<\/strong><\/p><p>当客服人员添加了案例之后，系统根据一定的规则自动给业务人员分配任务。这时移动客户端通过后台提供的获取任务的服务/ICMMCRest/resources/WorkItemList，就可以获取当前业务人员的任务列表，返回结果如下图所示：<\/p><h5 id=\"img001\">图 1. 当前业务人员的任务列表<\/h5><img alt=\"图 1. 当前业务人员的任务列表\" src=\"/sunshine_new/images/负929286467/img001.png\" width=\"581\" /><p><strong>任务处理<\/strong><\/p><p>业务人员通过查看任务的具体信息，进行业务的处理。移动客户端使用后台提供的分派服务/ICMMCRest/resources/WorkItemDispatch，提交处理数据，主要代码如下：<\/p><h5 id=\"listing10\">清单 10.\n                    提交处理数据：/ICMMCRest/resources/WorkItemDispatch<\/h5><div class=\"codesection\"><pre class=\"displaycode\">//step 1\nSystem.out.println(\"============== Dispatch task step 1, get the work item de-\ntail and Etag\");\nString dispatchTaskStep1URL = com.ibm.ecm.GlobalShareData.ICM_SERVER_URL + \n\"/CaseManager/P8BPMREST/p8/bpm/v1/queues/\"\n+ queueName + \"/stepelements/\" + wobNumber + \"?cp=\" + cp;\nJSONObject workObjectInfo = queryWorkObject(dispatchTaskStep1URL, username,\npassword, httpCodeInSteps);\n…\t\t\t\n//step 2\nSystem.out.println(\"============== Dispatch task step 2, lock the work item\");\n…\n//step 3\nSystem.out.println(\"============== Dispatch task step 3, dispatch the work item\");\nString dispatchTaskStep3URL = com.ibm.ecm.GlobalShareData.ICM_SERVER_URL + \n\"/CaseManager/P8BPMREST/p8/bpm/v1/queues/\" + queueName + \"/stepelements/\" + \nwobNumber + \"?cp=\" + cp + \"&amp;action=dispatch&amp;responseContent=0\";\t\t\t\ndispatchResult = dispatchWorkObject(dispatchTaskStep3URL, eTag, username, \npassword, workObjectInfo, action, httpCodeInSteps);\n……\n//step 4 email step - the optional step\t\t\t\nString userInfoRestUrl = com.ibm.ecm.GlobalShareData.ICM_SERVER_URL + \"/CaseM-\nanager/P8BPMREST/p8/bpm/v1/users?searchPattern=Steve&amp;searchType=1&amp;cp=\" + cp; \nString steveEmailAddress = getUserEmail(userInfoRestUrl, username, password, \"Steve\");\n…\nSystem.out.println(\"--- Start to send an email to \" + steveEmailAddress + \" for\nthe coming work item \" + wobNumber);\nEmailSender myMailSender = new EmailSender();\n\ttry{\n\tString mailBody = \"&lt;a href='CaseMgmt-HD://CaseMGMT/CaseMGMT.html?\n\twobNumber=\" + wobNumber + \"'&gt; Launch CaseMgmt &lt;/a&gt;\";\n\tmyMailSender.setMailServer(com.ibm.ecm.GlobalShareData.EMAIL_SERVER);\nmyMailSender.sendIt(mailBody, username, username+\"@xyz.com\", \"Steve\", \nsteveEmailAddress);\n\tSystem.out.println(\"Succeed to send email.\");<\/pre><\/div><p>其中，每一步都调用 ICM 产品提供的 Rest API 处理任务。<\/p><h2 id=\"major5\">结束语<\/h2><p>在这篇文章中，我们利用 Android 这个开发平台向大家介绍了如何开发一个具有基于地理信息位置服务的手机客户端应用，并通过这个客户端与后台 ICM\n                服务的接口进行通讯，获取实时的任务数据。这部分代码只是一种实现方式，在实际应用中，客户可以自己开发适合自己企业的客户端应用，当然也可以使用 iOS\n                来开发自己的手机客户端。<\/p><p>免责声明<\/p><p>本文包含解决方案。IBM\n                授予您（“被许可方”）使用这个解决方案的非专有的、版权免费的许可证。然而，解决方案是以“按现状”的基础提供的，不附有任何形式的（不论是明示的，还是默示的）保证，包括对适销性、适用于某特定用途或非侵权性的默示保证。IBM\n                及其许可方不对被许可方使用该软件所导致的任何损失负责。任何情况下，无论损失是如何发生的，也不管责任条款怎样，IBM\n                或其许可方都不对由使用该软件或不能使用该软件所引起的收入的减少、利润的损失或数据的丢失，或者直接的、间接的、特殊的、由此产生的、附带的损失或惩罚性的损失赔偿负责，即使\n                IBM 已经被明确告知此类损害的可能性，也是如此。<\/p><CMA ID: 973930><Site ID: 10><XSLT stylesheet used to transform this file: dw-document-html-7.0.xsl>\r\n\r\n\r\n<\/div>\r\n<\/div>\r\n","createTime":"2014-06-12 00:00:00","deployTime":"2014-06-12 00:00:00","id":0,"intro":"在上一篇文章中，我们了解了使用 ECM 产品解决汽车保险业务的智能分派与优化的项目背景。在这篇文章中，我们将主要介绍如何使用 Android 平台实现基于位置信息的服务。这部分包括手机客户端的主要功能实现，以及后台对应服务的实现。通过基于业务员位置信息的手机服务，后台 ECM 系统可以精确的定位每一名业务员的当前位置并通过 JRules 的一系列定制规则自动将任务分派给最适合处理此任务的业务人员。","keyword":"","recommend":false,"source":"http://www.ibm.com/developerworks/cn/data/library/techarticle/dm-1406-ecm-insurance2/index.html","title":"使用 ECM 产品解决汽车保险业务的智能分派与优化系列: 第二部分：利用 Android 平台实现基于位置信息的任务分派","typeId":0,"updateTime":"2014-06-12 00:00:00"}
{"author":"","clickNumber":0,"content":"\r\n<div class=\"ibm-columns\">\r\n<div class=\"ibm-col-1-1\">\r\n\r\n<h2 id=\"N1004E\">简介<\/h2><p>IBM&#174; Integration Toolkit（以前称为 WebSphere&#174; Message Broker Toolkit）提供 Endpoint Lookup 和 Registry Lookup 节点来为 WSRR 提供了明确的支持。这些节点可包含在消息流中，用以依据节点上定义的搜索条件从 WSRR 动态检索元数据。您还可以通过在 WSRR 节点之前的本地环境树中插入元素，以编程方式指定搜索条件。<\/p><p>Endpoint Lookup 节点用于从 WSRR 检索 WSDL 定义的一个 Web 服务的服务端点。该节点将检索的服务端点插入到本地环境树中，供后续 SOAP 或 HTTP Request 节点用来调用该 Web 服务。<\/p><p>Registry Lookup 节点是一个通用节点，可使用该节点从 WSRR 查询和检索任何文档或元数据，比如 WSDL、XML 模式、XSLT、策略文档等。该节点将检索的工件插入到本地环境树中，以在对消息流的后续处理中使用。<\/p><p>这些节点由 IBM Integration Toolkit 提供，可在消息流节点面板的 <strong>web services<\/strong> 文件夹中找到。本文将详细介绍这些节点。<\/p><h2 id=\"terminals\">节点终端<\/h2><p>Endpoint Lookup 和 Registry Lookup 节点的终端都是相同的，如  中所示。这些终端在  中进行了描述。 <\/p><h5 id=\"fig1\">WSRR 节点终端<\/h5><img alt=\"WSRR 节点终端\" src=\"/sunshine_new/images/593153172/images/WSRRNodes.jpg\" width=\"395\" /><h5 id=\"table1\">Endpoint Lookup 和 Registry Lookup 节点上的终端<\/h5><table border=\"0\" cellpadding=\"0\" cellspacing=\"0\" class=\"ibm-data-table\"><thead xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"><tr><th>终端<\/th><th>描述<\/th><\/tr><\/thead><tbody xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"><tr><td>In<\/td><td>输入终端，接受一条消息供节点处理。<\/td><\/tr><tr><td>Failure<\/td><td>输出终端，如果在节点处理过程中发生错误，那么消息将被路由到该终端。<\/td><\/tr><tr><td>Out<\/td><td>输出终端，未修改的输入消息和包含匹配的注册表数据的已更新本地环境被发送到该终端。<\/td><\/tr><tr><td>NoMatch<\/td><td>如果基于指定的搜索条件未找到匹配的条目，那么输入消息将被发送到此终端。<\/td><\/tr><\/tbody><\/table><h2 id=\"endpointlookup\">Endpoint Lookup 节点<\/h2><div class=\"dw-sidebar ibm-inset\"><h2 id=\"N100A4\">非 SOAP/HTTP 服务<\/h2><p> IIB 也可以从 WSRR 检索未由 WSDL 文档定义的服务（比如 REST 服务）的服务端点。为此，您应使用 Registry Lookup 节点或 HTTP Request 节点来检索端点元数据。 <\/p><\/div><p>Endpoint Lookup 节点用于从 WSRR 检索专门针对 WSDL 文档描述的服务的服务端点信息。WSDL 文档将服务定义为可在指定端口上使用的接口（称为 portType）。WSDL 端口定义访问服务需要的端点信息。Endpoint Lookup 节点从 WSRR 检索实现一个特定 portType 的 WSDL 端口。  下面通过一个示例展示了这些对象如何在 WSRR 中建模。<\/p><h5 id=\"fig2\">WSRR 中的 WSDL Port 与 WSDL Port Type 之间的关系<\/h5><img alt=\"WSRR 中的 WSDL Port 与 WSDL Port Type 之间的关系\" src=\"/sunshine_new/images/593153172/images/WSRRPortModel.jpg\" width=\"580\" /><div class=\"dw-sidebar ibm-inset\"><h2 id=\"N100B9\">Endpoint Lookup 节点的深度策略<\/h2><p>您可以指定 Endpoint Lookup 节点执行的 WSRR 查询的深度。Endpoint Lookup 节点始终对 WSRR 执行一种图形查询，该查询指定深度为 -1，返回所有与指定搜索条件匹配的 WSDLPort 对象，以及所有相关的子条目。<\/p><\/div><p>为了从 WSRR 检索服务端点信息，Endpoint Lookup 节点使用 WSRR Web 服务 API 执行图形查询。此查询采用了 XPath 表达式的形式，该表达式是基于节点上定义的属性而生成的。这些属性也可以编程方式指定，使用消息流中早期的计算节点将元素插入到本地环境树中。任何以编程方式指定的属性都会覆盖节点上指定的属性。您可以在 Endpoint Lookup 节点上定义的属性如 中所示。<\/p><h5 id=\"table2\">Endpoint Lookup 节点属性<\/h5><table border=\"0\" cellpadding=\"0\" cellspacing=\"0\" class=\"ibm-data-table\"><thead xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"><tr><th>属性<\/th><th>描述<\/th><\/tr><\/thead><tbody xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"><tr><td>PortType Name<\/td><td>在需要的端点上公开的 <strong>PortType<\/strong> 名称。<\/td><\/tr><tr><td>PortType Namespace<\/td><td>\n            在所需的端点上公开的 <strong>PortType<\/strong> 命名空间。\n    <\/td><\/tr><tr><td>PortType Version<\/td><td>\n        在所需的端点上公开的 <strong>PortType<\/strong> 版本。\n    <\/td><\/tr><tr><td>User Properties<\/td><td>\n允许在查询上指定所需的 <strong>WSDLPort<\/strong> 的属性。在 WSRR 中的 <strong>WSDLPort<\/strong> 对象上定义的属性如下：\n\n\n<ul class=\"ibm-bullet-list\"><li>bsrURI<\/li><li>name<\/li><li>namespace<\/li><li>version<\/li><li>description<\/li><li>owner<\/li><li>lastModified<\/li><li>lastModifiedBy<\/li><li>creationTimestamp<\/li><\/ul>\n            通常，WSRR 中的 <strong>WSDLPort<\/strong> 和 <strong>WSDLPortType<\/strong> 对象上的命名空间和版本相同。Property Type 可能为：\n            \n            \n                <ul class=\"ibm-bullet-list\"><li>\n                    字符串（默认），在这里，Property Value 是一个与 WSRR 中的属性值匹配的字符串。\n                    <\/li><li>\n                    XPATH 或 ESQL，在这里，Property Value 是一个 XPath 或 ESQL 表达式，它在消息树中找到一个包含与 WSRR 中的属性值匹配的字符串的字段。\n                    <\/li><\/ul><\/td><\/tr><tr><td>Classification<\/td><td><p>\n允许在查询上指定所需的 <strong>WSDLPort<\/strong> 的分类。<\/p><p>WSRR 允许定义可用来对注册的对象进行分类的本体（ontologies）。分类有助于让对象更容易被找到，也可以使用分类功能将一些相关对象分组到一起。例如，您可定义一个本体来表示组织中的各种业务单元。然后可将一个特定业务单元拥有的所有服务分组到一起，只要以相同方式对它们分类即可。<\/p><p>本体使用 OWL（Web Ontology Language，Web 本体语言）定义。每个分类器是 OWL 中的一个类，拥有一个 URI（Uniform Resource Identifier，统一资源标识符）。添加一个分类时，必须指定该类的完全限定的 OWL URI。<\/p><\/td><\/tr><tr><td>Match Policy<\/td><td>\n                        对 WSRR 执行的查询可能返回多个匹配的条目。如果 <strong>Match Policy<\/strong> 被设置为 <strong>One<\/strong>，那么 Endpoint Lookup 节点将会使用结果集中的第一个条目。如果 <strong>Match Policy<\/strong> 被设置为 <strong>All<\/strong>，那么 Endpoint Lookup 节点将会使用所有匹配的条目。\n                    <\/td><\/tr><\/tbody><\/table><p>\n            这些属性使用 IBM Integration Toolkit 中的<strong>属性<\/strong>编辑器来编辑，如 中所示。\n            <\/p><h5 id=\"fig3\">Endpoint Lookup 节点基本属性选项卡<\/h5><img alt=\"Endpoint Lookup 节点基本属性\" src=\"/sunshine_new/images/593153172/images/EndpointLookupNodeBasicProperties.jpg\" width=\"580\" /><p>\n            Endpoint Lookup 节点收到一条消息时，会按顺序执行以下步骤：\n            <\/p><ol><li>\n                    Endpoint Lookup 节点使用指定的搜索条件从 WSRR 检索服务数据。\n                <\/li><li><div class=\"dw-sidebar ibm-inset\"><h2 id=\"N1014C\">WSRR 查询结果的顺序<\/h2><p>\n    对 WSRR 执行查询时返回的结果的顺序不是固定的，可能无法在不同查询之间使用。                \n    <\/p><\/div>            \n                \n                    如果找到一个或多个匹配值，Endpoint Lookup 节点会将这些端点的一种表示添加到本地环境树中。一个端点的每种表示可作为 <strong>ITService<\/strong> 条目插入在本地环境中的 <strong>ServiceRegistry<\/strong> 条目下。 \n                    <ul class=\"ibm-bullet-list\"><li>\n                            如果 <strong>Match Policy<\/strong> 被设置为 <strong>One<\/strong>，那么 WSRR 返回的第一个条目将会返回给本地环境树。WSRR 不会保证一个查询返回的结果的顺序，所以，如果 WSRR 包含多个与指定搜索条件匹配的条目，则无法确定在每次发出该查询时 Endpoint Lookup 节点会选择哪个条目。\n                            <p>\n                            此外，检索的端点值设置为目标 URL 的本地环境覆盖值，供 SOAP Request、SOAP Asynchronous Request 或 HTTP Request 节点使用。也就是说，检索的端点值同时写入到本地环境树中的以下位置：\n                            <\/p><ul class=\"ibm-bullet-list\"><li><code>LocalEnvironment.Destination.HTTP.RequestURL<\/code><\/li><li><code>LocalEnvironment.Destination.SOAP.Request.Transport.WebServiceURL<\/code><\/li><\/ul><\/li><li>\n                            如果 <strong>Match Policy<\/strong> 被设置为 <strong>All<\/strong>，那么 WSRR 返回的所有匹配条目都会被添加到本地环境树中。SOAP Request、SOAP Asynchronous Request 或 HTTP Request 节点使用的目标 URL 不会设置。您必须向消息流添加一个计算节点，以便选择所需的地址并设置这些节点需要的本地环境设置。\n                        <\/li><\/ul>\n                    输入消息被原封不动地传播到 <strong>Out<\/strong> 端点。本地环境树也会传播到 <strong>Out<\/strong> 终端，在这里，可以让消息流中的后续节点进一步处理它。\n                <\/li><li>\n                    如果未找到匹配值，Endpoint Lookup 节点会将输入消息传播到 <strong>NoMatch<\/strong> 终端。                \n    <\/li><li>\n        如果发生处理错误，例如，如果连接到 <code>DefaultWSRR<\/code> 可配置服务上配置的 WSRR 服务器失败，或者连接超时，那么 Endpoint Lookup 节点会将输入消息原封不动地传播到 <strong>Failure<\/strong> 终端。<strong>ExceptionList<\/strong> 中会填入错误细节。\n    <\/li><\/ol><p>下面的示例展示了 Endpoint Lookup 节点生成的本地环境树的典型结构，其中 <strong>Match Policy<\/strong> 被设置为 <strong>One<\/strong>。根据消息流中以前已执行的处理，本地环境树中可能存在其他条目。<\/p><h5 id=\"listing1\">Endpoint Lookup 节点的典型输出<\/h5><div class=\"codesection\"><pre class=\"displaycode\">&lt;LocalEnvironment&gt;\n  &lt;Destination&gt;\n    &lt;HTTP&gt;\n      &lt;RequestURL&gt;http://localhost:7800/MathServer1/services/MathServer\n      &lt;/RequestURL&gt;\n    &lt;/HTTP&gt;\n    &lt;SOAP&gt;\n      &lt;Request&gt;\n        &lt;Transport&gt;\n          &lt;HTTP&gt;\n            &lt;WebServiceURL&gt;http://localhost:7800/MathServer1/services/MathServer\n            &lt;/WebServiceURL&gt;\n          &lt;/HTTP&gt;\n        &lt;/Transport&gt;\n      &lt;/Request&gt;\n    &lt;/SOAP&gt;\n  &lt;/Destination&gt;\n  &lt;ServiceRegistry&gt;\n    &lt;ITService&gt;\n      &lt;Endpoint&gt;\n        &lt;Address&gt;http://localhost:7800/MathServer1/services/MathServer&lt;/Address&gt;\n        &lt;PortType&gt;\n          &lt;name&gt;MathServerPortType&lt;/name&gt;\n          &lt;namespace&gt;http://math.pot.ibm.com&lt;/namespace&gt;\n          &lt;version&gt;1.0&lt;/version&gt;\n        &lt;/PortType&gt;\n        &lt;Classification&gt;http://www.ibm.com/xmlns/prod/serviceregistry/lifecycle/v6r3\n          /LifecycleDefinition#Online&lt;/Classification&gt;\n      &lt;/Endpoint&gt;\n    &lt;/ITService&gt;\n  &lt;/ServiceRegistry&gt;\n&lt;/LocalEnvironment&gt;<\/pre><\/div><h2 id=\"registrylookup\">Registry Lookup 节点<\/h2><p> Registry Lookup 节点是一个通用节点，可用于从 WSRR 查询和检索任何文档或元数据。该节点的工作原理与 Endpoint Lookup 节点非常类似，都基于指定的搜索条件生成一个 XPath 表达式，然后利用此表达式，使用 WSRR Web 服务 API 对 WSRR 执行一次图形查询。这两个节点之间的主要区别在 Registry Lookup 节点生成的 XPath 表达式中。Endpoint Lookup 生成一个 XPath 表达式，利用该表达式从 WSRR 中选择 WSDLPort 对象，而 Registry Lookup 节点不以任何方式限制从 WSRR 选择的对象类型。这使您能够在消息流中使用 Registry Lookup 节点从 WSRR 检索任何类型的条目。<\/p><p>可以在 Registry Lookup 节点上定义的属性如  中所示。 <\/p><h5 id=\"table3\">Registry Lookup 节点属性<\/h5><table border=\"0\" cellpadding=\"0\" cellspacing=\"0\" class=\"ibm-data-table\"><thead xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"><tr><th>属性<\/th><th>描述<\/th><\/tr><\/thead><tbody xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"><tr><td>Name<\/td><td>\n        您想要从 WSRR 检索的实体或工件的名称。\n    <\/td><\/tr><tr><td>Namespace<\/td><td>\n        您想要从 WSRR 检索的实体或工件的命名空间。\n    <\/td><\/tr><tr><td>Version<\/td><td>\n        您想要从 WSRR 检索的实体或工件的版本。\n    <\/td><\/tr><tr><td>User Properties<\/td><td><p>\n        允许在查询上指定 name、namespace 或 version 以外的属性。如果在 WSRR 业务模型中的一个类型上定义了所需的属性，指定的名称必须是该属性的程序化名称，包括模型的相关前缀。例如，如果想要将 <strong>Consumer Identifier<\/strong> 属性包含在查询中，则需要指定属性名称 <strong>gep63_consumerIdentifier<\/strong>。Property Type 可能为： <\/p><ul class=\"ibm-bullet-list\"><li>\n            字符串（默认），在这里，Property Value 是一个与 WSRR 中的属性值匹配的字符串。\n            <\/li><li>\n            XPATH 或 ESQL，在这里，Property Value 是一个 XPath 或 ESQL 表达式，它在消息树中找到一个包含与 WSRR 中的属性值匹配的字符串的字段。\n            <\/li><\/ul><\/td><\/tr><tr><td>Classification<\/td><td><p>\n        允许在查询上指定您想要从 WSRR 检索的实体或工件的分类。<\/p><p>WSRR 允许定义可用于对注册的对象进行分类的本体。分类有助于让对象更容易被找到，也可以利用分类功能将一些相关对象分组到一起。例如，您可定义一个本体来表示组织中的各种业务单元。然后可以将一个特定业务单元拥有的所有服务分组到一起，只要以相同方式对它们分类即可。<\/p><p>本体是使用 OWL（Web Ontology Language，Web 本体语言）定义的。每个分类器是 OWL 中的一个类，拥有一个 URI（Uniform Resource Identifier，统一资源标识符）。添加一个分类时，必须指定该类的完全限定的 OWL URI。 <\/p><\/td><\/tr><tr><td>Match Policy<\/td><td>\n        对 WSRR 执行的查询可能返回多个匹配的条目。如果 <strong>Match Policy<\/strong> 被设置为 <strong>One<\/strong>，那么 Registry Lookup 节点将会使用结果集中的第一个条目。如果 <strong>Match Policy<\/strong> 被设置为 <strong>All<\/strong>，那么 Registry Lookup 节点将会使用所有匹配的条目。\n    <\/td><\/tr><tr><td>Depth Policy<\/td><td>\n WSRR 允许客户端在执行图形查询时指定呈现的对象图的深度。这为客户端提供了对查询返回的数据量的一定控制水平。通过在 Registry Lookup 节点上指定合适的 <strong>Depth Policy<\/strong>（可在 <strong>Advanced<\/strong> 选项卡上找到），可以控制执行图形查询时传递给 WSRR 的深度。<strong>Depth Policy<\/strong> 的有效值包括：\n                        <ul class=\"ibm-bullet-list\"><li><strong>Return matched only (Depth = 0)<\/strong>，使用 WSRR 查询深度 0，仅返回匹配的条目。\n                            <\/li><li><strong>Return matched plus immediate related entities (Depth = 1)<\/strong>，使用 WSRR 查询深度 1，返回匹配的条目和直接相关的子条目。\n                            <\/li><li><strong>Return matched plus all related entities (Depth = -1)<\/strong>，使用 WSRR 查询深度 1，返回匹配的条目和直接相关的子条目。\n                            <\/li><\/ul><strong>Return matched showing immediate relationships (For compatibility only)<\/strong> 值也可以使用，但它已被弃用，不应使用它。\n                    <\/td><\/tr><\/tbody><\/table><p>\n这些属性使用 IBM Integration Toolkit 中的<strong>属性<\/strong>编辑器来编辑，如  中所示。\n<\/p><h5 id=\"fig4\">Registry Lookup 节点基本属性选项卡<\/h5><img alt=\"Registry Lookup 节点基本属性\" src=\"/sunshine_new/images/593153172/images/RegistryLookupNodeBasicProperties.jpg\" width=\"580\" /><p>\n如果想要使用 Registry Lookup 节点从 WSRR 中检索特定类型的对象，可执行以下操作： \n<\/p><ol><li>\n                指定一个 <strong>User Property<\/strong>，它的属性名为 <strong>primaryType<\/strong>，属性值为具有所需类型的 <strong>OWL URI<\/strong>。例如，要生成一个仅从 WSRR 返回 <strong>Business Services<\/strong> 的查询，可添加一个值为 <code>http://www.ibm.com/xmlns/prod/serviceregistry/profile/v6r3/GovernanceEnablementModel#BusinessService<\/code> 的 <strong>primaryType<\/strong> 属性。\n                <\/li><li>\n                在 <strong>Classifications<\/strong> 列表中指定所需类型的 <strong>OWL URI<\/strong>。\n                <\/li><\/ol><p>\n            Registry Lookup 节点收到一条消息时，会按顺序执行以下步骤：\n            <\/p><ol><li>\n    Registry Lookup 节点使用指定的搜索条件从 WSRR 中检索数据。                 \n<\/li><li>\n    如果找到一个或多个匹配值，Registry Lookup 节点会将这些实体的一种表示添加到本地环境树中。一个匹配实体的每种表示可作为 <strong>Entity<\/strong> 条目插入在本地环境中的 <strong>ServiceRegistry<\/strong> 条目下。<strong>ServiceRegistry<\/strong> 归 XMLNSC 分析器所有。\n    <ul class=\"ibm-bullet-list\"><li>\n            如果 <strong>Match Policy<\/strong> 被设置为 <strong>One<\/strong>，那么 WSRR 返回的第一个条目将会返回给本地环境树。WSRR 不会保证一个查询返回的结果的顺序，所以如果 WSRR 包含多个与指定搜索条件匹配的条目，则无法确定在每次发出该查询时 Endpoint Lookup 节点会选择哪个条目。\n        <\/li><li>\n            如果 <strong>Match Policy<\/strong> 被设置为 <strong>All<\/strong>，那么 WSRR 返回的所有匹配条目都会添加到本地环境树中。\n        <\/li><\/ul>\n    输入消息原封不动地被传播到 <strong>Out<\/strong> 端点。本地环境树也会传播到 <strong>Out<\/strong> 终端，在这里，可以让消息流中的后续节点进一步处理它。本地环境树中的实体的准确表示取决于指定的 <strong>Depth Policy<\/strong>。\n<\/li><li>\n        如果未找到匹配值，那么 Registry Lookup 节点会将输入消息传播到 <strong>NoMatch<\/strong> 终端。                \n    <\/li><li>\n        如果发生处理错误，例如，如果连接到 <code>DefaultWSRR<\/code> 可配置服务上配置的 WSRR 服务器失败，或者连接超时，那么 Registry Lookup 节点会将输入消息原封不动地传播到 <strong>Failure<\/strong> 终端。<strong>ExceptionList<\/strong> 中会填入错误细节。\n    <\/li><\/ol><p>\n以下 XML 展示了 Registry Lookup 节点可能在本地环境树中生成的 <strong>ServiceRegistry<\/strong> 条目的示例。这是使用 <strong>Depth Policy<\/strong><strong>Return matched plus immediate related entities (Depth = 1)<\/strong> 生成的。<\/p><h5 id=\"listing2\">Registry Lookup 节点的示例输出<\/h5><div class=\"codesection\"><pre class=\"displaycode\">&lt;ServiceRegistry&gt;\n  &lt;Entity\n    bsrURI=\"de3116de-6db2-422f.9d14.baee05ba14cc\"\n    name=\"CalculatorApplication\"\n    namespace=\"\"\n    version=\"1.0\"\n    description=\"Version 1.0 of the CalculatorApplication.\"\n    owner=\"wasadmin\"\n    lastModified=\"1382700226780\"\n    creationTimestamp=\"1379085488592\"\n    lastModifiedBy=\"wasadmin\"\n    primaryType=\"\"&gt;\n    &lt;classificationURIs&gt;\n      http://www.ibm.com/xmlns/prod/serviceregistry/lifecycle/v6r3\n        /LifecycleDefinition#Realized\n    &lt;/classificationURIs&gt;\n    &lt;classificationURIs&gt;\n      http://www.ibm.com/xmlns/prod/serviceregistry/profile/v6r3\n        /GovernanceEnablementModel#ApplicationVersion\n    &lt;/classificationURIs&gt;\n    &lt;userDefinedProperties name=\"ale63_ownerEmail\" value=\"\"/&gt;\n    &lt;userDefinedProperties name=\"ale63_guid\" value=\"\"/&gt;\n    &lt;userDefinedProperties name=\"ale63_assetType\" value=\"\"/&gt;\n    &lt;userDefinedProperties name=\"ale63_remoteState\" value=\"\"/&gt;\n    &lt;userDefinedProperties name=\"ale63_fullDescription\" value=\"\"/&gt;\n    &lt;userDefinedProperties name=\"ale63_assetOwners\" value=\"\"/&gt;\n    &lt;userDefinedProperties name=\"gep63_versionTerminationDate\" value=\"2019-09-13\"/&gt;\n    &lt;userDefinedProperties name=\"ale63_communityName\" value=\"\"/&gt;\n    &lt;userDefinedProperties name=\"gep63_consumerIdentifier\" value=\"\"/&gt;\n    &lt;userDefinedProperties name=\"gep63_versionAvailabilityDate\" value=\"2013-09-13\"/&gt;\n    &lt;userDefinedProperties name=\"ale63_requirementsLink\" value=\"\"/&gt;\n    &lt;userDefinedProperties name=\"ale63_assetWebLink\" value=\"\"/&gt;\n    &lt;userDefinedProperties name=\"ale63_owningOrganization\" value=\"\"/&gt;\n    &lt;userDefinedRelationships name=\"ale63_owningOrganization\"&gt;\n      &lt;targetEntities&gt;\n        &lt;Entity\n          bsrURI=\"d2d6c2d2-3d69-4975.b47d.d26767d27d38\"\n          name=\"IT Department\"\n          namespace=\"\"\n          version=\"\"\n          description=\"\"\n          owner=\"wasadmin\"\n          lastModified=\"1379084875512\"\n          creationTimestamp=\"1379084873049\"\n          lastModifiedBy=\"wasadmin\"\n          primaryType=\"\"&gt;\n          &lt;classificationURIs&gt;\n            http://www.ibm.com/xmlns/prod/serviceregistry/lifecycle/v6r3/\n              LifecycleDefinition#Governed\n          &lt;/classificationURIs&gt;\n          &lt;classificationURIs&gt;\n            http://www.ibm.com/xmlns/prod/serviceregistry/v6r3/ALEModel#Organization\n          &lt;/classificationURIs&gt;\n          &lt;userDefinedProperties name=\"ale63_contact\" value=\"Martin Smithson\"/&gt;\n          &lt;userDefinedProperties name=\"ale63_contactEmail\" value=\"msmiths@uk.ibm.com\"/&gt;\n        &lt;/Entity&gt;\n      &lt;/targetEntities&gt;\n    &lt;/userDefinedRelationships&gt;\n    &lt;userDefinedRelationships name=\"ale63_artifacts\"&gt;\n      &lt;targetEntities&gt;\n      &lt;/targetEntities&gt;\n    &lt;/userDefinedRelationships&gt;\n    &lt;userDefinedRelationships name=\"gep63_interfaceSpecifications\"&gt;\n      &lt;targetEntities&gt;\n      &lt;/targetEntities&gt;\n    &lt;/userDefinedRelationships&gt;\n    &lt;userDefinedRelationships name=\"gep63_providedSCAModules\"&gt;\n      &lt;targetEntities&gt;\n      &lt;/targetEntities&gt;\n    &lt;/userDefinedRelationships&gt;\n    &lt;userDefinedRelationships name=\"gep63_providedWebServices\"&gt;\n      &lt;targetEntities&gt;\n      &lt;/targetEntities&gt;\n    &lt;/userDefinedRelationships&gt;\n    &lt;userDefinedRelationships name=\"ale63_dependency\"&gt;\n      &lt;targetEntities&gt;\n      &lt;/targetEntities&gt;\n    &lt;/userDefinedRelationships&gt;\n    &lt;userDefinedRelationships name=\"gep63_provides\"&gt;\n      &lt;targetEntities&gt;\n      &lt;/targetEntities&gt;\n    &lt;/userDefinedRelationships&gt;\n    &lt;userDefinedRelationships name=\"gep63_providedRESTServices\"&gt;\n      &lt;targetEntities&gt;\n      &lt;/targetEntities&gt;\n    &lt;/userDefinedRelationships&gt;\n  &lt;/Entity&gt;\n&lt;/ServiceRegistry&gt;<\/pre><\/div><h2 id=\"overriding_properties\">以编程方式覆盖节点属性<\/h2><p>\n            如上所述，在查询 WSRR 时，Endpoint Lookup 和 Registry Lookup 节点使用的属性的值能够以编程方式进行指定。这通过使用一个转换节点（比如 Java Compute 节点）在本地环境树中插入字段来实现。这些字段必须在本地环境树的 <strong>ServiceRegistryLookupProperties<\/strong> 条目中进行设置。转换节点必须放在消息流中的 Endpoint Lookup 或 Registry Lookup 节点之前，如  中所示。\n            <\/p><h5 id=\"fig5\">以编程方式设置搜索条件<\/h5><img alt=\"以编程方式设置搜索条件\" src=\"/sunshine_new/images/593153172/images/ProgrammaticallySettingSearchCriteria.jpg\" width=\"293\" /><p>\n            可在本地环境树的 <strong>ServiceRegistryLookupProperties<\/strong> 条目中设置的字段如  中所示。 \n            <\/p><h5 id=\"table4\">erviceRegistryLookupProperties 字段<\/h5><table border=\"0\" cellpadding=\"0\" cellspacing=\"0\" class=\"ibm-data-table\"><thead xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"><tr><th>字段<\/th><th>描述<\/th><\/tr><\/thead><tbody xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"><tr><td>Name<\/td><td>\n    此字段覆盖了 Endpoint Lookup 节点上的 <strong>PortType Name<\/strong> 或 Registry Lookup 节点上的 <strong>Name<\/strong>。                    \n    <\/td><\/tr><tr><td>Namespace<\/td><td>\n    此字段覆盖了 Endpoint Lookup 节点上的 <strong>PortType Namespace<\/strong> 或 Registry Lookup 节点上的 <strong>Namespace<\/strong>。                    \n    <\/td><\/tr><tr><td>版本<\/td><td>\n                    此字段覆盖了 Endpoint Lookup 节点上的 <strong>PortType Version<\/strong> 或 Registry Lookup 节点上的 <strong>Version<\/strong>。                    \n    <\/td><\/tr><tr><td>UserProperties<\/td><td>\n    此字段覆盖了 Endpoint Lookup  或 Registry Lookup 节点上的 <strong>User Properties<\/strong>。\n    <\/td><\/tr><tr><td>Classification<\/td><td>\n    此字段覆盖了 Endpoint Lookup  和 Registry Lookup 节点上的 <strong>Classification<\/strong> 属性。\n    <\/td><\/tr><tr><td>MatchPolicy<\/td><td>\n    此字段覆盖了 Endpoint Lookup  和 Registry Lookup 节点上的 <strong>Match Policy<\/strong> 属性。以编程方式设置时，此属性的有效值包括 <strong>One<\/strong> 和 <strong>All<\/strong>。                    \n    <\/td><\/tr><tr><td>DepthPolicy<\/td><td>\n此字段覆盖了 Registry Lookup 节点上的 <strong>Depth Policy<\/strong> 属性。以编程方式设置此属性时的有效值包括：\n<ul class=\"ibm-bullet-list\"><li><strong>MatchOnly<\/strong> 表示 <strong>Return matched only (Depth = 0)<\/strong><\/li><li><strong>MatchPlusImmediate<\/strong> 表示 <strong>Return matched plus immediate related entities (Depth = 1)<\/strong><\/li><li><strong>MatchPlusAll<\/strong> 表示 <strong>Return matched plus all related entities (Depth = -1)<\/strong><\/li><\/ul><strong>MatchShowRel<\/strong> 值对应于可在节点的 <strong>Properties<\/strong> 编辑器中指定的 <strong>\nReturn matched showing immediate relationships (For compatibility only)<\/strong> 值。如前面所讨论的，这个值已被弃用，不应再使用。     \n<\/td><\/tr><\/tbody><\/table><p> 提供了一个使用 ESQL 以编程方式设置这些属性的示例。\n<\/p><h5 id=\"listing3\">使用 ESQL 动态指定搜索条件<\/h5><div class=\"codesection\"><pre class=\"displaycode\">SET OutputLocalEnvironment.ServiceRegistryLookupProperties.Name = 'MathServerPortType';\nSET OutputLocalEnvironment.ServiceRegistryLookupProperties.Namespace\n  = 'http://math.pot.ibm.com';\nSET OutputLocalEnvironment.ServiceRegistryLookupProperties.Version = '1.0';\nSET OutputLocalEnvironment.ServiceRegistryLookupProperties.UserProperties.prop1\n  = 'value1';\nSET OutputLocalEnvironment.ServiceRegistryLookupProperties.Classification\n  = 'http://www.ibm.com/xmlns/prod/serviceregistry/8/0/visibilitytaxonomy#Internal';\nSET OutputLocalEnvironment.ServiceRegistryLookupProperties.MatchPolicy = 'One';\nSET OutputLocalEnvironment.ServiceRegistryLookupProperties.DepthPolicy = 'MatchOnly';<\/pre><\/div><p> 提供了一个使用 Java 以编程方式设置这些属性的示例。IIB 中的 XPath 实现提供了许多可用来修改消息树的自定义 XPath 函数。 \n 中所示的示例 Java 代码使用了这些函数，以减少在本地环境树中创建字段所需的代码量。有关这些自定义 XPath 函数的更多信息，请访问 <a href=\"#resources\">参考资料<\/a> 一节中的<strong>使用 XPath 扩展更新消息<\/strong>链接。\n<\/p><h5 id=\"listing4\">使用 Java 动态指定搜索条件<\/h5><div class=\"codesection\"><pre class=\"displaycode\">MbMessage environment = new MbMessage(inAssembly.getLocalEnvironment());\nMbElement envRoot = environment.getRootElement();\nenvRoot.evaluateXPath( \"?ServiceRegistryLookupProperties/?Name\"\n                     + \"[set-value('MathServerPortType')]\");\nenvRoot.evaluateXPath( \"?ServiceRegistryLookupProperties/?Namespace\"\n                     + \"[set-value('http://math.pot.ibm.com')]\");\nenvRoot.evaluateXPath(\"?ServiceRegistryLookupProperties/?Version[set-value('1.0')]\");\nenvRoot.evaluateXPath( \"?ServiceRegistryLookupProperties/?UserProperties/?prop1\"\n                     + \"[set-value('value1')]\");\nenvRoot.evaluateXPath( \"?ServiceRegistryLookupProperties/?Classification\"\n                     + \"[set-value('http://www.ibm.com/xmlns/prod/serviceregistry/8/0/\"\n                     + \"visibilitytaxonomy#Internal')]\");\nenvRoot.evaluateXPath(\"?ServiceRegistryLookupProperties/?MatchPolicy\"\n                     + \"[set-value('One')]\");\nenvRoot.evaluateXPath( \"?ServiceRegistryLookupProperties/?DepthPolicy\"\n                     + \"[set-value('MatchOnly')]\");<\/pre><\/div><p>\nEndpoint Lookup 和 Registry Lookup 节点上的 <strong>User Properties<\/strong> 和 <strong>Classification<\/strong>\n属性都可配置多个值。可以在本地环境树中以编程方式为这些属性指定多个值。 \n 通过一个示例展示了如何使用 ESQL 完成此任务。\n<\/p><h5 id=\"listing5\">使用 ESQL 指定多个属性和分类<\/h5><div class=\"codesection\"><pre class=\"displaycode\">-- Create multiple properties\nSET OutputLocalEnvironment.ServiceRegistryLookupProperties.UserProperties.prop1\n  = 'value1';\nSET OutputLocalEnvironment.ServiceRegistryLookupProperties.UserProperties.prop2\n  = 'value2';\n\n-- Create multiple classifications\nSET OutputLocalEnvironment.ServiceRegistryLookupProperties.Classification[1]\n  = 'http://www.ibm.com/xmlns/prod/serviceregistry/8/0/visibilitytaxonomy#Internal';\nSET OutputLocalEnvironment.ServiceRegistryLookupProperties.Classification[2]\n  = 'http://www.ibm.com/xmlns/prod/serviceregistry/6/1/GovernanceProfileTaxonomy#Staging';<\/pre><\/div><p> 通过一个示例展示了如何使用 Java 完成此任务。            \n            <\/p><h5 id=\"listing6\">使用 Java 指定多个属性和分类<\/h5><div class=\"codesection\"><pre class=\"displaycode\">// Create multiple properties\nenvRoot.evaluateXPath( \"?ServiceRegistryLookupProperties/?UserProperties/?prop1\"\n                     + \"[set-value('value1')]\");\nenvRoot.evaluateXPath( \"?ServiceRegistryLookupProperties/?UserProperties/?prop2\"\n                     + \"[set-value('value2')]\");\n\n// Create multiple classifications\nenvRoot.evaluateXPath( \"?ServiceRegistryLookupProperties/?Classification\"\n  + \"[set-value('http://www.ibm.com/xmlns/prod/serviceregistry/8/0/visibilitytaxonomy#\"\n  + \"Internal')]\");\nenvRoot.evaluateXPath( \"?ServiceRegistryLookupProperties/?$Classification\"\n  + \"[set-value('http://www.ibm.com/xmlns/prod/serviceregistry/6/1/\"\n  + \"GovernanceProfileTaxonomy#Staging')]\");<\/pre><\/div><p>\n以编程方式覆盖 Endpoint Lookup 和 Registry Lookup 节点上的属性的能力使您能够克服这些节点上存在的限制。IBM Integration Toolkit 强制要求为这些节点上的 <strong>name<\/strong>、<strong>namespace<\/strong> 或 <strong>version<\/strong> 属性中的至少一个属性指定一个值。如果不为任何这些属性指定值，那么在保存消息流时就会得到一条错误消息，您将无法部署它。为了克服此限制，可为这些属性中的一个属性指定一个虚假值，然后在消息流中的早期阶段以编程方式清除该值。 显示了一个为 Registry Lookup 节点上的 <strong>name<\/strong> 属性指定值 <strong>dummy<\/strong> 的示例。            \n<\/p><h5 id=\"fig6\">指定一个虚假名称<\/h5><img alt=\"指定一个虚假名称\" src=\"/sunshine_new/images/593153172/images/RegistryLookupNodeDummyName.jpg\" width=\"580\" /><p> 通过一个示例展示了如何使用 Java 以编程方式清除此值。            \n<\/p><h5 id=\"listing7\">使用 Java 以编程方式清除 name 属性<\/h5><div class=\"codesection\"><pre class=\"displaycode\">envRoot.evaluateXPath(\"?ServiceRegistryLookupProperties/?Name[set-value('')]\");<\/pre><\/div><h2 id=\"N10382\">生成的 XPath 表达式<\/h2><p>\n            上面已经提到，Endpoint Lookup 和 Registry Lookup 节点都生成了 XPath 表达式，以基于节点上指定的属性或在本地环境树中以编程方式指定的属性来查询 WSRR。Endpoint Lookup 节点生成的 XPath 表达式的格式如 中所示。\n            <\/p><h5 id=\"listing8\">Endpoint Lookup 节点生成的 XPath 查询<\/h5><div class=\"codesection\"><pre class=\"displaycode\">/WSRR/WSDLService/ports[binding/portType[\n    @name='&lt;PORTTYPE_NAME&gt;' and \n    @namespace='&lt;PORTTYPE_NAMESPACE&gt;' and \n    @version='&lt;PORTTYPE_VERSION&gt;'] and \n    @&lt;PROPERTY_NAME_1&gt;='&lt;PROPERTY_VALUE_1&gt;' and\n        ...\n    @&lt;PROPERTY_NAME_N&gt;='&lt;PROPERTY_VALUE_N&gt;' and\n    exactlyClassifiedByAllOf(., '&lt;CLASSIFICATION_URI_1&gt;', ... ,'&lt;CLASSIFICATION_URI_N&gt;')]<\/pre><\/div><p>\n其中：\n<\/p><ul class=\"ibm-bullet-list\"><li><code>&lt;PORTTYPE_NAME&gt;<\/code> 是 <code>PortType Name<\/code> 属性的值。\n<\/li><li><code>&lt;PORTTYPE_NAMESPACE&gt;<\/code> 是 <code>PortType Namespace<\/code> 属性的值。\n<\/li><li><code>&lt;PORTTYPE_VERSION&gt;<\/code> 是 <code>PortType Version<\/code> 属性的值。 \n<\/li><li><code>&lt;PROPERTY_NAME_1&gt;<\/code> 是指定的第一个 <code>User Property<\/code>（如果有）的值。  \n<\/li><li><code>&lt;CLASSIFICATION_URI_1&gt;<\/code> 是指定的第一个 <code>Classification<\/code>（如果有）的 OWL URI。 \n<\/li><\/ul><p>\nRegistry Lookup 节点生成的 XPath 表达式的格式如  中所示。\n<\/p><h5 id=\"listing9\">Registry Lookup 节点生成的 XPath 查询<\/h5><div class=\"codesection\"><pre class=\"displaycode\">//*[@name='&lt;NAME&gt;' and \n    @namespace='&lt;NAMESPACE&gt;' and \n    @version='&lt;VERSION&gt;' and \n    @&lt;PROPERTY_NAME_1&gt;='&lt;PROPERTY_VALUE_1&gt;' and\n        ...\n    @&lt;PROPERTY_NAME_N&gt;='&lt;PROPERTY_VALUE_N&gt;' and\n    exactlyClassifiedByAllOf(., '&lt;CLASSIFICATION_URI_1&gt;', ... ,'&lt;CLASSIFICATION_URI_N&gt;')]<\/pre><\/div><ul class=\"ibm-bullet-list\"><li><code>&lt;NAME&gt;<\/code> 是 <code>Name<\/code> 属性的值。\n<\/li><li><code>&lt;NAMESPACE&gt;<\/code> 是 <code>Namespace<\/code> 属性的值。\n<\/li><li><code>&lt;VERSION&gt;<\/code> 是 <code>Version<\/code> 属性的值。 \n<\/li><li><code>&lt;PROPERTY_NAME_1&gt;<\/code> 是指定的第一个 <code>User Property<\/code>（如果有）的值。  \n<\/li><li><code>&lt;PROPERTY_VALUE_1&gt;<\/code> 是指定的第一个 <code>User Property<\/code>（如果有）的值。\n<\/li><li><code>&lt;CLASSIFICATION_URI_1&gt;<\/code> 是指定的第一个 <code>Classification<\/code>（如果有）的 OWL URI。 \n<\/li><\/ul><p>\n如果未为给定属性指定任何值，则会在已生成的 XPath 表达式中忽略适用于该属性的相应断言。例如，如果在消息流中包含了 Registry Lookup 节点，而且仅为 <code>Name<\/code> 属性指定了值 <code>MyTestService<\/code>，那么生成的 XPath 表达式应如下所示：\n<\/p><h5 id=\"listing10\">示例 XPath<\/h5><div class=\"codesection\"><pre class=\"displaycode\">//*[@name='MyTestService']<\/pre><\/div><p>\n另请注意，Endpoint Lookup 和 Registry Lookup 节点生成的 XPath 表达式都使用了 WSRR 所提供的 <code>exactlyClassifiedByAllOf<\/code> 自定义 XPath 函数。此函数返回的对象已按<strong>所有<\/strong>指定的 OWL URI 进行分类，而未考虑任何子分类。举例而言，如果想要返回某个服务的已按环境分类的所有端点，那么您将无法指定 <code>Environment<\/code> 分类的 OWL URI，因为您未考虑子分类：\n<\/p><div class=\"codesection\"><pre class=\"displaycode\">http://www.ibm.com/xmlns/prod/serviceregistry/6/1/GovernanceProfileTaxonomy#Environment<\/pre><\/div><p>\n相反，您需要显式包含想要包含在查询结果中的对象的所有环境分类。例如，WSRR 开箱即用地为环境分类定义了以下子分类：\n<\/p><div class=\"codesection\"><pre class=\"displaycode\">http://www.ibm.com/xmlns/prod/serviceregistry/6/1/GovernanceProfileTaxonomy#Development\nhttp://www.ibm.com/xmlns/prod/serviceregistry/6/1/GovernanceProfileTaxonomy#Production\nhttp://www.ibm.com/xmlns/prod/serviceregistry/6/1/GovernanceProfileTaxonomy#Staging\nhttp://www.ibm.com/xmlns/prod/serviceregistry/6/1/GovernanceProfileTaxonomy#Test<\/pre><\/div><h2 id=\"N10411\">性能和缓存<\/h2><p>从消息流中对 WSRR 的调用是同步的。显然，这可能影响消息流在运行时的性能。为了改善使用 Endpoint Lookup 和 Registry Lookup 节点的消息流的性能，IIB 提供了一个缓存来存储这些节点所执行的查询的结果。此缓存将在 <a href=\"http://www.ibm.com/developerworks/websphere/library/techarticles/1404_smithson7/1404_smithson7.html\" onmouseover=\"linkQueryAppend(this)\">第 7 部分：在 IIB 中配置 WSRR 缓存<\/a> 中更详细地介绍。<\/p><h2 id=\"N1041D\">结束语<\/h2><p>本文详细介绍了 IIB 所提供的 Endpoint Lookup 和 Registry Lookup 节点。本信息为帮助您了解在本系列剩余文章中描述的每个示例消息流中如何使用节点奠定了坚实的基础。<\/p><h2 id=\"N10424\">致谢<\/h2><p>感谢以下人员帮助开发本系列中的示例消息流：<\/p><ul class=\"ibm-bullet-list\"><li>John Hosie<\/li><li>Ben Thompson<\/li><li>Matt Golby-Kirk<\/li><li>Trevor Dolby<\/li><li>Andreas Martens<\/li><li>Graham Haxby<\/li><li>Andrew Coleman<\/li><li>John Reeve<\/li><\/ul><p>还要感谢以下人员帮助审阅本文：<\/p><ul class=\"ibm-bullet-list\"><li>David Seager<\/li><li>Arnauld Desprets<\/li><li>Anna Maciejkowicz<\/li><\/ul><CMA ID: 974173><Site ID: 10><XSLT stylesheet used to transform this file: dw-document-html-7.0.xsl>\r\n\r\n\r\n<\/div>\r\n<\/div>\r\n","createTime":"2014-06-12 00:00:00","deployTime":"2014-06-12 00:00:00","id":0,"intro":"IBM Integration Bus (IIB) 通过 Endpoint Lookup 和 Registry Lookup 节点提供了与 WebSphere Service Registry and Repository (WSRR) 的开箱即用的集成。使用这些节点，您可以在 IIB 中实现消息流，动态地从 WSRR 中检索服务元数据，并在运行时使用这些数据来修改消息流行为，这些节点可支持许多业务场景。第 2 部分将详细介绍 Enpoint Lookup 和 Registry Lookup 节点。","keyword":"","recommend":false,"source":"http://www.ibm.com/developerworks/cn/websphere/library/techarticles/1404_smithson2/1404_smithson2.html","title":"集成 IBM Integration Bus 与 WebSphere Service Registry and Repository: 第 2 部分：IBM Integration Bus 中的 WebSphere Service Registry and Repository 节点","typeId":0,"updateTime":"2014-06-12 00:00:00"}
{"author":"","clickNumber":0,"content":"\r\n<div class=\"ibm-columns\">\r\n<div class=\"ibm-col-1-1\">\r\n\r\n<h2 id=\"N10093\">简介<\/h2><p>人们通常认为，在 SOA 环境中绝不应允许直接访问服务提供者。相反，您应该将一个新的虚拟服务部署到企业服务总线 (ESB)，充当着实际的后端服务的代理。引入对后端服务的受控访问点有许多好处。从基本上讲，它会在服务使用者和服务提供者之间实现松散耦合，允许您重新定位后端服务或修改它的接口，而不会影响服务使用者。此模式常常称为简单服务代理。它还使您能够引入服务管理功能，例如错误处理和提醒、日志记录、安全性配置、流量管理、服务计费和性能度量。这些是对简单服务代理模式的扩展。<\/p><p>本文将介绍三个消息流示例。第一个示例是简单服务代理模式的一种实现，它在运行时动态地从 WSRR 检索真实后端服务的端点。第二个示例扩展了此模式，允许在不同提供者端点之间选择。最后一种模式是另一个扩展，它允许在调用最初选择的端点出错时，将服务请求路由到备用的端点。<\/p><h2 id=\"svc_location_scenario\">服务位置业务场景<\/h2><p>描述的第一个示例流重点关注 <a href=\"http://www.ibm.com/developerworks/websphere/library/techarticles/1404_smithson1/1404_smithson1.html#servicelocation\" onmouseover=\"linkQueryAppend(this)\">第 1 部分：场景和配置<\/a> 中描述的服务位置场景，如下所示：<\/p><ul class=\"ibm-bullet-list\"><li><p><strong>业务问题<\/strong><\/p><p>用作其他服务的代理或在运行时调用其他服务的消息流，需要知道这些服务的位置或端点。这些服务的位置可硬编码到每个消息流中，但这使得它们容易受到环境中出现的变化的影响。举例而言，如果调用的任何服务的位置发生改变，那么受影响的消息流需要更新新位置并重新进行部署。每个消息流调用的服务在开发期间在各种环境间移动时，可能还需要修改这些服务的位置。<\/p><\/li><li><p><strong>解决方案<\/strong><\/p><p>调用的服务的位置可在 WSRR 中注册，由消息流在运行时动态检索。如果一个服务的位置因为某种原因而发生改变，那么可以简单地更新 WSRR 中注册的端点，这样任何受影响的消息流都可以将请求路由到位于新位置的服务。<\/p><\/li><li><p><strong>益处<\/strong><\/p><p>此方法减少了对服务位置所做更改的影响，无论是对消息流的影响，还是对系统管理的影响。<\/p><p>它还支持将一个服务提供者替换为另一个，无需服务使用者了解这一更改，或者无需调整架构来支持这一替换。<\/p><\/li><\/ul><h2 id=\"svc_location_msg_flow_desc\">服务位置消息流<\/h2><div class=\"dw-sidebar ibm-inset\"><h2 id=\"N100C4\">找到消息流<\/h2><p>本文中描述的消息流是在 <code>EndpointLookup_Basic.msgflow<\/code> 文件中定义的。该文件包含在 <a href=\"#download\">下载<\/a> 部分提供的 <strong>WSRRIntegrationDemos.zip<\/strong> 压缩文件中。<\/p><\/div><p>服务位置消息流（如 中所示）使用 Endpoint Lookup 节点在运行时从 WSRR 检索目标服务的端点。它是本系列中介绍的最简单的消息流，因为它不需要任何额外的编程即可执行其任务。<\/p><h5 id=\"fig1\">基本端点查找消息流<\/h5><img alt=\"基本端点查找消息流\" src=\"/sunshine_new/images/821560577/images/basicFlow.jpg\" width=\"485\" /><h3 id=\"N100E2\">Service Request 节点<\/h3><p>该消息流始于 <code>Service Request<\/code> SOAP Input 节点。此节点的配置公开了 <strong>Math Service<\/strong> 的接口。该接口在节点的 <strong>Properties<\/strong> 编辑器的 <strong>Basic<\/strong> 选项卡上指定，如 中所示。可以看到，<code>MathServerServiceDummyEndpoint.wsdl<\/code> 已在 <strong>WSDL file name<\/strong> 字段中指定。从名称可以看出，这个 WSDL 文档为该服务定义了一个虚假端点，确保服务请求成功路由到目标服务的惟一途径是从 WSRR 检索该端点。<\/p><p>节点的其他基本属性会在选择 WSDL 文件中自动填入。通过配置来公开某个特定的 WSDL 接口时，<code>SOAP Input<\/code> 节点会验证它收到的所有服务请求，确保它们符合 WSDL 中包含的服务的定义。您还可以配置此节点，以便使用带 URL 后缀 <strong>/MathServer/Services/MathServer/eplookup1<\/strong> 的 <strong>HTTP<\/strong> 传输。使用者在调用此消息流公开的服务时需要使用这个值。Service Request 节点使用 <strong>out<\/strong> 终端连接到服务位置消息流中的下一个节点。<\/p><h5 id=\"fig2\">公开的 WSDL 接口<\/h5><img alt=\"公开的 WSDL 接口\" src=\"/sunshine_new/images/821560577/images/SOAPInput_WSDLProps.jpg\" width=\"580\" /><h3 id=\"N10115\">Endpoint Lookup 节点<\/h3><div class=\"dw-sidebar ibm-inset\"><h2 id=\"N1011A\">Endpoint Lookup 节点<\/h2><p>IIB 中的 Endpoint Lookup 节点已在 <a href=\"http://www.ibm.com/developerworks/websphere/library/techarticles/1404_smithson2/1404_smithson2.html#endpointlookup\" onmouseover=\"linkQueryAppend(this)\">第 2 部分：IIB 中的 WSRR 节点<\/a> 中详细介绍。<\/p><\/div><p><code>Endpoint Lookup<\/code> 节点查询 WSRR，以检索 1.0 版 <strong>Math Service<\/strong> 的端点。用于查询 WSRR 的属性指定如下：<\/p><h5 id=\"table4\">Endpoint Lookup 节点属性<\/h5><table border=\"0\" cellpadding=\"0\" cellspacing=\"0\" class=\"ibm-data-table\"><thead xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"><tr><th>属性名称<\/th><th>值<\/th><\/tr><\/thead><tbody xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"><tr><td>PortType Name<\/td><td><code>MathServerPortType<\/code><\/td><\/tr><tr><td>PortType Namespace<\/td><td><code>http://math.pot.ibm.com<\/code><\/td><\/tr><tr><td>PortType Version<\/td><td><code>1.0<\/code><\/td><\/tr><tr><td>Classification<\/td><td><code>http://www.ibm.com/xmlns/prod/serviceregistry/lifecycle/v6r3/LifecycleDefinition#Online<\/code><\/td><\/tr><tr><td>Match Policy<\/td><td><code>One<\/code><\/td><\/tr><\/tbody><\/table><p>匹配策略 One 已在节点上指定，这使得该节点能够够直接连接到一个 <code>SOAP Request<\/code> 节点，在本例中为 <code>Forward Request<\/code> 节点。<\/p><h5 id=\"N10161\">Endpoint Lookup 节点<\/h5><img alt=\"Endpoint Lookup 节点\" src=\"/sunshine_new/images/821560577/images/EndpointLookup.jpg\" width=\"109\" /><p>如果 <code>Endpoint Lookup<\/code> 节点执行的查询未返回任何结果，那么该节点会将该消息传递给 <strong>NoMatch<\/strong> 终端。此终端连接到 <code>No Match Fault<\/code> 节点。<\/p><h3 id=\"N10174\">Forward Request 和 SOAP Reply 节点<\/h3><p><code>Forward Request<\/code> 节点负责调用目标服务。在定义消息流时，必须为 <strong>Web Service URL<\/strong> 属性指定一个值，即使该值将在运行时被 <code>Endpoint Lookup 节点<\/code> 以编程方式覆盖。因此，为此属性指定了一个虚拟值 <code>http://tempuri.org/MathServer/services/MathServer<\/code>。节点的 <strong>Operation mode<\/strong> 必须设置为 <strong>Invoke a generic web service<\/strong>，它是在节点的 <strong>Properties<\/strong> 编辑器的 <strong>Basic<\/strong> 选项卡上指定的。<code> Forward Request<\/code> 节点使用 <strong>out<\/strong> 和 <strong>failure<\/strong> 终端直接连接到 <code>SOAP Reply<\/code> 节点。<\/p><h5 id=\"N1019F\">Forward Request 和 SOAP Reply 节点<\/h5><img alt=\"Forward Request 和 SOAP Reply 节点\" src=\"/sunshine_new/images/821560577/images/ForwardRequest_SOAPReply.jpg\" width=\"222\" /><p>从名称可以看出，<code>SOAP Reply<\/code> 节点将一个 SOAP 请求传递回服务使用者。成功经过该消息流后，返回的响应将是来自实际目标服务的响应。如果 <code>Endpoint Lookup<\/code> 节点无法在 WSRR 中找到一个在线端点，返回的响应将是 <code>No Match Fault<\/code> 节点生成的一个 SOAP 故障。<\/p><h3 id=\"noMatchFault\">No Match Fault 节点<\/h3><p>如果 <code>Endpoint Lookup<\/code> 节点执行的查询没有返回任何结果，那么不会自动生成 SOAP 故障。为此，此节点的 <strong>NoMatch<\/strong> 终端被连接到 <code>No Match Fault<\/code> Java Compute 节点。此节点以编程方式生成一个 SOAP 故障，该故障使用 <code>SOAP Reply<\/code> 节点返回到服务使用者。<\/p><h2 id=\"testFlow1\">测试服务位置消息流<\/h2><div class=\"dw-sidebar ibm-inset\"><h2 id=\"N101CB\">基本配置<\/h2><p> 在尝试测试消息流之前，确保您执行了 <a href=\"http://www.ibm.com/developerworks/websphere/library/techarticles/1404_smithson1/1404_smithson1.html\" onmouseover=\"linkQueryAppend(this)\">第 1 部分：场景和配置<\/a> 中介绍的所有配置步骤。<\/p><\/div><p>下面的步骤介绍了如何使用 <strong>Calculator<\/strong> 应用程序验证服务位置消息流在正常工作。<\/p><ol><li>确保您的 IIB 执行组正在运行，已部署并启动 <strong> EndpointLookup_Basic<\/strong> 流。<\/li><li>启动 Calculator 应用程序，如第 1 部分中的 <a href=\"http://www.ibm.com/developerworks/websphere/library/techarticles/1404_smithson1/1404_smithson1.html#calculator_app\" onmouseover=\"linkQueryAppend(this)\">运行 Calculator 应用程序<\/a> 中所述。<\/li><li>为运行 IIB 的服务器指定合适的<strong>主机名<\/strong>和<strong>端口号<\/strong>。例如，如果在与 <strong>Calculator<\/strong> 应用程序相同的机器上运行 IIB，而且使用了默认端口，那么这些值将为 <em>localhost<\/em> 和 <em>7800<\/em>。<\/li><li>修改服务路径，将它的值设置为 <strong>/MathServer/services/MathServer/eplookup1<\/strong>。这是 <strong>EndpointLookup_Basic<\/strong> 流的端点。<\/li><li>指定一些值并在下拉列表中指定一个合适的运算符（+、-、/、*），然后按下 <strong>=<\/strong> 按钮。<\/li><li><strong>Calculator<\/strong> 应用程序将一个服务请求发送给服务位置消息流，后者将它路由到 <strong>Math Service<\/strong>。响应然后返回到 <strong>Calculator<\/strong> 应用程序，后者会显示它。<strong>Calculator<\/strong> 应用程序看起来应类似于：                 \n\n<h5 id=\"N10213\">Calculator 应用程序，设置来使用服务位置消息流<\/h5><img alt=\"Calculator 应用程序，设置来使用服务位置消息流\" src=\"/sunshine_new/images/821560577/images/calcApp1.jpg\" width=\"466\" /><\/li><\/ol><p>如果从应用程序收到一个错误，请检查以下方面：<\/p><ol><li>您已经执行了本系列 <a href=\"http://www.ibm.com/developerworks/websphere/library/techarticles/1404_smithson1/1404_smithson1.html\" onmouseover=\"linkQueryAppend(this)\">第 1 部分：场景和配置<\/a> 中介绍的所有配置步骤。<\/li><li>已指定了正确的主机名。<\/li><li>已指定了正确的端口号。<\/li><li>已为消息流指定了正确的路径。<\/li><\/ol><h2 id=\"svc_selection_scenario\">服务选择业务场景<\/h2><p>服务选择场景是服务位置场景的扩展。在 <a href=\"http://www.ibm.com/developerworks/websphere/library/techarticles/1404_smithson1/1404_smithson1.html#serviceselection\" onmouseover=\"linkQueryAppend(this)\">第 1 部分：场景和配置<\/a> 中，对服务选择场景的描述如下：<\/p><ul class=\"ibm-bullet-list\"><li><p><strong>业务问题<\/strong><\/p><p><strong>股票报价<\/strong>服务有一个已定义的接口，但部署了 3 个实现。一个实现返回最新的股票报价，应该仅<strong>黄金级<\/strong>客户使用。另一个实现返回 5 分钟前的报价，应该仅由<strong>白银级<\/strong>客户使用。最后一个实现返回 20 分钟前的报价，应该仅由<strong>青铜级<\/strong>客户使用。股票报价服务的使用者希望能够使用单一端点调用它。<\/p><\/li><li><p><strong>解决方案<\/strong><\/p><p>所有 3 个服务的端点都可注册在 WSRR 中，可将额外的元数据与每个端点关联。例如，在上述场景中，您可在 WSRR 中定义个自定义本体 (ontology)，用于将每个端点分类为<strong>黄金级<\/strong>、<strong>白银级<\/strong>或<strong>青铜级<\/strong>。当消息流在运行时检索这些端点时，元数据也会返回给 IIB。消息流随后可以使用此元数据决定将请求路由到哪个端点，或许结合使用原始请求上提供的一些信息或 ESB 中提供的上下文信息。<\/p><\/li><li><p><strong>益处<\/strong><\/p><p>这种方法使您能够在运行时，基于与服务提供者相关的元数据在多个服务提供者之间进行选择。路由决策可能会受原始请求中提供的信息的影响，这有时被称为基于内容的路由。决策也可能完全基于目标端点的元数据。例如，您环境中的一个监视组件可将性能指标推送到 WSRR 中，而消息流可决定将请求路由到具有最低平均响应时间的端点。<\/p><\/li><\/ul><h2 id=\"svc_selection_msg_flow_desc\">服务选择消息流<\/h2><div class=\"dw-sidebar ibm-inset\"><h2 id=\"N10264\">找到消息流<\/h2><p>本文中描述的消息流是在 <code>EndpointLookup_EndpointSelection.msgflow<\/code> 文件中定义的。该文件包含在 <a href=\"#download\">下载<\/a> 部分中提供的 <strong>WSRRIntegrationDemos.zip<\/strong> 压缩文件中。<\/p><\/div><p>服务选择消息流（如  中所示）使用 Endpoint Lookup 节点在运行时从 WSRR 检索目标服务的<strong>所有<\/strong>在线端点。然后，它会选择一个端点，并将服务请求转发给它。<\/p><p>从  中可以看到，服务选择消息流非常类似于服务位置消息流。所以，以下各节仅介绍与服务位置消息流不同的实现部分。<\/p><h5 id=\"fig3\">服务选择消息流<\/h5><img alt=\"服务选择消息流\" src=\"/sunshine_new/images/821560577/images/serviceSelectorFlow.jpg\" width=\"580\" /><h3 id=\"N1028B\">Service Request 节点<\/h3><p>服务选择消息流的 <code>Service Request<\/code> SOAP Input 节点被配置为使用带 URL 后缀 <strong>/MathServer/Services/MathServer/eplookup2<\/strong>的 <strong>HTTP<\/strong> 传输。在调用此消息流公开的服务时，使用者需要使用这个值。<\/p><h3 id=\"N1029B\">Endpoint Lookup 节点的区别<\/h3><div class=\"dw-sidebar ibm-inset\"><h2 id=\"N102A1\">Endpoint Lookup 节点<\/h2><p>IIB 中的 Endpoint Lookup 节点已在 <a href=\"http://www.ibm.com/developerworks/websphere/library/techarticles/1404_smithson2/1404_smithson2.html#endpointlookup\" onmouseover=\"linkQueryAppend(this)\">第 2 部分：IIB 中的 WSRR 节点<\/a> 中详细介绍。<\/p><\/div><p>此消息流中的 <code>Endpoint Lookup<\/code> 节点的配置与服务位置消息流几乎完全相同。惟一的区别是，节点上的 <strong>Match Policy<\/strong> 被配置为 <strong>All<\/strong>。这是一个重要的区别，因为它意味着该节点不会在本地环境树中自动设置 <code>Destination.HTTP.RequestURL<\/code> 和 <code>Destination.SOAP.Request.Transport.WebServiceURL<\/code> 元素的值。如果请求要转发到 <code>SOAP Request<\/code> 或 <code>HTTP Request<\/code>，则必须由消息流后面的一个计算节点以编程方式完成此设置。在服务选择消息流中正是这样做的，<code>Endpoint Lookup<\/code> 节点的 <strong>out <\/strong> 终端被连接到 <code>Endpoint Selector<\/code> Java Compute 节点。<\/p><h3 id=\"N102CB\">Endpoint Selector 节点<\/h3><p><code>Endpoint Selector<\/code> 节点是 <code>Java Compute<\/code> 节点的一个实例。从名称可以看出，这个节点处理 <code>Endpoint Lookup<\/code> 节点所执行的查询的结果，选择服务请求转发到的端点。服务选择消息流已执行了一定的选择，仅检索在 WSRR 中分类为 <strong>Online<\/strong> 的 <strong>Math Service<\/strong> 端点。这配置为 <code>Endpoint Lookup<\/code> 节点自身上的一个 <strong>Classification <\/strong> 属性。<\/p><h5 id=\"N102E7\">Endpoint Selector 节点<\/h5><img alt=\"Endpoint Selector 节点\" src=\"/sunshine_new/images/821560577/images/EndpointSelector.jpg\" width=\"115\" /><p>上面在 <a href=\"#svc_selection_scenario\">服务选择业务场景<\/a> 中已讨论，您可以基于与对象关联的元数据来选择端点。通常，您将检查端点上的分类，以便选择合适的分类。此任务留给读者自行练习，服务选择消息流仅在运行时选择一个返回的端点。<\/p><p>此过程中的第一步是获取 <code>Endpoint Lookup<\/code> 节点从 WSRR 中检索的在线端点列表。这些端点放入本地环境树中的 <strong>ServiceRegistry<\/strong> 条目中  中的代码展示了如何从此位置获取端点地址列表：<\/p><h5 id=\"listing1\">检索端点地址列表<\/h5><div class=\"codesection\"><pre class=\"displaycode\">MbElement rootElement = inAssembly.getLocalEnvironment().getRootElement();\nMbElement serviceRegistry = rootElement.getFirstElementByPath(\"/ServiceRegistry\");\nList&lt;MbElement&gt; addresses = \n    (List &lt;MbElement&gt;)serviceRegistry.evaluateXPath(\"ITService/Endpoint/Address\");<\/pre><\/div><p>下一步是从列表中随机选择一个端点地址，假设存在多个端点。 中的代码展示了应该如何做。值得注意的是，至少必须有一个地址可供使用。如果 <code>Endpoint Lookup<\/code> 节点未从 WSRR 获取任何结果，则会绕过\n<code>Endpoint Selector<\/code> 节点，通过 <strong>NoMatch<\/strong> 终端来路由消息。<\/p><h5 id=\"listing2\">随机选择端点地址<\/h5><div class=\"codesection\"><pre class=\"displaycode\">int index = 0;\nif (addresses.size() &gt; 1) {\n    Random random = new Random();\n    index = random.nextInt(addresses.size());\n}\nString addressUrl = (String)addresses.get(index).getValue();<\/pre><\/div><div class=\"dw-sidebar ibm-inset\"><h2 id=\"N1031B\">设置 Destination.HTTP.RequestURL 字段<\/h2><p>只有在消息流中以编程方式覆盖 <code>HTTP Request<\/code> 节点上的 <strong>Web Service URL<\/strong> 属性时，才有必要设置本地环境树中的 <code>Destination.HTTP.RequestURL<\/code> 字段的值。这里给出了完成此任务的代码供您进行参考。没有它，服务选择消息流也能正常运行。<\/p><\/div><p>选择一个端点地址后，<code>Endpoint Selector<\/code> 节点需要将服务请求转发给目标服务。为此，服务选择消息流使用了一个名为 <code>Forward Request<\/code> 的 <code>SOAP Request<\/code> 节点。为了以编程方式覆盖已在 <code>Forward Request<\/code> 节点上配置的 <strong>Web Service URL<\/strong>，<code>Endpoint Selector<\/code> 节点需要将端点地址插入本地环境树中的 <code>Destination.SOAP.Request.Transport.HTTP.WebServiceURL<\/code> 字段中。 给出了执行此任务所需的代码。然后，<code>Endpoint Selector<\/code> 节点将消息传递给 <strong>out<\/strong> 终端，后者连接到 <code>Forward Request<\/code> 节点。<\/p><h5 id=\"listing3\">将地址放在本地环境树中<\/h5><div class=\"codesection\"><pre class=\"displaycode\">MbMessage environment = new MbMessage(inAssembly.getLocalEnvironment());\nMbElement environmentRoot = environment.getRootElement();\n\nenvironmentRoot.evaluateXPath(\"?Destination/?SOAP/?Request/?Transport/?\"\n    + \"HTTP/?WebServiceURL[set-value('\" + addressUrl + \"')]\");\n   \nenvironmentRoot.evaluateXPath(\"?Destination/?HTTP/?RequestURL[set-value('\"\n    + addressUrl + \"')]\");\n                \noutAssembly = new MbMessageAssembly( inAssembly\n                                   , environment\n                                   , inAssembly.getExceptionList()\n                                   , inAssembly.getMessage()\n                                   );<\/pre><\/div><h2 id=\"testFlow2\">测试服务选择消息流<\/h2><div class=\"dw-sidebar ibm-inset\"><h2 id=\"N10358\">基本配置<\/h2><p>在尝试测试消息流之前，确保您执行了 <a href=\"http://www.ibm.com/developerworks/websphere/library/techarticles/1404_smithson1/1404_smithson1.html\" onmouseover=\"linkQueryAppend(this)\">第 1 部分：场景和配置<\/a> 中介绍的所有配置步骤。<\/p><\/div><p>下面的步骤介绍了如何使用 <strong>Calculator<\/strong> 应用程序验证服务选择消息流在正常工作。<\/p><h3 id=\"endpointoffline\">将第二个端点上线<\/h3><p>在本系列文章提供的测试数据中，1.0 版的 <strong>Math Service<\/strong> 实际上在 WSRR 中注册了两个端点，如  中所示。<\/p><h5 id=\"fig4\">Math Service v1.0 端点<\/h5><img alt=\"Math Service v1.0 端点\" src=\"/sunshine_new/images/821560577/images/testData.jpg\" width=\"446\" /><p>您会注意到，其中一个端点实际上是一个虚假端点，具有 URL <strong>http://dummy.endpoint:7800/MathServer2/services/MathServer<\/strong>。这个端点目前分类为 <strong>Offline<\/strong>，所以在测试上面的服务位置消息流时没有返回它。为了证明服务选择消息流在正常工作，您需要将此端点的状态更改为 online。以下步骤介绍了如何完成此任务。<\/p><ol><li>在 Web 浏览器中，登录到您 WSRR 实例的 <strong>Service Registry Dashboard<\/strong>。<\/li><li>更改到 <strong>SOA Governance<\/strong> 视图，然后选择 <strong>Overview<\/strong> 页面。<\/li><li>在 <strong>Collection<\/strong> 小部件中选择 <strong>SLA - CalculatorApplication 1.0 to MathService 1.0<\/strong>，如下所示：\n<h5 id=\"fig5\">SOA Governance 视图<\/h5><img alt=\"SOA Governance 视图\" src=\"/sunshine_new/images/821560577/images/soa_overview.jpg\" width=\"580\" /><\/li><li>您将被转到 <strong>Browse<\/strong> 页面上，在该页面中，会在 <strong>Detail<\/strong> 小部件中显示 <strong>SLA - CalculatorApplication 1.0 to MathService 1.0<\/strong> 服务水平协议的详细信息。这是 <strong>Calculator<\/strong> 应用程序与 WSRR 中的 <strong>Math Service<\/strong> 之间的使用协议的一种表示。在此小部件中，在 <strong>Agreed Endpoints<\/strong> 下，选择 <strong>SLD - MathService v1.0<\/strong>。<\/li><li><strong>Detail<\/strong> 小部件将被更新，以便显示 <strong>SLD - MathService v1.0<\/strong> SLD 的详细信息。在 <strong>Detail <\/strong> 小部件中的 <strong>Available Endpoints<\/strong> 下，选择 <strong>http://dummy.endpoint:7800/MathServer2/services/MathServer (1.0)<\/strong>。<\/li><li><strong>Detail<\/strong> 小部件将被更新，以便显示 <strong>http://dummy.endpoint:7800/MathServer2/services/MathServer ?(1.0)<\/strong> 端点的详细信息。选择 <strong>Action =&gt; Approve For Use<\/strong>，如下所示：\n<h5 id=\"fig6\">Approve For Use<\/h5><img alt=\"Approve For Use\" src=\"/sunshine_new/images/821560577/images/ApproveForUse.jpg\" width=\"520\" /><\/li><li>在完成操作后单击 <strong>OK<\/strong>。该端点现在的治理状态为 <strong>Online<\/strong>。<\/li><\/ol><h3 id=\"N103E6\">测试消息流<\/h3><ol><li>确保您的 IIB 执行组正在运行，并且已经部署并启动了 <strong>EndpointLookup_EndpointSelection<\/strong> 流。<\/li><li>启动 Calculator 应用程序，如第 1 部分中的 <a href=\"http://www.ibm.com/developerworks/websphere/library/techarticles/1404_smithson1/1404_smithson1.htmll#calculator_app\" onmouseover=\"linkQueryAppend(this)\">运行 Calculator 应用程序<\/a> 中所述。<\/li><li>为运行 IIB 的服务器指定合适的<strong>主机名<\/strong>和<strong>端口号<\/strong>。例如，如果在与 <strong>Calculator<\/strong> 应用程序相同的机器上运行 IIB，则会使用默认端口，这些值将为 <em>localhost<\/em> 和 <em>7800<\/em>。<\/li><li>修改服务路径，将它的值设置为 <strong>/MathServer/services/MathServer/eplookup2<\/strong>。这是 <strong>EndpointLookup_EndpointSelection<\/strong> 流的端点。<\/li><li>指定一些值并在下拉列表中指定一个合适的运算符（+、-、/、*），然后按下 <strong>=<\/strong> 按钮几次。<\/li><li>我们将对 <strong>Math Service<\/strong> 执行几次调用并显示结果。一些调用失败了，<strong>Calculator<\/strong> 应用程序显示了消息 <strong>Error:Unable to invoke math service<\/strong>，如下所示。这在预料之中，因为刚在 WSRR 中切换为 online 的端点是一个虚假端点。大约 50% 的时间都会看到该错误。\n<h5 id=\"N10421\">Calculator 应用程序，设置来使用服务选择消息流<\/h5><img alt=\"Calculator 应用程序，设置来使用服务选择消息流\" src=\"/sunshine_new/images/821560577/images/calcApp2.jpg\" width=\"466\" /><\/li><\/ol><p>如果从应用程序收到一个错误，请检查以下方面：<\/p><ol><li>您已经执行了 <a href=\"http://www.ibm.com/developerworks/websphere/library/techarticles/1404_smithson1/1404_smithson1.html\" onmouseover=\"linkQueryAppend(this)\">第 1 部分：场景和配置<\/a> 中介绍的所有配置步骤。<\/li><li>已指定了正确的主机名。<\/li><li>已指定了正确的端口号。<\/li><li>已为消息流指定了正确的路径。<\/li><\/ol><h2 id=\"alt_svc_provider_scenario\">备用服务提供者业务场景<\/h2><p>备用服务提供者是服务选择场景的一种扩展，在 <a href=\"http://www.ibm.com/developerworks/websphere/library/techarticles/1404_smithson1/1404_smithson1.html#alternateprovider\" onmouseover=\"linkQueryAppend(this)\">第 1 部分<\/a> 中，对该场景的描述如下：<\/p><ul class=\"ibm-bullet-list\"><li><p><strong>业务问题<\/strong><\/p><p>多个端点可用于目标服务，但在尝试调用所选的端点时出现了一个错误。服务的使用者只知道代理该服务的消息流的端点。他们希望 ESB 能够透明地处理围绕问题端点的路由请求。<\/p><\/li><li><p><strong>解决方案<\/strong><\/p><p>目标服务的所有端点都可在 WSRR 中注册，由消息流在单次查询中检索。如果尝试在所选端点上调用目标服务时发生了错误，消息流可选择该服务的其他端点之一并进行重试。消息流可继续执行此过程，直到请求成功解决或所有服务端点都已尝试。<\/p><\/li><li><p><strong>益处<\/strong><\/p><p>此方法使您能够在 ESB 中建立一定水平的容错能力，允许 ESB 透明地围绕问题端点而路由服务请求。您可允许消息流尝试一个服务的所有可用端点，或者可限制向服务使用者返回错误之前尝试的端点数量。显然，对于在 ESB 中建立的任何容错能力，都必须设计为能与您环境中使用的其他高可用性机制联合工作。<\/p><\/li><\/ul><h2 id=\"alt_svc_provider_msg_flow_desc\">备用服务提供者消息流<\/h2><div class=\"dw-sidebar ibm-inset\"><h2 id=\"N1045E\">找到消息流<\/h2><p>本文中描述的消息流是在 <code>EndpointLookup_AlternateEndpoint.msgflow<\/code> 文件中定义的。该文件包含在 <a href=\"#download\">下载<\/a> 部分提供的 <strong>WSRRIntegrationDemos.zip<\/strong> 压缩文件中。<\/p><\/div><p>备用服务提供者消息流（如 中所示）使用 Endpoint Lookup 节点在运行时从 WSRR 检索目标服务的<strong>所有<\/strong>在线端点。然后，它会从列表中选择第一个端点，尝试将服务请求转发给该端点。如果尝试使用所选的第一个端点调用目标服务时出现了错误，那么消息流会尝试列表中的下一个端点。如果尝试完所有端点，它会返回一个错误。<\/p><p>从  中可以看到，服务提供者消息流非常类似于服务选择消息流。所以，以下各节仅介绍与服务选择消息流不同的实现部分。<\/p><h5 id=\"fig7\">Alternate Endpoint Selector 消息流<\/h5><img alt=\"Alternate Endpoint Selector 消息流\" src=\"/sunshine_new/images/821560577/images/AlternateEndpointSelectorFlow.jpg\" width=\"580\" /><h3 id=\"N10485\">Service Request 节点<\/h3><p>备用服务提供者消息流的 <code>Service Request<\/code> SOAP Input 节点配置为使用带 URL 后缀 <strong>/MathServer/Services/MathServer/eplookup3<\/strong> 的 <strong>HTTP<\/strong> 传输。在调用此消息流公开的服务时，使用者需要使用这个值。<\/p><h3 id=\"N10495\">Alternate Endpoint Selector 节点<\/h3><p><code>Alternate Endpoint Selector<\/code> 节点是 <code>Java Compute<\/code> 节点的一个实例。它以一种与服务选择消息流中的 <code>Endpoint Selector<\/code> 节点稍微不同的方式，处理 <code>Endpoint Lookup<\/code> 节点执行的查询的结果。<\/p><h5 id=\"N104A8\">Alternate Endpoint Selector 节点<\/h5><img alt=\"Alternate Endpoint Selector 节点\" src=\"/sunshine_new/images/821560577/images/AlternateEndpointSelector.jpg\" width=\"180\" /><p>该节点执行的第一个任务是获取 <code>Endpoint Lookup<\/code> 节点从 WSRR 检索的在线端点列表。然后，它会提取每个端点的实际地址，并将它放入一个列表中，如  中所示。<\/p><h5 id=\"listing4\">检索端点地址列表<\/h5><div class=\"codesection\"><pre class=\"displaycode\">MbElement rootElement = inAssembly.getLocalEnvironment().getRootElement();\nMbElement serviceRegistry = rootElement.getFirstElementByPath(\"/ServiceRegistry\");\n\nList&lt;MbElement&gt; addresses = \n    (List &lt;MbElement&gt;)serviceRegistry.evaluateXPath(\"ITService/Endpoint/Address\");\n    \nList&lt;String&gt; addressUrls = new ArrayList&lt;String&gt;();\nfor (MbElement address : addresses) {\n    addressUrls.add((String)address.getValue());\n}<\/pre><\/div><p>下一步是检查之前是否通过该节点选择了一个端点。如果是这样，以前选择的端点的地址将存储在本地环境树中的 <code>Destination.SOAP.Request.Transport.WebServiceURL<\/code> 元素中。在这种情况下，<code>Alternate Endpoint Selector<\/code> 节点可在地址列表中找到以前选择的端点，然后选择列表中的下一个地址，通过检查来确保它尚未到达列表末尾。 展示了应当如何做。如果所有地址都已尝试，则会生成一个 SOAP 错误，该节点会将错误消息传递给 <strong>failure<\/strong> 终端。这个终端与 <code>SOAP Reply<\/code> 节点直接相连，后者将 SOAP 错误传回给客户端。<\/p><h5 id=\"listing5\">选择端点地址<\/h5><div class=\"codesection\"><pre class=\"displaycode\">String webServiceUrl = null;\n\nMbElement webServiceUrlElement = rootElement.getFirstElementByPath(\n    \"/Destination/SOAP/Request/Transport/HTTP/WebServiceURL\");\n\nif (webServiceUrlElement != null) {\n    webServiceUrl = (String)webServiceUrlElement.getValue();\n}\n\nint index = 0;\nif (webServiceUrl != null &amp;&amp; addressUrls.contains(webServiceUrl)) {\n    index = addressUrls.indexOf(webServiceUrl) + 1;\n}\n\nif (index &lt; addressUrls.size()) {\n    String addressUrl = addressUrls.get(index);\n    \n    ...\n    \n} else {\n    outAssembly =\n        MessageUtils.createSOAPFault(inAssembly\n                                    , \"ERROR_EP_002\"\n                                    , \"It is not possible to process the request.\"\n                                    , \"All of the available endpoints for the service \"\n                                    + \"have been tried (\" + addressUrls.size() + \") and \"\n                                    + \"none of them succeeded.\"\n                                    );\n    outputTerminal = getOutputTerminal(\"failure\");\n}<\/pre><\/div><p>选择一个端点地址后，<code>Alternate Endpoint Selector<\/code> 节点会将服务请求转发给目标服务。完成此任务所需的代码与 <code>Endpoint Selector<\/code> 节点使用的代码相同，如上面的  中所示。然后，<code>Alternate Endpoint Selector<\/code> 节点会将消息传递给 <strong>out<\/strong> 终端，后者连接到 <code>Forward Request<\/code> 节点。<\/p><h3 id=\"N104EA\">Forward Request 节点<\/h3><p>与备用服务提供者消息流中的 <code>Forward Request<\/code> 节点的惟一区别是，它的 <strong>failure<\/strong> 终端被连接到 <code>Alternate Endpoint Selector<\/code> 节点 <strong>In<\/strong> 终端。这会导致以下情况：在消息流尝试将请求转发给虚假端点时，该消息流会返回来流经 <code>Alternate Endpoint Selector<\/code> 节点，选择列表中的下一个节点。当然，在真实场景中，如果调用最初的端点时返回了一个 SOAP 错误，那么您可能希望选择一个备用端点。在这种情况下，您可能希望将 <code>Forward Request<\/code> 节点的 <strong>Fault<\/strong> 终端连接回 <code>Alternate Endpoint Selector<\/code> 节点的 <strong>In<\/strong> 终端。<\/p><h2 id=\"testFlow3\">测试备用服务提供者消息流<\/h2><div class=\"dw-sidebar ibm-inset\"><h2 id=\"N10512\">基本配置<\/h2><p>在尝试测试消息流之前，确保您执行了 <a href=\"http://www.ibm.com/developerworks/websphere/library/techarticles/1404_smithson1/1404_smithson1.html\" onmouseover=\"linkQueryAppend(this)\">第 1 部分：场景和配置<\/a> 中介绍的所有配置步骤。<\/p><\/div><p>下面的步骤介绍了如何使用 <strong>Calculator<\/strong> 应用程序验证备用服务提供者消息流在正常工作。<\/p><ol><li>确保您的 IIB 执行组正在运行，已部署并启动了 <strong>EndpointLookup_AlternateEndpoint<\/strong> 流。<\/li><li>启动 Calculator 应用程序，如第 1 部分中的 <a href=\"http://www.ibm.com/developerworks/websphere/library/techarticles/1404_smithson1/1404_smithson1.html#calculator_app\" onmouseover=\"linkQueryAppend(this)\">运行 Calculator 应用程序<\/a> 中所述。<\/li><li>为运行 IIB 的服务器指定合适的<strong>主机名<\/strong>和<strong>端口号<\/strong>。例如，如果在与 <strong>Calculator<\/strong> 应用程序相同的机器上运行 IIB，而且使用了默认端口，那么这些值将为 <em>localhost<\/em> 和 <em>7800<\/em>。<\/li><li>修改服务路径，将它的值设置为 <strong>/MathServer/services/MathServer/eplookup3<\/strong>。这是 <strong>EndpointLookup_AlternateEndpoint<\/strong> 流的端点。<\/li><li>指定一些值并在下拉列表中指定一个合适的运算符（+、-、/、*），然后按下 <strong>=<\/strong> 按钮。<\/li><li><strong>Calculator<\/strong> 应用程序将一个服务请求发送给备用服务提供者消息流，后者将它路由到 <strong>Math Service<\/strong>。如果首先选择了虚假端点，那么消息流会收到一个错误，然后透明地将请求转发给服务的真实端点。响应随后会返回到 <strong>Calculator<\/strong> 应用程序，后者会显示它。<\/li><\/ol><p>如果从应用程序收到一个错误，请检查以下方面：<\/p><ol><li>您已经执行 <a href=\"http://www.ibm.com/developerworks/websphere/library/techarticles/1404_smithson1/1404_smithson1.html\" onmouseover=\"linkQueryAppend(this)\">第 1 部分<\/a> 中介绍的所有配置步骤。<\/li><li>已指定了正确的主机名。<\/li><li>已指定了正确的端口号。<\/li><li>已为消息流指定了正确的路径。<\/li><\/ol><h3 id=\"N10566\">将第二个端点离线<\/h3><p>如果打算练习本系列其他文章中介绍的消息流，一定要在此时将虚假端点的状态更改回 <strong>Offline<\/strong>。为此，执行  中所述的步骤，但在第 7 步，请选择 <strong>Action =&gt; Revoke From Use<\/strong>。<\/p><h2 id=\"N10576\">结束语<\/h2><p>本文介绍了一些消息流，它们都是服务虚拟化模式的实现。这些模式可用于帮助您在您 SOA 中的服务使用者与服务提供者之间实现松散耦合，使您能够将请求路由到一个或多个提供者端点，在服务使用者不知情的情况下透明地处理错误。<\/p><h2 id=\"N1057D\">致谢<\/h2><p>感谢以下人员帮助开发本系列中的示例消息流：<\/p><ul class=\"ibm-bullet-list\"><li>John Hosie<\/li><li>Ben Thompson<\/li><li>Matt Golby-Kirk<\/li><li>Trevor Dolby<\/li><li>Andreas Martens<\/li><li>Graham Haxby<\/li><li>Andrew Coleman<\/li><li>John Reeve<\/li><\/ul><p>还要感谢以下人员帮助审阅本文：<\/p><ul class=\"ibm-bullet-list\"><li>David Seager<\/li><li>Arnauld Desprets<\/li><li>Anna Maciejkowicz<\/li><\/ul><CMA ID: 974180><Site ID: 10><XSLT stylesheet used to transform this file: dw-document-html-7.0.xsl>\r\n<h2 id=\"download\">下载<\/h2><table class=\"ibm-data-table dw-download-table\" cellpadding=\"0\" cellspacing=\"0\" border=\"0\"><thead><tr><th scope=\"col\">描述<\/th><th scope=\"col\">名字<\/th><th scope=\"col\">大小<\/th><\/tr><\/thead><tbody><tr><th scope=\"row\" class=\"ibm-table-row\">代码示例<\/th><td nowrap=\"nowrap\"><a href=\"http://www.ibm.com/developerworks/apps/download/index.jsp?contentid=974180&amp;filename=WSRRIntegrationDemos.zip&amp;method=http&amp;locale=zh_CN\">WSRRIntegrationDemos.zip<\/a><\/td><td nowrap=\"nowrap\">304 KB<\/td><\/tr><\/tbody><\/table>\r\n\r\n<\/div>\r\n<\/div>\r\n","createTime":"2014-06-12 00:00:00","deployTime":"2014-06-12 00:00:00","id":0,"intro":"IBM Integration Bus (IIB) 通过 Endpoint Lookup 和 Registry Lookup 节点提供了与 WebSphere Service Registry and Repository (WSRR) 的开箱即用的集成。使用这些节点，您可以在 IIB 中实现消息流，动态地从 WSRR 中检索服务元数据，并在运行时使用这些数据来修改消息流行为。但是，这两个产品之间的集成可扩展到 Endpoint Lookup 和 Registry Lookup 节点以外。第 3 部分将介绍如何使用 Endpoint Lookup 节点动态地从 WSRR 检索服务元数据，以及如何在运行时使用此元数据来路由服务请求，包括在发生错误时绕过问题端点的能力。","keyword":"","recommend":false,"source":"http://www.ibm.com/developerworks/cn/websphere/library/techarticles/1404_smithson3/1404_smithson3.html","title":"集成 IBM Integration Bus 与 WebSphere Service Registry and Repository: 第 3 部分：端点查找场景","typeId":0,"updateTime":"2014-06-12 00:00:00"}
{"author":"","clickNumber":0,"content":"\r\n<div class=\"ibm-columns\">\r\n<div class=\"ibm-col-1-1\">\r\n\r\n<p><em>Codename: BlueMix 是一款 <strong>beta\n                    级<\/strong>产品，随着我们不断让其功能更加完善和更易于使用，它也将不断改进。我们会竭尽全力保持本文最新，但并不总是完全跟得上现状。感谢大家的理解！<\/em><\/p><p>IBM Bluemix? 提供了将您的伟大思想变成一个应用程序或服务所需的所有平台功能。BlueMix 还为您提供了对各种各样 API\n                的访问，通过将这些 API 与第三方提供的功能混合使用，您可以使用它们来增强您的应用程序。<\/p><p><a href=\"http://www.pb.com\">Pitney Bowes<\/a> 提供了功能强大的 API\n                来实现地理编码、地址查询等功能。本文使用了一个简单而又有趣的示例应用程序，该应用程序在 Instagram\n                中将任意美国街道地址的经纬度与媒体搜索相结合，通过这个示例，我们将向您展示如何在您的 BlueMix 应用程序中使用 Pitney Bowes\n                API。<\/p><h2 id=\"N10077\">入门的前提条件<\/h2><ul class=\"ibm-bullet-list\"><li>一个 <a href=\"https://ace.ng.bluemix.net/?utm_source=developerWorks&amp;amp;utm_medium=landing-page&amp;amp;utm_content=cloud-bluemix&amp;amp;utm_campaign=dwchina\">BlueMix<\/a> 帐户 <\/li><li>一个 <a href=\"https://pitneybowes.developer.pbondemand.com/portal/#tab=home\">Pitney Bowes 开发人员帐户<\/a>（参见 <a href=\"#step1\">步骤\n                    1<\/a>，以便获得有关的详细信息）<\/li><li>一个 <a href=\"http://instagram.com/developer\">Instagram 开发人员帐户<\/a><\/li><li>适用于您的系统的 CloudFoundry <a href=\"https://github.com/cloudfoundry/cli/blob/master/INSTALL.md\">V6 命令行界面<\/a><\/li><\/ul><ul class=\"ibm-bullet-list\"><li><a href=\"http://picturefinder.ng.bluemix.net/#/polls?cm_mmc=developerWorks-_-dW%20CloudOE%20content-_-cl-bluemix-pitneybowes-app-_-article\">运行应用程序<\/a><\/li><li><a href=\"https://hub.jazz.net/project/jstart/Picture%20Finder%20%28Node%29/overview?utm_source=developerWorks&amp;utm_medium=article&amp;utm_content=cl-bluemix-pitneybowes-app&amp;utm_campaign=dW%20CloudOE%20content\">获取代码<\/a><\/li><\/ul><h3 id=\"N100A1\">Pitney Bowes\n                定位服务快速指南<\/h3><p>使用 BlueMix 平台的开发人员可以使用的四项 Pitney Bowes 定位服务：<\/p><ul class=\"ibm-bullet-list\"><li><strong>地理编码<\/strong>：将地址转换成地址经纬度位置。<\/li><li><strong>反向地理编码<\/strong>：将一个经纬度位置（比如一个 GPS 信号）转换成一个可读地址。<\/li><li><strong>验证地址<\/strong>：正确的、标准化的、有效的地址，确保地址数据符合邮政管理局设立的质量标准，以便提高邮件和包裹的送达率。<\/li><li><strong>旅行边界服务<\/strong>：根据平均驾驶距离或平均驾驶时间来确定某个地址的边界，从而增加根据地理信息制定决策的信心。<\/li><\/ul><ul class=\"ibm-bullet-list\"><li><a href=\"https://pitneybowes.developer.pbondemand.com/portal/#tab=documentation&amp;apiId=358\">Pitney Bowes 定位服务 API 文档<\/a><\/li><\/ul><h2 id=\"step1\">步骤 1. 注册\n                Pitney Bowes 服务<\/h2><ol><li>通过 <a href=\"https://pitneybowes.developer.pbondemand.com/portal/#tab=signUp\">注册<\/a> 在 Pitney Bowes 开发人员门户上获得一个开发人员帐户。当您完成电子邮件确认步骤时，您将获得一个具有\n                    API 特权的账号。<\/li><li>登录并注册一个应用程序。返回的应用程序 ID 需要能够对 Pitney Bowes 进行 API 调用。（还提供了密钥，Pitney\n                    Bowes API 目前不需要它。） <\/li><li>默认情况下，您无权进行 API 调用。在 <strong>Entitlements<\/strong> 页面上，单击\n                        <strong>Select Entitlement<\/strong> 并选择 free 级别（每天 2,000 个调用），这是自动认可的级别：\n<h5 id=\"N100D4\">图 1. <\/h5><img alt=\"Pitney Bowes 定位 API 的两个权利选项的屏幕截图\" src=\"/sunshine_new/images/644827122/register.jpg\" width=\"650\" /><\/li><\/ol><p>现在，您已经为在 BlueMix 中使用应用程序 ID 和 Pitney Bowes services 服务做好了准备。<\/p><h2 id=\"step2\">步骤 2. 在\n                BlueMix 中创建一个 Pitney Bowes 服务实例<\/h2><ol><li>登录到 <a href=\"http://www.bluemix.net\">BlueMix<\/a>。 <\/li><li>在目录中，选择 Pitney Bowes 地理编码服务：\n<h5 id=\"N100EB\">图 2. <\/h5><img alt=\"BlueMix 中的 Pitney Bowes 地理编码条目的屏幕截图\" src=\"/sunshine_new/images/644827122/geo.jpg\" width=\"167\" /><\/li><li>选择 <strong>Do not associate<\/strong>。（您将在步骤 3\n                    中向应用程序添加服务实例。）为服务实例选择一个名称并输入您的 Pitney Bowes 应用程序 ID。<\/li><\/ol><h2 id=\"N100F7\">步骤 3. 克隆 Node.js\n                寻像器应用程序代码<\/h2><p>从 IBM jStart DevOps 存储库克隆 Node 寻像器应用程序：<\/p><div class=\"codesection\"><pre class=\"displaycode\">git clone https://hub.jazz.net/git/jstart/Picture.Finder.(Node)<\/pre><\/div><p>所有应用程序逻辑都在 app.js 中，包括一些使得 Web 应用程序开发变得更容易的 Node 模块：<\/p><ul class=\"ibm-bullet-list\"><li>Express Web 开发框架<\/li><li>针对 Express 的 Hogan 模板引擎<\/li><li>用来调用 Pitney Bowes 的 REST 客户端 <\/li><li>一个 Instagram API 包装器库<\/li><li>执行日期格式化的时间<\/li><li>针对 JSON 操作的 pinch<\/li><\/ul><p>“post to /location” 命令将会对 Pitney Bowes 地理编码服务执行一个 GET 调用。然后，返回的经纬度被传递给\n                Instagram（记得将代码中的 instagramID 和 instagramSecret 替换为那您自己的 Instagram\n                开发人员帐号和密钥），以便检索描述指定地址一公里范围以内的所有图片的 JSON。<\/p><p>请注意，在对地理编码服务的调用中，使用了从地理编码服务凭据中获得的 Pitney Bowes URL 和应用程序 ID。<\/p><div class=\"codesection\"><pre class=\"displaycode\">   var Client = rest.Client;\n   client = new Client();\n   \n   if (!address &amp;&amp; !city &amp;&amp; !state)\n      res.render('index.html');\n\n   // direct way\n   client.get(url + \"?address=\" + address + \"&amp;city=\" + city + \n\"&amp;stateProvince=\" + state + \"&amp;country=USA&amp;fallbackToPostal=Y&amp;\nfallbackToStreet=Y&amp;fallbackToGeographic=Y&amp;\ncloseMatchesOnly=Y&amp;appId   =\" + appId, function(data, response){\n               // data in callback contains the json returned from pitney bowes\n                  \n            if (data.httpCode != \"500\")\n            {\n               lat = data.Output.Geometry.Pos.Y;\n               lng = data.Output.Geometry.Pos.X;\n            \n               instagram.media.search({\n              lat: lat,\n              lng: lng,\n              complete: function(data){\n               // pinch converts all unix timestamps to a friendly date\n               pinch(data, /created_time/, function(path, key, value) {\n                 return moment(value*1000).format(\"MMMM Do YYYY, h:mm a\");\n               });            \n\n                res.render('index.html', {data: data, address: address, city: city, state: state});\n\n              }, // end complete\n            });// end search\n            }// end httpCode check\n            else\n            {\n              msg = \"Can't find any pictures near this address\";\n              res.render('index.html', {msg: msg, address: address, city: city, state: state});\n         } \n\n\n           }); // end PB call<\/pre><\/div><p>Hogan 模板语言和超净（ultra-clean）Mustache 模板语言将结果显示在 index.html 视图中。它们显示了从\n                Instagram 返回的 JSON 直接返回的结果（对创建时间进行了更改，利用服务器端的 pinch 库，将该时间从 UNIX\n                时间戳改为一个友好的日期格式）：<\/p><div class=\"codesection\"><pre class=\"displaycode\">&lt;div&gt;\n   &lt;ul&gt;\n   {{#data}}\n      &lt;li style=\"display: inline-block; padding: 25px\"&gt;&lt;a href=\"{{link}}\"&gt;\n&lt;img src=\"{{#images}}{{#thumbnail}} {{url}} {{/thumbnail}}{{/images}}\"&gt;&lt;/a&gt; &lt;br/&gt;\n         By: &lt;em&gt; {{#user}} {{username}} {{/user}}&lt;/em&gt; &lt;br/&gt;\n            {{created_time}} \n         &lt;br/&gt;\n {{#comments}} {{count}} {{/comments}} comment(s)  {{#likes}} {{count}} {{/likes}} likes. &lt;/li&gt;   \n   {{/data}}\n   &lt;/ul&gt;\n&lt;/div&gt;<\/pre><\/div><h2 id=\"N1011B\">步骤 4. 将应用程序推入\n                BlueMix<\/h2><ol><li>转到应用程序的 app 目录。使用以下命令从命令行登录 BlueMix：\n                        \n<div class=\"codesection\"><pre class=\"displaycode\">cf login -a api.ng.bluemix.net<\/pre><\/div><br />\n                    提供您的用户名、密码和组织，并在系统提示您时按下空格键。<\/li><li>一个 manifest.yml 文件包含在应用程序中，用于流线化该流程。它将设置应用程序名称、内存、实例数量和您在 <a href=\"#step2\">步骤 2<\/a> 中创建的 Pitney Bowes 地理编码服务名称。 \n<p>编辑\n                        manifest.yml 文件，以便更改那些对您的应用程序必须惟一的值。主机名必须是不同于 picturefinder\n                        的名称，这样您获得的 URL 路由就不会与演示 URL (http://picturefinder.ng.bluemix.net)\n                        发生冲突。<\/p><div class=\"codesection\"><pre class=\"displaycode\">---\napplications: #Reference http://docs.cloudfoundry.com/docs/using/deploying-apps/manifest.html\n- name: PictureFinder #Application Name. Unique to the user's Space\n  memory: 256M #The maximum memory to allocate to each application instance\n  instances: 1 #The number of instances of the application to start\n  host: <em>my-unique-ehostname<\/em> #Hostname for app routing. Unique to domain ng.bluemix.net.  Change.\n  path: . #Path to the application to be pushed\n  command: node app.js #The command to use to start the application\nservices: \n- <em>Geocoding-demo<\/em> #the already created geocode service<\/pre><\/div><\/li><li>从包含 app.js 和 manifest.yml 文件的 app 目录推入您的应用程序：\n                        \n<div class=\"codesection\"><pre class=\"displaycode\">cf push<\/pre><\/div><\/li><\/ol><p>当应用程序运行时，转到 http://<em>my-unique-hostname<\/em>.ng.bluemix.net（其中的\n                    <em>my-unique-hostname<\/em> 是您在 manifest 文件中使用的主机名）。输入您的地址，并查看哪些\n                Instagram 用户正在您的附近发帖子。<\/p><h2 id=\"N10144\">结束语<\/h2><p>当在主要社交媒体平台上签入或使用位置共享特性时，全世界超过十二亿的人都在使用 Pitney Bowes\n                位置智能解决方案。通过精心定制用户对当前位置的体验，这些服务可帮助您，让您的应用程序更多地参与其中。<\/p><CMA ID: 973657><Site ID: 10><XSLT stylesheet used to transform this file: dw-document-html-7.0.xsl>\r\n\r\n\r\n<\/div>\r\n<\/div>\r\n","createTime":"2014-06-12 00:00:00","deployTime":"2014-06-12 00:00:00","id":0,"intro":"使用 Codename: BlueMix 上的 Pitney Bowes 定位服务 API 来构建一个应用程序，该应用程序在 Instagram 中将地址的经纬度与媒体搜索相结合。","keyword":"","recommend":false,"source":"http://www.ibm.com/developerworks/cn/cloud/library/cl-bluemix-pitneybowes-app/index.html","title":"使用 Pitney Bowes 定位服务构建一个简单的图片定位应用程序","typeId":0,"updateTime":"2014-06-12 00:00:00"}
{"author":"","clickNumber":0,"content":"\r\n<div class=\"ibm-columns\">\r\n<div class=\"ibm-col-1-1\">\r\n\r\n<h2 id=\"N10085\">简介<\/h2><p>IBM&#174; Integration Bus（IIB，以前称为 WebSphere&#174; Message Broker）是一个企业服务总线 (ESB)，为 SOA（service-oriented architecture，面向服务的架构）和非 SOA 环境提供了连接能力和通的用数据转换能力<\/p><p>WebSphere Service Registry and Repository (WSRR) 是服务元数据的一个中央引用点，包括服务定义文档，比如 WSDL、XSD 和 WS-Policy 文档。<\/p><p>将 WSRR 与 IIB 集成，使消息流能够在运行时访问与 WSRR 中注册服务有关联的元数据，支持在服务使用者和服务提供者之间建立动态连接。IIB 还可以在运行时从 WSRR 动态地检索资源，以便在消息流处理过程中使用它们。这个过程允许您将想要在消息流中使用哪些工件的决定推迟到运行时，而不是在部署时做决定，避免了在工件改变时构建并重新部署消息流的需求。<\/p><p>举例而言，目标端点不需要在消息流中预先定义，因为您可以在运行时从 WSRR 动态检索它们。因此，您可以部署一个消息流，通过在 WSRR 中更新服务元数据来动态地控制它的路线和转换。<\/p><p>本文将介绍一些可使用 WSRR 与 IIB 的集成功能解决的场景。文中还会展示如何配置 IIB，以便它可使用许多不同的节点与 WSRR 进行通信。本文还会介绍本系列后续文章中将会使用的各种资源，用它们来演示这两个产品的集成功能。<\/p><p>有关 Endpoint Lookup 和 Registry Lookup 节点的更多信息，请参阅 <a href=\"http://www.ibm.com/developerworks/cn/websphere/library/techarticles/1404_smithson2/1404_smithson2.html\">第 2 部分<\/a>。<\/p><h2 id=\"business_scenarios\">业务场景<\/h2><p> 本系列文章中描述的示例消息流，可用于解决许多业务场景。这些场景将在以下各节中介绍： <\/p><h3 id=\"servicelocation\">服务位置<\/h3><p>ESB 很久以前就提供了将服务使用者与服务提供者分开的能力。但实际上，对知道目标服务的位置的需求已从服务使用者转移到了 ESB。<\/p><ul class=\"ibm-bullet-list\"><li><p><strong>业务问题<\/strong><\/p><p>用作其他服务的代理或在运行时调用其他服务的消息流，需要知道这些服务的位置或端点。这些服务的位置可硬编码到每个消息流中，但这使它们容易受到您环境中发生的变化的影响。举例而言，如果调用的任何服务的位置发生改变，那么受影响的消息流需要更新新位置并重新部署。每个消息流调用的服务在开发期间在各种环境间移动时，可能还需要修改这些服务的位置。<\/p><\/li><li><p><strong>解决方案<\/strong><\/p><p>调用的服务的位置可注册在 WSRR 中，由消息流在运行时动态检索。如果一个服务的位置由于某种原因而发生了更改，那么可以简单地更新 WSRR 中注册的端点，因此，任何受影响的消息流都可以将请求路由到位于新位置的服务。<\/p><\/li><li><p><strong>益处<\/strong><\/p><p>此方法减少了对服务位置所做更改的影响，无论是对消息流的影响，还是对系统管理的影响。它还支持将一个服务提供者替换为另一个，无需服务使用者了解这一更改，或者无需调整架构来支持这一替换。<\/p><\/li><\/ul><p>本系列中提供的几乎所有示例流都会在运行时动态地从 WSRR 检索端点。<a href=\"http://www.ibm.com/developerworks/cn/websphere/library/techarticles/1404_smithson2/1404_smithson2.html\">第 3 部分，端点查找场景<\/a> 将详细讨论动态路由。<\/p><h3 id=\"serviceselection\">服务选择<\/h3><p> 服务选择场景是上述服务位置场景的一种扩展，该场景会在一个目标服务有多个实现可用时出现。 <\/p><ul class=\"ibm-bullet-list\"><li><p><strong>业务问题<\/strong><\/p><p><strong>股票报价<\/strong>服务有一个已定义的接口，但部署了 3 个实现。一个实现返回最新的股票报价，应该仅由<strong>黄金级<\/strong>客户使用。另一个实现返回 5 分钟前的报价，只应由<strong>白银级<\/strong>客户使用。最后一个实现返回 20 分钟前的报价，只应由<strong>青铜级<\/strong>客户使用。股票报价服务的使用者希望能够使用单一端点调用它。 <\/p><\/li><li><p><strong>解决方案<\/strong><\/p><p>所有 3 个服务的端点都可在 WSRR 中注册，可将额外的元数据与每个端点关联。例如，在上述场景中，您可以在 WSRR 中定义个自定义本体 (ontology)，将每个端点分类为<strong>黄金级<\/strong>、<strong>白银级<\/strong>或<strong>青铜级<\/strong>。消息流在运行时检索这些端点时，元数据也会返回给 IIB。消息流然后可使用此元数据决定将请求路由到哪个端点，该操作或许会结合使用原始请求上提供的一些信息或 ESB 中提供的上下文信息。 <\/p><\/li><li><p><strong>益处<\/strong><\/p><p>这种方法使您能够在运行时，基于与服务提供者相关的元数据来在多个服务提供者之间选择。路由决策可能会受原始请求中提供的信息的影响，这有时称为基于内容的路由。决策也可能完全基于目标端点的元数据。例如，您环境中的一个监视组件可将性能指标推送到 WSRR 中，而消息流可决定将请求路由到具有最低平均响应时间的端点。 <\/p><\/li><\/ul><p>因为此场景是服务选择场景的一种扩展，所以也会在 <a href=\"http://www.ibm.com/developerworks/cn/websphere/library/techarticles/1404_smithson3/1404_smithson3.html\">第 3 部分：端点查找场景<\/a> 中详细讨论。 <\/p><h3 id=\"alternateprovider\">替代服务提供者<\/h3><p>替代服务提供者是上述服务选择场景的一种扩展。 <\/p><ul class=\"ibm-bullet-list\"><li><p><strong>业务问题<\/strong><\/p><p>多个端点可用于目标服务，但在尝试调用所选的端点时发生了一个错误。服务的使用者仅知道代理该服务的消息流的端点。他们希望 ESB 能够透明地处理围绕问题端点的路由请求。 <\/p><\/li><li><p><strong>解决方案<\/strong><\/p><p>目标服务的所有端点都可在 WSRR 中注册，由消息流在单次查询中检索。如果尝试在所选端点上调用目标服务时发生了错误，消息流可选择该服务的其他端点并进行重试。消息流可继续执行此过程，直到请求成功解决或所有服务端点都已尝试。<\/p><\/li><li><p><strong>益处<\/strong><\/p><p>此方法使您能够在 ESB 中建立一定水平的容错能力，允许 ESB 透明地围绕问题端点而路由服务请求。您可允许消息流尝试一个服务的所有可用端点，或者可限制向服务使用者返回错误之前尝试的端点数量。显然，在 ESB 中建立的任何容错能力，都必须设计为能与您环境中使用的其他高可用性机制联合工作。<\/p><\/li><\/ul><p>因为此场景是服务选择场景的一种扩展，所以会在 <a href=\"http://www.ibm.com/developerworks/cn/websphere/library/techarticles/1404_smithson3/1404_smithson3.html\">第 3 部分：端点查找场景<\/a> 中进行详细讨论。 <\/p><h3 id=\"servicetransformation\">服务转换<\/h3><p>ESB 通常提供的另一种能力是，在服务使用者与服务提供者之间转换消息格式。通常，不同服务的接口和操作是不同的。ESB 可将消息从源格式转换为目标服务可以接受的格式。<\/p><ul class=\"ibm-bullet-list\"><li><p><strong>业务问题<\/strong><\/p><p>为服务实现的新版本可能无法向后兼容以前的版本。您可能希望让服务的旧版本处于离线状态，从而释放资源，但不希望影响这些版本的使用者，或者迫使他们更新自己的实现。<\/p><\/li><li><p><strong>解决方案<\/strong><\/p><p>可将服务的所有版本都注册在 WSRR 中，并将额外的元数据与每个服务关联。例如，在上述场景中，您可以定义 XSL 转换，将对服务的旧版本的请求转换为最新版本要求的格式（然后对服务响应执行反向转换）。这些 XSL 转换可加载到 WSRR 中并与相关服务相关联。它们然后可由消息流在运行时检索，应用到整个 ESB 的消息流上。<\/p><\/li><li><p><strong>益处<\/strong><\/p><p>此方法使您能够透明地将针对服务的较早版本的请求路由到服务的更新版本。这使您能够让服务的较早版本处于离线状态，从而释放平时会使用的资源。它还使您能够将 XSL 转换存储在 WSRR 中并在运行时动态检索它们，避免在这些转换改变时构建和重新部署消息流的需求。 <\/p><\/li><\/ul><p>服务转换场景将在 <a href=\"http://www.ibm.com/developerworks/cn/websphere/library/techarticles/1404_smithson4/1404_smithson4.html\">第 4 部分，服务转换<\/a> 中详细讨论。<\/p><h3 id=\"servicegateway\">服务网关<\/h3><p>IIB 中的 SOAP 网关可在网关模式下操作。配置为在网关模式下工作时，节点不会配置为使用一个特定的 WSDL 文件，能够处理一般性的 SOAP 消息。<\/p><ul class=\"ibm-bullet-list\"><li><p><strong>业务问题<\/strong><\/p><p>您有许多服务，您希望在 ESB 级别向它们应用一些通用的处理。您不希望需要构建和部署一个不同的流来代理每个后端服务，然后才能实现此目的。<\/p><\/li><li><p><strong>解决方案<\/strong><\/p><p>通过在<strong>网关模式<\/strong>下使用 <strong>SOAP Input<\/strong> 节点，无需在该节点收到的 SOAP 消息上执行特定于服务的验证。这使您能够实现一个消息流来处理对多个不同的后端服务的服务请求。这样一个消息流然后可提供某种通用功能，以应用到它处理的所有服务请求上，比如授权、日志记录等。为了将服务请求路由到后端服务，消息流可从 WSRR 检索端点。<\/p><\/li><li><p><strong>益处<\/strong><\/p><p>此方法使您能够在单个位置实现通用的处理逻辑，通过简化对针对多个服务的服务请求进行路由、监视、日志记录、版本控制和保护的过程，减少总体开发和测试工作。它还简化了调用目标服务的过程，因为服务使用者仅需要知道一个端点。<\/p><\/li><\/ul><p>服务网关场景将在 <a href=\"http://www.ibm.com/developerworks/cn/websphere/library/techarticles/1404_smithson6/1404_smithson6.html\">第 6 部分：服务网关<\/a> 中详细讨论。<\/p><h3 id=\"slacheck\">SLA 检查<\/h3><p>WSRR 中的服务水平协议 (SLA) 是服务提供者与服务使用者之间的协议。他们可由 ESB 在运行时处理请求时执行，确保服务使用者有权调用目标服务。<\/p><ul class=\"ibm-bullet-list\"><li><p><strong>业务问题<\/strong><\/p><p>您的 SOA 中部署了许多服务，而且它们都已在 WSRR 中注册。但是，您无法在 WSRR 中注册这些服务的使用者。结果，您不知道哪些服务使用者可能在任何给定时间点调用每个服务。您希望确保 SOA 中的所有服务使用者都已在 WSRR 中注册，而且只有有权调用目标服务的使用者被允许这么做。<\/p><\/li><li><p><strong>解决方案<\/strong><\/p><p>WSRR 允许您在 SOA 中注册服务使用者和服务提供者。它还支持使用服务水平协议 (SLA) 表示服务提供者和服务使用者之间的协议或契约。消息流可在运行时动态地从 WSRR 检索此信息，使用此信息确定服务使用者是否有权调用目标服务。如果服务使用者有权调用目标服务，它可以将请求转发给协商好的端点。如果服务使用者无权调用目标服务，则会返回一个恰当的错误。<\/p><\/li><li><p><strong>益处<\/strong><\/p><p>此方法允许您控制哪些服务使用者可以调用实际的后端服务，使您能够在 SOA 中执行一定水平的运行时治理。一种附加好处是，服务使用者和提供者在 WSRR 中注册后，即可在 <strong>Service Registry Dashboard<\/strong> 用户界面直观地表示这些关系，并使用它们来评估您计划对服务执行的任何更改所带来的影响。<\/p><\/li><\/ul><p>SLA 检查场景将在本系列的两篇文章中讨论。<a href=\"http://www.ibm.com/developerworks/cn/websphere/library/techarticles/1404_smithson5/1404_smithson5.html\">第 5 部分：在运行时执行 SLA 检查<\/a> 展示了如何使用 <code>Registry Lookup<\/code> 节点实现此功能，而 <a href=\"http://www.ibm.com/developerworks/cn/websphere/library/techarticles/1404_smithson8/1404_smithson8.html\">第 8 部分：使用 HTTP Request 节点执行 SLA 检查<\/a> 展示了如何使用 <code>HTTP Request<\/code> 节点调用 WSRR REST API 来实现它。<\/p><h3 id=\"policyenforcement\">策略执行<\/h3><p>除了使您能够注册服务提供者和服务使用者之外，WSRR 还支持您加载策略并附加到服务上。以这种方式使用时，WSRR 就变成了 SOA 中的服务和策略的一个中央引用点。<\/p><ul class=\"ibm-bullet-list\"><li><p><strong>业务问题<\/strong><\/p><p>您对遗留系统上的许多现有应用程序启用了服务，以便可以在新环境中使用它们。但是，您仍然可以通过其他渠道访问这些应用程序，比如通过原生接口，消息应用程序可通过 WebSphere MQ 进行访问。为了确保这些应用程序的现有使用者不会受到通过 Web 服务接口传入的请求的负面影响，您希望能够对可通过此接口处理的流量指定一个限制。<\/p><\/li><li><p><strong>解决方案<\/strong><\/p><p>IIB 通过附向消息流附加 WLM，使您能够控制消息流内的处理速率。WLM 策略允许您增加、降低或简单地监视消息流处理消息的速率。一个 WLM 策略可附加到多个消息流。WLM 策略也可在运行时更新，不需要重新启动任何消息流即可让更改生效。<\/p><p>IIB WLM 策略是使用 WS-Policy 定义的，这使得它们能够与您 SOA 中使用其他类型 WS-Policy 一起加载到 WSRR 中并集中管理。通过在 WSRR 中注册消息流并向它们附加 WLM 策略，您可以在运行时在 IIB 中动态地控制流经该消息流的流量。<\/p><\/li><li><p><strong>益处<\/strong><\/p><p>此方法使您能够控制流经您消息流的流量，同时仍然能够在 WSRR 中集中管理您的服务和策略，提供了 SOA 中的服务以及对它们应用的策略的单一视图。<\/p><\/li><\/ul><p>策略执行场景将在 <a href=\"http://www.ibm.com/developerworks/cn/websphere/library/techarticles/1404_smithson9/1404_smithson9.html\">第 9 部分，IIB WLM 策略集成<\/a> 中详细讨论。<\/p><h2 id=\"N101A8\">基本的 IBM Integration Bus 配置<\/h2><p>IIB 中的消息流可能依赖于外部服务，比如 WSRR。与这些外部服务相关的属性使用 IIB 中的<strong>可配置服务<\/strong>来定义。无需在消息流中的节点上定义属性就可以创建<strong>可配置服务<\/strong>，这样消息流节点就可以在运行时引用它们来查找属性。控制 IIB 与 WSRR 之间的交互的大部分属性都封装在 <code>DefaultWSRR<\/code> 可配置服务对象中。您可以使用 <code>mqsireportproperties<\/code> 命令显示 <code>DefaultWSRR<\/code> 可配置服务对象的当前属性，如下所示：<\/p><h5 id=\"N101BF\">mqsireportproperties 命令<\/h5><div class=\"codesection\"><pre class=\"displaycode\"> mqsireportproperties &amp;lt;BROKER_NAME&amp;gt; -c ServiceRegistries -o DefaultWSRR -r<\/pre><\/div><p>其中：<\/p><ul class=\"ibm-bullet-list\"><li><code>&amp;lt;BROKER_NAME&amp;gt;<\/code> 是代理的名称 (Integration Node)。<\/li><\/ul><p>此命令的一个输出示例如下所示：<\/p><h5 id=\"listing12\">mqsireportproperties 输出<\/h5><p><a href=\"#N101D1\" class=\"ibm-popup-link\" onclick=\"ibmweb.overlay.show('N101D1',this);return false;\">点击查看代码清单<\/a><\/p><div id=\"N101D1\" class=\"dw-sidefile-overlay ibm-common-overlay ibm-overlay-alt-two\"><div class=\"ibm-head\"><p><a href=\"#close\" class=\"ibm-common-overlay-close\">关闭 [x]<\/a><\/p><\/div><div class=\"ibm-body\"><div class=\"ibm-main\"><div class=\"ibm-title\"><h2>mqsireportproperties 输出<\/h2><\/div><div class=\"ibm-container ibm-alternate\"><div class=\"ibm-container-body\"><div class=\"codesection\"><pre class=\"displaycode no-auto-overflow\"> ServiceRegistries DefaultWSRR connectionFactoryName='jms/SRConnectionFactory' connectionTimeout='180' enableCacheNotification='false' endpointAddress='http://my.wsrr.host:9080/WSRRCoreSDO/services/WSRRCoreSDOPort' initialContextFactory='com.ibm.websphere.naming.WsnInitialContextFactory' locationJNDIBinding='iiop://fill.in.your.host.here:2809/' needCache='false' predefinedCacheQueries='' refreshQueriesAfterNotification='true' subscriptionTopic='jms/SuccessTopic' timeout='100000000'<\/pre><\/div><\/div><\/div><\/div><\/div><div class=\"ibm-footer\"><><\/div><\/div><h3 id=\"modifyingDefaultWSRR\">修改 DefaultWSRR 可配置服务<\/h3><p>IIB 中的 Endpoint Lookup 和 Registry Lookup 节点使用 WSRR Web 服务 API 与 WSRR 进行通信。为实现此目的，IIB 必须配置 WSRR Web 服务 API 的端点地址。这可以通过在 <code>DefaultWSRR<\/code> 可配置服务对象上设置 <code>endpointAddress<\/code> 属性来实现。但是，WSRR 公开了 Web 服务 API 的多个端点，以保持与该产品以前的版本的向后兼容性。公开的每个特定于版本的端点有一个惟一的 URL 后缀。有关这些 URL 的更多信息，请访问 <a href=\"#resources\">参考资料<\/a> 一节中的 <strong>Web 服务接口 URL<\/strong> 链接。为 <code>endpointAddress<\/code> 属性指定的值必须是 IIB 支持的兼容性 URL 之一。对于 <strong>IIB 9.0<\/strong>，受支持的兼容性 URL 后缀列表如下所示：<\/p><h5 id=\"table5\">IIB 支持的 WSRR 兼容性 URL<\/h5><table border=\"0\" cellpadding=\"0\" cellspacing=\"0\" class=\"ibm-data-table\"><thead xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"><tr><th>WSRR 版本<\/th><th>URL 后缀<\/th><\/tr><\/thead><tbody xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"><tr><td>6.1<\/td><td>/WSRR6_1/services/WSRRCoreSDOPort<\/td><\/tr><tr><td>6.2<\/td><td>/WSRR6_2/services/WSRRCoreSDOPort<\/td><\/tr><tr><td>6.3<\/td><td>/WSRR6_3/services/WSRRCoreSDOPort<\/td><\/tr><\/tbody><\/table><p>要在 <code>DefaultWSRR<\/code> 可配置服务对象上设置 <strong>endpointAddress<\/strong> 属性的值，需要使用 <code>mqsichangeproperties<\/code> 命令，如下所示： <\/p><h5 id=\"listing13\">配置端点地址<\/h5><p><a href=\"#N10219\" class=\"ibm-popup-link\" onclick=\"ibmweb.overlay.show('N10219',this);return false;\">点击查看代码清单<\/a><\/p><div id=\"N10219\" class=\"dw-sidefile-overlay ibm-common-overlay ibm-overlay-alt-two\"><div class=\"ibm-head\"><p><a href=\"#close\" class=\"ibm-common-overlay-close\">关闭 [x]<\/a><\/p><\/div><div class=\"ibm-body\"><div class=\"ibm-main\"><div class=\"ibm-title\"><h2>配置端点地址<\/h2><\/div><div class=\"ibm-container ibm-alternate\"><div class=\"ibm-container-body\"><div class=\"codesection\"><pre class=\"displaycode no-auto-overflow\"> mqsichangeproperties &amp;lt;BROKER_NAME&amp;gt; -c ServiceRegistries -o DefaultWSRR -n endpointAddress -v &amp;lt;WSRR_ENDPOINT_URL&amp;gt;<\/pre><\/div><\/div><\/div><\/div><\/div><div class=\"ibm-footer\"><><\/div><\/div><p>其中：<\/p><ul class=\"ibm-bullet-list\"><li><code>&amp;lt;BROKER_NAME&amp;gt;<\/code> 是代理的名称 (Integration Node)。<\/li><li><code>&amp;lt;WSRR_ENDPOINT_URL&amp;gt;<\/code> 是 WSRR Web 服务 API 的端点的完全限定 URL，例如 <strong>https://localhost:9443/WSRR6_3/services/WSRRCoreSDOPort<\/strong>。<\/li><\/ul><p>为了优化 IIB 和 WSRR 在运行时的相互交互，Endpoint Lookup 和 Registry Lookup 节点将它们发出的查询的结果都存储在缓存中。出于性能原因，推荐在生产环境中使用 IIB 中的 WSRR 缓存。但是，在开发环境中，建议禁用 WSRR 缓存。这使您能够立即测试在 WSRR 中对元数据所做的任何更改对消息流的影响，而无需等待 WSRR 缓存更新。WSRR 缓存将在 <a href=\"http://www.ibm.com/developerworks/websphere/library/techarticles/1404_smithson7/1404_smithson7.html\">第 7 部分，在 IIB 中配置 WSRR 缓存<\/a> 中详细介绍。要禁用 WSRR 缓存，需要使用 <code>mqsichangeproperties<\/code> 命令，如下所示：<\/p><h5 id=\"listing14\">禁用 WSRR 缓存<\/h5><div class=\"codesection\"><pre class=\"displaycode\"> mqsichangeproperties &amp;lt;BROKER_NAME&amp;gt; -c ServiceRegistries -o DefaultWSRR -n needCache -v false<\/pre><\/div><p>其中：<\/p><ul class=\"ibm-bullet-list\"><li><code>&amp;lt;BROKER_NAME&amp;gt;<\/code> 是代理的名称 (Integration Node)。<\/li><\/ul><h2 id=\"N1023F\">配置 IBM Integration Bus 以访问一个安全的 WSRR 实例<\/h2><p>在典型的生产环境中，会在包含 WSRR 的 WebSphere Application Server 单元上启用应用程序安全性。这对尝试访问安全 WSRR 实例的客户有两种影响：<\/p><ol><li>尝试访问这样一种环境中的 WSRR 的用户必须经过身份验证。在用户经过验证后，WSRR 通过评估应用程序的任何访问控制权限，确定允许该用户访问哪些资源。无论用户使用基于浏览器的用户界面（比如 <strong>Service Registry Dashboard<\/strong>），还是使用一种编程接口（比如 WSRR Web 服务 API）访问 WSRR，此描述都适用。<\/li><li>客户端与 WSRR 实例之间的通信必须通过一个加密通道进行，比如 <code>HTTPS<\/code>。<\/li><\/ol><h3 id=\"wsrrUseridPassword\">指定 WSRR 用户 ID 和密码<\/h3><div class=\"dw-sidebar ibm-inset\"><h2 id=\"N10256\">mqsisetdbparms 命令<\/h2><p><code>mqsisetdbparms<\/code> 命令可在代理运行期间运行。但是，您必须停止并重新启动该代理 (Integration Node)，更改才能生效。<\/p><\/div><p>在 IIB 中运行的任何尝试访问安全 WSRR 实例的消息流，都必须提供用户名和密码。如果消息流使用了 Endpoint Lookup 或 Registry Lookup 节点，那么可在 IIB 中使用 <code>mqsisetdbparms<\/code> 命令配置传递给 WSRR 的凭据，如下所示。如果消息流使用 <code>HTTP Request<\/code> 节点来调用 WSRR REST API，那么可以使用消息流中的一个计算节点，以编程方式指定用户 ID 和密码。此方法将在 <a href=\"http://www.ibm.com/developerworks/cn/websphere/library/techarticles/1404_smithson8/1404_smithson8.html\">第 8 部分：使用 HTTP Request 节点执行 SLA 检查<\/a> 中详细介绍。<\/p><h5 id=\"N1026A\">指定 WSRR 用户 ID 和密码<\/h5><div class=\"codesection\"><pre class=\"displaycode\"> mqsisetdbparms &amp;lt;BROKER_NAME&amp;gt; -n DefaultWSRR::WSRR -u &amp;lt;USER_ID&amp;gt; -p &amp;lt;PASSWORD&amp;gt;<\/pre><\/div><p>其中：<\/p><ul class=\"ibm-bullet-list\"><li><code>&amp;lt;BROKER_NAME&amp;gt;<\/code> 是代理的名称 (Integration Node)。<\/li><li><code>&amp;lt;USER_ID&amp;gt;<\/code> 是被授权访问 WSRR 中需要的工件的用户的 ID。<\/li><li><code>&amp;lt;PASSWORD&amp;gt;<\/code> 是此用户的密码。<\/li><\/ul><h3 id=\"N1027E\">提取 WSRR 签名者证书<\/h3><div class=\"dw-sidebar ibm-inset\"><h2 id=\"N10283\">密钥库和信任库<\/h2><p>密钥库和信任库都是密钥库。惟一的区别在于它们的使用方式：<\/p><ul class=\"ibm-bullet-list\"><li>密钥库通常包含私钥和公钥证书，这些信息在客户端尝试连接到服务器时提供给客户端。 <\/li><li>信任库通常包含受信任的根证书颁发机构 (CA) 证书。这些证书用于在建立出站连接时确定目标服务器是否值得信赖。<\/li><\/ul><\/div><p>在 IIB 尝试与安全的 WSRR 实例进行通信时，会执行一次 SSL 握手来建立安全的连接。要成功完成 SSL 握手，IIB 最低限度上必须信任目标 WSRR 实例。这通过提取目标 WSRR 实例的签名者证书并将它添加到 IIB 所使用的信任库中来实现。下面的步骤描述了如何使用 Firefox 或 Internet Explorer 提取目标 WSRR 实例的签名者证书：<\/p><p>使用 Firefox：<\/p><ol><li>输入您在上面的  中配置的 WSRR Web 服务 API 的端点地址。例如： <strong>https://localhost:9443/WSRR6_3/services/WSRRCoreSDOPort<\/strong><\/li><li>输入您在上面的  中配置的用户 ID 和密码。您会看到一个与以下页面类似的页面： <h5 id=\"fig7\">WSRR Web 服务 API hello 程序<\/h5><img alt=\"WSRR Web 服务 API hello 程序\" src=\"/sunshine_new/images/负1870594959/images/WebServiceHello.jpg\" width=\"580\" /><\/li><li>右键单击该页面并选择 <strong>View Page Info<\/strong>。<\/li><li>在 <strong>Security<\/strong> 选项卡上，单击 <strong>View Certificate<\/strong>。<\/li><li>切换到 <strong>Details<\/strong> 选项卡并单击 <strong>Export<\/strong>。<\/li><li>为证书提供一个合适的名称并选择类型（比如 DER）。单击 <strong>Save<\/strong>。<\/li><\/ol><p>使用 Internet Explorer：<\/p><ol><li>确保<strong>保护模式<\/strong>已关闭：转到 <strong>“工具” =&amp;gt; “Internet 选项” =&amp;gt; “安全”<\/strong> 并取消选择 <strong>“启用保护模式”<\/strong>。<\/li><li>输入您在上面的  中配置的 WSRR Web 服务 API 的端点地址，例如 <strong>https://localhost:9443/WSRR6_3/services/WSRRCoreSDOPort<\/strong>。<\/li><li>输入您在上面的  中配置的用户 ID 和密码。您会看到一个与上面的  中显示的类似的页面。<\/li><li>右键单击该页面，选择 <strong>Properties<\/strong>，然后单击 <strong>Certificates<\/strong>。<\/li><li>转到 <strong>Details<\/strong> 选项卡并单击 <strong>Copy to file<\/strong>。按照 <strong>Certificate Export Wizard<\/strong> 提供的指令操作。<\/li><\/ol><h3 id=\"N102F6\">创建 IIB 信任库<\/h3><p>IIB 没有提供或创建任何现成的密钥库。您需要在保护 IIB 及它与您环境中其他服务器的通信期间手动创建它们。使用 <code>gsk7cmd<\/code> 命令行工具创建密钥库的过程已在 IIB 信息库中介绍。请访问 <a href=\"#resources\">参考资料<\/a> 一节中的<strong>设置公钥基础架构<\/strong>链接，以便了解有关的更多信息。下面的步骤介绍了如何使用 IIB 中提供的 <code>IBM Key Management<\/code> 图形化工具来创建密钥库。如果已在 IIB 环境中创建了一个密钥库，那么请跳过这些步骤。<\/p><ol><li>打开一个命令窗口。<\/li><li>使用 <code>strmqikm<\/code> 命令或导航到 <code>&amp;lt;IIB_INSTALL&amp;gt;/jre17/bin<\/code> 目录并直接运行 <code>ikeyman<\/code> 命令，启动 <code>IBM Key Management<\/code> 工具。<\/li><li>此时将会显示一个 <code>IBM Key Management<\/code> 窗口。单击 <strong>Key Database File =&amp;gt; New<\/strong>。<\/li><li>此时将会显示一个 <strong>New<\/strong> 对话框。指定 <code>JKS<\/code> 作为 <code>Key database type<\/code> 并为 <code>File Name<\/code> 和 <code>Location<\/code> 指定一个合适的值。对话框应类似于： <h5 id=\"fig8\">创建一个新的密钥数据库文件<\/h5><img alt=\"创建一个新的密钥数据库文件\" src=\"/sunshine_new/images/负1870594959/images/NewKeystore.jpg\" width=\"580\" /><\/li><li>单击 <strong>OK<\/strong>。<\/li><li>此时将会显示一个 <strong>Password Prompt<\/strong> 对话框。指定将用于保护对密钥数据库文件的访问的密码并确认它。<\/li><li>单击 <strong>OK<\/strong>。<\/li><\/ol><h3 id=\"N1034B\">导入 WSRR 签名者证书<\/h3><p>下面的步骤描述了如何使用 IIB 提供的 <code>IBM Key Management<\/code> 工具将 WSRR 签名者证书导入 IIB 信任库中。<\/p><ol><li>打开一个命令窗口。<\/li><li>使用 <code>strmqikm<\/code> 命令或导航到 <code>&amp;lt;IIB_INSTALL&amp;gt;/jre17/bin<\/code> 目录并直接运行 <code>ikeyman<\/code> 命令，启动 <code>IBM Key Management<\/code> 工具。<\/li><li>此时将会显示一个 <code>IBM Key Management<\/code> 窗口。单击 <strong>Key Database File =&amp;gt; Open<\/strong>。<\/li><li>此时将会显示一个 <strong>Open<\/strong> 对话框。指定 <code>JKS<\/code> 作为 <code>Key database type<\/code>，然后单击 <strong>Browse<\/strong>。<\/li><li>找到并选择您的 IIB 信任库，然后单击 <strong>Open<\/strong>。<\/li><li>单击 <strong>OK<\/strong>。<\/li><li>此时将会显示一个 <strong>Password Prompt<\/strong> 对话框。输入 IIB 信任库的密码。<\/li><li>单击 <strong>OK<\/strong>。<\/li><li>在窗口的 <strong>Key database content<\/strong> 部分中，选择下拉列表中的 <code>Signer Certificates<\/code>。<\/li><li>单击 <strong>Add...<\/strong>。<\/li><li>此时将会显示一个 <strong>Open<\/strong> 对话框。单击 <strong>Browse...<\/strong>。<\/li><li>找到并选择包含您之前提取的 WSRR 签名者证书的文件。单击 <strong>OK<\/strong>。<\/li><li>此时将会显示一个 <strong>Enter a Label<\/strong> 对话框。输入用于在信任库中标识 WSRR 签名者证书的标签。<\/li><li>单击 <strong>OK<\/strong>。<\/li><li>WSRR 签名者证书将通过您指定的标签添加到信任库中的签名者列表中。<strong>IBM Key Management<\/strong> 窗口应类似于： <h5 id=\"fig9\">IIB 信任库<\/h5><img alt=\"IIB 信任库\" src=\"/sunshine_new/images/负1870594959/images/IIBTrustStore.jpg\" width=\"580\" /><\/li><li>关闭 <code>IBM Key Management<\/code> 工具。<\/li><\/ol><h3 id=\"N103C6\">配置 IIB 信任库<\/h3><p>现在您已经有了一个包含您的 WSRR 服务器的签名者证书的密钥库，您需要配置 IIB 来使用该密钥库。IIB 使用的密钥库的位置使用 <code>mqsichangeproperties<\/code> 命令在 <code>BrokerRegistry<\/code> 对象上配置，如下所示：<\/p><h5 id=\"lksting16\">指定信任库的位置<\/h5><p><a href=\"#N103D6\" class=\"ibm-popup-link\" onclick=\"ibmweb.overlay.show('N103D6',this);return false;\">点击查看代码清单<\/a><\/p><div id=\"N103D6\" class=\"dw-sidefile-overlay ibm-common-overlay ibm-overlay-alt-two\"><div class=\"ibm-head\"><p><a href=\"#close\" class=\"ibm-common-overlay-close\">关闭 [x]<\/a><\/p><\/div><div class=\"ibm-body\"><div class=\"ibm-main\"><div class=\"ibm-title\"><h2>指定信任库的位置<\/h2><\/div><div class=\"ibm-container ibm-alternate\"><div class=\"ibm-container-body\"><div class=\"codesection\"><pre class=\"displaycode no-auto-overflow\"> mqsichangeproperties &amp;lt;BROKER_NAME&amp;gt; -o BrokerRegistry -n brokerTruststoreFile -v &amp;lt;TRUST_STORE_FILE&amp;gt;<\/pre><\/div><\/div><\/div><\/div><\/div><div class=\"ibm-footer\"><><\/div><\/div><p>其中：<\/p><ul class=\"ibm-bullet-list\"><li><code>&amp;lt;BROKER_NAME&amp;gt;<\/code> 是代理的名称 (Integration Node)。<\/li><li><code>&amp;lt;TRUST_STORE_FILE&amp;gt;<\/code> 是信任库文件的完整路径。<\/li><\/ul><div class=\"dw-sidebar ibm-inset\"><h2 id=\"N103E4\">mqsisetdbparms 命令<\/h2><p><code>mqsisetdbparms<\/code> 命令可在代理运行期间运行。但是，您必须停止并重新启动该代理 (Integration Node)，更改才能生效。<\/p><\/div><p>为了让 IIB 能够打开信任库文件并访问它包含的证书，您需要将密码提供给它。这需要配置 <code>mqsisetdbparms<\/code>，如下所示：<\/p><h5 id=\"listing17\">指定信任库密码<\/h5><div class=\"codesection\"><pre class=\"displaycode\"> mqsisetdbparms &amp;lt;BROKER_NAME&amp;gt; -n brokerTruststore::password -u dummy -p &amp;lt;PASSWORD&amp;gt;<\/pre><\/div><p>其中： <\/p><ul class=\"ibm-bullet-list\"><li><code>&amp;lt;BROKER_NAME&amp;gt;<\/code> 是代理的名称 (Integration Node)。<\/li><li><code>&amp;lt;PASSWORD&amp;gt;<\/code> 是已在 IIB 中配置的信任库的密码。<\/li><\/ul><p> 现在已完成 IIB 与 WSRR 之间的连接的配置。<\/p><h2 id=\"N10403\">导入和构建示例流<\/h2><p>本系列文章附带的示例流包含在 <a href=\"#download\">下载<\/a> 部分的 <strong>WSRRIntegrationDemos.zip<\/strong> 压缩文件中。这些流包含 <strong>Math Service<\/strong> 的两个版本。此服务执行基本的算术运算并将结果返回给客户端。剩余流使用了 <strong>Math Service<\/strong>，演示了可在 IIB 与 WSRR 之间建立的集成的不同方面。要能够将这些流部署到 IIB 中，首先需要将它们导入一个 <strong>IBM Integration Toolkit<\/strong> 工作区中并构建到一个 BAR 文件中。以下各节介绍如何执行这些任务。<\/p><h3 id=\"N1041A\">将示例工作流导入 IBM Integration Toolkit 中<\/h3><p>第一步是将压缩文件中包含的示例流导入到一个 IBM Integration Toolkit 工作区中。为此，需要执行以下步骤：<\/p><ol><li>打开 <strong>IBM Integration Toolkit<\/strong>。<\/li><li>选择 <strong>File =&amp;gt; Import...<\/strong>。<\/li><li>此时将会显示一个 <strong>Import<\/strong> 对话框。展开 <strong>General<\/strong> 文件夹并选择 <strong>Existing Projects into Workspace<\/strong>，然后单击 <strong>Next &amp;gt;<\/strong>。<\/li><li>在下一个面板上，选择 <strong>Select archive file<\/strong> 单选按钮，然后单击 <strong>Browse...<\/strong>。<\/li><li>导航到包含本文所提供的 <strong>WSRRIntegrationDemos.zip<\/strong> 压缩文件的目录。<\/li><li>双击 <strong>WSRRIntegrationDemos.zip<\/strong> 压缩文件。<\/li><li>在 <strong>Import<\/strong> 对话框中，确保列出的所有项目（<strong>BARFiles<\/strong>、<strong>WSRRIntegrationDemos<\/strong> 和 <strong>WSRRIntegrationDemosJava<\/strong>）都已被选中。<strong>Import<\/strong> 对话框应类似于： <h5 id=\"fig10\">Import 对话框<\/h5><img alt=\"Import 对话框\" src=\"/sunshine_new/images/负1870594959/images/ImportDialog.jpg\" width=\"580\" /><\/li><li>单击 <strong>Finish<\/strong>。<\/li><\/ol><h3 id=\"N1046A\">修改 Java 项目构建路径<\/h3><p>导入到您工作区中的 <strong>WSRRIntegrationDemosJava<\/strong> 项目可能有许多编译错误。原因如下：添加到此项目的 <strong>Java Build Path<\/strong> 中的 <strong>com.ibm.mq.jar<\/strong> 和 <strong>ConfigManagerProxy.jar<\/strong> 文件可能位于您环境中的不同位置。如果 <strong>WSRRIntegrationDemosJava<\/strong> 项目具有编译错误，则需要修改 <strong>Java Build Path<\/strong>，然后才能进行编译。为此，需要执行以下步骤：<\/p><ol><li>在 <strong>IBM Integration Toolkit<\/strong> 中，打开 <strong>Java<\/strong> 透视图。<\/li><li>右键单击 <strong>WSRRIntegrationDemosJava<\/strong> 项目。<\/li><li>在显示的上下文菜单中，选择 <strong>Build Path =&amp;gt; Configure Build Path...<\/strong>。<\/li><li>此时将会显示一个 <strong>Properties for WSRRIntegrationDemosJava<\/strong> 对话框，其中已在左侧面板中选择了 <strong>Java Build Path<\/strong>。在右侧面板中，选择 <strong>Libraries<\/strong> 选项卡。<\/li><li>从列表中选择 <strong>com.ibm.mq.jar<\/strong> 文件并单击 <strong>Edit...<\/strong>。<\/li><li>此时将会显示一个 <strong>Edit JAR<\/strong> 对话框。导航到 <code>&amp;lt;MQ_INSTALL_DIR&amp;gt;/java/lib<\/code> 目录。选择 <strong>com.ibm.mq.jar<\/strong> 并单击 <strong>Ok<\/strong>。<\/li><li>从列表中选择 <strong>ConfigManagerProxy.jar<\/strong> 并单击 <strong>Edit<\/strong>。<\/li><li>此时将会显示一个 <strong>Edit JAR<\/strong> 对话框。导航到 <code>&amp;lt;IIB_INSTALL_DIR&amp;gt;/classes<\/code> 目录。选择 <strong>ConfigManagerProxy.jar<\/strong>，然后单击 <strong>Ok<\/strong>。<\/li><li>在 <strong>Properties for WSRRIntegrationDemosJava<\/strong> 对话框中，单击 <strong>Ok<\/strong>。<\/li><\/ol><h3 id=\"N104D4\">在 IBM Integration Toolkit 中构建示例流<\/h3><p>现在需要在 IBM Integration Toolkit 中构建示例流。为此，需要执行以下步骤：<\/p><ol><li>打开 <strong>Integration Development<\/strong> 透视图。<\/li><li>在 <strong>Application Development<\/strong> 视图中，展开 <strong>BARs<\/strong> 并双击 <strong>WSRRIntegrationDemos.bar<\/strong>，如下所示： <h5 id=\"fig11\">打开 BAR 文件<\/h5><img alt=\"打开 BAR 文件\" src=\"/sunshine_new/images/负1870594959/images/OpenBARfile.jpg\" width=\"433\" /><\/li><li>该文件将在 <strong>Broker Archive Editor<\/strong> 中打开。选择编辑器底部的 <strong>Prepare<\/strong> 选项卡。<\/li><li>单击 <strong>Build and Save...<\/strong>，如下所示： <h5 id=\"fig12\">构建 BAR 文件<\/h5><img alt=\"构建 BAR 文件\" src=\"/sunshine_new/images/负1870594959/images/BuildandSave.jpg\" width=\"580\" /><\/li><li>在 IBM Integration Toolkit 构建 BAR 文件期间，系统会显示一个进度对话框。该过程完成后，您会看到消息 <strong>Operation completed successfully<\/strong>。单击 <strong>OK<\/strong>。<\/li><\/ol><h3 id=\"N10512\">将示例流部署到 IIB<\/h3><div class=\"dw-sidebar ibm-inset\"><h2 id=\"N10517\">进一步配置<\/h2><p>一些流需要在 IIB 中执行进一步配置，然后它们才能工作。所需的额外配置步骤取决于某些场景，这些内容会在与该场景对应的文章中介绍。<\/p><\/div><p>现在我们需要将 BAR 文件部署到 IIB。幸运的是，这个过程非常简单。<\/p><ol><li>确保目标 IIB 实例正在运行。<\/li><li>打开 <strong>Integration Development<\/strong> 透视图。<\/li><li>在 <strong>Application Development<\/strong> 视图中，展开 <strong>BARs<\/strong> 并右键单击 <strong>WSRRIntegrationDemos.bar<\/strong>，如下所示：<\/li><li>在显示的上下文菜单中，单击 <strong>Deploy...<\/strong>。<\/li><li>此时将会显示一个 <strong>Deploy<\/strong> 对话框。选择 BAR 文件应部署到的 <strong>Integration Server<\/strong>，如下面的示例所示： <h5 id=\"fig13\">部署 BAR 文件<\/h5><img alt=\"部署 BAR 文件\" src=\"/sunshine_new/images/负1870594959/images/DeployDialog.jpg\" width=\"580\" /><\/li><li>单击 <strong>Finish<\/strong>。<\/li><li>部署 BAR 文件期间将会显示一个进度对话框。该过程完成后，进度对话框会自动关闭。如果该对话框未关闭，请单击 <strong>Close<\/strong>。<\/li><\/ol><h2 id=\"N10551\">在将测试数据导入 WSRR 中<\/h2><p>测试任何示例流之前，需要将一组测试数据导入 WSRR 实例中。此测试数据包含 <strong>Math Service<\/strong> 的表示和一个使用此服务的应用程序，称为 <strong>Calculator Application<\/strong>。使用关系可在一个<strong>服务水平协议<\/strong>（也包含在测试数据中）中找到。 显示了测试数据中的这一关系的总体视图。<\/p><h5 id=\"fig14\">测试数据<\/h5><img alt=\"测试数据\" src=\"/sunshine_new/images/负1870594959/images/TestData.jpg\" width=\"445\" /><div class=\"dw-sidebar ibm-inset\"><h2 id=\"N1056F\">在 Windows 上运行<\/h2><p>本节中列出的命令都假设 WSRR 在 Unix 平台上运行。如果在 Windows 上运行，则需要使用 <code>wsadmin.bat<\/code> 命令和使用反斜杠指定的此命令的相对路径。<\/p><\/div><p>要将测试数据导入 WSRR 中，可执行以下步骤：<\/p><ol><li>打开一个命令窗口。<\/li><li>导航到 <code>&amp;lt;WAS_INSTALL_ROOT&amp;gt;/WSRR/admin/scripts_cell<\/code> 目录。<\/li><li><p>如果 WSRR 实例在 WebSphere Application Server 集群上运行，那么可以执行以下命令：<\/p><p><a href=\"#N10585\" class=\"ibm-popup-link\" onclick=\"ibmweb.overlay.show('N10585',this);return false;\">点击查看代码清单<\/a><\/p><div id=\"N10585\" class=\"dw-sidefile-overlay ibm-common-overlay ibm-overlay-alt-two\"><div class=\"ibm-head\"><p><a href=\"#close\" class=\"ibm-common-overlay-close\">关闭 [x]<\/a><\/p><\/div><div class=\"ibm-body\"><div class=\"ibm-main\"><div class=\"ibm-container ibm-alternate\"><div class=\"ibm-container-body\"><div class=\"codesection\"><pre class=\"displaycode no-auto-overflow\"> &amp;lt;WAS_INSTALL_ROOT&amp;gt;/bin/wsadmin.sh -f importMetadata.jacl -user &amp;lt;USER_ID&amp;gt; -password &amp;lt;PASSWORD&amp;gt; -cluster &amp;lt;CLUSTER_NAME&amp;gt; -filepath &amp;lt;FILE_PATH&amp;gt; -filename MathService_Export.zip<\/pre><\/div><\/div><\/div><\/div><\/div><div class=\"ibm-footer\"><><\/div><\/div><p>如果 WSRR 实例未在 WebSphere Application Server 集群上运行，那么可以执行以下命令：<\/p><p><a href=\"#N1058A\" class=\"ibm-popup-link\" onclick=\"ibmweb.overlay.show('N1058A',this);return false;\">点击查看代码清单<\/a><\/p><div id=\"N1058A\" class=\"dw-sidefile-overlay ibm-common-overlay ibm-overlay-alt-two\"><div class=\"ibm-head\"><p><a href=\"#close\" class=\"ibm-common-overlay-close\">关闭 [x]<\/a><\/p><\/div><div class=\"ibm-body\"><div class=\"ibm-main\"><div class=\"ibm-container ibm-alternate\"><div class=\"ibm-container-body\"><div class=\"codesection\"><pre class=\"displaycode no-auto-overflow\"> &amp;lt;WAS_INSTALL_ROOT&amp;gt;/bin/wsadmin.sh -f importMetadata.jacl -user &amp;lt;USER_ID&amp;gt; -password &amp;lt;PASSWORD&amp;gt; -cell &amp;lt;CELL_NAME&amp;gt; -node &amp;lt;NODE_NAME&amp;gt; -server &amp;lt;SERVER_NAME&amp;gt; -filepath &amp;lt;FILE_PATH&amp;gt; -filename MathService_Export.zip<\/pre><\/div><\/div><\/div><\/div><\/div><div class=\"ibm-footer\"><><\/div><\/div><p>其中：<\/p><ul class=\"ibm-bullet-list\"><li><code>&amp;lt;USER_ID&amp;gt;<\/code> 是 WSRR 管理员的 ID。<\/li><li><code>&amp;lt;PASSWORD&amp;gt;<\/code> 是此用户的密码。<\/li><li><code>&amp;lt;CLUSTER_NAME&amp;gt;<\/code> 是 WAS 集群的名称。<\/li><li><code>&amp;lt;CELL_NAME&amp;gt;<\/code> 是 WAS 单元的名称。<\/li><li><code>&amp;lt;NODE_NAME&amp;gt;<\/code> 是 WAS 节点的名称。<\/li><li><code>&amp;lt;SERVER_NAME&amp;gt;<\/code> 是 WAS 服务器的名称。<\/li><li><code>&amp;lt;FILE_PATH&amp;gt;<\/code> 是 <code>MathService_Export.zip<\/code> 文件的路径。无论在何种平台上执行该命令，都应该使用反斜杠作为路径分隔符。<\/li><\/ul><p>使用该命令的示例如下所示：<\/p><p><a href=\"#N105B1\" class=\"ibm-popup-link\" onclick=\"ibmweb.overlay.show('N105B1',this);return false;\">点击查看代码清单<\/a><\/p><div id=\"N105B1\" class=\"dw-sidefile-overlay ibm-common-overlay ibm-overlay-alt-two\"><div class=\"ibm-head\"><p><a href=\"#close\" class=\"ibm-common-overlay-close\">关闭 [x]<\/a><\/p><\/div><div class=\"ibm-body\"><div class=\"ibm-main\"><div class=\"ibm-container ibm-alternate\"><div class=\"ibm-container-body\"><div class=\"codesection\"><pre class=\"displaycode no-auto-overflow\"> # /opt/IBM/WebSphere/AppServer/profiles/WSRRSrv01/bin/wsadmin.sh -f importMetadata.jacl -user wasadmin -password passw0rd -cell halberdNode01Cell -node halberdNode01 -server server1 -filepath /root -filename MathService_Export.zip<\/pre><\/div><\/div><\/div><\/div><\/div><div class=\"ibm-footer\"><><\/div><\/div><\/li><li><p>测试数据将导入到目标 WSRR 实例中。您会在命令窗口中的控制台输出末尾看到以下消息：<\/p><p><a href=\"#N105B7\" class=\"ibm-popup-link\" onclick=\"ibmweb.overlay.show('N105B7',this);return false;\">点击查看代码清单<\/a><\/p><div id=\"N105B7\" class=\"dw-sidefile-overlay ibm-common-overlay ibm-overlay-alt-two\"><div class=\"ibm-head\"><p><a href=\"#close\" class=\"ibm-common-overlay-close\">关闭 [x]<\/a><\/p><\/div><div class=\"ibm-body\"><div class=\"ibm-main\"><div class=\"ibm-container ibm-alternate\"><div class=\"ibm-container-body\"><div class=\"codesection\"><pre class=\"displaycode no-auto-overflow\"> The entities with the following URIs were imported: [7c94a07c-1917-47ce.bc0a.95e874950a25, 72c3c072-56f7-4735.ba18.3afa1b3a1858] &amp;gt; ServiceRegistryRepository#importMetaData imported URIs: &amp;gt;&amp;gt; 7c94a07c-1917-47ce.bc0a.95e874950a25 &amp;gt;&amp;gt; 72c3c072-56f7-4735.ba18.3afa1b3a1858 &amp;gt; ServiceRegistryRepository#importMetaData completed, successfully.<\/pre><\/div><\/div><\/div><\/div><\/div><div class=\"ibm-footer\"><><\/div><\/div><\/li><\/ol><h3 id=\"N105B9\">修改测试数据中的端点<\/h3><p>本系列文章所提供的测试数据假设您的 IIB 实例被配置为在默认端口 (<em>7800<\/em>) 上监听 HTTP 请求。如果不是这样，则需要修改端点 WSDL 文档来指定正确的端口，然后将修改的文档上传到 WSRR，替换现有文档的内容。您可以使用 <code>mqsireportproperties<\/code> 命令检查目当前配置的端口，如下所示：<\/p><h5 id=\"listing18\">检查 HTTPConnector 端口<\/h5><div class=\"codesection\"><pre class=\"displaycode\"> mqsireportproperties &amp;lt;BROKER_NAME&amp;gt; -e &amp;lt;EXECUTION_GROUP_NAME&amp;gt; -o HTTPConnector -n port<\/pre><\/div><p>其中：<\/p><ul class=\"ibm-bullet-list\"><li><code>&amp;lt;BROKER_NAME&amp;gt;<\/code> 是代理的名称 (Integration Node)。<\/li><li><code>&amp;lt;EXECUTION_GROUP_NAME&amp;gt;<\/code> 是代理的名称 (Integration Node)。<\/li><\/ul><p>如果执行此命令时显示的端口号不是 <em>7800<\/em>，则需要完成以下步骤来修改端点 WSDL 文档，并将它加载到 WSRR 中：<\/p><ol><li>打开 <strong>IBM Integration Toolkit<\/strong>。<\/li><li>打开 <strong>Integration Development<\/strong> 透视图。 <\/li><li>在 <strong>Application Development<\/strong> 视图中，展开 <strong>WSRRIntegrationDemos =&amp;gt; WSDL Definitions<\/strong> -&amp;gt; <strong>http://math.pot.ibm.com<\/strong> 并双击 <strong>MathServerService_EP1.wsdl<\/strong>，如下所示： <h5 id=\"fig15\">打开 WSDL 文件<\/h5><img alt=\"打开 WSDL 文件\" src=\"/sunshine_new/images/负1870594959/images/OpenWSDLfile.jpg\" width=\"385\" /><\/li><li>该文件将在 <strong>WSDL Editor<\/strong> 中打开。指定 URL 中正确的端口号作为 <strong>location<\/strong> 属性。<\/li><li>保存对该文件的更改。<\/li><li>在 Web 浏览器中，登录到您 WSRR 实例的 <strong>Service Registry Dashboard<\/strong>。<\/li><li>更改到 <strong>Development<\/strong> 视图，然后选择 <strong>Overview<\/strong> 页面。<\/li><li>在 <strong>Collection<\/strong> 小部件中选择 <strong>MathService (1.0)<\/strong>，如下所示： <h5 id=\"fig16\">选择 MathService<\/h5><img alt=\"选择 MathService\" src=\"/sunshine_new/images/负1870594959/images/DevOverview.jpg\" width=\"580\" /><\/li><li>您会转到 <strong>Browse<\/strong> 页面上，在该页面中，将会在 <strong>Detail<\/strong> 小部件中显示 <strong>MathService (1.0)<\/strong> 服务版本的详细信息。这是该服务在 WSRR 中的实现（具体讲就是 1.0 版）的一种表示形式。在 <strong>Detail<\/strong>小部件中的 <strong>Artifacts<\/strong> 下，选择 <strong>MathServerService_EP1.wsdl ?(1.0)<\/strong>。<\/li><li><strong>Detail<\/strong> 小部件将被更新，以便显示 <strong>MathServerService_EP1.wsdl ?(1.0)<\/strong> WSDL 文档的详细信息。选择 <strong>Action =&amp;gt; Replace Document...<\/strong>，如下所示： <h5 id=\"fig17\">替换文档<\/h5><img alt=\"替换文档\" src=\"/sunshine_new/images/负1870594959/images/ReplaceDocument.jpg\" width=\"544\" /><\/li><li>此时将会显示一个 <strong>Replace Document<\/strong> 对话框。单击 <strong>Browse...<\/strong>。<\/li><li>在文件系统上找到并选择已修改的 <strong>MathServerService_EP1.wsdl <\/strong> 文档。单击 <strong>Replace Document<\/strong>。<\/li><li>此时将会显示一个 <strong>Warning<\/strong> 对话框。单击 <strong>Yes<\/strong>。<\/li><li><strong>Replace Document<\/strong> 对话框将被更新，以便表示文档已成功替换。单击 <strong>Close<\/strong>。<\/li><\/ol><h2 id=\"calculator_app\">运行 Calculator 应用程序<\/h2><p>calculator.jar 压缩文件中提供了一个客户端应用程序，可在本文底部的 <a href=\"#download\">下载<\/a> 部分下载获得该应用程序。它是一个调用 Math Service 的基于 SWING 的简单 Java 应用程序。运行 Calculator 应用程序并验证 IIB 环境是否已正确配置：<\/p><ol><li>打开一个命令窗口。<\/li><li>执行以下命令： <div class=\"codesection\"><pre class=\"displaycode\">java -jar &amp;lt;CALCULATOR_JAR_PATH&amp;gt;<\/pre><\/div><br /> 其中： <ul class=\"ibm-bullet-list\"><li><code>&amp;lt;CALCULATOR_JAR_PATH&amp;gt;<\/code> 是 <strong>calculator.jar<\/strong> 文件的完整路径。<\/li><\/ul> 此命令假设该 Java 代码位于您环境中的正确路径上。如果不是，则需要指定您的 Java 可执行文件的完整路径。<\/li><li>Calculator 应用程序打开后，为运行 IIB 的服务器指定合适的主机名和端口号。<\/li><li>修改该服务的路径，将它的值设置为 /MathServer1/services/MathServer，这是实际的 Math Service 的路径，它将验证实现该服务的流是否已成功构建并部署到 IIB 中。<\/li><li>指定一些值并在下拉列表中指定一个合适的运算符（+、-、/、*），然后单击 <strong>=<\/strong>。Calculator 应用程序将调用 Math Service 并显示指定的运算的结果。它应类似于： <h5 id=\"fig18\">Calculator 应用程序<\/h5><img alt=\"Calculator 应用程序\" src=\"/sunshine_new/images/负1870594959/images/CalculatorApplication1.jpg\" width=\"466\" /><\/li><li>修改该服务的路径，将它的值设置为 /MathServer/services/MathServer/eplookup1，这是基本的端点查找消息流的路径。它将验证 IIB 能否与目标 WSRR 实例进行通信。<\/li><li>单击 <strong>=<\/strong>。来自 Calculator 应用程序的服务请求将由基本的端点查找消息流路由到 Math Service。您会看到与直接调用 Math Service 相同的结果。<\/li><\/ol><h2 id=\"N106A1\">结束语<\/h2><p>本文介绍了一些可通过集成 IIB 和 WSRR 来解决的业务问题。文中提供了一些解决这些业务问题的示例消息流，还介绍了在 IIB 和 WSRR 环境中正常运行它们的过程。本系列的其余文章将会详细介绍每种消息流，解释如何实现每个消息流来实现想要的目标。<\/p><h2 id=\"N106A8\">致谢<\/h2><p>感谢以下人员帮助开发本系列中的示例消息流：<\/p><ul class=\"ibm-bullet-list\"><li>John Hosie<\/li><li>Ben Thompson<\/li><li>Matt Golby-Kirk<\/li><li>Trevor Dolby<\/li><li>Andreas Martens<\/li><li>Graham Haxby<\/li><li>Andrew Coleman<\/li><li>John Reeve<\/li><\/ul><p>还要感谢以下人员帮助审阅本文：<\/p><ul class=\"ibm-bullet-list\"><li>David Seager<\/li><li>Arnauld Desprets<\/li><li>Anna Maciejkowicz<\/li><\/ul><CMA ID: 974158><Site ID: 10><XSLT stylesheet used to transform this file: dw-document-html-7.0.xsl>\r\n<h2 id=\"download\">下载<\/h2><table class=\"ibm-data-table dw-download-table\" cellpadding=\"0\" cellspacing=\"0\" border=\"0\"><thead><tr><th scope=\"col\">描述<\/th><th scope=\"col\">名字<\/th><th scope=\"col\">大小<\/th><\/tr><\/thead><tbody><tr><th scope=\"row\" class=\"ibm-table-row\">代码示例<\/th><td nowrap=\"nowrap\"><a href=\"http://www.ibm.com/developerworks/apps/download/index.jsp?contentid=974158&amp;filename=Calculator.zip&amp;method=http&amp;locale=zh_CN\">Calculator.zip<\/a><\/td><td nowrap=\"nowrap\">25 KB<\/td><\/tr><tr><th scope=\"row\" class=\"ibm-table-row\">代码示例<\/th><td nowrap=\"nowrap\"><a href=\"http://www.ibm.com/developerworks/apps/download/index.jsp?contentid=974158&amp;filename=MathServiceExport.zip&amp;method=http&amp;locale=zh_CN\">MathServiceExport.zip<\/a><\/td><td nowrap=\"nowrap\">55 KB<\/td><\/tr><tr><th scope=\"row\" class=\"ibm-table-row\">代码示例<\/th><td nowrap=\"nowrap\"><a href=\"http://www.ibm.com/developerworks/apps/download/index.jsp?contentid=974158&amp;filename=WSRRIntegrationDemos.zip&amp;method=http&amp;locale=zh_CN\">WSRRIntegrationDemos.zip<\/a><\/td><td nowrap=\"nowrap\">304 KB<\/td><\/tr><\/tbody><\/table>\r\n\r\n<\/div>\r\n<\/div>\r\n","createTime":"2014-06-11 00:00:00","deployTime":"2014-06-11 00:00:00","id":0,"intro":"IBM Integration Bus (IIB) 通过 Endpoint Lookup 和 Registry Lookup 节点提供了与 WebSphere Service Registry and Repository (WSRR) 的开箱即用的集成。使用这些节点，您可以在 IIB 中实现消息流，动态地从 WSRR 中检索服务元数据，并在运行时使用这些数据来修改消息流行为。但是，这两个产品之间的集成可扩展到 Endpoint Lookup 和 Registry Lookup 节点以外。本系列文章详细介绍这两个产品之间的集成，并提供了一些示例来演示一些重要业务问题的解决方案。","keyword":"","recommend":false,"source":"http://www.ibm.com/developerworks/cn/websphere/library/techarticles/1404_smithson1/1404_smithson1.html","title":"集成 IBM Integration Bus 与 WebSphere Service Registry and Repository: 第 1 部分：场景和配置","typeId":0,"updateTime":"2014-06-11 00:00:00"}
{"author":"","clickNumber":0,"content":"\r\n<div class=\"ibm-columns\">\r\n<div class=\"ibm-col-1-1\">\r\n\r\n<div class=\"dw-sidebar ibm-inset\"><p>下载 <a href=\"http://www.ibm.com/developerworks/cn/downloads/r/rcq/index.html\">Rational ClearQuest<\/a> 试用版，提前体验它的强大功能！<\/p><\/div><h2 id=\"1.CQ 和 CALM 集成环境中如何应对 CALM 服务器重命名 |outline\">CQ 和 CALM 集成环境中如何应对 CALM 服务器重命名<\/h2><a id=\"OLE_LINK2\"><\/a><a id=\"OLE_LINK1\"><\/a><p>对服务器的更名和数据的迁移，CALM 提供了服务器重命名功能。重命名之后为了保证 CQ 和 CALM 的集成可以继续运作，历史数据可以继续访问，新集成数据可以被成功创建，CQ 需要进行一些应对的操作。<\/p><h3 id=\"N10089\">CALM 服务器重命名介绍<\/h3><p>在安装完 CALM 并进行配置后，一般会生成一些公共的 URL 供用户访问。<\/p><h5 id=\"N10091\">图 1. CALM 中的主要的公共 URL<\/h5><img alt=\"CALM 中的主要的公共 URL\" src=\"/sunshine_new/images/1526737589/image002.jpg\" width=\"540\" /><p>每个公共的 URL 都提供了对不同数据的访问，服务器重命名操作就是要对这些 URL 进行更改。而这些操作都会用到 repotools-jts 这个工具，它保存在以下路径：<\/p><div class=\"codesection\"><pre class=\"displaycode\">/IBM/JazzTeamServer/server<\/pre><\/div><p><strong>第一步：用 repotools-jts 工具生成 url 映射文件<\/strong><\/p><p>调用以下命令：<\/p><div class=\"codesection\"><pre class=\"displaycode\">repotools-jts -generateURLMappings toFile=&lt;mappingfilepath&gt; \\\n   adminUserId=&lt;username&gt; adminPassword=&lt;password&gt;<\/pre><\/div><p>toFile 参数值指向要生成的 url 映射文件的全路径。<\/p><h5 id=\"N100AE\">图 2. 生成的 url 映射文件<\/h5><img alt=\"生成的 url 映射文件\" src=\"/sunshine_new/images/1526737589/image003.jpg\" width=\"563\" /><p>上述映射文件中当前和目标的 url 地址中的主机名是一样的，我们需要手动把目标地址中的主机名更新成新的并保存文件。<\/p><p><strong>第二步：验证新的映射文件<\/strong><\/p><p>调用以下命令：<\/p><div class=\"codesection\"><pre class=\"displaycode\">repotools-jts -verifyURLMappings  mappingFile=&lt;mappingfilepath&gt;\nadminUserId=&lt;username&gt; adminPassword=&lt;password&gt;<\/pre><\/div><p><strong>第三步：停止所有要被重命名的应用服务器<\/strong><\/p><p>停止响应的应用服务器后，需要下载一个激活秘钥文件，用以触发服务器重命名操作。秘钥文件需要保存在和 repotools-jts 工具同一级的目录下。<\/p><p>注：激活秘钥的获取请联系销售团队。<\/p><p><strong>第四步：执行服务器重命名操作<\/strong><\/p><div class=\"codesection\"><pre class=\"displaycode\">repotools-jts -importURLMappings fromFile=&lt;absolute directory path&gt;/jpimapping.txt<\/pre><\/div><p><strong>注<\/strong>：上述命令中请提供之前修改的映射文件的绝对地址。<\/p><p><strong>第五步：更改 hosts 文件并重启应用服务器<\/strong><\/p><p>打开操作系统中的 hosts 文件，Windows 中文件存储在 C:\\Windows\\System32\\drivers\\etc；linux 中文件路径是/etc/hosts<\/p><p>把文件中的主机名和 IP 地址的映射更新成新的，然后重新启动应用服务器。<\/p><p><strong>第六步：完成后续的重命名操作<\/strong><\/p><p>启动应用服务器后，打开浏览器访问以下 url 查看重命名操作的进度<\/p><div class=\"codesection\"><pre class=\"displaycode\">https:// &lt;newhostname&gt;:9443/jts/serverRenameStatus<\/pre><\/div><h5 id=\"N100E7\">图 3. 重命名操作的进度<\/h5><img alt=\"重命名操作的进度\" src=\"/sunshine_new/images/1526737589/image005.jpg\" width=\"582\" /><p>当以上进度都显示 100%后，按照左侧的步骤去验证不同 domain 中数据访问的正确性，每验证一个 domain 就点击验证完成。全部验证结束后，需要对数据进行解锁。服务器重命名功能会在用户手动解锁前，先把数据创建操作锁住。<\/p><h5 id=\"N100F5\">图 4. 解锁 Jazz 应用和服务器<\/h5><img alt=\"解锁 Jazz 应用和服务器\" src=\"/sunshine_new/images/1526737589/image007.jpg\" width=\"581\" /><p>到现在 CALM 服务器重命名操作完成。<\/p><h3 id=\"N10102\">CQ 应对操作<\/h3><p><strong>第一步：更改 CQ 操作系统上的 hosts 文件<\/strong><\/p><p>由于在 CQ 和 CALM 集成的配置中需要在双方的操作系统 hosts 文件中填写对方主机名和 IP 的映射信息，现在 CALM 的主机名更新了，所以要在 CQ 机器上的 hosts 文件中做相应的更新。<\/p><p><strong>第二步：更新 CQ 机器上集成映射文件的信息<\/strong><\/p><p>CQ 机器上会有三个文件保存和 CALM 的映射信息，friendsconfig.rdf, project-area-links.rdf, oauth-consumers.rdf。这三个文件都存储在以下路径：<\/p><div class=\"codesection\"><pre class=\"displaycode\">C:\\&lt;WebSphere_Profiles_Path&gt;\\&lt;AppServerInstalledCQWeb&gt;\\installedApps\\&lt;Cellname&gt;\n\\TeamEAR.ear\\cqweb.war\\WEB-INF\\classes<\/pre><\/div><p>为了对这三个文件进行更新 CQ 也提供了一个工具 clm_server_rename.pl，这个 perl 脚本提供了应对 CALM 服务器重命名的 CQ 操作。这个 perl 文件和上述三个映射文件存储在同一路径下。<\/p><p>运行以下命令：<\/p><div class=\"codesection\"><pre class=\"displaycode\">cqperl clm_server_rename.pl -username admin -password secret -dbset 8.0.1 -dbname SAMPL \\\n-oldprefix https://clmhost.example.com/ccm/ -newprefix\nhttps://ServerRename.example.com/ccm/ \\\n-remapconfigfiles<\/pre><\/div><p>命令中 dbset 是指登陆 CQ 用的 connection 名称；dbname 是用户数据库名称；oldprefix 是 CALM 重命名前的 url 地址；newprefix 是 CALM 的新地址。<\/p><p>注：提供的 CALM 地址是根据 domain 不同的，也就是说如果 CQ 已经和 RTC 进行了集成，可以对 https://&lt;hostname&gt;:9443/ccm 进行映射更新。如果 CQ 和 RTC/RQM/RRC 都进行了集成，那就需要调用上述命令三次，每次分别提供不同 CALM 产品的 url 地址。<\/p><p>命令运行输出：<\/p><p>Started: Remapping URIs in config file friendsconfig.rdf.<\/p><p>Completed: Remapping URIs in config file friendsconfig.rdf.<\/p><p>Started: Remapping URIs in config file project-area-links.rdf.<\/p><p>Completed: Remapping URIs in config file project-area-links.rdf.<\/p><p>Started: Remapping URIs in config file oauth-consumers.rdf.<\/p><p>Completed: Remapping URIs in config file oauth-consumers.rdf.<\/p><p><strong>第三步：对已经集成的数据连接进行更新<\/strong><\/p><p>第二步中是对映射文件的更新，集成环境中很可能已经配置了一些集成数据，对于这些数据也需要更新 CALM 链接地址。首先需要重新启动 CQWeb 安装的应用服务器，然后可以在 CQWeb 右上角中的 site administration 看到更新后的 CALM 链接信息。然后运行以下命令：<\/p><div class=\"codesection\"><pre class=\"displaycode\">cqperl clm_server_rename.pl -username admin -password secret -dbset 8.0.1 -dbname SAMPL\n    -oldprefix https://clmhost.example.com/ccm/ -newprefix\n    https://ServerRename.example.com/ccm/ -update<\/pre><\/div><p>这里命令同样是对一个集成产品的信息更新，如果 CQ 和多个产品集成需要运行上述命令多次。<\/p><p>这样就完成了 CQ 中应对 CALM 服务器重命名的所有操作。<\/p><h2 id=\"2.OSLC 负载均衡环境中的 CQ 和 CALM 集成配置 |outline\">OSLC 负载均衡环境中的 CQ 和 CALM 集成配置<\/h2><p>CQ 负载均衡下支持 OSLC 的集成是在 CQ 8.0.1.1 版本。由于有多种产品可以做负载均衡器，本文中只介绍使用 IBM HttpServer 在做负载均衡。准备的环境描述如下：<\/p><ul class=\"ibm-bullet-list\"><li>两个 CQ Web Server/CM Server<ul class=\"ibm-bullet-list\"><li>两个应用服务器安装了 CQ Web 和 CM Server<\/li><\/ul><\/li><li>1 个 IBM Http Server<ul class=\"ibm-bullet-list\"><li>作为负载均衡器<\/li><\/ul><\/li><\/ul><p>机器描述如下：<\/p><ul class=\"ibm-bullet-list\"><li>机器 1(负载均衡器)：CQ, IBM HttpServer, CM Server, WebSphere Application Server (IHS 已经通过 WAS\n    plugin 配置集成，也就是说用户可以通过 http://hostname/cqweb 来访问 CQ)<\/li><li>机器 2：CQ, IBM HttpServer(停掉服务不用)，CM Server, WebSphere Application Server<\/li><\/ul><h3 id=\"N10154\">配置负载均衡环境<\/h3><p><strong>第一步：修改 server.xml 文件<\/strong><\/p><p>找到两台机器上的 server.xml 文件，server.xml 文件在以下路径：<\/p><div class=\"codesection\"><pre class=\"displaycode\">C:\\WebSphere\\AppServer\\profiles\\&lt;AppServerName&gt;\\config\\cells\\&lt;CellName&gt;\n\\nodes\\&lt;NodeName&gt;\\servers\\server1\\server.xml<\/pre><\/div><p>例如：<\/p><div class=\"codesection\"><pre class=\"displaycode\">C:\\IBM\\WebSphere\\AppServer\\profiles\\AppSrv01\\config\\cells\\WIN-AG6F01JODHMNode01Cell\\nodes\n\\WIN-AG6F01JODHMNode01\\servers\\server1\\server.xml<\/pre><\/div><p>找到包含 WebContainer 信息的部分，例如：<\/p><div class=\"codesection\"><pre class=\"displaycode\">&lt;components xmi:type=\"applicationserver.webcontainer:WebContainer\" xmi:id=\"webcontainer_1225386837920\" …&gt;<\/pre><\/div><p>为 Components 这个元素添加一个属性：<\/p><div class=\"codesection\"><pre class=\"displaycode\">&lt;properties xmi:id=\"Property_1225386837920\" name=\"HttpSessionCloneId\" value=\"2137\" required=\"false\"/&gt;<\/pre><\/div><p>注 1：添加的属性中数字 1225386837920 是要和 WebContainer 中的 xmi:id 的数字吻合的<\/p><p>注 2：添加的属性中 value 的值 server137 是一个唯一的标识，会被后面的配置步骤引用为 CloneID.<\/p><p>保存 server.xml 的修改，重启 WebSphere Application Server。<\/p><p><strong>第二步：修改 plugin-cfg.xml<\/strong><\/p><p>这里只需要修改机器 1 上的这个文件，也就是作为负载均衡器的 IHS 所在的机器。这个文件一般保存在 C:\\IBM\\WebSphere\\Plugins\\config\\webserver1。<\/p><p>打开文件并找到 ServerCluster 段落，例如：<\/p><div class=\"codesection\"><pre class=\"displaycode\">&lt;ServerCluster Name=\"cmprofile_Cluster\"&gt; <br />&lt;Server Name=\"server1\"&gt; \n&lt;Transport Hostname=\"localhost\" Port=\"12080\" Protocol=\"http\"/&gt; &lt;/Server&gt;\n &lt;/ServerCluster&gt;<\/pre><\/div><p>直接用类似以下内容覆盖这个段落：<\/p><div class=\"codesection\"><pre class=\"displaycode\">&lt;ServerCluster CloneSeparatorChange=\"false\" LoadBalance=\"Round Robin\" \n   Name=\"server1_WIN-AG6F01JODHMNode01_Cluster_0\" RetryInterval=\"60\"&gt;\n&lt;Server CloneID=\"2137\" ConnectTimeout=\"20\" LoadBalanceWeight=\"1\" Name=\"server137\"&gt;\n&lt;Transport Hostname=\"cqoslc137\" Port=\"9080\" Protocol=\"http\"/&gt;\n&lt;Transport Hostname=\"cqoslc137\" Port=\"9443\" Protocol=\"https\"&gt;\n&lt;Property Name=\"keyring\" Value=\"C:\\IBM\\HTTPServer\\key.kdb\"/&gt;\n&lt;Property Name=\"stashfile\" Value=\"C:\\IBM\\HTTPServer\\key.sth\"/&gt;\n&lt;/Transport&gt;\n&lt;/Server&gt;\n&lt;Server CloneID=\"2150\" ConnectTimeout=\"20\" LoadBalanceWeight=\"2\" Name=\"server150\"&gt;\n&lt;Transport Hostname=\"cqoslc150\" Port=\"9080\" Protocol=\"http\"/&gt;\n&lt;Transport Hostname=\"cqoslc150\" Port=\"9443\" Protocol=\"https\"/&gt;\n&lt;/Server&gt;\n&lt;PrimaryServers&gt;\n&lt;Server Name=\"server137\"/&gt;\n&lt;Server Name=\"server150\"/&gt;\n&lt;/PrimaryServers&gt;\n&lt;/ServerCluster&gt;<\/pre><\/div><p>注：CloneID 是要和 server.xml 中定义的 value 值一致的；hostname 必须是可识别的，也就是 hosts 文件中定义了主机名和 ip 的映射。<\/p><p><strong>第三步：测试负载均衡是否成功<\/strong><\/p><p>这里介绍一种简单的办法测试负载均衡，使用浏览器 Firefox 中的插件 Firebug。安装 Firebug 后，启动并为页面加载所有 console。然后访问机器 1 的 cqweb 地址：<\/p><div class=\"codesection\"><pre class=\"displaycode\">http://机器 1/cqweb<\/pre><\/div><p>在 server.xml 中我们定义了 CloneID 值，同样也是 HttpSessionCloneId 值。<\/p><p>在 firebug 中我们可以看到下面的信息 JSESSIONID 信息表明目前负载均衡已经把信息发送给哪一个 CQ CM Server。<\/p><h5 id=\"N1019D\">图 5.\n    Firebug 中的 JSESSIONID 信息<\/h5><img alt=\"Firebug 中的 JSESSIONID 信息\" src=\"/sunshine_new/images/1526737589/image008.jpg\" width=\"593\" /><p>多次访问 cqweb 链接会发现 JSESSIONID 的变化，说明负载均衡配置成功。<\/p><h3 id=\"N101AA\">SSL 模式的负载均衡环境<\/h3><p>在第一篇中我们提到了 CQ 和 CALM 集成需要 CQ 启动 SSL 模式，所以我们要在上面配置好的环境中启动 SSL。<\/p><p>单个机器安装 IHS 是可以通过简单配置启动 https 的，但是现在是负载均衡环境，环境中有两台以上的几点安装了 CQ，所以需要把 IHS 负载均衡器所在的节点以外的节点上的 WebSphere Application Server 的密钥证书注册到负载均衡器所在节点的密钥数据库中，这样可以负载均衡器的 IHS 可以辨认多个节点来使用 https 协议。<\/p><p><strong>第一步：配置机器 1 上的 SSL<\/strong><\/p><p>此部分参考上一部分中配置 CQ SSL 部分。<\/p><p><strong>第二步：为每个节点抽取个人证书<\/strong><\/p><p>在机器 1 和机器 2 上分别打开 ikeyman 工具，开始菜单?HttpServer?Start key management utility，选择左上角的密钥数据库文件，单击打开。<\/p><p>在密钥数据库类型字段中选择 PKCS12，单击浏览寻找 root-key.12 文件。这个文件保存在 C:\\IBM\\WebSphere\\AppServer\\profiles\\AppSrv01\\config\\cells\\WIN-AG6F01JODHMNode01Cell\\nodes\\WIN-AG6F01JODHMNode01。<\/p><p>单击确定后输入密码 WebAS，打开根密钥库文件。在个人证书下选择缺省证书。单击抽取证书，输入名称。(建议以机器名或 ip 地址为名称方便记录)，然后保存文件。<\/p><p><strong>第三步：把节点证书导入到密钥库文件中<\/strong><\/p><p>在机器 1 上，用 ikeyman 工具打开第一步中创建的新的密钥库文件 key.kdb，选择 CMS 作为密钥库类型。在签署证书列表中，&#160;\"添加\"第二步中导出的两个证书文件。<\/p><p><strong>第四步：修改 plugin-cfg.xml 文件<\/strong><\/p><p>在机器 1 上，&#160;打开 C:\\IBM\\WebSphere\\Plugins\\config\\webserver1\\plugin-cfg.xml 文件，找到以下段落，并把 key.kdb, key,sth 文件的路径换成第一步中新生成的文件路径。最后重新启动 IHS，SSL 模式生效。<\/p><h2 id=\"3.总结 |outline\">总结<\/h2><p>本文中主要针对两种复杂的使用场景(CALM 服务器重命名和负载均衡)中 CQ 和 CALM 的集成特点进行了描述，更加深入和贴近用户实际使用场景。<\/p><CMA ID: 973694><Site ID: 10><XSLT stylesheet used to transform this file: dw-document-html-7.0.xsl>\r\n\r\n\r\n<\/div>\r\n<\/div>\r\n","createTime":"2014-06-11 00:00:00","deployTime":"2014-06-11 00:00:00","id":0,"intro":"在集成的第一篇文章中我们讲述了基本的集成功能点，在本文中将介绍集成环境下 ClearQuest 如何应对 CALM 的服务器重命名功能，以及 ClearQuest 最新支持的 OSLC 集成环境下的负载均衡功能。","keyword":"","recommend":false,"source":"http://www.ibm.com/developerworks/cn/rational/1406_lianglu_cq8new4/index.html","title":"Rational ClearQuest V8.0.1 新功能: 与 IBM CALM 产品的集成：第 2 部分","typeId":0,"updateTime":"2014-06-11 00:00:00"}
{"author":"","clickNumber":0,"content":"\r\n<div class=\"ibm-columns\">\r\n<div class=\"ibm-col-1-1\">\r\n\r\n<h2 id=\"2.开源 HadoopHDFS 的高可用性介绍 |outline\">开源 Hadoop HDFS 的高可用性介绍<\/h2><p>Hadoop 是目前最热门的大数据计算系统，它实现了一个可扩展的分布式文件系统 HDFS 作为海量数据的存储系统。HDFS 是主从式的分布式系统（如图 1），NameNode 管理整个文件系统的元数据，负责数据的分配，并管理着 DataNode；而 DataNode 负责存储数据块，按块（用户可设置，默认是 64MB）提供数据存取服务。<\/p><p>HDFS 的客户端进行读写操作都需要通过 NameNode。在读操作时，客户端需要连接 NameNode，获取数据块所在的 DataNode，再连接 DataNode\n    进行数据块的读取；在写操作时，客户端需要连接 NameNode，得到 NameNode 分配的数据写入位置后，连接相应的 DataNode\n    写入数据；在进行元数据操作时，客户端需要连接 NameNode 进行修改（如图 1）。在早前的 Hadoop 集群中，NameNode 只有一个，它是否正常运行，直接决定了整个 Hadoop 集群能否正常运转，进而会影响工作于 Hadoop 集群之上的 HBase、Hive、Pig 等服务的工作。 因此 NameNode 也就成为了系统的一个单一故障点，NameNode 的可用性关系到集群系统的可用性。如果 NameNode 的元信息由于故障损坏，更会导致整个分布式文件系统损坏。<\/p><h5 id=\"N10077\">图 1.HDFS 的架构及读写流程<\/h5><img alt=\"HDFS 的架构及读写流程\" src=\"/sunshine_new/images/负664846767/image003.gif\" width=\"509\" /><h2 id=\"3.HDFS 高可用性的种类以及优缺点 |outline\">HDFS 高可用性的种类以及优缺点<\/h2><p>为了提高整个集群的可靠性与可维护性，各大公司与社区提出了许多改进 HDFS 的方案，主要有如下几种：<\/p><p>NameNode 多目录存储：通过配置 dfs.name.dir，可以 NameNode 维护的元数据保存到多个目录，进而可以备份一份到远程的 NFS 目录，当 NameNode 故障或停机时，可以通过另外一台 NameNode 读取 NFS 目录中的备份进行恢复工作。不足之处在于写入 NFS 增加了系统开销，不利于 NameNode 高效工作；并且需要管理员手工进行操作。由于在恢复过程中存在一段系统不可用的时间，该方案只是一种备份方案，并不是真正意义上的 HA 方案。<\/p><p>Secondary NameNode：Secondary NameNode 通过定期下载 NameNode 的元数据和日志文件，并进行合并更新，来对 NameNode 进行备份。当 NameNode 故障时，可以通过 Secondary NameNode 进行恢复。不足之处在于 Secondary NameNode 的备份只是 NameNode 的 Checkpoint，并没有与 NameNode 实时同步，恢复后的数据存在一定的元信息丢失。由于在恢复过程中存在一段系统不可用的时间，该方案只是一种备份方案，并不是真正意义上的 HA 方案。<\/p><p>Checkpoint Node：与 Secondary NameNode 的原理基本相同，利用了 HDFS 的 Checkpoint 机制进行备份，通过一个 Checkpoint Node，定期从 Primary NameNode 中下载元数据信息进行合并，形成最新的 Checkpoint，并上传到 NameNode 进行更新不足之处在于 Checkpoint 的备份没有与 NameNode 实时同步，恢复后的数据存在一定的元信息丢失。由于在恢复过程中存在一段系统不可用的时间，该方案只是一种备份方案，并不是真正意义上的 HA 方案。<\/p><p>Backup Node：Backup Node 在内存和磁盘保存了 NameNode 最新的元数据。当 NameNode 发生故障，可用读取 Backup Node 中最新的元数据信息进行恢复。 该方案只是的不足在于当 NameNode 发生故障，目前还只能通过重启 NameNode 的方式来恢复服务，系统会出现一段不可用时间。<\/p><p>FaceBook 的 AvatarNode：存在两个 NameNode，分别为 Active Node 和 Standby Node，Active Node 对外提供服务。Standby Node 处于 Safe mode，在内存中保存 Active Node 最新的元数据信息。Active Node 和 Standby Node 通过共享的 NFS 进行交互，DataNode 同时向 Active Node 和 Standby Node 汇报数据块信息。当 Active Node 故障时，管理员通过一条命令进行切换，Standby Node 转换为 Active Node 后立刻就可以工作，大大减少了系统不可用的时间，是一种真正的 HA 方案。不足之处在于该方案最终没有被社区接受。<\/p><p>社区开发的 HDFS HA：与 AvatarNode 类似，存在 Active Node 和 Standby Node 两个 NameNode， 管理员通过一条命令进行切换。针对 Active Node 和 Standby Node 的共享日志，社区又提供三种解决方案：<\/p><ol type=\"1\"><li>两个 Node 共享 NAS 上的 NFS，是社区最初的解决方案，该方案需要专用存储设备，在使用上有一定限制。<\/li><li>基于 Bookkeeper 的日志存储方案，该方案主要依靠 Zookeeper 的子项目 Bookkeeper 实现日志的高可靠共享存储，该方案对 Zookeeper 依赖较大，配置比较复杂。<\/li><li>基于 QJM（Qurom Journal Manager）的共享日志方案。QJM 的基本原理就是用 2N+1 台 Journal Node 存储日志，每次写数据操作有大多数（W&gt;=N+1）返回成功时，就认为该次写入日志成功。该方案独立性好，配置比较简单，是社区目前主推的方案。在手动切换的基础上，社区又开发了基于 Zookeeper 的 ZKFC（Zookeeper Failover Controller）自动切换解决方案，每个 Active Node 和 Standby Node 各有一个 ZKFC 进程监控 NameNode 的健康状况，当 Active Node 出现问题时，自动 Standby Node 切换为 Active Node。<\/li><\/ol><h2 id=\"4.PLinux 对于 Hadoop 的支持 |outline\">PLinux 对于 Hadoop 的支持<\/h2><p>随着开源开发平台的迅猛发展，Linux 用户正面临着企业转型升级所带来的 IT 挑战。作为服务器领域创新的引领者，IBM 推出了\"Project CAMP\"。它通过将 VAD(增值分销商)合作伙伴的软件预装在 PowerLinux 服务器上，帮助用户降低 Power 平台的使用成本以及 PowerVM 虚拟化的技术门槛。<\/p><p>当前 IBM CAMP 服务器上安装 PLinux 操作系统，在 PLinux 上使用 IBM JDK1.6 或者 JDK1.7，开源 Hadoop 对其支持。本文将详细描述基于 PRedhat6.4，IBM JKD1.7 上配置 Hadoop HDFS 的 HA。<\/p><h2 id=\"5.PLinux 系统上 HadoopHDFSHA 的配置 |outline\">PLinux 系统上 Hadoop HDFS HA 的配置<\/h2><h3 id=\"N100AB\">PLinux 的环境准备<\/h3><p>硬件信息列表：<\/p><table border=\"0\" cellpadding=\"0\" cellspacing=\"0\" class=\"ibm-data-table\" summary=\"\"><thead xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"><tr><td style=\"vertical-align:top\"><code><strong>主机<\/strong><\/code><\/td><td style=\"vertical-align:top\"><code><strong>主机名<\/strong><\/code><\/td><td style=\"vertical-align:top\"><code><strong>系统 ip 地址 1<\/strong><\/code><\/td><td colspan=\"2\" style=\"vertical-align:top\"><code><strong>配置<\/strong><\/code><\/td><td style=\"vertical-align:top\"><code><strong>调整后 CPU<\/strong><\/code><\/td><td style=\"vertical-align:top\"><code><strong>硬盘<\/strong><\/code><\/td><\/tr><\/thead><tbody xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"><tr><td rowspan=\"3\" style=\"vertical-align:middle\">\nCAMP_1\n<\/td><td style=\"vertical-align:middle\">\nCAMP_1_vios\n<\/td><td style=\"text-align:right; vertical-align:middle\">\n10.10.10.23\n<\/td><td rowspan=\"3\" style=\"vertical-align:middle\">\n8C/64G\n<\/td><td colspan=\"2\" style=\"vertical-align:middle\">\n1C\n<\/td><td style=\"text-align:right; vertical-align:middle\">\n2*900\n<\/td><\/tr><tr><td style=\"vertical-align:middle\">\nplinux9\n<\/td><td style=\"text-align:right; vertical-align:middle\">\n10.10.10.24\n<\/td><td colspan=\"2\" style=\"vertical-align:middle\"><strong>3.5C<\/strong><\/td><td style=\"text-align:right; vertical-align:middle\">\n2*900\n<\/td><\/tr><tr><td style=\"vertical-align:middle\">\nplinux10\n<\/td><td style=\"text-align:right; vertical-align:middle\">\n10.10.10.25\n<\/td><td colspan=\"2\" style=\"vertical-align:middle\"><strong>3.5C<\/strong><\/td><td style=\"text-align:right; vertical-align:middle\">\n2*900\n<\/td><\/tr><tr><td rowspan=\"3\" style=\"vertical-align:middle\">\nCAMP_2\n<\/td><td style=\"vertical-align:middle\">\nCAMP_2_vios\n<\/td><td style=\"text-align:right; vertical-align:middle\">\n10.10.10.26\n<\/td><td rowspan=\"3\" style=\"vertical-align:middle\">\n8C/64G\n<\/td><td colspan=\"2\" style=\"vertical-align:middle\">\n1C\n<\/td><td style=\"text-align:right; vertical-align:middle\">\n2*900\n<\/td><\/tr><tr><td style=\"vertical-align:middle\">\nplinux11\n<\/td><td style=\"text-align:right; vertical-align:middle\">\n10.10.10.27\n<\/td><td colspan=\"2\" style=\"vertical-align:middle\"><strong>3.5C<\/strong><\/td><td style=\"text-align:right; vertical-align:middle\">\n2*900\n<\/td><\/tr><tr><td style=\"vertical-align:middle\">\nplinux12\n<\/td><td style=\"text-align:right; vertical-align:middle\">\n10.10.10.28\n<\/td><td colspan=\"2\" style=\"vertical-align:middle\"><strong>3.5C<\/strong><\/td><td style=\"text-align:right; vertical-align:middle\">\n2*900\n<\/td><\/tr><\/tbody><\/table><p>两台 IBM CAMP 服务器，每台服务器上各有两个 PLinux 分区。<\/p><p>软件信息列表：<\/p><table border=\"0\" cellpadding=\"0\" cellspacing=\"0\" class=\"ibm-data-table\" summary=\"\"><thead xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"><tr><th style=\"vertical-align:top\">\n软件\n<\/th><th style=\"vertical-align:top\">\n版本号\n<\/th><\/tr><\/thead><tbody xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"><tr><td style=\"vertical-align:middle\">\n操作系统\n<\/td><td style=\"vertical-align:middle\">\nRed Hat Enterprise Linux Server release 6.4 (Santiago)\n<\/td><\/tr><tr><td style=\"vertical-align:middle\">\nHadoop\n<\/td><td style=\"vertical-align:middle\">\nVersion 2.2.0\n<\/td><\/tr><tr><td style=\"vertical-align:middle\">\nHbase\n<\/td><td style=\"vertical-align:middle\">\nVersion 0.96\n<\/td><\/tr><tr><td style=\"vertical-align:middle\">\nJAVA\n<\/td><td style=\"vertical-align:middle\">\nibm-java-sdk-7.0-4.2-ppc64-archive\n<\/td><\/tr><tr><td style=\"vertical-align:middle\">\nZooKeeper\n<\/td><td style=\"vertical-align:middle\">\nVersion 3.3.0\n<\/td><\/tr><tr><td style=\"vertical-align:middle\">\nHive\n<\/td><td style=\"vertical-align:middle\">\nVersion 0.12\n<\/td><\/tr><\/tbody><\/table><h5 id=\"N10182\">图 2 .Hadoop 开源组件结构图<\/h5><img alt=\"图 2 .Hadoop 开源组件结构图\" src=\"/sunshine_new/images/负664846767/image005.jpg\" width=\"442\" /><p>本文使用了以上开源组件: Hadoop、HBase、Hive 以及 ZooKeeper。<\/p><h5 id=\"N10191\">图 3.HDFS HA 系统结构图<\/h5><img alt=\"HDFS HA 系统结构图\" src=\"/sunshine_new/images/负664846767/image007.jpg\" width=\"575\" /><p>四个 PLinux 分区分别是 plinux09、plinux10、plinux11、plinux12.<\/p><p>NameNode: plinux09、plinux10<\/p><p>DataNode: plinux09、plinux10、plinux11、plinux12<\/p><p>ZooKeeper: plinux09、plinux10、plinux11<\/p><p>HBase: plinux10<\/p><p>Hive: plinux09<\/p><h3 id=\"N101A8\">HDFS HA 的配置步骤：<\/h3><p>本文详解 <a href=\"http://blog.csdn.net/duheaven/article/details/17038679\">HDFS 利用 QJM 实现 HA（HDFS High Availability Using the Quorum Journal Manager）<\/a><\/p><p>架构图如下：<\/p><h5 id=\"OLE_LINK4\">图 4.HDFS 利用 QJM 实现 HA 的架构图<\/h5><img alt=\"HDFS 利用 QJM 实现 HA 的架构图\" src=\"/sunshine_new/images/负664846767/image009.jpg\" width=\"465\" /><p><strong>Hadoop2.2.0 的源码编译<\/strong><\/p><p>因为使用 IBM 的 JDK，目前需要在 Apache 官方网站上下载<a href=\"http://apache.dataguru.cn/hadoop/common/stable2/hadoop-2.2.0-src.tar.gz\">hadoop2.2.0<\/a>的源码包，然后打上补丁进行手动编译。具体编译步骤请参考<a href=\"http://blog.csdn.net/licongcong_0224/article/details/12972889\">相关文档<\/a>，这里不在详细描述。编译成功后，会自动生成 ./hadoop-dist/target/hadoop-2.2.0.tar.gz 文件。<\/p><p><strong>安装配置 Hadoop2.2.0 之前，进行环境设置<\/strong><\/p><p>在 PLinux 系统上创建一个普通用户，本文创建一个用户名\"hadoop\"的用户。<\/p><div class=\"codesection\"><pre class=\"displaycode\">[root@plinux09 ~]# id hadoop\nuid=500(hadoop) gid=501(hadoop) groups=501(hadoop)<\/pre><\/div><p>创建目录/bigdata 与/hadoopdata，并且使用 chown -R 命令把这两个目录属性设置成 hadoop 用户和组。其中/bigdata 目录下存放所有的开源组件，/hadoopdata 用于存放 hdfs 的 NameNode 与 DataNode 数据。<\/p><div class=\"codesection\"><pre class=\"displaycode\">[root@plinux09 ~]# chown -R hadoop:hadoop /bigdata /hadoopdata/\n[root@plinux09 ~]# ll /\ntotal 110\ndrwxr-xr-x.   9 hadoop hadoop  4096 Jan  9 22:17 bigdata\ndrwxr-xr-x.   5 hadoop hadoop  4096 Jan  9 23:05 hadoopdata<\/pre><\/div><p>关闭所有分区上的 SELinux 与 Iptables，关闭 Selinux 后需要重启系统才能生效。<\/p><div class=\"codesection\"><pre class=\"displaycode\">[root@rhel226 ~]# vim /etc/selinux/config\nSELINUX=disabled\n[root@rhel226 ~]# service iptables stop\n[root@rhel226 ~]# chkconfig --level 345 iptables off<\/pre><\/div><p>SSH 无密码验证配置<\/p><p>配置/etc/hosts 文件<\/p><div class=\"codesection\"><pre class=\"displaycode\">[root@plinux09 ~]# cat /etc/hosts\n10.10.10.24\tplinux09\n10.10.10.25\tplinux10\n10.10.10.27\tplinux11\n10.10.10.28\tplinux12<\/pre><\/div><p>在四个 plinux 系统上分别使用命令 ssh-keygen 生成的密钥对 id_rsa 和 id_rsa.pub，默认存放在\"/home/hadoop/.ssh\"目录下。<\/p><div class=\"codesection\"><pre class=\"displaycode\">[hadoop@plinux09 ~]$ ssh-keygen -t rsa -P ''\nGenerating public/private rsa key pair.\nEnter file in which to save the key (/home/test/.ssh/id_rsa):\nCreated directory '/home/test/.ssh'.\nYour identification has been saved in /home/test/.ssh/id_rsa.\nYour public key has been saved in /home/test/.ssh/id_rsa.pub.\nThe key fingerprint is:\n89:23:48:5b:f9:e5:6b:9b:32:b5:66:81:24:b4:e6:3b test@plinux09\nThe key's randomart image is:\n+--[ RSA 2048]----+\n|                 |\n|    ..           |\n|  ..o.  .        |\n| . ++..+ .       |\n|  oo.o+.S        |\n|    ....o.       |\n|     . .oo       |\n|    E o.+o       |\n|     . =o        |\n+-----------------+\n\n[hadoop@plinux09 .ssh]$ ls -al /home/hadoop/.ssh\n-rw------- 1 hadoop hadoop 1675 Dec 23 13:36 id_rsa\n-rw-r--r-- 1 hadoop hadoop  395 Dec 23 13:36 id_rsa.pub<\/pre><\/div><p>然后把所有的公钥的内容添加 authorized_keys 文件里，再把这个文件分别拷贝到每台机器的相同目录下。<\/p><div class=\"codesection\"><pre class=\"displaycode\">[hadoop@plinux09 ~]$ cat ~/.ssh/id_rsa.pub &gt;&gt; ~/.ssh/authorized_keys<\/pre><\/div><p>设置 authorized_keys 文件属性为 600，否则 ssh 无密码验证不能生效。<\/p><div class=\"codesection\"><pre class=\"displaycode\">[hadoop@plinux09 ~]$ chmod 600 ~/.ssh/authorized_keys\n[hadoop@plinux09 ~]$ ll .ssh/\n<strong>-rw-------<\/strong>. 1 hadoop hadoop 1193 Jan  9 21:06 authorized_keys\n-rw-------. 1 hadoop hadoop 1675 Jan  9 21:00 id_rsa\n-rw-r--r--. 1 hadoop hadoop  397 Jan  9 21:00 id_rsa.pub<\/pre><\/div><p>配置/etc/security/limits.conf 文件，添加以下内容：<\/p><div class=\"codesection\"><pre class=\"displaycode\">[hadoop@plinux09 ~]$ vim /etc/security/limits.conf\nhadoop             soft    nproc           -1\nhadoop             hard    nproc           -1\nhadoop             soft    nofile          -1\nhadoop             hard    nofile          65536\nhadoop             soft    memlock         -1\nhadoop             hard    memlock         -1\nhadoop             soft    sigpending      -1\nhadoop             hard    sigpending      -1<\/pre><\/div><p><strong>安装配置 Hadoop2.2.0,实现手动方式 NameNode HA 的切换<\/strong><\/p><p>首先对编译生成的 hadoop-2.2.0.tar.gz 文件进行解压。<\/p><div class=\"codesection\"><pre class=\"displaycode\">[hadoop@plinux09 bigdata]$ tar -zxvf hadoop-2.2.0.tar.gz<\/pre><\/div><p>然后设置系统环境变量，修改~/.bash_profile 文件，添加以下内容：<\/p><div class=\"codesection\"><pre class=\"displaycode\">export JAVA_HOME=/bigdata/ibm-java-ppc64-70\nexport CLASSPATH=.:$CLASSPATH:$JAVA_HOME/lib:$JAVA_HOME/jre/lib\nexport HADOOP_HOME=/bigdata/hadoop\nexport ZOOKEEPER=/bigdata/zookeeper\nexport ZOO_LOG_DIR=/bigdata/zookeeper/data/logs\nexport HBASE_HOME=/bigdata/hbase\nexport HIVE_HOME=/bigdata/hive\nexport\nPATH=$ZOOKEEPER/bin:$PROTOBUF/bin:$HBASE_HOME/bin:$JAVA_HOME/bin:$JAVA_HOME/jre/bin:$HADOOP_HOME:\\\n  $HADOOP_HOME/bin:$HADOOP_HOME/sbin:$HIVE_HOME:$HIVE_HOME/bin:$PATH\nexport HADOOP_HOME_WARN_SUPPRESS=1<\/pre><\/div><p>运行以下命令使之生效:<\/p><div class=\"codesection\"><pre class=\"displaycode\">[hadoop@plinux09 bigdata]$ . ~/.bash_profile<\/pre><\/div><p>配置 hdfs-site.xml 文件，以便实现手动方式的 NameNode HA 切换<\/p><div class=\"codesection\"><pre class=\"displaycode\">[hadoop@plinux09 bigdata]$ vim /bigdata/hadoop/etc/hadoop/hdfs-site.xml<\/pre><\/div><a id=\"OLE_LINK6\"><\/a><a id=\"OLE_LINK5\"><\/a><p>&lt;!-- \"dfs.nameservices\"来定义 nameservices 的名字，这个名字可以任意定义，这里定义成\"mycluster\"。--&gt; <\/p><div class=\"codesection\"><pre class=\"displaycode\">&lt;property&gt;\n   &lt;name&gt;dfs.nameservices&lt;/name&gt;\n   &lt;value&gt;mycluster&lt;/value&gt;\n&lt;/property&gt;<\/pre><\/div><a id=\"OLE_LINK8\"><\/a><a id=\"OLE_LINK7\"><\/a><p>&lt;!-- \"dfs.ha.namenodes.[nameservice ID]\" 来标识每个 NameNode，每个 NameNode 的标识必须唯一，并且最多有两个 NameNode。这里将两个 NameNode 分别取名为 nn1,nn2。--&gt;<\/p><div class=\"codesection\"><pre class=\"displaycode\">             &lt;property&gt;\n                     &lt;name&gt;dfs.ha.namenodes.mycluster&lt;/name&gt;\n                     &lt;value&gt;nn1,nn2&lt;/value&gt;\n             &lt;/property&gt;<\/pre><\/div><a id=\"OLE_LINK10\"><\/a><a id=\"OLE_LINK9\"><\/a><p>&lt;!-- \"dfs.namenode.rpc-address. [nameservice ID].[name node ID]\" 来定义每个 NameNode 的 IP 或 Hostname 以及端口号。--&gt;<\/p><div class=\"codesection\"><pre class=\"displaycode\">             &lt;property&gt;\n                     &lt;name&gt;dfs.namenode.rpc-address.mycluster.nn1&lt;/name&gt;\n                     &lt;value&gt;plinux09:8020&lt;/value&gt;\n             &lt;/property&gt;\n             &lt;property&gt;\n                     &lt;name&gt;dfs.namenode.rpc-address.mycluster.nn2&lt;/name&gt;\n                     &lt;value&gt;plinux10:8020&lt;/value&gt;\n             &lt;/property&gt;<\/pre><\/div><a id=\"OLE_LINK20\"><\/a><a id=\"OLE_LINK19\"><\/a><p>&lt;!-- \"dfs.namenode.http-address. [nameservice ID].[name node ID]\" 来定义 HTTP 服务的端口号。--&gt;<\/p><div class=\"codesection\"><pre class=\"displaycode\">             &lt;property&gt;\n                     &lt;name&gt;dfs.namenode.http-address.mycluster.nn1&lt;/name&gt;\n                     &lt;value&gt;plinux09:50070&lt;/value&gt;\n             &lt;/property&gt;\n             &lt;property&gt;\n                     &lt;name&gt;dfs.namenode.http-address.mycluster.nn2&lt;/name&gt;\n                     &lt;value&gt;plinux10:50070&lt;/value&gt;\n             &lt;/property&gt;<\/pre><\/div><a id=\"OLE_LINK22\"><\/a><a id=\"OLE_LINK21\"><\/a><p>&lt;!-- \"dfs.namenode.shared.edits.dir\" 共享存储目录的位置。这是配置备份节点需要随时保持同步活动节点所作更改的远程共享目录，只能配置一个目录，这个目录挂载到两个 NameNode 上都必须是可读写的，且必须是绝对路径。--&gt;<\/p><div class=\"codesection\"><pre class=\"displaycode\">             &lt;property&gt;\n                     &lt;name&gt;dfs.namenode.shared.edits.dir&lt;/name&gt;\n                     &lt;value&gt;qjournal://plinux09:8485;plinux10:8485;plinux11:8485/mycluster&lt;/value&gt;\n             &lt;/property&gt;<\/pre><\/div><a id=\"OLE_LINK31\"><\/a><a id=\"OLE_LINK30\"><\/a><p>&lt;!-- \"dfs.client.failover.proxy.provider.[nameservice ID]\" HDFS 客户端用来和活动的 namenode 进行联系的 Java 类。配置的 Java 类是用来给 HDFS 客户端判断哪个 NameNode 节点是活动的，当前是哪个 NameNode 处理客户端的请求。目前 Hadoop 唯一的实现类是 ConfiguredFailoverProxyProvider。--&gt;<\/p><div class=\"codesection\"><pre class=\"displaycode\">&lt;property&gt;\n   &lt;name&gt;dfs.client.failover.proxy.provider.mycluster&lt;/name&gt;                   \n     &lt;value&gt;org.apache.hadoop.hdfs.server.namenode.ha.ConfiguredFailoverProxyProvider\n     &lt;/value&gt;\n   &lt;/property&gt;<\/pre><\/div><p>&lt;!-- \"dfs.ha.fencing.methods\" 用于停止活动 NameNode 节点的故障转移期间的脚本或 Java 类的列表。在任何时候只有一个 NameNode 处于活动状态，对于 HA 集群的操作是至关重要的，因此，在故障转移期间，启动备份节点前，首先需要确保活动节点处于等待状态，或者进程被中止，为了达到这个目的，您至少要配置一个强行中止的方法，或者回车分隔的列表，这是为了一个一个的尝试中止，直到其中一个返回成功，表明活动节点已停止。Hadoop 提供了两个方法：shell 和 sshfence，要实现您自己的方法，请看 org.apache.hadoop.ha.NodeFencer 类。--&gt;<\/p><div class=\"codesection\"><pre class=\"displaycode\">&lt;property&gt;\n                     &lt;name&gt;dfs.ha.fencing.methods&lt;/name&gt;\n                     &lt;value&gt;sshfence(hdfs)\n                     shell(/bin/true)&lt;/value&gt;\n             &lt;/property&gt;\n             &lt;property&gt;\n                     &lt;name&gt;dfs.ha.fencing.ssh.private-key-files&lt;/name&gt;\n                     &lt;value&gt;/home/hadoop/.ssh/id_rsa&lt;/value&gt;\n             &lt;/property&gt;<\/pre><\/div><p>&lt;!-- \"dfs.journalnode.edits.dir\" 用来定义 journaldata 的存储路径。--&gt;<\/p><div class=\"codesection\"><pre class=\"displaycode\">             &lt;property&gt;\n                     &lt;name&gt;dfs.journalnode.edits.dir&lt;/name&gt;\n                     &lt;value&gt;/bigdata/hadoop/journalnode&lt;/value&gt;\n             &lt;/property&gt;<\/pre><\/div><p><strong>*注意：<\/strong> sshfence(hdfs)后是\"回车\"，这是源代码里定义成这种格式，否则使用其它符号 HA 将不能正常切换。<\/p><p>然后编辑core-site.xml 文件。<\/p><div class=\"codesection\"><pre class=\"displaycode\">[hadoop@plinux09 bigdata]$ vim /bigdata/hadoop/etc/hadoop/core-site.xml<\/pre><\/div><p>&lt;!-- \"fs.defaultFS \" 定义 HDFS 的名称为 mycluster，即命名空间。--&gt;<\/p><div class=\"codesection\"><pre class=\"displaycode\">                &lt;property&gt;\n                                &lt;name&gt;fs.defaultFS&lt;/name&gt;\n                                &lt;value&gt;hdfs://mycluster&lt;/value&gt;\n                &lt;/property&gt;<\/pre><\/div><p>&lt;!-- \"fs.default.name\" 指定 NameNode 的 IP 地址和端口号。--&gt;<\/p><div class=\"codesection\"><pre class=\"displaycode\">                &lt;property&gt;\n                                &lt;name&gt;fs.default.name&lt;/name&gt;\n                                &lt;value&gt;hdfs://mycluster&lt;/value&gt;\n                &lt;/property&gt;<\/pre><\/div><p>配置完 hdfs-site.xml 与 core-site.xml 文件后，启动 plinux09,plinux10,plinux11 上 journalnode。<\/p><div class=\"codesection\"><pre class=\"displaycode\">[hadoop@plinux09 bigdata]$ hadoop/sbin/hadoop-daemons.sh --hostnames 'plinux09 plinux10 plinux11'\n    start jouralnode\nstarting journalnode, logging to /bigdata/hadoop/logs/hadoop-hadoop-journalnode-plinux09.out\nstarting journalnode, logging to /bigdata/hadoop/logs/hadoop-hadoop-journalnode-plinux10.out\nstarting journalnode, logging to /bigdata/hadoop/logs/hadoop-hadoop-journalnode-plinux11.out<\/pre><\/div><p>然后对 plinux09 的 NameNode 进行格式化.<\/p><div class=\"codesection\"><pre class=\"displaycode\">[hadoop@plinux09 ~]$ hadoop namenode Cformat\n***\n14/01/12 22:25:05 INFO util.ExitUtil: Exiting with status 0\n14/01/12 22:25:05 INFO namenode.NameNode: SHUTDOWN_MSG:\n/************************************************************\nSHUTDOWN_MSG: Shutting down NameNode at plinux09/9.110.75.104\n************************************************************/<\/pre><\/div><p>在返回的结果中，显示 Exiting with status 0 表示格式化成功，否则表示格式化失败，如果失败，请查看 NameNode 的日志文件 hadoop/logs/hadoop-hadoop-namenode-plinux09.log<\/p><p>NameNode 格式化完成后，启动主节点 plinux09 的 NameNode<\/p><div class=\"codesection\"><pre class=\"displaycode\">[hadoop@plinux09 bigdata]$ hadoop-daemon.sh start namenode\nstarting namenode, logging to /bigdata/hadoop/logs/hadoop-hadoop-namenode-plinux09.out<\/pre><\/div><p>然后对 standby 节点 plinux10 的 NameNode 上进行元数据同步。<\/p><div class=\"codesection\"><pre class=\"displaycode\">[hadoop@plinux10 ~]$ hdfs namenode -bootstrapStandby<\/pre><\/div><p>接着启动 standby 节点 plinux10 上的 NameNode。<\/p><div class=\"codesection\"><pre class=\"displaycode\">[hadoop@plinux10 ~]$ hadoop-daemon.sh start namenode\nstarting namenode, logging to /bigdata/hadoop/logs/hadoop-hadoop-namenode-plinux10.out<\/pre><\/div><p>最后分别在所有节点(plinux09, plinux10, plinux11, plinux12)上启动 DataNode。<\/p><div class=\"codesection\"><pre class=\"displaycode\">[hadoop@plinux09 bigdata]$ hadoop-daemon.sh start datanode\nstarting datanode, logging to /bigdata/hadoop/logs/hadoop-hadoop-datanode-plinux09.out\n***<\/pre><\/div><p>可以使用 hdfs haadmin 帮助命令来查看 HA 的状态或者配置 HA 的节点。<\/p><div class=\"codesection\"><pre class=\"displaycode\">[hadoop@plinux09 bigdata]$ hdfs haadmin\nUsage: DFSHAAdmin [-ns &lt;nameserviceId&gt;]\n    [-transitionToActive &lt;serviceId&gt;]\n    [-transitionToStandby &lt;serviceId&gt;]\n    [-failover [--forcefence] [--forceactive] &lt;serviceId&gt; &lt;serviceId&gt;]\n    [-getServiceState &lt;serviceId&gt;]\n    [-checkHealth &lt;serviceId&gt;]\n    [-help &lt;command&gt;]\nGeneric options supported are\n-conf &lt;configuration file&gt;     specify an application configuration file\n-D &lt;property=value&gt;            use value for given property\n-fs &lt;local|namenode:port&gt;      specify a namenode\n-jt &lt;local|jobtracker:port&gt;    specify a job tracker\n-files &lt;comma separated list of files&gt;specify comma separated files to be copied to the \\\nmap reduce cluster\n-libjars &lt;comma separated list of jars&gt; specify comma separated jar files to include\nin the classpath.\n-archives &lt;comma separated list of archives&gt;specify comma separated archives to \n                                                  be unarchived on the compute machines.\nThe general command line syntax is\nbin/hadoop command [genericOptions] [commandOptions]<\/pre><\/div><p>激活 plinux09 节点上的 NameNode。<\/p><div class=\"codesection\"><pre class=\"displaycode\">[hadoop@plinux09 bigdata]$ hdfs haadmin -transitionToActive nn1<\/pre><\/div><p>查看两个节点上 NamNode 的状态。<\/p><div class=\"codesection\"><pre class=\"displaycode\">[hadoop@plinux09 conf]$ hdfs haadmin -getServiceState nn1\nActive\n\n[hadoop@plinux09 conf]$ hdfs haadmin -getServiceState nn2\nStandby<\/pre><\/div><p>进行手动 NameNode 的切换测试。<\/p><div class=\"codesection\"><pre class=\"displaycode\">[hadoop@plinux09 bigdata]$ hdfs haadmin -failover nn1 nn2\nFailover to NameNode at plinux10/9.110.75.105:8020 successful\n\n[hadoop@plinux09 bigdata]$ hdfs haadmin -getServiceState nn1\nStandby\n\n[hadoop@plinux09 bigdata]$ hdfs haadmin -getServiceState nn2\nactive<\/pre><\/div><p>下图为 Web 上查看 NameNode 的状态<\/p><h5 id=\"N102DB\">图 5 .Web 上查看 plinux09 的 NameNode 状态<\/h5><img alt=\"图 5 .Web 上查看 plinux09 的 NameNode 状态\" src=\"/sunshine_new/images/负664846767/image011.jpg\" width=\"470\" /><h5 id=\"OLE_LINK11\">图 6\n    .Web 上查看 plinux10 的 NameNode 状态<\/h5><img alt=\"图 6 .Web 上查看 plinux10 的 NameNode 状态\" src=\"/sunshine_new/images/负664846767/image013.jpg\" width=\"477\" /><p>通过上面的配置与测试，可以成功实现 PLinux 上 HDFS 的 NameNode 手动切换。<\/p><p><strong>安装配置 Hadoop2.2.0,实现自动方式 NameNode HA 的切换<\/strong><\/p><p>下面进行自动切换配置。<\/p><p>在 hdfs-site.xml 里添加：<\/p><p>&lt;!-- \"ha.zookeeper.quorum\" 打开自动切换 NameNode 的功能。--&gt;<\/p><div class=\"codesection\"><pre class=\"displaycode\">             &lt;property&gt;\n                     &lt;name&gt;dfs.ha.automatic-failover.enabled&lt;/name&gt;\n                     &lt;value&gt;true&lt;/value&gt;\n             &lt;/property&gt;<\/pre><\/div><p>在 core-site.xml 里添加：<\/p><p>&lt;!-- \"ha.zookeeper.quorum\" 指定用于 HA 的 ZooKeeper 集群机器列表，并且列表数目一定是奇数。--&gt;<\/p><div class=\"codesection\"><pre class=\"displaycode\">             &lt;property&gt;\n                     &lt;name&gt;ha.zookeeper.quorum&lt;/name&gt;\n                     &lt;value&gt;plinux09:2181,plinux10:2181,plinux11:2181&lt;/value&gt;\n             &lt;/property&gt;<\/pre><\/div><p>配置完上面两个文件，分别在 plinux09、plinux10、plinux11 上启动 ZooKeeper Server。<\/p><div class=\"codesection\"><pre class=\"displaycode\">[hadoop@plinux09 hadoop]$ zkServer.sh start\nJMX enabled by default\nUsing config: /bigdata/zookeeper/bin/../conf/zoo.cfg\nStarting zookeeper ... STARTED\n\n[hadoop@plinux10 ~]$ zkServer.sh start\nJMX enabled by default\nUsing config: /bigdata/zookeeper/bin/../conf/zoo.cfg\nStarting zookeeper ... STARTED\n\n[hadoop@plinux11 ~]$ zkServer.sh start\nJMX enabled by default\nUsing config: /bigdata/zookeeper/bin/../conf/zoo.cfg\nStarting zookeeper ... STARTED<\/pre><\/div><p>然后格式化 ZKFC<\/p><div class=\"codesection\"><pre class=\"displaycode\">[hadoop@plinux09 hadoop]$  hdfs zkfc -formatZK\n===============================================\nThe configured parent znode /hadoop-ha/mycluster already exists.\nAre you sure you want to clear all failover information from\nZooKeeper?\nWARNING: Before proceeding, ensure that all HDFS services and\nfailover controllers are stopped!\n===============================================\nProceed formatting /hadoop-ha/mycluster? (Y or N) Y\n14/01/13 02:19:24 INFO ha.ActiveStandbyElector: Recursively deleting /hadoop-ha/mycluster from ZK...\n14/01/13 02:19:24 INFO ha.ActiveStandbyElector: Successfully deleted /hadoop-ha/mycluster from ZK.\n14/01/13 02:19:24 INFO ha.ActiveStandbyElector: Successfully created /hadoop-ha/mycluster in ZK.\n14/01/13 02:19:24 INFO zookeeper.ZooKeeper: Session: 0x2438a6d6f0a0000 closed\n14/01/13 02:19:24 INFO zookeeper.ClientCnxn: EventThread shut down<\/pre><\/div><p><strong>* 注意：<\/strong>格式化 ZooKeeper 之前必须先关闭 HDFS Services。运行用 dfs-stop.sh 命令来关闭。<\/p><p>格式化完毕后启动 NameNode,DataNode, journalnode 和 zkfc。<\/p><div class=\"codesection\"><pre class=\"displaycode\">[hadoop@plinux09 hadoop]$ start-dfs.sh\nStarting namenodes on [plinux09 plinux10]\nplinux10: starting namenode, logging to /bigdata/hadoop/logs/hadoop-hadoop-namenode-plinux10.out\nplinux09: starting namenode, logging to /bigdata/hadoop/logs/hadoop-hadoop-namenode-plinux09.out\nplinux11: starting datanode, logging to /bigdata/hadoop/logs/hadoop-hadoop-datanode-plinux11.out\nplinux09: starting datanode, logging to /bigdata/hadoop/logs/hadoop-hadoop-datanode-plinux09.out\nplinux10: starting datanode, logging to /bigdata/hadoop/logs/hadoop-hadoop-datanode-plinux10.out\nStarting journal nodes [plinux09 plinux10 plinux11]\nplinux11: starting journalnode, logging to /bigdata/hadoop/logs/hadoop-hadoop-journalnode-plinux11.out\nplinux10: starting journalnode, logging to /bigdata/hadoop/logs/hadoop-hadoop-journalnode-plinux10.out\nplinux09: starting journalnode, logging to /bigdata/hadoop/logs/hadoop-hadoop-journalnode-plinux09.out\nStarting ZK Failover Controllers on NN hosts [plinux09 plinux10]\nplinux10: starting zkfc, logging to /bigdata/hadoop/logs/hadoop-hadoop-zkfc-plinux10.out\nplinux09: starting zkfc, logging to /bigdata/hadoop/logs/hadoop-hadoop-zkfc-plinux09.out<\/pre><\/div><p>启动好后，其中一台 NameNode 会自动被激活成 active，另一台是 standby 状态。<\/p><div class=\"codesection\"><pre class=\"displaycode\">[hadoop@plinux09 hadoop]$ hdfs haadmin -getServiceState nn1\nStandby\n[hadoop@plinux09 hadoop]$ hdfs haadmin -getServiceState nn2\nActive<\/pre><\/div><p>通过 Kill NameNode 的进程来进行 NameNode HA 的自动切换测试。<\/p><div class=\"codesection\"><pre class=\"displaycode\">[hadoop@plinux10 ~]$ ps -ef|grep -i namenode\nhadoop    9378     1  1 02:23 ?        00:00:18 /bigdata/ibm-java-ppc64-70/bin/java C\n***\norg.apache.hadoop.hdfs.server.namenode.NameNode\n\n[hadoop@plinux10 ~]$ kill -9 9378\n\n[hadoop@plinux09 conf]$ hdfs haadmin -getServiceState nn1\nActive\n\n[hadoop@plinux09 conf]$ hdfs haadmin -getServiceState nn2\n14/01/13 02:56:09 INFO ipc.Client: Retrying connect to server: plinux10/9.110.75.105:8020.\n Already tried 0 time(s); retry policy is RetryUpToMaximumCountWithFixedSleep(\n       maxRetries=1, sleepTime=1 SECONDS)\nOperation failed: Call From plinux09/9.110.75.104 to plinux10:8020 failed on connection exception: \njava.net.ConnectException: Connection refused; For more details see: \n   http://wiki.apache.org/hadoop/ConnectionRefused<\/pre><\/div><p>当 kill plinux10 上 active NameNode 的进程后，在短时间内 NameNode 自动切换到 plinux09 上。<\/p><p><strong>基于 HDFS HA 来配置 Hbase<\/strong><\/p><p>基于 HDFS HA 来配置 Hbase 的方法如下：<\/p><p>配置 hbase-site.xml 文件，添加如下内容<\/p><div class=\"codesection\"><pre class=\"displaycode\">[hadoop@plinux09 bigdata]$ vim /bigdata/hbase/conf/hbase-site.xml<\/pre><\/div><p>&lt;!-- \"hbase.rootdir\"用于 HA 节点的 NameService 来配置 HBase。--&gt;<\/p><div class=\"codesection\"><pre class=\"displaycode\">        &lt;property&gt;\n                &lt;name&gt;hbase.rootdir&lt;/name&gt;\n                &lt;value&gt;hdfs://mycluster/hbase&lt;/value&gt;\n        &lt;/property&gt;\n&lt;property&gt;\n                &lt;name&gt;hbase.master&lt;/name&gt;\n                &lt;value&gt;hdfs://mycluster:60000&lt;/value&gt;\n        &lt;/property&gt;<\/pre><\/div><p>配置好后启动 Hbase 服务。<\/p><div class=\"codesection\"><pre class=\"displaycode\">[hadoop@plinux10 ~]$ start-hbase.sh\nstarting master, logging to /bigdata/hbase/logs/hbase-hadoop-master-plinux10.out\nplinux12: starting regionserver, logging to /bigdata/hbase/logs/hbase-hadoop-regionserver-plinux12.out\nplinux11: starting regionserver, logging to /bigdata/hbase/logs/hbase-hadoop-regionserver-plinux11.out\nplinux09: starting regionserver, logging to /bigdata/hbase/logs/hbase-hadoop-regionserver-plinux09.out\nplinux10: starting regionserver, logging to /bigdata/hbase/logs/hbase-hadoop-regionserver-plinux10.out<\/pre><\/div><h5 id=\"N10345\">图 7.登录 plinux10 的 Web 查看 HBase 的状态<\/h5><img alt=\"登录 plinux10 的 Web 查看 HBase 的状态\" src=\"/sunshine_new/images/负664846767/image015.jpg\" width=\"576\" /><p>通过以上配置，Hbase 可以在 HDFS HA 的环境中正常工作。这样一套基本的 Hadoop HDFS 的 HA 解决方案配置完成。<\/p><h2 id=\"6.总结 |outline\">总结<\/h2><p>随着 Hadoop 日渐成熟，越来越多的企业使用它来分析处理日常大量的数据。随之而来的安全性，可靠性和性能问题被提出。本文使用开源的软件结合 IBM CAMP 服务器的强大性能实现高可用性来满足客户的需求。<\/p><CMA ID: 973653><Site ID: 10><XSLT stylesheet used to transform this file: dw-document-html-7.0.xsl>\r\n\r\n\r\n<\/div>\r\n<\/div>\r\n","createTime":"2014-06-11 00:00:00","deployTime":"2014-06-11 00:00:00","id":0,"intro":"随着大数据应用的日益流行，高可用性越来越被重视。作为服务器领域创新的引领者和业务价值的驱动者，IBM 推出了性能强大的 CAMP 服务器。那么 CAMP 服务器对开源 Hadoop 的高可用性是否支持？答案是肯定的。本文将介绍如何在 CAMP 服务器上使用 PLinux 操作系统实现开源 Hadoop HDFS 的高可用性。","keyword":"","recommend":false,"source":"http://www.ibm.com/developerworks/cn/linux/1406_jiangtao_camphadoop/index.html","title":"在 IBM CAMP 服务器上实现开源 Hadoop HDFS 的高可用性","typeId":0,"updateTime":"2014-06-11 00:00:00"}
{"author":"","clickNumber":0,"content":"\r\n<div class=\"ibm-columns\">\r\n<div class=\"ibm-col-1-1\">\r\n\r\n<div class=\"dw-sidebar ibm-inset\"><h2 id=\"N10053\">关于本系列<\/h2><p>由于多核系统普遍存在，并发性编程的应用无疑比以往任何时候都要广泛。但并发性很难正确实现，用户需要借助工具来为他们提供帮助。很多基于 JVM\n                    的语言都属于这类开发工具，Scala 在此领域尤为活跃。此系列文章将介绍一些针对 Java 和 Scala\n                    语言的较新的并发性编程方法。<\/p><\/div><p>在期待已久的 Java 8 版本中，并发性方面已实现了许多改进，其中包括在 <code>java.util.concurrent<\/code>\n                    层级中增加新的类和强大的新并行<em>流<\/em> 功能。设计流的目的是与 <em>lambda 表达式<\/em> 共同使用，Java 8\n                的这项增强也使得日常编程的其他很多方面变得更加简便。（参见介绍 Java 8 语言的 <a href=\"http://www.ibm.com/developerworks/library/j-java8lambdas/index.html\">指南文章<\/a>，了解对于 lambda 表达式的介绍及相关 <code>interface<\/code> 改动。）<\/p><p>本文首先介绍了新的 <code>CompletableFuture<\/code> 类如何更好地协调异步操作。接下来，我将介绍如何使用并行流（Java\n                8 中在并发性方面最大的亮点）在值集上并行地执行操作。最后，我探讨了 Java 8 新功能的执行方法，并与此系列 <a href=\"http://www.ibm.com/developerworks/library/j-jvmc1/index.html\">首篇文章<\/a> 中的一些代码进行了比较。（参见 <a href=\"#resources\">参考资料<\/a>\n                中的本文完整示例代码的链接。） <\/p><h2 id=\"N10077\">回到 <code>Future<\/code><\/h2><p>此系列中的 <a href=\"http://www.ibm.com/developerworks/cn/java/j-jvmc1/index.html\">首篇文章<\/a> 简要介绍了 Java 和 Scala <code>Future<\/code>。Java 8 之前的 Java\n                版本功能较弱，仅支持两种用法：要么检查 future 是否已经完成，要么等待 future 完成。Scala 版本要灵活得多：可以在 future\n                完成时执行回调函数，并以 <code>Throwable<\/code> 的形式处理异常的完成。<\/p><p>Java 8 增加了 <code>CompletableFuture&lt;T&gt;<\/code> 类，它实现了新的\n                <code>CompletionStage&lt;T&gt;<\/code> 接口，并对 <code>Future&lt;T&gt;<\/code>\n                进行了扩展。（本节中讨论的所有并发性类与接口全都包含在 <code>java.util.concurrent<\/code>\n                包中。）<code>CompletionStage<\/code> 代表异步计算中的一个阶段或步骤。该接口定义了多种不同的方式，将\n                <code>CompletionStage<\/code> 实例与其他实例或代码链接在一起，比如完成时调用的方法（一共 59 种方法，比\n                <code>Future<\/code> 接口中的 5 种方法要多得多。）<\/p><p>清单 1 显示了 <code>ChunkDistanceChecker<\/code> 类，它基于 <a href=\"http://www.ibm.com/developerworks/cn/java/j-jvmc1/index.html\">首篇文章<\/a> 中的编辑距离比较代码。<\/p><h5 id=\"listing1\">清单 1. <code>ChunkDistanceChecker<\/code><\/h5><div class=\"codesection\"><pre class=\"displaycode\">public class ChunkDistanceChecker {\n    private final String[] knownWords;\n\n    public ChunkDistanceChecker(String[] knowns) {\n        knownWords = knowns;\n    }\n\n    /**\n    * Build list of checkers spanning word list.\n    * \n    * @param words\n    * @param block\n    * @return checkers\n    */\n    public static List&lt;ChunkDistanceChecker&gt; buildCheckers(String[] words, int block) {\n        List&lt;ChunkDistanceChecker&gt; checkers = new ArrayList&lt;&gt;();\n        for (int base = 0; base &lt; words.length; base += block) {\n            int length = Math.min(block, words.length - base);\n            checkers.add(new ChunkDistanceChecker(Arrays.copyOfRange(words, base, base + length)));\n        }\n        return checkers;    \n        }\n    ...\n    /**\n     * Find best distance from target to any known word.\n     * \n     * @param target\n     * @return best\n     */\n    public DistancePair bestDistance(String target) {\n        int[] v0 = new int[target.length() + 1];\n        int[] v1 = new int[target.length() + 1];\n        int bestIndex = -1;\n        int bestDistance = Integer.MAX_VALUE;\n        boolean single = false;\n        for (int i = 0; i &lt; knownWords.length; i++) {\n            int distance = editDistance(target, knownWords[i], v0, v1);\n            if (bestDistance &gt; distance) {\n                bestDistance = distance;\n                bestIndex = i;\n                single = true;\n            } else if (bestDistance == distance) {\n                single = false;\n            }\n        }\n        return single ? new DistancePair(bestDistance, knownWords[bestIndex]) :\n            new DistancePair(bestDistance);\n    }\n}<\/pre><\/div><p><code>ChunkDistanceChecker<\/code> 类的每个实例负责根据一个已知单词数组来检查目标单词，从而找出最佳匹配。静态的\n                <code>buildCheckers()<\/code> 方法从整个已知单词数组创建一个\n                <code>List&lt;ChunkDistanceChecker&gt;<\/code> 和一个合适的块大小。这个\n                <code>ChunkDistanceChecker<\/code> 类是本文中几种并发实现的基础，第一种实现就是清单 2 中的\n                <code>CompletableFutureDistance0<\/code> 类。<\/p><h5 id=\"listing2\">清单 2. 使用 <code>CompletableFuture<\/code>\n                    的编辑距离计算<\/h5><div class=\"codesection\"><pre class=\"displaycode\">public class CompletableFutureDistance0 extends TimingTestBase {\n    private final List&lt;ChunkDistanceChecker&gt; chunkCheckers;\n\n    private final int blockSize;\n\n    public CompletableFutureDistance0(String[] words, int block) {\n        blockSize = block;\n        chunkCheckers = ChunkDistanceChecker.buildCheckers(words, block);\n    }\n    ...\n    public DistancePair bestMatch(String target) {\n        List&lt;CompletableFuture&lt;DistancePair&gt;&gt; futures = new ArrayList&lt;&gt;();\n        for (ChunkDistanceChecker checker: chunkCheckers) {\n            CompletableFuture&lt;DistancePair&gt; future =\n                CompletableFuture.supplyAsync(() -&gt; checker.bestDistance(target));\n            futures.add(future);\n        }\n        DistancePair best = DistancePair.worstMatch();\n        for (CompletableFuture&lt;DistancePair&gt; future: futures) {\n            best = DistancePair.best(best, future.join());\n        }\n        return best;\n    }\n}<\/pre><\/div><div class=\"dw-sidebar ibm-inset\"><h2 id=\"N100CB\">了解 lambdas 的相关知识<\/h2><p>我传递给 <code>supplyAsync()<\/code> 方法的 lambda 表达式是 <em>捕获的<\/em> lambda\n                    表达式，因为它引用了 <code>target<\/code> 参数值。在 \"<a href=\"http://www.ibm.com/developerworks/library/j-java8lambdas/index.html\">Java 8 语言变化<\/a>\" 中了解 lambda 表达式，同时了解捕获的 lambda 与非捕获 lambda\n                    之间的区别。<\/p><\/div><p><a href=\"#listing2\">清单 2<\/a><code> CompletableFutureDistance0<\/code> 类显示了使用\n                <code>CompletableFuture<\/code> 进行并发计算的一种方式。<code>supplyAsync()<\/code>\n                方法使用一个 <code>Supplier&lt;T&gt;<\/code> 实例（一个带有返回 <code>T<\/code>\n                类型值的方法的函数式接口），并在对 <code>Supplier<\/code> 进行排队以便异步运行它时返回\n                <code>CompletableFuture&lt;T&gt;<\/code>。我向第一个 <code>for<\/code> 循环中的\n                <code>supplyAsync()<\/code> 方法传递了一个 lambda 表达式，目的是构建一个与\n                <code>ChunkDistanceChecker<\/code> 数组相匹配的 future 列表。第二个 <code>for<\/code>\n                循环等待每个 future 完成（但大多数会在循环到达之前完成，因为它们是异步执行的），然后从所有结果中收集最佳匹配。<\/p><h3 id=\"N10102\">在 <code>CompletableFuture<\/code>\n                上进行构建<\/h3><p>在本系列的 <a href=\"http://www.ibm.com/developerworks/cn/java/j-jvmc1/index.html\">首篇文章<\/a> 中您已经看到，使用 Scala <code>Future<\/code> 可以通过各种方式附加完成处理程序和组合\n                future。<code>CompletableFuture<\/code> 为 Java 8\n                提供了类似的灵活性。在这一小节中，您将在编辑距离检查的上下文中学习使用这些功能的一些方式。<\/p><p>清单 3 显示了 <a href=\"#listing2\">清单 2<\/a> 中 <code>bestMatch()<\/code>\n                方法的另一个版本。该版本使用一个带 <code>CompletableFuture<\/code> 的完成处理程序，以及一些较老的并发性类。<\/p><h5 id=\"listing3\">清单 3. 完成处理程序的\n                    <code>CompletableFuture<\/code><\/h5><div class=\"codesection\"><pre class=\"displaycode\">public DistancePair bestMatch(String target) {\n    AtomicReference&lt;DistancePair&gt; best = new AtomicReference&lt;&gt;(DistancePair.worstMatch());\n    CountDownLatch latch = new CountDownLatch(chunkCheckers.size());\n    for (ChunkDistanceChecker checker: chunkCheckers) {\n        CompletableFuture.supplyAsync(() -&gt; checker.bestDistance(target))\n            .thenAccept(result -&gt; {\n                best.accumulateAndGet(result, DistancePair::best);\n                latch.countDown();\n            });\n    }\n    try {\n        latch.await();\n    } catch (InterruptedException e) {\n        throw new RuntimeException(\"Interrupted during calculations\", e);\n    }\n    return best.get();\n}<\/pre><\/div><p>在 <a href=\"#listing3\">清单 3<\/a> 中，<code>CountDownLatch<\/code> 被初始化为代码中创建的\n                futures 的数量。创建每个 future 时，我使用 <code>CompletableFuture.thenAccept()<\/code>\n                方法附加了一个处理器（以 <code>java.util.function.Consumer&lt;T&gt;<\/code> 函数式接口的一个\n                lambda 实例的形式）。该处理器在 future 正常完成时执行，它使用\n                <code>AtomicReference.accumulateAndGet()<\/code> 方法（Java 8\n                中增加的）来更新找到的最佳值，然后将闩锁 (latch) 递减。与此同时，执行的主线程进入了 <code>try-catch<\/code>\n                块，并等待闩锁释放。当所有 futures 完成后，主线程会继续，然后返回找到的最后一个最佳值。<\/p><p>清单 4 显示了 <a href=\"#listing2\">清单 2<\/a> 中 <code>bestMatch()<\/code>\n                方法的另一个版本。<\/p><h5 id=\"listing4\">清单 4. 组合使用\n                    <code>CompletableFuture<\/code><\/h5><div class=\"codesection\"><pre class=\"displaycode\">public DistancePair bestMatch(String target) {\n    CompletableFuture&lt;DistancePair&gt; last =\n        CompletableFuture.supplyAsync(bestDistanceLambda(0, target));\n    for (int i = 1; i &lt; chunkCheckers.size(); i++) {\n        last = CompletableFuture.supplyAsync(bestDistanceLambda(i, target))\n            .thenCombine(last, DistancePair::best);\n    }\n    return last.join();\n}\n\nprivate Supplier&lt;DistancePair&gt; bestDistanceLambda(int i, String target) {\n    return () -&gt; chunkCheckers.get(i).bestDistance(target);\n}<\/pre><\/div><p>这段代码使用了 <code>CompletableFuture.thenCombine ()<\/code> 方法将两个 future\n                合并，具体做法是对两个结果使用一个 <code>java.util.function.BiFunction<\/code> 方法（在这个例子中为\n                <code>DistancePair.best()<\/code> 方法），然后返回一个 future 作为函数的结果。<\/p><p>清单 4 是最简洁和最干净的代码版本，但它有一个缺点，就是创建了一个额外的 <code>CompletableFuture<\/code>\n                层来表示每次批量操作与之前操作的组合使用。作为最初的 Java 8 版本，这有可能导致\n                <code>StackOverflowException<\/code>（在此代码中未包含该异常），从而导致最后一个 future 永远无法完成。这个\n                bug 正在被解决，在近期的版本中会得到修正。<\/p><p><code>CompletableFuture<\/code> 定义了这些例子中所用方法的多个变体。当您对您的应用程序使用\n                <code>CompletableFuture<\/code> 时，可以检查完成方法的完整列表，然后结合使用多种方法来找出您需要的最佳匹配。<\/p><p>当您执行各种类型的操作并且必须调整结果时，<code>CompletableFuture<\/code>\n                是最佳选择。当在很多不同的数据值上运行相同计算过程时，并行流将为您提供一个更简单的方法和更好的性能。编辑距离检查的例子更适合并行流方法。<\/p><h2 id=\"N1016F\">流<\/h2><p>流是 Java 8 的主要特色之一，可与 lambda\n                表达式结合使用。从根本上讲，流就是基于一个值序列的推送迭代器。流可以与适配器链接在一起，以便执行诸如过滤与映射之类的操作，这一点与 Scala\n                序列很像。流还有串行和并行的变体，这也和 Scala 序列很像（但 Scala 有一个用于并行序列的单独的类层级，而 Java 8\n                使用一个内部标记来指示串行或并行）。流的变体包括原始的 <code>int<\/code>、<code>long<\/code> 和\n                <code>double<\/code> 类型，以及类型化的对象流。<\/p><p>新的流 API 过于复杂，本文很难完整地讲述它们，因此我将重点放在了并发性方面。参见 <a href=\"#resources\">参考资料<\/a>\n                部分中关于流的更加详细的说明。<\/p><p>清单 5 显示了编辑距离最佳匹配代码的另一种变体。这个版本使用了 <a href=\"#listing1\">清单 1<\/a> 中的\n                <code>ChunkDistanceChecker<\/code> 来进行距离计算，并像 <a href=\"#listing2\">清单 2<\/a>\n                示例中的那样使用了 <code>CompletableFuture<\/code>，但这次我使用了流来获得最佳的匹配结果。<\/p><h5 id=\"listing5\">清单 5. 使用流的\n                    <code>CompletableFuture<\/code><\/h5><div class=\"codesection\"><pre class=\"displaycode\">public class CompletableFutureStreamDistance extends TimingTestBase {\n    private final List&lt;ChunkDistanceChecker&gt; chunkCheckers;\n\n    ...\n    public DistancePair bestMatch(String target) {\n        return chunkCheckers.stream()\n            .map(checker -&gt; CompletableFuture.supplyAsync(() -&gt; checker.bestDistance(target)))\n            .collect(Collectors.toList())\n            .stream()\n            .map(future -&gt; future.join())\n            .reduce(DistancePair.worstMatch(), (a, b) -&gt; DistancePair.best(a, b));\n    }\n}<\/pre><\/div><p>位于清单 5 底部的多行语句使用了简便的流 API 来完成所有工作：<\/p><ol><li><code>chunkCheckers.stream()<\/code> 从\n                    <code>List&lt;ChunkDistanceChecker&gt;<\/code> 创建一个流。<\/li><li><code>.map(checker -&gt; ...<\/code> 对流中的值使用映射，这个例子中，使用了与 <a href=\"#listing2\">清单 2<\/a> 例子中相同的技术来构造一个针对\n                    <code>ChunkDistanceChecker.bestDistance()<\/code> 方法的异步执行结果的\n                    <code>CompletableFuture<\/code>。<\/li><li><code>.collect(Collectors.toList())<\/code> 将值收集到一个列表中，然后用\n                    <code>.stream()<\/code> 将它转换回为流。<\/li><li><code>.map(future -&gt; future.join())<\/code> 等待每个 future 的结果变为可用，而\n                    <code>.reduce(...<\/code> 通过对前最佳结果与最新结果反复应用\n                    <code> DistancePair.best()<\/code> 方法来找出最佳值。<\/li><\/ol><p>无可否认，这让人感到有些混乱。在您不想读下去之前，我向您保证下一版一定会更简单、更清晰。<a href=\"#listing5\">清单 5<\/a>\n                的目的是让您了解如何使用流来代替普通循环。<\/p><p>清单 5 的代码会更简单，因为它没有进行多次转换（从流到列表再回到流）。在这个例子中需要转换，否则在创建 future 后，代码就会立刻开始等待\n                <code>CompletableFuture.join()<\/code> 方法。<\/p><h3 id=\"N101D1\">并行流<\/h3><p>幸运的是，存在着比 <a href=\"#listing5\">清单 5<\/a>\n                更简单的在流上实现并行操作的方法。顺序流可以变为并行流，而并行流可自动跨多个线程共享工作，并在稍后收集结果。清单 6 显示了如何使用这种方法从\n                <code>List&lt;ChunkDistanceChecker&gt;<\/code> 中找到最佳匹配项。<\/p><h5 id=\"listing6\">清单 6. 使用批量并行流的最佳匹配<\/h5><div class=\"codesection\"><pre class=\"displaycode\">public class ChunkedParallelDistance extends TimingTestBase {\n    private final List&lt;ChunkDistanceChecker&gt; chunkCheckers;\n    ...\n    public DistancePair bestMatch(String target) {\n        return chunkCheckers.parallelStream()\n            .map(checker -&gt; checker.bestDistance(target))\n            .reduce(DistancePair.worstMatch(), (a, b) -&gt; DistancePair.best(a, b));\n    }\n}<\/pre><\/div><p>再次申明，位于末尾的多行语句完成了所有工作。和在 <a href=\"#listing5\">清单 5<\/a>\n                中一样，语句一开始从列表创建流，但这个版本使用了 <code>parallelStream()<\/code>\n                方法来获取用于并行处理的流。（您还可以将普通流转换为并行处理的流，只需在流上调用 <code>parallel()<\/code>\n                方法即可。）接下来的部分是\n                <code>.map(checker -&gt; checker.bestDistance(target))<\/code>，用于在大量已知单词中找到最佳匹配。最后一部分是\n                <code>.reduce(...<\/code>，用于在所有数据块中收集最佳结果，这一点也和 <a href=\"#listing6\">清单\n                    5<\/a> 中相同。<\/p><p>并行流会并行执行某些步骤，比如 <code>map<\/code> 和 <code>filter<\/code> 操作。因此在后台，<a href=\"#listing6\">清单 6<\/a>\n                代码在减数步骤中整合结果之前，会将映射步骤分散到多个线程上（不一定要按照特定的顺序，因为结果的到来和产生结果的操作是并行的）。<\/p><p>在流中，对要完成的工作进行分解的能力取决于流中使用的 <code>java.util.Spliterator&lt;T&gt;<\/code>\n                新接口。从名称可以看出来，<code>Spliterator<\/code> 类似于 <code>Iterator<\/code>。和\n                <code>Iterator<\/code> 一样，使用 <code>Spliterator<\/code> 每次可以处理某个元素集合中的一个元素\n                &#8212; 不是从 <code>Spliterator<\/code> 中获取元素，而是使用 <code>tryAdvance()<\/code>\n                或 <code>forEachRemaining()<\/code> 方法对元素应用操作。但 <code>Spliterator<\/code>\n                还可以用于估计其中保存的元素数量，而且还可以像细胞分裂一样变为一分为二。这些新增加的能力让流并行处理代码可以很方便地将工作分布到多个可用线程上完成。<\/p><p><a href=\"#listing6\">清单 6<\/a> 中的代码可能让您觉得似曾相识，这是因为它与此系列 <a href=\"http://www.ibm.com/developerworks/library/j-jvmc1/index.html\">首篇文章<\/a> 中的 Scala 并行集合例子非常相似：<\/p><div class=\"codesection\"><pre class=\"displaycode\">def bestMatch(target: String) =\n  matchers.par.map(m =&gt; m.bestMatch(target)).\n    foldLeft(DistancePair.worstMatch)((a, m) =&gt; DistancePair.best(a, m))<\/pre><\/div><p>无论语法还是操作都存在一些差别，但实际上，Java 8 并行流代码和 Scala 并行集合代码是在以相同的方式做着同样的事情。<\/p><h3 id=\"N10234\">全程使用流<\/h3><p>迄今为止，所有例子均保留了此系列 <a href=\"http://www.ibm.com/developerworks/cn/java/j-jvmc1/index.html\">首篇文章<\/a> 中比较任务使用的分块结构，在老版本的 Java 中，这种结构是高效处理并行任务所必需的。Java 8\n                并行流设计用于处理它们自己的的工作分工，因此您能够以流的形式传递一个要处理的值集，然后内置的并发处理机制会将这个集合分解到各个可用的处理器进行处理。<\/p><p>如果尝试将这种方法用于编辑距离任务，则会出现很多问题。如果将处理步骤全部链接到一个<em>管道<\/em>（流操作序列的官方叫法）中，那么可以只将每个步骤的结果传给管道的下一阶段。如果想获得多个结果（比如最佳距离值和编辑距离任务中使用的对应已知单词），则必须以对象的形式传递它们。但是与分块方法相比，为每次比较的结果创建一个对象将会损害直接流方法的性能。甚至更糟的情况是，编辑距离计算会重用一对已分配的数组。这对数组无法在并行计算之间共享，因此需要为每次计算重新分配数组。<\/p><p>幸运的是，流 API 支持您有效地应对这种情况，但还需要另外做一些工作。清单 7\n                演示了如何使用流来处理整个计算过程，同时不会创建中间对象或额外的工作数组。<\/p><h5 id=\"listing7\">清单 7. 每次编辑距离比较的流处理<\/h5><div class=\"codesection\"><pre class=\"displaycode\">public class NonchunkedParallelDistance extends TimingTestBase\n{\n    private final String[] knownWords;\n    ...\n    private static int editDistance(String target, String known, int[] v0, int[] v1) {\n    ...\n    }\n    \n    public DistancePair bestMatch(String target) {\n        int size = target.length() + 1;\n        Supplier&lt;WordChecker&gt; supplier = () -&gt; new WordChecker(size);\n        ObjIntConsumer&lt;WordChecker&gt; accumulator = (t, value) -&gt; t.checkWord(target, knownWords[value]);\n        BiConsumer&lt;WordChecker, WordChecker&gt; combiner = (t, u) -&gt; t.merge(u);\n        return IntStream.range(0, knownWords.length).parallel()\n            .collect(supplier, accumulator, combiner).result();\n    }\n    \n    private static class WordChecker {\n        protected final int[] v0;\n        protected final int[] v1;\n        protected int bestDistance = Integer.MAX_VALUE;\n        protected String bestKnown = null;\n        \n        public WordChecker(int length) {\n            v0 = new int[length];\n            v1 = new int[length];\n        }\n        \n        protected void checkWord(String target, String known) {\n            int distance = editDistance(target, known, v0, v1);\n            if (bestDistance &gt; distance) {\n                bestDistance = distance;\n                bestKnown = known;\n            } else if (bestDistance == distance) {\n                bestKnown = null;\n            }\n        }\n        \n        protected void merge(WordChecker other) {\n            if (bestDistance &gt; other.bestDistance) {\n                bestDistance = other.bestDistance;\n                bestKnown = other.bestKnown;\n            } else if (bestDistance == other.bestDistance) {\n                bestKnown = null;\n            }\n        }\n        \n        protected DistancePair result() {\n            return (bestKnown == null) ? new DistancePair(bestDistance) : new \n                DistancePair(bestDistance, bestKnown);\n        }\n    }\n}<\/pre><\/div><p>清单 7 使用一个可变的结果容器类（这里使用的是 <code>WordChecker<\/code>\n                类）来整合结果。<code>bestMatch()<\/code> 方法使用三个 lambdas 形式的活动部分实现了比较。<\/p><ul class=\"ibm-bullet-list\"><li><code>Supplier&lt;WordChecker&gt; supplier<\/code> lambda\n                    提供结果容器的实例。<\/li><li><code>ObjIntConsumer&lt;WordChecker&gt; accumulator<\/code> lambda\n                    将一个新值收集到结果容器中。<\/li><li><code>BiConsumer&lt;WordChecker, WordChecker&gt; combiner<\/code>\n                    lambda 将两个结果容器合并，从而实现值的整合。<\/li><\/ul><p>定义了这三个 lambdas 之后，最后一条 <code>bestMatch()<\/code> 语句将为已知单词数组中的索引创建一个\n                <code>int<\/code> 值的并行流，并将流传递给 <code>IntStream.collect()<\/code>\n                方法。<code>collect()<\/code> 方法使用三个 lambdas 来完成实际的工作。<\/p><h2 id=\"N1026F\">Java 8 并发性能<\/h2><p>图 1 显示了在我使用 Oracle's Java 8 for 64-bit Linux&#174; 的四核 AMD\n                系统上运行测试代码时，对不同大小的块测量性能时的性能变化。与本系列 <a href=\"http://www.ibm.com/developerworks/cn/java/j-jvmc1/index.html\">首篇文章<\/a> 中的定时测试一样，将每个输入的单词依次与 12,564\n                个已知单词进行比较，而每个任务都会在已知单词的范围内找到最佳匹配。所有 933 个拼写错误的输入单词将被反复运行，但在每次传递给 JVM\n                进行处理的间隙会出现暂停。图 1 中使用了 10 次传递后的最佳时间。最终的块大小 16,384\n                大于已知单词的数量，因此这个例子显示的是单线程的性能。定时测试中包含的实现是本文中的四种主要变体和首篇文章中的总体最佳变体：<\/p><ul class=\"ibm-bullet-list\"><li>CompFuture：<a href=\"#listing2\">清单 2 中的\n                        <code>CompletableFutureDistance0<\/code><\/a><\/li><li>CompFutStr：<a href=\"#listing5\">清单 5 中的\n                        <code>CompletableFutureStreamDistance<\/code><\/a><\/li><li>ChunkPar：<a href=\"#listing6\">清单 6 中的\n                        <code>ChunkedParallelDistance<\/code><\/a><\/li><li>ForkJoin：<a href=\"http://www.ibm.com/developerworks/cn/java/j-jvmc1/index.html\">首篇文章<\/a> 中清单 3 中的 <code>ForkJoinDistance<\/code><\/li><li>NchunkPar：<a href=\"#listing7\">清单 7 中的\n                        <code>NonchunkedParallelDistance <\/code><\/a><\/li><\/ul><h5 id=\"fig1\">图 1. Java 8 性能<\/h5><img alt=\"图像显示了某个块大小范围内的 Java 8 性能和实现\" src=\"/sunshine_new/images/负2011673675/chart.png\" width=\"688\" /><p>图 1 显示新的 Java 8 并行流方法的性能非常突出，特别是完全流化的 <a href=\"#listing7\">清单\n                7<\/a><code>\nNchunkPar<\/code>。定时测试结果表现出用于消除对象创建的优化效果（只有图表中的一个值，因为这种方法不使用块大小），这与其他任何方法的最佳效果相当。<code>CompletableFuture<\/code>\n                    方法在性能方面表现稍弱，但这并不意外，因为这个例子并未真正体现出该类的强大功能。<a href=\"#listing5\">清单\n                5<\/a><code> ChunkPar<\/code> 时间大致与 <a href=\"http://www.ibm.com/developerworks/cn/java/j-jvmc1/index.html\">首篇文章<\/a> 中 <code>ForkJoin<\/code>\n                代码相当，但对块大小的敏感性有所降低。对于一次性测试大量单词的所有变体，您会看到块大小较小时性能更差，因为创建对象的开销较之实际的计算工作更高。<\/p><p>和 <a href=\"http://www.ibm.com/developerworks/library/j-jvmc1/index.html\">首篇文章<\/a>\n                中的定时测试结果相同，这些结果只能用作性能参考，具体性能应当以您自己的应用程序为准。这里最重要的一条经验是，只有正确使用新的 Java 8\n                并行流，它才能表现出优异的性能。将优异性能与流的功能性编码方式的开发优点结合起来，就能在值集上进行计算时获得成功。<\/p><h2 id=\"N102C9\">结束语<\/h2><p>Java 8 为开发人员提供一些重要的新功能。并行流实现走在并发性领域前沿，速度更快且易于使用，特别是在与用于功能性编程风格的 lambda\n                表达式（它能够清晰而准确地表达用户意图）结合使用时。当处理独立操作时，新的 <code>CompletableFuture<\/code>\n                类还可以降低并发性编程的难度，在这种情况下不宜使用流模型。<\/p><p>下一篇 <a href=\"https://www.ibm.com/developerworks/cn/views/global/libraryview.jsp?sort_by=&amp;show_abstract=true&amp;show_all=&amp;search_flag=&amp;contentarea_by=Java+technology&amp;search_by=JVM+并发性&amp;product_by=-1&amp;topic_by=-1&amp;type_by=所有类别&amp;ibm-search=搜索\"><em>JVM 并发性<\/em><\/a> 文章将会转而介绍 Scala，并探讨处理异步计算的另一种有趣方式。借助\n                <code>async<\/code> 宏，您可以写出与进行顺序分块操作相似的代码，并通过 Scala\n                将代码转换为完全非分块的结构。我将给出一些例子来说明这种功能的用处和实现。谁知道呢 &#8212; 也许这些来自 Scala 的新功能将会包含在\n                Java 9 中。<\/p><CMA ID: 973796><Site ID: 10><XSLT stylesheet used to transform this file: dw-document-html-7.0.xsl>\r\n\r\n\r\n<\/div>\r\n<\/div>\r\n","createTime":"2014-06-10 00:00:00","deployTime":"2014-06-10 00:00:00","id":0,"intro":"Java 8 包含一些新的语言功能，添加了让编程变得更加简便的类，包括并发性编程。了解 Java 8 扩展提供的全新的、功能强大的并行处理语言支持，其中包括 CompletableFuture 和流。您可以看到，这些新功能与本系列的首篇文章中探讨的某些 Scala 功能有相似之处。","keyword":"","recommend":false,"source":"http://www.ibm.com/developerworks/cn/java/j-jvmc2/index.html","title":"JVM\n            并发性: Java 8 并发性基础","typeId":0,"updateTime":"2014-06-10 00:00:00"}
{"author":"","clickNumber":0,"content":"\r\n<div class=\"ibm-columns\">\r\n<div class=\"ibm-col-1-1\">\r\n\r\n<p>本文介绍了 OpenStack Storage，该产品为其他 OpenStack 项目提供了永久存储。<\/p><p>根据文中对 OpenStack Compute\n                的描述，计算是计算工作量的核心。在某些情况下，一个计算实例可能就是所需的一切，但是，通常需要在实例的整个使用期限内的持久存储，或者说，可能需要在运行的各个服务之间共享大量的数据。<\/p><p>事实上，也可能出现这样的情况：应用程序在 OpenStack 环境以外的地方运行，具体情况取决于可重复、可扩展和可靠的存储，而且 OpenStack\n                Storage 满足了所有这些规范。但是，在评估备选方案之前，重要的是要认识到 OpenStack\n                和其他许多云服务有两个根本不同的存储服务：<\/p><ul class=\"ibm-bullet-list\"><li>OpenStack Swift 是一个对象存储示例，它在概念上与 Amazon Simple Storage Service\n                    类似。<\/li><li>与之相反，OpenStack Cinder 表示块存储，类似于 Amazon Elastic Block Store。<\/li><\/ul><h2 id=\"block_cinder\">块存储 (Cinder)<\/h2><p>Cinder 是 OpenStack Block Storage 的项目名称；它为来宾虚拟机 (VM)\n                提供了持久块存储。对于可扩展的文件系统、最大性能、与企业存储服务的集成以及需要访问原生块级存储的应用程序而言，块存储通常是必需的。<\/p><p>系统可以暴露并连接设备，随后管理服务器的创建、附加到服务器和从服务器分离。应用程序编程接口 (API)\n                也有助于加强快照管理，这种管理可以备份大量块存储。<\/p><h2 id=\"object_swift\">对象存储 (Swift)<\/h2><div class=\"dw-sidebar ibm-inset\"><h2 id=\"when_to_use\">Swift 还是 Cinder？何时使用以及使用哪一种？<\/h2><p>那么，应该使用哪一种对象存储：Swift 还是\n                    Cinder？答案取决于您的应用程序。如果需要运行商用或遗留应用程序，那么很少需要进行这种选择。这些应用程序不可能被编码来利用 Swift\n                    API，但您可以轻松挂载一个 Cinder 磁盘，它表现得就像是直接将存储附加到大多数应用程序。<\/p><p>当然，您还可以对新应用程序使用 Cinder，但是不会从 Swift 自动附带的弹性和冗余中获益。如果编程人员面对这样的挑战，那么 Swift\n                    的分布式可扩展架构是一个值得考虑的特性。<\/p><\/div><p>Swift 是两种产品中较为成熟的一个：自 OpenStack 成立以来一直是一个核心项目。Swift 的功能类似于一个分布式、可访问 API\n                的存储平台，可直接将它集成到应用程序中，或者用于存储 VM 镜像、备份和归档以及较小的文件，例如照片和电子邮件消息。<\/p><p>Object Store 有两个主要的概念：对象和容器。<\/p><p>对象就是主要存储实体。对象中包括与 OpenStack Object Storage\n                系统中存储的文件相关的内容和所有可选元数据。数据保存为未压缩、未加密的格式，包含对象名称、对象的容器以及键值对形式的所有元数据。对象分布在整个数据中心的多个磁盘中，Swift\n                可以借此确保数据的复制和完整性。分布式操作可以利用低成本的商用硬件，同时增强可扩展性、冗余性和持久性。<\/p><p>容器类似于 Windows&#174;\n                文件夹，容器是用于存储一组文件的一个存储室。容器无法被嵌套，但一个租户可以供创建无限数量的容器。对象必须存储在容器中，所以您必须至少拥有一个容器来使用对象存储。<\/p><p>与传统的文件服务器不同，Swift\n                是横跨多个系统进行分布的。它会自动存储每个对象的冗余副本，从而最大程度地提高可用性和可扩展性。对象版本控制提供了防止数据意外丢失或覆盖的额外保护。<\/p><h2 id=\"architecture\">Swift 架构<\/h2><p>Swift 架构包含三个组件：服务器、流程和环。<\/p><h3 id=\"servers\">服务器<\/h3><p>Swift 架构是分布式的，可防止所有单点故障和进行水平扩展。它包括以下四种服务器：<\/p><ul class=\"ibm-bullet-list\"><li>代理服务器<\/li><li>对象服务器<\/li><li>容器服务器<\/li><li>帐户服务器<\/li><\/ul><p>代理服务器为 OpenStack Object Storage\n                架构的其余部分提供一个统一的界面。它接收创建容器、上传文件或修改元数据的请求，还可以提供容器清单或展示存储的文件。当收到请求时，代理服务器会确定帐户、容器或对象在环中的位置，并将请求转发至相关的服务器。<\/p><p>对象服务器是一种简单的服务器，可以上传、修改和检索存储在它所管理的设备上的对象（通常为文件）。对象被存储在本地文件系统中，使用了扩展的属性保存所有的元数据。路径基于对象名称的散列和时间戳。<\/p><p>容器服务器实质上是对象的一个目录。它处理特定容器的对象的分配，并根据请求来提供容器清单。可以跨集群复制该清单，以提供冗余。<\/p><div class=\"dw-sidebar ibm-inset\"><h2 id=\"N1008F\">试一试！<\/h2><\/div><p>帐户服务器通过使用对象存储服务来管理帐户。它的操作类似于在内部提供了清单的容器服务器，在这种情况下，将会枚举分配到给定帐户的容器。<\/p><h3 id=\"processes\">流程<\/h3><p>有几种预定的内部管理流程可以管理数据存储，包括复制服务、审计程序（auditor）和更新程序（updater）。<\/p><p>复制服务是至关重要的流程：确保整个集群的一致性和可用性。由于对象存储的一个主要吸引点是其分布式存储，所以 OpenStack\n                必须在瞬态错误条件下确保获得一致的状态，例如断电或组件故障。复制服务通过定期对比本地数据与远程副本并确保所有副本都包含最新版本来做到这一点。<\/p><p>为了最大程度地减少进行对比所需的网络流量的数量，该服务创建了每个分区分段的一个散列（hash），并比较这些列表。容器和帐户复制也可以使用散列，但通过高水位标记（high-water\n                mark）对这些散列进行了补充。实际的更新被推送，通常使用 <code>rsync<\/code> 来复制对象、容器和帐户。<\/p><p>在删除对象、容器或帐户时，复制器（replicator）还会执行垃圾收集来实施一致的数据删除。在删除时，系统会使用一个墓碑图片来标记最新版本，这是一个告诉复制器可以从所有重复的节点中删除对象、容器或帐户的信号。<\/p><p>即使是最好的复制设计，也只在拥有实现该复制的组件时有效，不过，无论是硬件故障还是软件故障，抑或只是因为产品能力不足，生产环境都必须能够重现这些故障。在\n                Swift 中，该操作是由更新程序和审计程序来完成的。<\/p><p>更新程序负责在系统面临故障时确保系统的完整性。当复制服务遇到一个问题，并且无法更新容器或帐户时，就会出现一段时间的不一致，在此其间，对象虽然存在于存储中，但并未列出在所有容器或帐户服务器上。在这种情况下，系统会在本地文件系统上对更新进行排队，并有一个更新程序会定期重试更新。<\/p><p>审计程序对这种不一致提供额外级别的保护。它们定期扫描本地存储库，验证帐户、容器和对象的完整性。在确认任何损坏时，审计程序会隔离该元素，并使用来自另一个复制物的副本替换它。如果发现了无法协调的不一致性（例如，对象不属于任何容器），审计程序就会将该错误记录在一个日志文件中。<\/p><h3 id=\"rings\">环<\/h3><p>用户和其他 OpenStack\n                项目会根据逻辑名称来引用存储实体，但最终，所有请求，无论是用于读取还是用于写入，都必须映射到某个物理位置。为了完成这一操作，代理服务器和后台流程（包括复制服务）都必须能够将逻辑名称映射到物理位置。这种映射就称为一个环（ring）。帐户、容器和对象都配有单独的环。环根据设备、分区、副本和专区来描述这一映射。<\/p><p>在此上下文中，术语<em>分区<\/em> 指的是环中所存储内容的逻辑子集。建议为每个参与设备分配 100 个分区。分区均匀地分布在分配给\n                OpenStack Object Storage\n                的所有设备上。如果集群使用了不同规格的驱动，那么有可能会分配权重，以便平衡各个设备上的分区的分布。<\/p><p>默认情况下，每个分区可被复制三次。有可能会使用一个较大的数字来优化可用性，但这显然会增加存储消耗。环还会指定在故障场景中使用哪些设备来接管工作负载，以及在向集群添加设备或从中删除设备时如何重新分配分区。<\/p><p>环映射的最后一个元素是专区，用于启用数据亲和性和反亲和性，一个专区可以表示一个存储设备、一个物理服务器或者一个位置，例如机架、通道或数据中心，专区是用户可用来满足其需求的一个逻辑概念，但通常反映的是物理元素，例如位置、电源和网络连接。<\/p><h2 id=\"cinder_arch\">Cinder 架构<\/h2><p>Cinder 比 Swift 简单得多，因为它不提供自动对象分布和复制。图 1 显示了 Cinder 架构。<\/p><h5 id=\"fig1\">图 1. Cinder architecture<\/h5><img alt=\"该图显示了 Cinder 架构\" src=\"/sunshine_new/images/负569518384/figure1.png\" width=\"750\" /><p>与其他 OpenStack 项目类似，Cinder 的功能通过 API 暴露给仪表板和命令行。它能够通过具有具象状态传输\n                (Representational State Transfer, REST) 的 HTTP API 来访问对象存储，并使用一个名为\n                <code>Auth Manager<\/code> 的 Python 类将身份验证纳入 OpenStack Keystone。<\/p><p>API\n                解析所有传入的请求并将它们转发给消息队列，调度程序和卷服务器在该队列中执行实际的工作。在创建新的卷时，调度程序将会决定哪台主机应对该卷负责。默认情况下，它会选择拥有最多可用空间的节点。<\/p><p>卷管理程序管理着可动态附加的块存储设备，这些设备也被称为卷。它们可用作虚拟实例的启动设备，或作为辅助存储进行添加。Cinder\n                还为快照（卷的只读副本）提供了一种设备。然后可以使用这些快照来创建新的卷，以供读写使用。<\/p><p>卷通常通过 iSCSI\n                附加到计算节点。块存储也需要某种形式的后端存储，在默认情况下，该后端存储是本地卷组上的逻辑卷管理，但可以通过驱动程序将它扩展到外部存储阵列或设备。<\/p><h2 id=\"setup\">设置<\/h2><p>实际的安装指令在发行版和 OpenStack\n                版本之间极为不同。通常，它们可作为发行版的一部分。但是，必须完成相同的基本任务。本节将会介绍其中涉及的概念。<\/p><h3 id=\"sys-reqs\">系统要求<\/h3><p>OpenStack 依赖于一种 64 位 x86 架构；另外，它是为商用硬件而设计的，所以具有极低的系统要求。它可以在配有包含 8GB RAM\n                的单个系统上运行整套 OpenStack\n                项目。但是，对于大型的工作负载，它对于使用专用系统来实现存储至关重要。因为我们的重点在商用设备上，所以不需要独立磁盘冗余阵列 (redundant\n                array of independent disks, RAID) 功能，但使用至少两个四核 CPU、8-12GB 的 RAM 和 1GB\n                的网络适配器是一种明智之举。显然，硬盘或固态磁盘的大小取决于要存储的数据量和希望的冗余级别。<\/p><h3 id=\"install\">安装<\/h3><p>安装指令取决于发行版，更具体地讲，取决于您所选择的包管理实用程序。在许多情况下，必须声明存储库。所以，举例而言，如果您使用的是\n                Zypper，那么您要用 <code>zypper ar<\/code> 向 <code>libzypp<\/code> 公开：<\/p><p><a href=\"#N100F4\" class=\"ibm-popup-link\" onclick=\"ibmweb.overlay.show('N100F4',this);return false;\">点击查看代码清单<\/a><\/p><div id=\"N100F4\" class=\"dw-sidefile-overlay ibm-common-overlay ibm-overlay-alt-two\"><div class=\"ibm-head\"><p><a href=\"#close\" class=\"ibm-common-overlay-close\">关闭 [x]<\/a><\/p><\/div><div class=\"ibm-body\"><div class=\"ibm-main\"><div class=\"ibm-container ibm-alternate\"><div class=\"ibm-container-body\"><div class=\"codesection\"><pre class=\"displaycode no-auto-overflow\"># zypper ar -f http://download.opensuse.org/repositories/Cloud:/OpenStack:/Grizzly/SLE_11_SP3/Cloud:OpenStack:Grizzly.repo<\/pre><\/div><\/div><\/div><\/div><\/div><div class=\"ibm-footer\"><><\/div><\/div><p>然后，安装所需的 Swift 和/或 Cinder 包。包管理实用程序应自动安装所有依赖关系。整个安装程序取决于您所期望的配置和 OpenStack\n                的准确版本。请务必查看安装指南中的权威说明，为了演示之目的，下面提供了适用于 Debian（例如 Ubuntu）、Red Hat（例如，Red\n                Hat Enterprise Linux&#174;、CentOS、Fedora）和 openSUSE 的一些主要命令。<\/p><ul class=\"ibm-bullet-list\"><li><strong>Debian<\/strong>：在所有主机上安装基础 Swift 包：\n                        <div class=\"codesection\"><pre class=\"displaycode\">sudo apt-get install python-swift\nsudo apt-get install swift\nand the server-specific packages on the hosts that will be running them:\nsudo apt-get install swift-auth\nsudo apt-get install swift-proxy\nsudo apt-get install swift-account\nsudo apt-get install swift-container\nsudo apt-get install swift-object<\/pre><\/div><p>Cinder\n                        包包含\n                        API、调度程序和卷管理程序：<\/p><div class=\"codesection\"><pre class=\"displaycode\">sudo apt-get install cinder-api\nsudo apt-get install cinder-scheduler\nsudo apt-get install cinder-volume<\/pre><\/div><\/li><li><strong>Red Hat<\/strong>：在 Red Hat 系统上，使用的命令是：\n                        <div class=\"codesection\"><pre class=\"displaycode\">sudo yum install openstack-swift\nsudo yum install openstack-swift-proxy\nsudo yum install openstack-swift-account\nsudo yum install openstack-swift-container\nsudo yum install openstack-swift-object\nsudo yum install openstack-swift-doc\nsudo yum install openstack-cinder\nsudo yum install openstack-cinder-doc<\/pre><\/div><\/li><li><strong>openSUSE<\/strong>：使用以下命令：\n                        <div class=\"codesection\"><pre class=\"displaycode\">sudo zypper install  openstack-swift\nsudo zypper install  openstack-swift-auth \nsudo zypper install  openstack-swift-account \nsudo zypper install  openstack-swift-container \nsudo zypper install  openstack-swift-object \nsudo zypper install  openstack-swift-proxy\nsudo zypper install openstack-cinder-api\nsudo zypper install openstack-cinder-scheduler\nsudo zypper install openstack-cinder-volume<\/pre><\/div><\/li><\/ul><h3 id=\"config\">配置<\/h3><p>配置 OpenStack Object Storage 安装涉及到为四个包的每一个包量身定制配置文件：<\/p><ul class=\"ibm-bullet-list\"><li>account-server.conf<\/li><li>container-server.conf<\/li><li>object-server.conf<\/li><li>proxy-server.conf<\/li><\/ul><p>配置文件安装在 /etc/swift/ 中。默认的一组选项在标准安装中运作良好，但在有特殊需求时，有必要编辑该配置。<\/p><h2 id=\"scenarios\">使用场景<\/h2><p>如欲了解如何使用 OpenStack\n                存储，可以想象这样一个场景：在该场景中，有一项服务使用一个文件系统和新代码运行了遗留软件，您想在该文件系统和新代码中使用分布式对象存储。适用于此项目的环境应该包括\n                Swift 和 Cinder。<\/p><p>首先来看一看 Cinder。<\/p><ol><li>以具有 Member 角色的用户身份登录到 OpenStack Dashboard。在导航面板中的 Manage Computer 下，单击\n                        <strong>Volumes<\/strong> &gt; <strong>Create Volume<\/strong>。 <h5 id=\"fig2\">图 2. 创建一个卷<\/h5><img alt=\"该图显示了如何创建一个卷\" src=\"/sunshine_new/images/负569518384/figure2.jpg\" width=\"709\" /><\/li><li>卷应出现在项目的列表中。 <h5 id=\"fig3\">图 3. 项目中的卷<\/h5><img alt=\"该图显示了项目的卷\" src=\"/sunshine_new/images/负569518384/figure3.jpg\" width=\"800\" height=\"356\" /><p><a href=\"#N10147\" class=\"ibm-popup-link\" onclick=\"ibmweb.overlay.show('N10147',this);return false;\">点击查看大图<\/a><\/p><div id=\"N10147\" class=\"dw-sidefile-overlay ibm-common-overlay ibm-overlay-alt-two\"><div class=\"ibm-head\"><p><a href=\"#close\" class=\"ibm-common-overlay-close\">关闭 [x]<\/a><\/p><\/div><div class=\"ibm-body\"><div class=\"ibm-main\"><div class=\"ibm-title\"><h2>图 3. 项目中的卷<\/h2><\/div><div class=\"ibm-container ibm-alternate\"><div class=\"ibm-container-body\"><img alt=\"该图显示了项目的卷\" src=\"/sunshine_new/images/负569518384/figure3.jpg\" width=\"1000\" /><\/div><\/div><\/div><\/div><div class=\"ibm-footer\"><><\/div><\/div><\/li><li>编辑附件，以便将卷连接到其中一个计算实例。 <h5 id=\"fig4\">图 4. 管理卷附件<\/h5><img alt=\"该图显示了如何编辑附件\" src=\"/sunshine_new/images/负569518384/figure4.jpg\" width=\"713\" /><\/li><\/ol><p>OpenStack 创建一个惟一的 iSCSI 合格名称，并将其显示给目前具有活动 iSCSI 会话的计算节点。如果实例是逻辑存储（通常是一个\n                /dev/sdX 磁盘），那么可以使用 Cinder 卷。<\/p><p>要想对您的项目使用 Swift，首先必须创建一个容器。<\/p><ol><li>作为具有 Member 角色的用户身份登录到 OpenStack Dashboard，在导航面板的 Object Store 下，单击\n                        <strong>Containers<\/strong> &gt; <strong>Create\n                    Container<\/strong>。 <h5 id=\"fig5\">图 5. 创建容器<\/h5><img alt=\"该图显示了如何创建一个容器\" src=\"/sunshine_new/images/负569518384/figure5.jpg\" width=\"696\" /><p>这是一个简单的操作，根本不会涉及提供任何数据。它只是一个名称而已。<\/p><\/li><li>当拥有容器之后，通常由应用程序使用对象填充它，并根据需要使用一个编程接口来检索这些对象。 <h5 id=\"fig6\">图 6. 已填充的容器<\/h5><img alt=\"该图显示了已填充的容器\" src=\"/sunshine_new/images/负569518384/figure6.jpg\" width=\"800\" height=\"521\" /><p><a href=\"#N10176\" class=\"ibm-popup-link\" onclick=\"ibmweb.overlay.show('N10176',this);return false;\">点击查看大图<\/a><\/p><div id=\"N10176\" class=\"dw-sidefile-overlay ibm-common-overlay ibm-overlay-alt-two\"><div class=\"ibm-head\"><p><a href=\"#close\" class=\"ibm-common-overlay-close\">关闭 [x]<\/a><\/p><\/div><div class=\"ibm-body\"><div class=\"ibm-main\"><div class=\"ibm-title\"><h2>图 6. 已填充的容器<\/h2><\/div><div class=\"ibm-container ibm-alternate\"><div class=\"ibm-container-body\"><img alt=\"该图显示了已填充的容器\" src=\"/sunshine_new/images/负569518384/figure6.jpg\" width=\"1000\" /><\/div><\/div><\/div><\/div><div class=\"ibm-footer\"><><\/div><\/div><\/li><li>不过，您还可以从仪表板上传对象。在 Object Store 下，单击 <strong>Containers<\/strong> &gt;\n                        <strong>Upload Object<\/strong> 并提供一个包含存储内容的文件。 <h5 id=\"fig7\">图 7. 上传对象<\/h5><img alt=\"该图显示了如何上传对象\" src=\"/sunshine_new/images/负569518384/figure7.jpg\" width=\"694\" /><\/li><\/ol><p>您还可以使用界面来下载、复制或删除对象。<\/p><h2 id=\"N1018E\">结束语<\/h2><p>如您所见，OpenStack 提供了一个直观的界面来设置私有云存储，并使其可用于工作负载。这些只是所有可能情况的冰山一角。例如，许多客户使用 Ceph\n                或 GlusterFS\n                作为后端存储机制，但即使在这些情况下，最终用户也只需与用户界面进行交互。如您在本系列的前几篇文章中已经了解到的，OpenStack\n                仅仅是集成一组可插拔组件的抽象层。<\/p><CMA ID: 973813><Site ID: 10><XSLT stylesheet used to transform this file: dw-document-html-7.0.xsl>\r\n\r\n\r\n<\/div>\r\n<\/div>\r\n","createTime":"2014-06-10 00:00:00","deployTime":"2014-06-10 00:00:00","id":0,"intro":"本文将介绍 OpenStack Block (Swift) 和 Object (Glance) 存储，解释它如何融入到整体架构中，并展示它的操作方式。本文还将在介绍这些工具的过程中了解了如何安装、配置和使用各种组件。","keyword":"","recommend":false,"source":"http://www.ibm.com/developerworks/cn/cloud/library/cl-openstack-swift-cinder/index.html","title":"发现 OpenStack: Storage 组件 Swift 和 Cinder","typeId":0,"updateTime":"2014-06-10 00:00:00"}
{"author":"","clickNumber":0,"content":"\r\n<div class=\"ibm-columns\">\r\n<div class=\"ibm-col-1-1\">\r\n\r\n<h2 id=\"stubsmadeeasierwithrationalintegrationtester\">通过使用 Rational Integration Tester 更加便捷创建测试存根<\/h2><p><em>集成测试<\/em>（Integration testing）是指横跨所有组件和服务的界限测试一个用户应用程序。但是，要做到这一点并不总是那么容易。<\/p><p>例如系统的一些组件可能还并不可用――也许是因为某个特定的服务仍处在开发之中；某些服务可能由于别的人正在使用而不能共享，又或者是使用起来可能会很昂贵；开放对其他服务的访问可能暴露隐私数据给测试人员，所以这些服务并不能提供给测试团队。<\/p><p>如果您通过使用存根（Stub）隔离替代这些系统组件，您就可以直接测试系统而无需等待组件变得可用了。然而，测试人员传统上需要依赖于开发人员来创建这些存根。通常情况下这些存根都并不用户友好，而且您也很少有机会能再重用它们。而且，存根的维护通常也是由开发人员来处理的。<\/p><p>IBM&#174; Rational&#174; Integration Tester（IBM&#174; Rational&#174; Test Workbench 的一部分）是一个桌面解决方案，旨在帮助您解决测试遗留或现代的架构所带来的挑战：<\/p><ul class=\"ibm-bullet-list\"><li>可视化服务和组件之间的连接与依赖关系，来规划集成测试策略<\/li><li>为对测试来说不可用的服务创建存根，使得持续集成测试成为可能，并减少应用程序中存在的错误所带来的风险<\/li><li>自动化集成测试的各个方面<\/li><\/ul><h2 id=\"howintegrationtestingworkswithrationalintegrationtester\">如何使用 Rational Integration Tester 进行集成测试<\/h2><p>下面的步骤详细说明您可以如何轻松地使用 Rational Integration Tester 为集成测试创建存根。<\/p><h3 id=\"N10084\">配置 Library Manager<\/h3><p>支持多种技术――例如开箱即用的 web 服务和电子邮件。然而，对于专有技术需要由外部库（或 Java JAR 文件）来提供。这些库由该软件的安装文件来提供。Library Manager（库管理器）， Rational Integration Tester 的主要配置工具，可帮助您管理这些受支持的技术。<\/p><p>要配置进行测试所需要的库，打开 Library Manager，并从  <strong>Database (JDBC)<\/strong> 选项卡中开始配置以下项：<\/p><ol type=\"1\"><li>从 <strong>Providers<\/strong> 部分选择 <strong>IBM DB2 9.7<\/strong><\/li><li>浏览到 <strong>Installation Directory<\/strong>，如图 1 所示：<\/li><\/ol><h5 id=\"fig1\">图 1. 为 IBM DB2 配置 Library Manager<\/h5><img alt=\"配置 Library Manager，选择 IBM DB2 9.7\" src=\"/sunshine_new/images/负1400194277/image001.jpg\" width=\"719\" /><p>这一演示使用样例 WSDL 来添加数字，它不需要任何特定的 Library Manager 设置项。<\/p><p>在配置完所需要的库之后，您就可以开始工作在一个 Rational Integration Tester 项目之上了。<\/p><h3 id=\"N100AC\">创建一个新项目<\/h3><p>一个项目就像是一个用户工作台，您可以在此创建测试和存根，并执行它们。创建一个项目需要三个步骤：<\/p><ol type=\"1\"><li>设置名称和位置<\/li><li>连接到项目数据库<\/li><li>建立一个基于用户的权限<\/li><\/ol><p>步骤 2 和 3 是可选的，虽然第 2 步被建议进行，因为您可以记录和查看测试结果。在这里，我创建了一个带 <strong>MySQl C projectdb<\/strong> 数据库的项目（假定项目数据库 projectdb 是使用 MySQL 创建的）。<\/p><p>在 Rational Integration Tester 欢迎页面上点击 <strong>New Project<\/strong>，设置名称和位置，并点击 Next 按钮导航，直到您到达  Create New Project 向导的 Server Settings 界面。 选择这些服务器设置：<\/p><ul class=\"ibm-bullet-list\"><li>Database provider：<strong>MySQL<\/strong><\/li><li>Database URL：jdbc:mysql://localhost:3306/projectdb<\/li><li>Username：<strong>root<\/strong><\/li><li>Password：您的数据库密码<\/li><\/ul><p>当这些步骤完成后，单击 <strong>Finish<\/strong> 按钮，如图 2 所示：<\/p><h5 id=\"fig2\">图 2. 创建新项目的详细信息<\/h5><img alt=\"创建新项目并选择服务器设置\" src=\"/sunshine_new/images/负1400194277/image002.jpg\" width=\"500\" /><p>当您创建完您的项目之后，您就可以使用工作台创建您的测试环境了。请注意 Perspectives 工具栏，其中有六个<em>视角<\/em>（perspective）。参见图 3：<\/p><h5 id=\"fig3\">图 3. Workbench 布局<\/h5><img alt=\"Workbench 布局显示视角工具栏\" src=\"/sunshine_new/images/负1400194277/image003.jpg\" width=\"850\" /><p>图 4 显示了这六个视角及每个视角的描述：<\/p><h5 id=\"fig4\">图 4. 六个视角<\/h5><img alt=\"六个视角及每个视角的描述\" src=\"/sunshine_new/images/负1400194277/image004.jpg\" width=\"497\" /><h3 id=\"N10268\">创建测试环境<\/h3><p>测试环境是关于测试资源的一组运行时配置设置。要创建测试环境，从 Rational Integration Tester 工作台选择 <strong>Project<\/strong>，并点击 <strong>Create New Environment<\/strong>。图 5 显示了 Create New Environment 向导。指定环境的名称――在这个例子中，使用 <strong>demo<\/strong>――然后点击 OK。<\/p><h5 id=\"fig5\">图 5. 创建新环境向导<\/h5><img alt=\"创建新的测试环境\" src=\"/sunshine_new/images/负1400194277/image005.jpg\" width=\"296\" /><h3 id=\"N10116\">为测试构建模型系统<\/h3><p>为了构建用于测试的模型系统，您首先要添加新的 Web 服务描述语言（Web Services Description Language，WSDL）。对于这个演示中，我使用的样例 WSDL 来添加数字。假定服务开始于 http://localhost:8088/addNumbers?wsdl 这一位置。要调用新的 WSDL 向导，请按照下列步骤操作：<\/p><p>在逻辑视图（logical view）中右键单击，并选择 <strong>New &gt; Web &gt; WSDL &gt; Wizard<\/strong>。 参见图 6：<\/p><h5 id=\"fig6\">图 6. 调用添加新的WSDL向导<\/h5><img alt=\"为了构建用于测试的模型系统，要添加新的 WSDL\" src=\"/sunshine_new/images/负1400194277/image006.jpg\" width=\"850\" /><p>用于添加新的 WSDL 的向导将会出现。单击 <strong>New<\/strong>。参见图 7：<\/p><h5 id=\"fig7\">图 7. 配置 WSDL 对话框<\/h5><img alt=\"配置向导来创建新的 WSDL\" src=\"/sunshine_new/images/负1400194277/image007.jpg\" width=\"540\" /><p>在 New WSDL 向导上，点击 <strong>Change<\/strong> 按钮。参见图 8：<\/p><h5 id=\"fig8\">图 8. 浏览到 New WSDL 位置对话框<\/h5><img alt=\"New WSDL 位置对话框提供了 Change 按钮\" src=\"/sunshine_new/images/负1400194277/image008.jpg\" width=\"393\" /><p>在 Select Location 向导中，点击 <strong>URL<\/strong> 选项卡。在 URL 域，输入：<strong>http://localhost:8088/addNumbers?wsdl<\/strong>。点击 <strong>OK<\/strong>。参见图 9：<\/p><h5 id=\"fig9\">图 9. 选择 WSDL 位置的对话框<\/h5><img alt=\"Select Location 对话框显示的 URL 域\" src=\"/sunshine_new/images/负1400194277/image009.jpg\" width=\"441\" /><p>现在 addNumbers 的 WSDL 已经在向导中添加好了。点击 <strong>Next<\/strong>。参见图 10：<\/p><h5 id=\"fig10\">图 10. 已配置好 WSDL 的对话框<\/h5><img alt=\"已配置好 WSDL 的对话框包括了 addNumbers WSDL\" src=\"/sunshine_new/images/负1400194277/image010.jpg\" width=\"540\" /><p>现在，您可以创建一个新的服务组件，或选择一个已有的组件。在本演示中，您要创建一个新的组件，所以请使用默认选择 <strong>Create a new Component<\/strong>。点击 <strong>Next<\/strong>。参见图 11：<\/p><h5 id=\"fig11\">图 11. 创建新组件对话框<\/h5><img alt=\"选择一个新的或已有的服务组件\" src=\"/sunshine_new/images/负1400194277/image011.jpg\" width=\"540\" /><p>下一步向导会询问您是否要创建一个新的环境，或是选择现有的。如图 12 所示，您已经为项目创建了环境，并把它命名为 <strong>demo<\/strong>。继续点击 <strong>Next<\/strong>：<\/p><h5 id=\"fig12\">图 12. 配置环境对话框<\/h5><img alt=\"配置所需要的环境\" src=\"/sunshine_new/images/负1400194277/image012.jpg\" width=\"533\" /><p>图 13 显示了下一组选项。选择 <strong>Open Synchronization View and perform the synchronization<\/strong>。点击 <strong>Finish<\/strong> 来完成 WSDL 同步（synchronization）选项。<\/p><h5 id=\"fig13\">图 13. 同步选项对话框<\/h5><img alt=\"完成 Synchronization Options 对话框\" src=\"/sunshine_new/images/负1400194277/image013.jpg\" width=\"538\" /><p>点击 <strong>Schema Library<\/strong> 选项卡。图 14 显示了 WSDL 模式：<\/p><h5 id=\"fig14\">图 14. Schema Library<\/h5><img alt=\"Schema Library 对话框显示了 WSDL schema\" src=\"/sunshine_new/images/负1400194277/image014.jpg\" width=\"850\" /><p><a href=\"#N101B4\" class=\"ibm-popup-link\" onclick=\"ibmweb.overlay.show('N101B4',this);return false;\">点击查看大图<\/a><\/p><div id=\"N101B4\" class=\"dw-sidefile-overlay ibm-common-overlay ibm-overlay-alt-two\"><div class=\"ibm-head\"><p><a href=\"#close\" class=\"ibm-common-overlay-close\">关闭 [x]<\/a><\/p><\/div><div class=\"ibm-body\"><div class=\"ibm-main\"><div class=\"ibm-title\"><h2>图 14. Schema Library<\/h2><\/div><div class=\"ibm-container ibm-alternate\"><div class=\"ibm-container-body\"><img alt=\"Schema Library 对话框显示了 WSDL schema\" src=\"/sunshine_new/images/负1400194277/image014_lg.jpg\" width=\"1412\" /><\/div><\/div><\/div><\/div><div class=\"ibm-footer\"><><\/div><\/div><p>WSDL 已经是同步的了。点击 <strong>Logical View<\/strong> 选项卡来查看它与已建模系统的更新，如图 15 所示：<\/p><h5 id=\"fig15\">图 15. 系统建模视图<\/h5><img alt=\"Logical View 选项卡显示已建模系统\" src=\"/sunshine_new/images/负1400194277/image015.jpg\" width=\"470\" /><h3 id=\"N101C8\">创建新的测试<\/h3><p>您可以在测试 Test Factory 视角创建测试。切换到 Test Factory 视角。然后：<\/p><ol type=\"1\"><li>使用消息交换模式（Message Exchange Pattern，MEP）窗口调用测试。<\/li><li>右键点击 <strong>addition<\/strong> 操作并选择 <strong>New &gt; Tests &gt; Test using MEP<\/strong>。<\/li><\/ol><p><strong>Send Request<\/strong> 并 <strong>Receive Reply<\/strong> 的动作将被添加到测试中。参见图 16：<\/p><h5 id=\"fig16\">图 16. 编辑发送请求<\/h5><img alt=\"编辑 Send Request 界面\" src=\"/sunshine_new/images/负1400194277/image016.jpg\" width=\"576\" /><p>您可以修改 Send Request 和 Receive Reply 动作的标签（tags）或变量（variables）。标签提供运行时的配置设置来测试资源，并用来在 Rational Integration Tester 中传递信息。<\/p><p>当前的测试修改了输入值。参见图 17：<\/p><h5 id=\"fig17\">图 17. 编辑接收回复<\/h5><img alt=\"编辑 Receive Reply 界面\" src=\"/sunshine_new/images/负1400194277/image017.jpg\" width=\"579\" /><h3 id=\"N101FA\">保存并执行测试<\/h3><p>现在您已经可以保存您刚才所创建的测试了。 要做到这一点请操作：<\/p><ol type=\"1\"><li>右键点击 test 来获得右键菜单选项。<\/li><li>选择 <strong>Run<\/strong>。<\/li><li>查看测试是否通过。<\/li><\/ol><p>当测试通过之后，您会看到 Execution Result 对话框被显示，如图 18 所示：<\/p><h5 id=\"fig18\">图 18. 测试的执行结果<\/h5><img alt=\"测试通过之后的 Execution Result\" src=\"/sunshine_new/images/负1400194277/image018.jpg\" width=\"850\" /><p><a href=\"#N10219\" class=\"ibm-popup-link\" onclick=\"ibmweb.overlay.show('N10219',this);return false;\">点击查看大图<\/a><\/p><div id=\"N10219\" class=\"dw-sidefile-overlay ibm-common-overlay ibm-overlay-alt-two\"><div class=\"ibm-head\"><p><a href=\"#close\" class=\"ibm-common-overlay-close\">关闭 [x]<\/a><\/p><\/div><div class=\"ibm-body\"><div class=\"ibm-main\"><div class=\"ibm-title\"><h2>图 18. 测试的执行结果<\/h2><\/div><div class=\"ibm-container ibm-alternate\"><div class=\"ibm-container-body\"><img alt=\"测试通过之后的 Execution Result\" src=\"/sunshine_new/images/负1400194277/image018_lg.jpg\" width=\"1519\" /><\/div><\/div><\/div><\/div><div class=\"ibm-footer\"><><\/div><\/div><h3 id=\"N1021E\">为服务创建存根<\/h3><p>存根（Stubs）将模拟当前不可用的服务。创建存根的一种方法是通过使用 MEP 窗口。首先您要在 Test Factory 视角来选择要进行存根的操作――在这一示例中是 <strong>addition<\/strong> 运算操作。右键点击 <strong>addition<\/strong>，并选择 <strong>New &gt; Stubs &gt; Stub using MEP<\/strong>。<\/p><p><strong>addition<\/strong> 操作的 MEP 定义是基于 WSDL 文件中的信息。存根的细节信息显示于图 19：<\/p><h5 id=\"fig19\">图 19. 编辑存根<\/h5><img alt=\"addition 操作存根的细节信息\" src=\"/sunshine_new/images/负1400194277/image019.jpg\" width=\"850\" /><p><a href=\"#N1023D\" class=\"ibm-popup-link\" onclick=\"ibmweb.overlay.show('N1023D',this);return false;\">点击查看大图<\/a><\/p><div id=\"N1023D\" class=\"dw-sidefile-overlay ibm-common-overlay ibm-overlay-alt-two\"><div class=\"ibm-head\"><p><a href=\"#close\" class=\"ibm-common-overlay-close\">关闭 [x]<\/a><\/p><\/div><div class=\"ibm-body\"><div class=\"ibm-main\"><div class=\"ibm-title\"><h2>图 19. 编辑存根<\/h2><\/div><div class=\"ibm-container ibm-alternate\"><div class=\"ibm-container-body\"><img alt=\"addition 操作存根的细节信息\" src=\"/sunshine_new/images/负1400194277/image019_lg.jpg\" width=\"1235\" /><\/div><\/div><\/div><\/div><div class=\"ibm-footer\"><><\/div><\/div><p>Rational Integration Tester 为测试和存根供了诸多元素，如决策点（decision point）、循环（loop）和调用其它测试或外部过程――甚至对数据库的 SQL 调用（SQL call）。所有这些元素可以通过图形界面（GUI）来添加，而无需编写任何代码。<\/p><h3 id=\"N10244\">保存并执行存根<\/h3><p>为了确保存根已经取代了服务， 停止 <strong>addition<\/strong> 服务，如果它依然在运行的话。您可以通过执行您所创建的 addition 测试来确保它已停止。如果服务没有运行，测试将会失败，如图 20 所示：<\/p><h5 id=\"fig20\">图 20. 测试执行失败的结果<\/h5><img alt=\"测试执行失败结果的屏幕界面\" src=\"/sunshine_new/images/负1400194277/image020.jpg\" width=\"850\" /><p><a href=\"#N10259\" class=\"ibm-popup-link\" onclick=\"ibmweb.overlay.show('N10259',this);return false;\">点击查看大图<\/a><\/p><div id=\"N10259\" class=\"dw-sidefile-overlay ibm-common-overlay ibm-overlay-alt-two\"><div class=\"ibm-head\"><p><a href=\"#close\" class=\"ibm-common-overlay-close\">关闭 [x]<\/a><\/p><\/div><div class=\"ibm-body\"><div class=\"ibm-main\"><div class=\"ibm-title\"><h2>图 20. 测试执行失败的结果<\/h2><\/div><div class=\"ibm-container ibm-alternate\"><div class=\"ibm-container-body\"><img alt=\"测试执行失败结果的屏幕界面\" src=\"/sunshine_new/images/负1400194277/image020_lg.jpg\" width=\"1400\" /><\/div><\/div><\/div><\/div><div class=\"ibm-footer\"><><\/div><\/div><p>现在执行存根：<\/p><ol type=\"1\"><li>右键点击您所创建的存根来查看右键菜单选项。<\/li><li>选择 <strong>Run<\/strong>。<\/li><li>在右侧面板检查存根的状态是否为 <strong>Ready<\/strong>。<\/li><li>再次执行 <strong>addition<\/strong> 测试。<\/li><\/ol><p>这一次测试应当通过，如果图 21 所示：<\/p><h5 id=\"fig21\">图 21. 执行测试通过的结果<\/h5><img alt=\"测试执行通过结果的屏幕界面\" src=\"/sunshine_new/images/负1400194277/image021.jpg\" width=\"850\" /><p><a href=\"#N10280\" class=\"ibm-popup-link\" onclick=\"ibmweb.overlay.show('N10280',this);return false;\">点击查看大图<\/a><\/p><div id=\"N10280\" class=\"dw-sidefile-overlay ibm-common-overlay ibm-overlay-alt-two\"><div class=\"ibm-head\"><p><a href=\"#close\" class=\"ibm-common-overlay-close\">关闭 [x]<\/a><\/p><\/div><div class=\"ibm-body\"><div class=\"ibm-main\"><div class=\"ibm-title\"><h2>图 21. 执行测试通过的结果<\/h2><\/div><div class=\"ibm-container ibm-alternate\"><div class=\"ibm-container-body\"><img alt=\"测试执行通过结果的屏幕界面\" src=\"/sunshine_new/images/负1400194277/image021_lg.jpg\" width=\"1403\" /><\/div><\/div><\/div><\/div><div class=\"ibm-footer\"><><\/div><\/div><p>如果其他团队成员需要重复使用存根，也可以使用 IBM&#174; Rational&#174; Test Virtualization Server 发布到的 IBM&#174; Rational&#174; Test Control Panel。<\/p><h2 id=\"conclusion\">结论<\/h2><p>使用 Rational Integration Tester 构建和维护服务存根非常容易，因为这一过程无需任何编程技能，并且确保可以最大化的重用。Rational Integration Tester 可以通过以下三个关键方式提供帮助：<\/p><ol type=\"1\"><li>当服务不可用时您依然可以继续进行测试。<\/li><li>您可以尽早和更经常地进行测试，从而减少缺陷所带来的成本开销。<\/li><li>您可以通过控制服务来强制被测试系统中服务的行为（或者，更具体地，从这些服务所返回的响应）。<\/li><\/ol><CMA ID: 973638><Site ID: 10><XSLT stylesheet used to transform this file: dw-document-html-7.0.xsl>\r\n\r\n\r\n<\/div>\r\n<\/div>\r\n","createTime":"2014-06-09 00:00:00","deployTime":"2014-06-09 00:00:00","id":0,"intro":"集成测试是具有挑战性的，因为――虽然一个应用程序的所有组件都应该被测试――但并不是所有的组件都一定可用。通过使用 IBM Rational Integration Tester，一个 IBM Rational Test Workbench 的组件，您可以创建无需编写代码、具备可用性和可维护性的存根（Stub），以便测试在某些组件缺失的情况下依然可以继续。此外，Rational Integration Tester 还提供了全面的功能测试、回归测试、负载测试和集成测试，以帮助缩短测试周期和将集成测试尽早安排在开发生命周期的早期。","keyword":"","recommend":false,"source":"http://www.ibm.com/developerworks/cn/rational/stubs-made-easier/index.html","title":"通过使用 Rational Integration Tester 更加便捷创建测试存根","typeId":0,"updateTime":"2014-06-09 00:00:00"}
{"author":"","clickNumber":0,"content":"\r\n<div class=\"ibm-columns\">\r\n<div class=\"ibm-col-1-1\">\r\n\r\n<p><em>Codename: BlueMix 是一款 <strong>beta 级<\/strong>产品，随着我们不断让其功能更加完善和更易于使用，它也将不断改进。我们会竭尽全力保持本文最新，但并不总是完全跟得上现状。感谢大家的理解！<\/em><\/p><p><a href=\"http://meteor.com/\">Meteor<\/a> 是一个面向 JavaScript 开发人员的完全实时的应用程序堆栈。它独一无二的响应式编程模型支持快速创建交互程度很高的、可实时更新的单页 Web 应用程序。<\/p><p>我在 developerWorks 文章 \"<a href=\"http://www.ibm.com/developerworks/cn/web/wa-meteor-webapps/index.html\">使用 Meteor 创建即时的 Web 应用程序<\/a>\" 中深入探讨了 Meteor 开发和 Meteor 架构。该文中有一个编码示例是一个以单页 Web 应用程序形式生成的交互式销售图。当 <a class=\"ibm-tooltip\" title=\"BlueMix is IBM's open platform for developing and hosting applications.         Built on the Cloud Foundry open source technology, BlueMix is a Platform as a         Service (PaaS) offering that aims to simplify the normally tedious tasks         associated with managing the infrastructure necessary to develop and host         applications at Internet scale.\">BlueMix<\/a> beta 计划开始时，我意识到 BlueMix 能够为我提供一种在云中演示和分享该应用程序的很好的途径。（您在本文中看到的代码已经在最新的 Meteor 预览版 V0.8.1.1 上测试过。而 \"<a href=\"http://www.ibm.com/developerworks/cn/web/wa-meteor-webapps/index.html\">使用 Meteor 创建即时的 Web 应用程序<\/a>\" 一文中的代码基于较早的 Meteor 版本。）因为 BlueMix 并不完全适用于开发 Meteor 应用程序，所以我准备了一个自定义的 <a class=\"ibm-tooltip\" title=\"Buildpacks are Cloud Foundry-specific provisioning scripts                     executed to prepare the  environment for deployment of an application.                     By default, BlueMix  has buildpacks for Liberty for Java, Node.js, and                     Ruby (Rails and Sinatra) projects.\">buildpack<\/a>，用它来简化在 BlueMix 上开发 Meteor 应用程序的过程。<\/p><p>我将向您演示如何在 DevOps Services 上创建自己的 Meteor 实时销售图应用程序，并将它部署到 BlueMix，以供全球用户进行网络访问。Meteor 在服务器端使用 MongoDB 保存数据，因此您将使用在 BlueMix 上预先定义的 MongoDB 服务来保存应用程序的销售数据。运行自己的应用程序后，您可以通过修改代码来分析 Meteor 的响应式编程模型。<\/p><p class=\"dw-article-ps-see-blk\"><span class=\"dw-article-ps-see-head\">阅读：<\/span><a class=\"dw-article-ps-see\" href=\"http://www.ibm.com/developerworks/cn/web/wa-meteor-webapps/index.html\">使用 Meteor 创建即时的 Web 应用程序<\/a><\/p><p class=\"dw-article-ps-see-blk\"><span class=\"dw-article-ps-see-head\">阅读：<\/span><a class=\"dw-article-ps-see\" href=\"https://hub.jazz.net/tutorials/jazzeditor\">使用 Node.js 开始学习 BlueMix 和 DevOps Services\n                    <\/a><\/p><h2 id=\"N10076\">What you\n                need<\/h2><ul class=\"ibm-bullet-list\"><li>一个 <a href=\"https://www.ibm.com/developerworks/dwwi/jsp/Register.jsp\">IBM ID 和密码<\/a><\/li><li>一个链接到您的 IBM ID 的 <a href=\"https://hub.jazz.net/\">DevOps Services<\/a> 帐号 <\/li><li>一个 <a href=\"https://ace.ng.bluemix.net/\">BlueMix<\/a> 帐号<\/li><li>一个 Web 浏览器<\/li><\/ul><div class=\"ibm-columns\"><div class=\"ibm-col-6-2\"><p class=\"ibm-button-link-alternate\"><a href=\"http://meteorsales.ng.bluemix.net/?cm_mmc=developerWorks-_-dW%20CloudOE%20content-_-wa-bluemix-meteor-app-_-article\">运行应用程序<\/a><\/p><\/div><div class=\"ibm-col-6-2\"><p class=\"ibm-button-link-alternate\"><a href=\"https://hub.jazz.net/project/singli/meteorsales?utm_source=developerWorks&amp;utm_medium=article&amp;utm_content=wa-bluemix-meteor-app&amp;utm_campaign=dW%20CloudOE%20content\">获得代码<\/a><\/p><\/div><\/div><div class=\"ibm-pull-quote ibm-inset\"><blockquote><p><em><span class=\"ibm-pullquote-open\">“<\/span>我准备了一个自定义的 buildpack 来简化在 BlueMix 上开发 Meteor 应用程序的过程。<span class=\"ibm-pullquote-close\">”<\/span><\/em><\/p><\/blockquote><p class=\"ibm-pullquote-source\"/><\/div><h2 id=\"N100A2\">步骤 1. 分析现有应用程序<\/h2><p>单击本文的 <strong>Run the app<\/strong> 按钮，尝试与销售图应用程序进行交互：<\/p><ol><li>打开一个桌面或手机浏览器的多个实例，并将它们都指向应用程序的 URL（http://meteorsales.ng.bluemix.net/)。<\/li><li>选择并单击（或敲击）标准的任意销售图，修改编号，然后单击 <strong>OK<\/strong> 进行更新。通过观察您会发现，所有应用程序实例中的表和饼图都被更新了。<\/li><li>尝试从另一个浏览器实例或移动设备更新销售图。<\/li><\/ol><p>如果其他读者和您在同时试用这个应用程序，那么您还会看到他们的更新。<\/p><h2 id=\"N100B8\">步骤 2. 创建项目代码<\/h2><ol><li>单击本文的 <strong>Get the code<\/strong> 按钮。<\/li><li>在我在 DevOps Services 上的 meteorsales 项目页面上，单击位于右上方的 <strong>EDIT CODE<\/strong> 按钮： \n                    <img alt=\"DevOps Services 项目页面上的 EDIT CODE 按钮的屏幕截图\" src=\"/sunshine_new/images/负502058097/edit_button.jpg\" width=\"566\" /><br />\n                    试用您的 IBM ID 和密码登录 DevOps Services。<\/li><li>单击 <strong>FORK<\/strong> 创建一个新项目。<br /><img alt=\"DevOps Services 中的 FORK 按钮的屏幕截图\" src=\"/sunshine_new/images/负502058097/fork_button.jpg\" width=\"472\" /><div class=\"dw-sidebar ibm-inset\"><p>部署在 BlueMix 上时，您的应用程序应该与 DevOps Services 项目同名。目前所有 BlueMix 项目都共享一个命名空间，因此您的项目（应用程序）名称必须是独一无二的。<\/p><\/div> \n                    输入一个不同于 meteorsales 的项目名称。您的项目可以是公共项目或私有项目。<\/li><li>检查项目的目录结构： \n                    <ul class=\"ibm-bullet-list\"><li><strong>manifest.yml<\/strong>：Manifest DevOps Services 用于将应用程序部署到 BlueMix<\/li><li><strong>sales.css<\/strong>：用于销售图应用程序的 CSS 样式<\/li><li><strong>sales.html<\/strong>：用于应用程序的 Meteor 模板<\/li><li><strong>sales.js<\/strong>：应用程序的客户端与服务器端 JavaScript 代码<\/li><li><strong>client/*<\/strong>&#8212;<a href=\"http://jquery.com/\">jQuery<\/a> 应用程序使用的插件库<\/li><li><strong>client/css/*<\/strong>：jQuery 插件库使用的 CSS 样式<\/li><\/ul><\/li><\/ol><h3 id=\"N100FF\">Meteor 代码的工作原理<\/h3><p>使用 Meteor 时，您将使用 JavaScript 编写客户端逻辑和服务器逻辑。这个应用程序的客户端与服务器端代码都位于 sales.js 中。（此外，客户端服务器代码均位于各自的子目录中。）<\/p><p>Meteor 扫描客户端目录（与子目录）中的 CSS 样式文件和 JS 文件，这是它选择 jQuery 插件的方式。对于 HTML 文件，它通常会将所找到文件的 <code>&lt;head&gt;<\/code> 与 <code>&lt;body&gt;<\/code> 部分进行合并。<\/p><p>UI 通常使用 Spacebar 构造，它是一个类似于 Handlebars 的 Meteor 特定模板。在 sales.html 中，销售图应用程序的模板代码如下所示。<\/p><div class=\"codesection\"><pre class=\"displaycode\">&lt;head&gt;\n&lt;title&gt;Sales by Region&lt;/title&gt;\n&lt;/head&gt;\n\n&lt;body&gt;\n  &lt;div id=\"title\"&gt;\n  \t&lt;h1&gt;Global Sales 2014&lt;/h1&gt;\n  &lt;/div&gt;\n  &lt;div id=\"container\"&gt;\n  \t&lt;div id=\"salestable\"&gt;\n    \t{{&gt; salesdata}}\n  \t&lt;/div&gt;\n        {{&gt; piechart}}\n  &lt;/div&gt;\n&lt;/body&gt;\n\n&lt;template name=\"piechart\"&gt;\n  \t&lt;div id=\"chart\"&gt;\n    &lt;/div&gt;\n&lt;/template&gt;\n\n&lt;template name=\"salesdata\"&gt;\n  &lt;div class=\"salesdata\"&gt;\n    {{#each dataset}}\n      {{&gt; datapoint}}\n    {{/each}}\n  &lt;/div&gt;\n&lt;/template&gt;\n\n&lt;template name=\"datapoint\"&gt;\n  &lt;div class=\"datapoint {{selected}}\"&gt;\n    &lt;span id=\"{{_id}}_region\" class=\"region\"&gt;{{region}}&lt;/span&gt;\n    &lt;span id=\"{{_id}}_total\" class=\"sales editable\"&gt;{{total}}&lt;/span&gt;\n  &lt;/div&gt;\n&lt;/template&gt;<\/pre><\/div><p>销售图的表是通过 <code>salesdata<\/code> 模板呈现的，其中包含一个用于每行的 <code>datapoint<\/code> 模板实例。<code>chart &lt;div&gt;<\/code> 是 <code>jqPlot<\/code> 插件呈现饼图的位置。此处创建了 <code>jEditable<\/code> 插件的一个实例，用于支持销售图的就地编辑（in-place editing）。<\/p><p>只要在 UI 中修改销售图，就会调用 Meteor 的客户端 MongoDB 实现 (mini-mongo) 来更新数字。然后，Meteor 的响应引擎会与服务器端的 MongoDB 实例进行同步。这次修改的内容将被传播给查看相同页面的所有浏览器或移动实例，而 Meteor 引擎会相应地更新本地试图。<\/p><p> 惟一的服务器端代码会使用种子数据来初始化 MongoDB 实例：<\/p><div class=\"codesection\"><pre class=\"displaycode\">if (Meteor.isServer) {\n  Meteor.startup(function () {\n      Sales2013.remove({});\n      Sales2013.insert({region:\"US East\", total: 2032333});\n      Sales2013.insert({region:\"US Central\", total: 150332});\n      Sales2013.insert({region:\"US West\", total: 1202412});\n      Sales2013.insert({region:\"Asia Pacific\", total: 701223});\n                   \n  });\n}<\/pre><\/div><h2 id=\"N1012B\">步骤 3. 将应用程序部署到 BlueMix<\/h2><ol><li>单击 <strong>DEPLOY AS<\/strong> 并选择 <strong>Deploy application from Web IDE to BlueMix<\/strong>。如果您以前从未从 DevOps Services 部署到 BlueMix，那么请输入您的 BlueMix 用户 ID 和密码。<\/li><li>选择 <strong>dev<\/strong> 空间作为目标的 BlueMix 部署空间，然后单击 <strong>DEPLOY<\/strong>：\n                    <img alt=\"Configure Application Deployment 对话框的屏幕截图\" src=\"/sunshine_new/images/负502058097/space_deploy.jpg\" width=\"404\" /><\/li><li>等待部署时，您会看到页面顶部弹出的状态消息。<\/li><\/ol><p>最终，您会看到一条失败消息，说明另一应用程序已经在使用名为 meteorsales 的 BlueMix 路由。清单中的应用程序名称（目前为 meteorsales）必须是您自己应用程序的惟一名称。此外，该清单目前指向我在 BlueMix 上的 MongoDB 服务实例，meteorsales 应用程序使用该实例进行存储。您的应用程序不能访问该实例。（您将在步骤 5 中更新清单。）<\/p><h2 id=\"N1014B\">步骤 4. 创建一个 BlueMix MongoDB 服务实例<\/h2><p>现在创建您自己的 MongoDB 服务实例，并将它绑定到您的应用程序：<\/p><ol><li>登录 <a href=\"https://ace.ng.bluemix.net/\">BlueMix<\/a>。<\/li><li>向下滚动并单击 <strong>Add a service<\/strong>。<\/li><li>在可用的 <strong>Data Management<\/strong> 服务中单击 <strong>mongodb<\/strong>，然后单击 <strong>CREATE AND ADD TO APP<\/strong>。<\/li><li>为 <strong>Add to:<\/strong> 选项选择 <strong>Do not associate<\/strong>，然后为服务取一个名字。单击 <strong>Create<\/strong>。<\/li><\/ol><p>右上角的一条通知简要显示了 MongoDB 新实例的名称。如果您没有看到这条通知，那么可以滚动查看服务实例的列表，从中找到已命名的 MongoDB 实例。<\/p><h2 id=\"N10176\">步骤 5. 更新部署清单<\/h2><p>在 DevOps Services 项目中打开 manifest.yml 文件进行编辑。现在，它与我项目中的 manifest.yml 文件完全相同。<\/p><div class=\"dw-sidebar ibm-inset\"><p>请注意，该清单使用了一个自定义的 buildpack。<a href=\"https://github.com/Sing-Li/heroku-buildpack-meteorite\">这个 buildpack<\/a> 基于 <a href=\"https://github.com/Sing-Li/heroku-buildpack-meteorite/\">Heroku Meteorite buildpack<\/a>，它专门针对将 Meteor 应用程序部署到 BlueMix 进行了修改。<\/p><\/div><div class=\"codesection\"><pre class=\"displaycode\">applications:\n- services:\n - mongodb-bf\n  host: meteorsales\n  disk: 1024M\n  name: meteorsales\n  buildpack: https://github.com/Sing-Li/heroku-buildpack-meteorite\n  path: .\n  domain: ng.bluemix.net\n  mem: 1024M\n  instances: 1<\/pre><\/div><p>针对您的项目自定义清单：<\/p><ol><li>将 <code>host:<\/code> 与 <code>name:<\/code> 设置修改为包含项目的惟一名称。<\/li><li>将服务实例名称修改为您在步骤 4 中创建的 MongoDB 服务名称。<\/li><li>保存修改后的清单（<strong>File<\/strong> &gt;\n                        <strong>Save<\/strong>）。<\/li><\/ol><h2 id=\"N101A0\">步骤 6. 重新部署到\n                BlueMix<\/h2><ol><li>单击 <strong>DEPLOY<\/strong> 按钮。过一会，您会看到一条部署状态消息。这次的部署成功了。<\/li><li> 在 <strong>Manual Deployment Information<\/strong> 区域中，可以看到应用程序名称后面跟着一个大大的圆点。如果这个圆点是绿色的，则表示 Meteor 应用程序正运行在 BlueMix 上，您可以跳过余下的步骤。如果圆点是红色的，单击它，然后单击 <strong>Start application<\/strong>：\n                    <img alt=\"Start Application 按钮的屏幕截图\" src=\"/sunshine_new/images/负502058097/start_app.jpg\" width=\"220\" /><br />\n                    红点最终变为绿色，这表示应用程序正在运行。您还将获得应用程序的一个 URL 和指向开发与部署日志的链接。<\/li><li>单击应用程序 URL 可以运行您自己的销售图应用程序。<\/li><\/ol><p> 现在，您可以尝试着修改代码并根据需要重新部署它。<\/p><h2 id=\"N101BF\">结束语<\/h2><p>您不再需要一排昂贵的部署工作站和开发服务器来开发运行在桌面浏览器与移动设备上的、高度交互的流数据更新 Web 应用程序。借助新一代的快速开发全堆栈平台，比如 Meteor（您可以将它与 DevOps Services 和 BlueMix 提供的基于云的开发人员工具结合使用），您可以在任何地方使用联网的浏览器来实现自己的创意。<\/p><CMA ID: 973609><Site ID: 10><XSLT stylesheet used to transform this file: dw-document-html-7.0.xsl>\r\n\r\n\r\n<\/div>\r\n<\/div>\r\n","createTime":"2014-06-09 00:00:00","deployTime":"2014-06-09 00:00:00","id":0,"intro":"在云中创建和部署您自己的单页交互式 Meteor 应用程序（实时更新），只需使用浏览器即可完成该操作。在 IBM DevOps Services 上编写代码，使用 Codename: BlueMix MongoDB 服务实现服务器端存储，并将应用程序部署到 BlueMix。","keyword":"","recommend":false,"source":"http://www.ibm.com/developerworks/cn/web/wa-bluemix-meteor-app/index.html","title":"使用 Meteor 构建一个响应式的销售图应用程序","typeId":0,"updateTime":"2014-06-09 00:00:00"}
{"author":"","clickNumber":0,"content":"\r\n<div class=\"ibm-columns\">\r\n<div class=\"ibm-col-1-1\">\r\n\r\n<h2 id=\"major1\">Rules Management 介绍<\/h2><p> 想必大家对 IBM Analytical Decision Management（简称\n                ADM）都已比较了解，它融入了预测分析的概念和思想，基于商业规则和数据挖掘算法自动得出解决问题的方案，并对这些方案进行优化和筛选，最终得出符合企业要求的最佳方案，并将其集成并部署到企业现有的\n                IT 设施中，从而为企业的日常决策活动提供可靠高效的支持。IBM Analytical Decision Management 是一个基于 Web\n                的应用，它的界面外观是完全可以根据客户需求进行现场配置的，而且它的配置相当便捷，是基于 XML\n                和一些相关文件的修改，不依赖于研发人员的介入。<\/p><p> 在 IBM Analytical Decision Management 安装之后，作为其中的一个核心应用，已经存在于用户的环境中了。登陆 ADM\n                之后，在 Launch Page 页面，通过点击 <strong>添加应用<\/strong> 并选择 <strong>Rules\n                Management<\/strong>，可以轻松的把它添加到界面上，就可以开始创建和管理你的业务规则了。它为用户提供了一个集中创建业务规则并对其进行管理的场所。这些业务规则被创建之后，可以存储在公共的\n                Repository 中，供 ADM\n                中各个应用使用，进而为解决商业问题提供决策支持。在这个应用里，用户可以根据自己的具体需要，创建三种类型的商业规则，分别是：segment\n                规则、selection 规则、aggregation 规则，这三种规则分别有不同的用途。segment\n                规则是最基本的规则，可以被转换成其他类型的规则，而 selection 规则主要用于对记录的筛选，aggregation\n                规则主要应用于对风险等级的评分。例如，用户可以在 Rules Management 中创建一个 selection\n                类型的业务规则，将那些还没达到法定年龄的客户排除在外。这样一个业务规则经创建和存储后，就可以被应用到其他各个应用中作为一个公共的规则，对这个公共的规则的修改将会作用到所有应用这个公共规则的商业应用中。接下来，就会对\n                Rules Management 的具体功能进行一个详细的介绍。<\/p><h2 id=\"major2\">基于不同商业需求，创建各种类型业务规则<\/h2><p>在 Rules Management 中，业务规则的种类可以被分为三大类：Segment 规则、Selection 规则和 Aggregation\n                规则。下面将分别介绍每种规则的用途和定义方法。<\/p><h3 id=\"major3\">定义 Segment 规则<\/h3><p>Segment 规则的应用最为广泛，可用于在各个应用中筛选和分配记录。每个 Segment\n                规则由一个或多个表达式所定义，都会返回一个“真”或者“假”的结果。例如，用户可以定义如下一个 Segment 规则：<\/p><p>如果 “年龄大于 18 岁”，那么返回 “真”。<\/p><p>可供使用的操作符根据所选字段的类型会有所不同，具体可以归纳为表 1。<\/p><h5 id=\"major4\">表 1. 可供使用的操作符<\/h5><table border=\"0\" cellpadding=\"0\" cellspacing=\"0\" class=\"ibm-data-table\" summary=\"\"><thead xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"><tr><th> 字段类型 <\/th><th> 可用的操作符 <\/th><\/tr><\/thead><tbody xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"><tr><td rowspan=\"9\"> 时间戳、日期、时间类型 <\/td><td> ? =（等于） <\/td><\/tr><tr><td> ? !=（不等于） <\/td><\/tr><tr><td> ? &gt;（大于） <\/td><\/tr><tr><td> ? &lt;（小于） <\/td><\/tr><tr><td> ? &gt;=（大于等于） <\/td><\/tr><tr><td> ? &lt;=（小于等于） <\/td><\/tr><tr><td> ? BETWEEN…AND（介于…之间） <\/td><\/tr><tr><td> ? ISNIL（为空） <\/td><\/tr><tr><td> ? IS NOT NIL（不为空） <\/td><\/tr><tr><td rowspan=\"11\"> 范围类型 <\/td><td> ? =（等于） <\/td><\/tr><tr><td> ? !=（不等于） <\/td><\/tr><tr><td> ? &gt;（大于） <\/td><\/tr><tr><td> ? &lt;（小于） <\/td><\/tr><tr><td> ? &gt;=（大于等于） <\/td><\/tr><tr><td> ? &lt;=（小于等于） <\/td><\/tr><tr><td> ? BETWEEN…AND（介于…之间） <\/td><\/tr><tr><td> ? ISNIL（为空） <\/td><\/tr><tr><td> ? IS NOT NIL（不为空） <\/td><\/tr><tr><td> ? ONE OF（某一个或多个） <\/td><\/tr><tr><td> ? NOT ONE OF（不是某一个或多个） <\/td><\/tr><tr><td rowspan=\"6\"> 离散类型 <\/td><td> ? =（等于） <\/td><\/tr><tr><td> ? !=（不等于） <\/td><\/tr><tr><td> ? ISNIL（为空） <\/td><\/tr><tr><td> ? IS NOT NIL（不为空） <\/td><\/tr><tr><td> ? ONE OF（某一个或多个） <\/td><\/tr><tr><td> ? NOT ONE OF（不是某一个或多个） <\/td><\/tr><tr><td rowspan=\"4\"> 布尔类型 <\/td><td> ? =（等于） <\/td><\/tr><tr><td> ? !=（不等于） <\/td><\/tr><tr><td> ? ISNIL（为空） <\/td><\/tr><tr><td> ? IS NOT NIL（不为空） <\/td><\/tr><\/tbody><\/table><p>进入 Rules Management 应用之后，添加一个需要创建 Segment 规则的数据源，选择规则选项卡，在规则类型下拉框中选择\n                Segment，打开新建规则窗口，如图 1 填上表达式。例如，这里创建了一个 “年龄大于 18 岁的男性” 的规则。<\/p><h5 id=\"img001\">图 1. “年龄大于 18 岁的男性” 的规则<\/h5><img alt=\"图 1.“年龄大于 18 岁的男性”的规则\" src=\"/sunshine_new/images/198774415/img001.png\" width=\"808\" /><p>Segment 规则被创建好后，可以将其保存到 IBM? SPSS? Collaboration and Deployment Services\n                Repository 中，作为公共的规则应用于不同的商业应用中。在这里，我们可以点击保存按钮将这个 Segment 规则保存为 “年龄大于 18\n                岁的男性”，如图 2 所示。<\/p><h5 id=\"img002\">图 2. 将规则保存到 IBM? SPSS? Collaboration\n                    and Deployment Services Repository 中<\/h5><img alt=\"图 2. 将规则保存到 IBM? SPSS? Collaboration and Deployment Services Repository 中\" src=\"/sunshine_new/images/198774415/img002.png\" width=\"610\" height=\"374\" /><p><a href=\"#N100E9\" class=\"ibm-popup-link\" onclick=\"ibmweb.overlay.show('N100E9',this);return false;\">点击查看大图<\/a><\/p><div id=\"N100E9\" class=\"dw-sidefile-overlay ibm-common-overlay ibm-overlay-alt-two\"><div class=\"ibm-head\"><p><a href=\"#close\" class=\"ibm-common-overlay-close\">关闭 [x]<\/a><\/p><\/div><div class=\"ibm-body\"><div class=\"ibm-main\"><div class=\"ibm-title\"><h2>图 2. 将规则保存到 IBM? SPSS? Collaboration\n                    and Deployment Services Repository 中<\/h2><\/div><div class=\"ibm-container ibm-alternate\"><div class=\"ibm-container-body\"><img alt=\"图 2. 将规则保存到 IBM? SPSS? Collaboration and Deployment Services Repository 中\" src=\"/sunshine_new/images/198774415/img002.png\" width=\"886\" /><\/div><\/div><\/div><\/div><div class=\"ibm-footer\"><><\/div><\/div><h3 id=\"major5\">定义 Selection 规则<\/h3><p>Selection 规则是由一个或一组 Segment 规则和 “包含” 或者 “排除” 属性而组成的。Selection\n                规则被用来在创建数据模型或者预测等其他操作之前，筛选记录的子集。<\/p><p>同样的，在创建一个 Selection 规则之前，需要添加一个数据源，选择规则选项卡，在规则类型下拉框中选择\n                Selection，打开新建规则窗口，如图 1 填上表达式。图 3 创建了一个包含 “年龄大于 18 岁的男性” 的规则；图 4\n                创建了一个排除“年龄大于 18 岁的男性”的规则。<\/p><h5 id=\"img003\">图 3. 包含“年龄大于 18 岁的男性”的规则<\/h5><img alt=\"图 3 包含“年龄大于 18 岁的男性”的规则\" src=\"/sunshine_new/images/198774415/img003.png\" width=\"808\" /><h5 id=\"img004\">图 4. 排除 “年龄大于 18 岁的男性” 的规则<\/h5><img alt=\"图 4 排除“年龄大于 18 岁的男性”的规则\" src=\"/sunshine_new/images/198774415/img004.png\" width=\"808\" /><h3 id=\"major6\">定义 Aggregation 规则<\/h3><p>Aggregation 规则可以对 Segment 规则及其度量进行汇总。这种规则常常被应用在保险行业中基于风险因素对风险系数进行评估。<\/p><p>进到 Rules Management 应用之后，添加一个数据源，点击创建一个新规则按钮，就看到了如图 5 所示的创建 Aggregation\n                规则窗口。<\/p><h5 id=\"img005\">图 5. 创建 Aggregation 规则窗口<\/h5><img alt=\"图 5. 创建 Aggregation 规则窗口\" src=\"/sunshine_new/images/198774415/img005.png\" width=\"807\" /><p>在里面填上规则名称和风险点，以及表达式。例如，图 5 创建了一个用来评估汽车保险行业中事故的发生概率的规则，对于 45\n                岁以上的女性司机来说，具有比较高的事故发生概率，设置的风险点比较高，为 3。同样的，可以基于商业应用创建类似的规则，再给其赋上风险点。<\/p><p>作为这个 Aggregation 规则的一部分，“其余部分” 也包含在这个规则中，可以对其赋上一定的风险等级，这里设置为\n                1，因为认为其余部分的司机风险点比较低，如图 6 所示。<\/p><h5 id=\"img006\">图 6. 为 Aggregation 规则设置风险点<\/h5><img alt=\"图 6. 为 Aggregation 规则设置风险点\" src=\"/sunshine_new/images/198774415/img006.png\" width=\"808\" /><h2 id=\"major7\">业务规则的嵌套<\/h2><p>\n                在之前介绍的创建一个规则并定义它的表达式的时候，我们都是选择了数据源中的一个字段作为表达式等号左边的输入。这里介绍一下在定义表达式的时候，可以使用一个已经创建好的\n                Segment 规则作为表达式等号左边的输入，等号右边可以是符合这个规则的 “真 T” 或者不符合这个规则的 “假 F”。在除了 Rules\n                Management 应用之外的其他应用中，所有可以创建规则的地方，都可以创建一个嵌套的业务规则。<\/p><p> 例如，我们之前在定义 Segment 规则那一节定义了一个“年龄大于 18 岁的男性” 的 Segment 规则，并已经将其存到 Repository\n                中。在这里可以利用它来创建一个嵌套的规则。在新建规则窗口中创建表达式的时候，选择从存储库中选择现有对象来生成表达式，如图 7 所示。如图\n                8，选择 “年龄大于 18 岁的男性” 的 Segment 规则，并在表达式等号右边选择 T，代表选择了满足 “年龄大于 18 岁的男性” 的\n                Segment\n                规则为真 “T” 的那些客户。这样，一个嵌套的业务规则就完成了，这种规则适用于当表达式比较复杂且又同时可以被很多规则通用时，可以省去每次创建规则编写复杂的表达式的工作。<\/p><h5 id=\"img007\">图 7. 新建规则时选择从存储库中选择现有对象创建表达式<\/h5><img alt=\"图 7. 新建规则时选择从存储库中选择现有对象创建表达式\" src=\"/sunshine_new/images/198774415/img007.png\" width=\"811\" /><h5 id=\"img008\">图 8. 创建一个嵌套的业务规则<\/h5><img alt=\"图 8. 创建一个嵌套的业务规则\" src=\"/sunshine_new/images/198774415/img008.png\" width=\"809\" /><h2 id=\"major8\">基于多种数据模型创建业务规则<\/h2><p>\n                前面介绍了创建规则的时候使用简单的字段或者将存储库中现有的规则用来创建表达式，同样的，表达式的创建也可以使用一个数据模型的输出。这一节就只介绍如何利用预测模型的输出结果来创建一个业务规则。所有可以创建规则的地方，都可以创建一个基于数据模型的业务规则。<\/p><p> 在新建规则窗口，创建表达式的时候，点击构建新模型按钮，如图 9 所示。打开一个模型构建器，叫 MiniMA 窗口，如图 10\n                所示。在这里，可以创建四种类型的数据模型，分别是预测模型、预测规则模型、聚类模型和关联模型。<\/p><h5 id=\"img009\">图 9. 新建规则时选择构建新模型来创建表达式<\/h5><img alt=\"图 9. 新建规则时选择构建新模型来创建表达式\" src=\"/sunshine_new/images/198774415/img009.png\" width=\"811\" /><h5 id=\"img010\">图 10. 数据模型构建器<\/h5><img alt=\"图 10 数据模型构建器\" src=\"/sunshine_new/images/198774415/img010.png\" width=\"618\" height=\"412\" /><p><a href=\"#N10161\" class=\"ibm-popup-link\" onclick=\"ibmweb.overlay.show('N10161',this);return false;\">点击查看大图<\/a><\/p><div id=\"N10161\" class=\"dw-sidefile-overlay ibm-common-overlay ibm-overlay-alt-two\"><div class=\"ibm-head\"><p><a href=\"#close\" class=\"ibm-common-overlay-close\">关闭 [x]<\/a><\/p><\/div><div class=\"ibm-body\"><div class=\"ibm-main\"><div class=\"ibm-title\"><h2>图 10. 数据模型构建器<\/h2><\/div><div class=\"ibm-container ibm-alternate\"><div class=\"ibm-container-body\"><img alt=\"图 10 数据模型构建器\" src=\"/sunshine_new/images/198774415/img010.png\" width=\"898\" /><\/div><\/div><\/div><\/div><div class=\"ibm-footer\"><><\/div><\/div><p>在模型构建器中选择模型类型按钮，可以打开四种模型供用户选择，如图 11 所示。<\/p><h5 id=\"img011\">图 11. 四种数据模型可供选择<\/h5><img alt=\"图 11. 四种数据模型可供选择\" src=\"/sunshine_new/images/198774415/img011.png\" width=\"615\" height=\"465\" /><p><a href=\"#N1016D\" class=\"ibm-popup-link\" onclick=\"ibmweb.overlay.show('N1016D',this);return false;\">点击查看大图<\/a><\/p><div id=\"N1016D\" class=\"dw-sidefile-overlay ibm-common-overlay ibm-overlay-alt-two\"><div class=\"ibm-head\"><p><a href=\"#close\" class=\"ibm-common-overlay-close\">关闭 [x]<\/a><\/p><\/div><div class=\"ibm-body\"><div class=\"ibm-main\"><div class=\"ibm-title\"><h2>图 11. 四种数据模型可供选择<\/h2><\/div><div class=\"ibm-container ibm-alternate\"><div class=\"ibm-container-body\"><img alt=\"图 11. 四种数据模型可供选择\" src=\"/sunshine_new/images/198774415/img011.png\" width=\"894\" /><\/div><\/div><\/div><\/div><div class=\"ibm-footer\"><><\/div><\/div><p>在这里，我选择第一种预测模型，然后选择数据源和目标之后，点击构建模型按钮，就可以轻松构建一个模型了。如图 12 所示，是模型构建完成后的页面。<\/p><h5 id=\"img012\">图 12. 预测模型构建完成<\/h5><img alt=\"图 12. 预测模型构建完成\" src=\"/sunshine_new/images/198774415/img012.png\" width=\"613\" height=\"586\" /><p><a href=\"#N10179\" class=\"ibm-popup-link\" onclick=\"ibmweb.overlay.show('N10179',this);return false;\">点击查看大图<\/a><\/p><div id=\"N10179\" class=\"dw-sidefile-overlay ibm-common-overlay ibm-overlay-alt-two\"><div class=\"ibm-head\"><p><a href=\"#close\" class=\"ibm-common-overlay-close\">关闭 [x]<\/a><\/p><\/div><div class=\"ibm-body\"><div class=\"ibm-main\"><div class=\"ibm-title\"><h2>图 12. 预测模型构建完成<\/h2><\/div><div class=\"ibm-container ibm-alternate\"><div class=\"ibm-container-body\"><img alt=\"图 12. 预测模型构建完成\" src=\"/sunshine_new/images/198774415/img012.png\" width=\"891\" /><\/div><\/div><\/div><\/div><div class=\"ibm-footer\"><><\/div><\/div><p>接下来，点击使用模型，会提示先将模型存储到 Repository 中，存储之后，就可以选择一个模型的输出作为表达式等号左边的输入了。如图 13\n                所示，我们选择预测模型（$XS-pmethod - 结果）作为表达式左边，选择 ONE OF 操作符，右边可以选择预测模型结果字段的值。<\/p><h5 id=\"img013\">图 13. 使用预测模型结果创建表达式<\/h5><img alt=\"图 13. 使用预测模型结果创建表达式\" src=\"/sunshine_new/images/198774415/img013.png\" width=\"816\" /><p>这样一个基于数据模型的业务规则就创建完成了。这样的规则可以将数据挖掘模型的算法应用到业务规则创建中，利用历史数据和历史数据构建的模型来预测未来，避免了人为一味利用经验创建业务规则的局限性。<\/p><h2 id=\"major9\">创建集成的 IBM ILOG 业务规则<\/h2><h3 id=\"major10\">ILOG 业务规则简介<\/h3><p> 在 ADM 中可以使用其他管理商业规则系统所创建的规则例如 ILOG 规则。这些外部规则的使用和其他通过 ADM\n                创建的内部规则的使用方法是一样的都是通过点击页面上的 “查找已存在的规则” 控件来加入到 ADM 里面的。这些外部的规则在 ADM\n                里面是通过一个图标来区分它和其他的内部规则的不同。当然这些 ILOG\n                规则的使用和其他的内部规则也有不一样的地方，它是可以当做一个数据模型来使用的。例如在 Claims Management 应用里面可以把 ILOG\n                规则单做一个数据模型引用在“使用模型来确定要触发的操作”。ILOG 规则的输出也可以用在“优化”里面参数的值。这些都是一般的内部规则所做不到的。 <\/p><h3 id=\"major11\">ILOG 业务规则的创建<\/h3><p> 前面是对 ILOG 规则是如何使用的做了一个简单的描述，可能有的读者会说 “知道了应用还不够啊，我们想知道这些外部的规则是如何创建的”。接下来会对\n                ILOG 规则的创建做简单的介绍。首先要在 ADM 的任何一个应用的“数据”页面中选中想要创建 ILOG\n                规则的数据作为 “项目数据源” 然后选择 “工具栏” 里面的 “下载元数据” 把数据以 XSD 的方式下载下来，如图 14 所示。 <\/p><h5 id=\"img014\">图 14. 下载元数据<\/h5><img alt=\"图 14. 下载元数据\" src=\"/sunshine_new/images/198774415/img014.png\" width=\"808\" /><p>通常我们从 ADM 里面 download metadata 只有一个 string\n                类型的输出，如果这个输出可以满足用户需求就可以直接把这个数据导入到 Operational Decision Management 的 Rule\n                Studio 里面创建 ILOG 规则。而如果用户想要一个 Integer 类型或者 double 类型的输出则可以通过编辑下载的 XSD\n                文件来实现。在 XSD 文件中定义想要类型的输出以及其输出值然后再将编辑好的 XSD 文件导入到 Rule Studio 中创建 ILOG\n                规则。<\/p><p>在 ILOG 的 Rule Studio 里面正如前文所提到的首先要导入 XSD 文件，定义 ILOG\n                规则的输入和输出。所谓输入就是指实际的输入数据而输出则是 ILOG 规则的输出。在定义了输入和输出之后还需要定义规则包以及规则的一个流向。每一个\n                ILOG 规则至少要有一个规则包。这些都是创建 ILOG 规则的前期准备工作，ILOG 规则的创建是通过写 IF-Then-Else\n                语句来完成的。清单 1 是一个 ILOG 规则语句的实例。<\/p><h5 id=\"listing1\">清单 1. 定义 ILOG 规则语句<\/h5><div class=\"codesection\"><pre class=\"displaycode\">if the age of 'the drug1n' is more than 25\nthen \nset the value double of 'the drug1nresponse' to 0.8;\nset the value sex of 'the drug1nresponse' to \"Female\";\nset the value string of 'the drug1nresponse' to \"true\";\nmake it true that 'the drug1nresponse' is value boolean ; \nelse \nset the value double of 'the drug1nresponse' to 0.2;\nset the value sex of 'the drug1nresponse' to \"Male\" ;\nset the value string of 'the drug1nresponse' to \"fales\" ;\nmake it false that 'the drug1nresponse' is value boolean ;<\/pre><\/div><p>在这里输入就是 “the drug1n” 而输出就是 “the drug1nresponse”。可以看出这个 ILOG\n                规则的输入条件有一个就是“age”的值大于 25，而输出有三种类型：double 类型的“0.8”或者“0.2”；string\n                类型的“Male”或者“Female”；Boolean 类型的“True”或者“False”。<\/p><h3 id=\"N101B6\">ILOG 规则的部署<\/h3><p>ILOG 规则在 Rule studio 里面创建完了之后需要部署之后才能使用。其部署方式有两种一种是部署到本地的 RES\n                服务器，另一种方式是部署在本地的一个机器上面。在这里我们注重讲述下是怎样通过 WSDL 的方式来访问创建好的 ILOG 规则。在把 ILOG\n                规则部署到 RES\n                服务器之后，会得到一个类似于 “http://&lt;IP&gt;:&lt;Port&gt;/DecisionService/ws/BPisHIGH/1.0/drug/1.0?WSDL”\n                这样的\n                URL。在 Content Repository 添加 ILOG 规则时只需要定义部署 ILOG 规则的 RES 服务器的 URL，在 ADM\n                里面就可以通过 Web Service 来访问到已经部署好的 ILOG 规则。<\/p><h3 id=\"major12\">通过实例讲解 ILOG 规则的应用<\/h3><p>在了解了 ILOG 规则在 ADM 里面的应用以及如何创建及部署一个 ILOG 规则之后，下面将通过一个实例讲下 ADM 里面是如何用 ILOG\n                规则来创建业务规则以及如何使用 ILOG 规则来作为优化参数。以 Campaign Optimization\n                这个应用举例，在 “定义” 页面可以通过两种方式吧 ILOG 规则加进来。一种是通过点击 “查找现有规则” 直接将 ILOG\n                规则引用进来作为包含或排除参与 “我的竞销活动” 的对象的规则或为活动分配“报价”的规则。如果采用这种方式引用 ILOG 规则则默认使用 ILOG\n                规则的 boolean\n                类型的输出。另一种是先点击 “创建规则”，在新建规则的表达式时选择 “从存储库中选择现有对象” 然后在打开的“查找规则/模型”的对话框中选择一个 ILOG\n                规则。如果采用这种方式引用 ILOG 规则，需要选择使用 ILOG 规则的哪一个输出作为规则的表达式的字段，这样引用 ILOG 规则类似于使用一个\n                model 来创建规则。如下图所示，可以选择 “value_string” 作为 “外部规则字段” 这时所创建的规则就是用了在 ILOG\n                规则里面定义的“string”类型的输出作为了规则的输入条件，如图 15 所示。<\/p><h5 id=\"img015\">图 15. 基于 ILOG 规则创建规则<\/h5><img alt=\"图 15. 基于 ILOG 规则创建规则\" src=\"/sunshine_new/images/198774415/img015.png\" width=\"850\" height=\"422\" /><p><a href=\"#N101C9\" class=\"ibm-popup-link\" onclick=\"ibmweb.overlay.show('N101C9',this);return false;\">点击查看大图<\/a><\/p><div id=\"N101C9\" class=\"dw-sidefile-overlay ibm-common-overlay ibm-overlay-alt-two\"><div class=\"ibm-head\"><p><a href=\"#close\" class=\"ibm-common-overlay-close\">关闭 [x]<\/a><\/p><\/div><div class=\"ibm-body\"><div class=\"ibm-main\"><div class=\"ibm-title\"><h2>图 15. 基于 ILOG 规则创建规则<\/h2><\/div><div class=\"ibm-container ibm-alternate\"><div class=\"ibm-container-body\"><img alt=\"图 15. 基于 ILOG 规则创建规则\" src=\"/sunshine_new/images/198774415/img015.png\" width=\"1234\" /><\/div><\/div><\/div><\/div><div class=\"ibm-footer\"><><\/div><\/div><p>创建好的新规则如图 16 所示。<\/p><h5 id=\"img016\">图 16. 创建好的基于 ILOG 规则的规则<\/h5><img alt=\"图 16. 创建好的基于 ILOG 规则的规则\" src=\"/sunshine_new/images/198774415/img016.png\" width=\"589\" height=\"124\" /><p><a href=\"#N101D5\" class=\"ibm-popup-link\" onclick=\"ibmweb.overlay.show('N101D5',this);return false;\">点击查看大图<\/a><\/p><div id=\"N101D5\" class=\"dw-sidefile-overlay ibm-common-overlay ibm-overlay-alt-two\"><div class=\"ibm-head\"><p><a href=\"#close\" class=\"ibm-common-overlay-close\">关闭 [x]<\/a><\/p><\/div><div class=\"ibm-body\"><div class=\"ibm-main\"><div class=\"ibm-title\"><h2>图 16. 创建好的基于 ILOG 规则的规则<\/h2><\/div><div class=\"ibm-container ibm-alternate\"><div class=\"ibm-container-body\"><img alt=\"图 16. 创建好的基于 ILOG 规则的规则\" src=\"/sunshine_new/images/198774415/img016.png\" width=\"856\" /><\/div><\/div><\/div><\/div><div class=\"ibm-footer\"><><\/div><\/div><p>ILOG 规则除了可以用来创建业务规则它的输出也可以用来作为优化参数的值。如果是使用 ILOG 规则作为优化参数则必须要求 ILOG\n                规则的输出中有数字类型的。其使用方法和创建规则类似，例如在 “优化” 页面上使用 ILOG\n                规则的输出作为“我的报价”的“相应概率”，首先先点击 “我的报价” 文本框右边的下拉箭头，选择 “从存储库中选择现有对象”，在打开的“查找模型” 对话框中选择一个\n                ILOG 规则。ADM 会自动选用 ILOG 规则中的数字类型的输出作为优化参数的值，如图 17 所示。<\/p><h5 id=\"img017\">图 17. 将 ILOG 规则的输出作为优化参数<\/h5><img alt=\"图 17. 将 ILOG 规则的输出作为优化参数\" src=\"/sunshine_new/images/198774415/img017.png\" width=\"754\" height=\"241\" /><p><a href=\"#N101E1\" class=\"ibm-popup-link\" onclick=\"ibmweb.overlay.show('N101E1',this);return false;\">点击查看大图<\/a><\/p><div id=\"N101E1\" class=\"dw-sidefile-overlay ibm-common-overlay ibm-overlay-alt-two\"><div class=\"ibm-head\"><p><a href=\"#close\" class=\"ibm-common-overlay-close\">关闭 [x]<\/a><\/p><\/div><div class=\"ibm-body\"><div class=\"ibm-main\"><div class=\"ibm-title\"><h2>图 17. 将 ILOG 规则的输出作为优化参数<\/h2><\/div><div class=\"ibm-container ibm-alternate\"><div class=\"ibm-container-body\"><img alt=\"图 17. 将 ILOG 规则的输出作为优化参数\" src=\"/sunshine_new/images/198774415/img017.png\" width=\"1096\" /><\/div><\/div><\/div><\/div><div class=\"ibm-footer\"><><\/div><\/div><h2 id=\"major13\">总结<\/h2><p> 本文详细介绍了 Rules Management 作为 ADM\n                的一个核心应用，在创建和管理业务规则，嵌套业务规则，利用多种数据模型创建业务规则，以及 IBM ILOG\n                规则的集成应用等方面的强大的功能。并结合不同商业需求，利用 Rules Management 创建各种类型业务规则并将其应用到商业模型中。 <\/p><p>本文所介绍的例子和方法只是使读者了解并认识 IBM Analytical Decision Management Rules Management\n                这样一个应用，希望读者能通过本文对数据挖掘技术和预测分析软件 IBM Analytical Decision Management\n                有进一步的认识，也希望本文能够为数据分析人员和企业决策人员提供如何通过创建业务规则来解决实际行业问题的方法。<\/p><CMA ID: 973720><Site ID: 10><XSLT stylesheet used to transform this file: dw-document-html-7.0.xsl>\r\n\r\n\r\n<\/div>\r\n<\/div>\r\n","createTime":"2014-06-09 00:00:00","deployTime":"2014-06-09 00:00:00","id":0,"intro":"IBM Analytical Decision Management（简称 ADM）作为 IBM Business Analytics 产品里重要的预测分析软件之一，以其自身强大的业务规则创建、数据建模、优化预测分析及客户定制等特点吸引了大批的用户。Rules Management 作为 ADM 的一个核心应用，在创建和管理业务规则、嵌套业务规则、利用多种数据模型创建业务规则，以及 IBM ILOG Rule 的集成应用等方面提供了强大的功能。本文将着重介绍基于不同商业需求，利用 Rules Management 创建各种类型业务规则并将其应用到商业模型中。希望能够为从事相关工作的数据分析人员和企业决策人员提供一种解决实际行业问题的业务规则分析方法，并使读者进一步了解数据挖掘技术和预测分析软件 IBM Analytical Decision Management。","keyword":"","recommend":false,"source":"http://www.ibm.com/developerworks/cn/data/library/ba/ba-1406-ADM-rulesbusiness/index.html","title":"利用 IBM Analytical Decision Management Rules Management 创建业务规则及其商业应用","typeId":0,"updateTime":"2014-06-09 00:00:00"}
{"author":"","clickNumber":0,"content":"\r\n<div class=\"ibm-columns\">\r\n<div class=\"ibm-col-1-1\">\r\n\r\n<div class=\"dw-sidebar ibm-inset\"><p>下载 <a href=\"http://www.ibm.com/developerworks/cn/downloads/r/rcq/index.html\">Rational ClearQuest<\/a> 试用版，提前体验它的强大功能！<\/p><\/div><h2 id=\"1.内容简介 |outline\">内容简介<\/h2><p>什么是多记录更新(Multi-Record Update, MRU)？通过 MRU, 用户可以在一个查询结果集中的多条记录上执行相同的操作，便于一次性批处理多条记录。该功能是从 ClearQuest V7.1 开始引入，最新发布的 ClearQuest V8.0.1 移除了老版本 MRU 的多记录更新表单和操作方法，设计了一个全新的 MRU，很大程度上提升了该功能的易用性和实用性。<\/p><p>本文将首先简单介绍老版本 7.1 MRU 功能局限性和 8.0.1 MRU 的新特点，然后结合 8.0.1 MRU 的几个重要视图及使用技巧，详细阐述 8.0.1 MRU 的典型工作场景。最后简单列举了该功能的限制。<\/p><h2 id=\"2.8.0.1MRU 功能综述 |outline\">8.0.1 MRU 功能综述<\/h2><h3 id=\"N10072\">7.1 MRU 简介<\/h3><p>熟悉 ClearQuest 的用户应该会了解 7.1 MRU，它是 ClearQuest V7.1 引入的在一个查询结果集中的多条记录上执行相同的操作的功能，该功能的目的是给用户提供批处理的便捷方式。但是 7.1 MRU 有以下三点局限性，在一定程度上影响了该功能的实用性：<\/p><ol type=\"1\"><li>只能选择修改(Modify)操作类型，不允许其他状态转换。<\/li><li>只能批量更新文本和日期字段（允许前缀、替换、附加）。<\/li><li>显示特殊的 MRU 表格（如图 1）。<\/li><\/ol><p>- 只显示 MRU 支持的字段。<\/p><p>- 跟一般的记录表格不同。<\/p><h5 id=\"N10086\">图 1. 7.1 MRU 表格<\/h5><img alt=\"7.1 MRU 表格\" src=\"/sunshine_new/images/负540365657/image003.jpg\" width=\"552\" /><h3 id=\"N10091\">8.0.1 MRU 新特点<\/h3><p>为了弥补 7.1 MRU 的局限性，ClearQuest V8.0.1 移除了老版本 MRU 的表单和操作模式，推出了全新的、实用性强的 8.0.1 MRU。<\/p><p>8.0.1 MRU 使用全新的记录和回放模型，用户在模板记录上记录的操作在结果集中的其他记录上进行重放，操作按记录的顺序进行回放。8.0.1 MRU 操作针对结果集页面上显示的所有记录，用户可以在记录上执行各种操作，例如，修改、更改状态、删除和记录脚本别名。把对一条记录的更改应用到选定的多个记录上，方便用户批量修改记录的各种类型字段。并且，8.0.1 MRU 为客户提供新的选项卡视图，方便组织并控制在更新多条记录过程中所作的所有工作。下面会详细介绍 8.0.1 MRU 的整个工作流程。<\/p><h2 id=\"3.8.0.1MRU 典型工作场景 |outline\">8.0.1 MRU 典型工作场景<\/h2><p>本章节将根据一个典型的工作场景来描述 8.0.1 MRU 的使用方式和工作流程。首先，筛选需要批处理的记录并创建相应的结果集，然后打开其中一条记录进行编辑，最后基于对该条记录的操作对整个结果集进行批处理。用户通过观察\"多记录更新\"选项卡的各个视图对整个更新过程进行监控。<\/p><h3 id=\"N100A1\">创建用于多记录更新操作的结果集<\/h3><p>8.0.1 MRU 操作针对结果集页面上显示的所有记录。因此，在执行多记录更新之前，首先要筛选出要进行该操作的结果集。除了传统的通过查询过滤器构建查询或利用全文检索功能来构建结果集的方法之外，8.0.1 MRU 引入了一种创建结果集的新方式。该方式在一个结果集界面上用鼠标选中一些记录，通过\"根据选择创建查询\"来创建一个只包含选中记录的查询（如图 2 所示）。该功能极大的方便了用户筛选需要批处理的多条记录。<\/p><h5 id=\"N100A9\">图 2. 创建结果集<\/h5><img alt=\"创建结果集\" src=\"/sunshine_new/images/负540365657/image005.jpg\" width=\"564\" /><p>该查询以选中记录的标识（id）集合作为过滤器，显示字段与创建它的父查询相同。在多记录更新操作完成之后，用户可以选择保存或取消该查询（如图 3 所示）。<\/p><h5 id=\"N100B7\">图 3. 根据选择创建查询<\/h5><img alt=\"根据选择创建查询\" src=\"/sunshine_new/images/负540365657/image007.jpg\" width=\"576\" /><h3 id=\"N100C2\">“多记录更新”选项卡<\/h3><p>8.0.1 MRU 所有多记录更新操作都集中在一个\"多记录更新\"选项卡上。多记录更新操作会应用在结果集选项卡上显示的每一条记录。通过在\"结果集\"选项卡上右键单击打开菜单并选择\"多记录更新\"（参见图 2 右键菜单）将打开一个新的\"多记录更新\"选项卡。该选项卡垂直分割为子选项卡区和用来录制所做编辑的模板记录区。子选项卡区包括一个\"控制面板\"子选项卡，一个\"编辑\"子选项卡，此外，\"结果集\"选项卡将作为一个子选项卡移至该选项卡。布局如图 4 所示。 <\/p><h5 id=\"N100CA\">图 4. “多记录更新”选项卡视图<\/h5><img alt=\"“多记录更新”选项卡视图\" src=\"/sunshine_new/images/负540365657/image009.jpg\" width=\"582\" /><p><strong>模板记录区<\/strong><\/p><p>模板记录用来录制要被回放的多记录更新操作，模板采用选定的记录类型的表单（如图 4 右下角记录模板）。用户可以通过编辑模板记录来记录所作的编辑以回放记录。当用户执行\"修改\"或\"更改状态\"操作，模板表单会变为可编辑。用户所作的所有更改和点击均按发生的顺序加以记录，并显示在编辑选项卡上。不同的字段类型和表单控件可支持不同类型的更改。对选中的表单控件有效的重放类型显示在\"类型\"列中。用户可以更改针对某种类型的表单控件重放的重放类型，但是不能更改记录的文本。 例如，如果要添加 STOP SHIP 作为文本框的前缀，但是错误地输入 STOP SHOP，那么不能纠正已记录的拼写。用户必须取消多记录更新并重新启动。<\/p><p><strong>\"编辑\"子选项卡<\/strong><\/p><p>在模板记录上所作的字段和表单控件更改将按更改的先后顺序列在\"编辑\"子选项卡上。对相同字段的多次更改会单独记录并单独重放。 该选项卡包含具有以下列的表格：<\/p><ul class=\"ibm-bullet-list\"><li>\"操作\"列，显示执行的操作。<\/li><li>\"名称\"列，显示更改的控件的名称。<\/li><li>\"数据\"列，显示控件的新数据值。<\/li><li>\"类型\"列，显示要执行的更改的类型。支持前缀，替换，附加和差别类型。<\/li><\/ul><p>编辑模板记录时和回放期间，多记录更新选项卡标题为红色，并使用星号 (*) 作为前缀。<\/p><h5 id=\"N100EB\">图 5. “编辑”子选项卡视图<\/h5><img alt=\"“编辑”子选项卡视图\" src=\"/sunshine_new/images/负540365657/image011.jpg\" width=\"575\" /><p><strong>\"结果集\"子选项卡<\/strong><\/p><p>在对模板记录的编辑完成之后，单击\"保存\"或\"保存并关闭\"回放就开始了。回放会按照对模板记录上字段进行编辑的顺序，逐一应用在\"结果集\"选项卡上显示的所有记录，并在该选项卡上显示回放的结果，所以该选项卡上的记录也被称为回放记录。该选项卡的名称与查询相同，它包含的列与查询中定义的列相同。单击任何列标题可以按列的内容对结果集进行排序。信息列可显示每条记录的状态，绿色正方形表明记录已成功更新，红色圆圈内的 X 表明该记录更新失败，如果列为空，那么表示该记录未通过多记录更新得到修改。<\/p><h5 id=\"N100FC\">图 6. “结果集”子选项卡视图<\/h5><img alt=\"“结果集”子选项卡视图\" src=\"/sunshine_new/images/负540365657/image013.jpg\" width=\"576\" /><p><strong>\"控制面板\"子选项卡<\/strong><\/p><p>\"控制面板\"子选项卡用来显示有关多记录更新的信息，包括查询名称、操作、进度信息、更新失败的记录数量、多记录更新耗用的时间以及剩余时间。 每在模板记录上执行一项操作，操作值都会被更新。在更新每条记录后会更新进度信息。该选项卡还包含回放控件以便随时停止或继续：暂停按钮会暂停多记录更新操作以便查看结果，恢复按钮会继续多记录更新操作。多记录更新操作进行中时，会启用暂停按钮。暂停多记录更新之后，恢复按钮会被启用。<\/p><h5 id=\"N1010D\">图 7. “控制面板”子选项卡视图<\/h5><img alt=\"“控制面板”子选项卡视图\" src=\"/sunshine_new/images/负540365657/image015.jpg\" width=\"576\" /><h2 id=\"4.8.0.1MRU 的局限性 |outline\">8.0.1 MRU 的局限性<\/h2><p>由于 ClearQuest 产品本身的特点，8.0.1 MRU 不支持以下表单更改。<\/p><ol type=\"1\"><li>不记录创建新记录的按钮。<\/li><li>不记录附件按钮。<\/li><li>在多记录更新期间禁用弹出表单支持。<\/li><li>不记录使用 OSLCLinks 包来修改 OSLC 链接。<\/li><li>不支持重复和取消重复更改状态操作。<\/li><\/ol><CMA ID: 973133><Site ID: 10><XSLT stylesheet used to transform this file: dw-document-html-7.0.xsl>\r\n\r\n\r\n<\/div>\r\n<\/div>\r\n","createTime":"2014-06-05 00:00:00","deployTime":"2014-06-05 00:00:00","id":0,"intro":"本篇文章通过对老版本 (ClearQuest V7.1) 多记录更新功能 (Multi-Record Update, 7.1 MRU) 和新版本 (ClearQuest V8.0.1) 多记录更新功能 (Multi-Record Update, 8.0.1 MRU)的对比介绍，以及对 8.0.1 MRU 典型工作流程的讲述，详细地阐述了最新多记录更新的主要功能、使用方式、应用场景和限制。","keyword":"","recommend":false,"source":"http://www.ibm.com/developerworks/cn/rational/1406_lianglu_cq8new1/index.html","title":"Rational ClearQuest V8.0.1 新功能: 多记录更新","typeId":0,"updateTime":"2014-06-05 00:00:00"}
{"author":"","clickNumber":0,"content":"\r\n<div class=\"ibm-columns\">\r\n<div class=\"ibm-col-1-1\">\r\n\r\n<div class=\"dw-sidebar ibm-inset\"><h2 id=\"N10050\">关于本系列<\/h2><p>Java 传承的是平台，而不是语言。有超过 200 种语言可以在 JVM 上运行，它们之中不可避免地会有一种语言最终取代 Java\n                    语言，成为编写 JVM 程序的最佳方式。本系列将探讨三种下一代 JVM 语言：Groovy、Scala 和\n                    Clojure，比较并对比新的功能和范例，让 Java 开发人员对自己近期的未来发展有大体的认识。<\/p><\/div><p> Java&#8482; 工程师在努力让并发性容易为开发人员所用。尽管做了不少的改进，但并发性仍然是 Java\n                平台的一个复杂、容易出错的部分。一部分复杂之处在于理解语言本身中的并发性的低级抽象，这些抽象在您的代码中填满了同步的代码块。另一个复杂之处来自一些新库，比如\n                fork/join，这些库在某些场景中非常有用，但在其他场景中收效甚微。了解容易混乱的大量低级选项需要专业经验和时间。 <\/p><p> 脱离 Java 语言的优势之一是，能够改善和简化并发性等区域。每种 Java\n                下一代语言都为此问题提供了独特的答案，利用了该语言的默认编程风格。在本期文章中，我首先将会介绍函数式编程风格的优势：轻松并行化。我会深入分析\n                Scala 和 Groovy 的细节（下一期文章将全面介绍 Clojure）。然后介绍 Scala <em>actor<\/em>。 <\/p><div class=\"dw-sidebar ibm-inset\"><h2 id=\"sidebar1\">完美数<\/h2><p> 数学家尼科马库斯（诞生于公元前 6 世纪）将自然数分为惟一的<em>完美数（perfect\n                        number）<\/em>、<em>过剩数（abundant number）<\/em> 或<em>亏数（deficient\n                        number）<\/em>。一个完美数等于它的正因数（不包括它本身）之和。例如，6 是一个完美数，因为它的因数是 1、2、3 和\n                    6，28 也是完美数 (28 = 1 + 2 + 4 + 7 + 14)。过剩数的因素之和大于该数，亏数的因数之和小于该数。 <\/p><p>这里使用完美数分类法是为了方便介绍。除非要处理大量数字，是否查找因素对于从并行化中获益而言是一个微不足道的问题。使用更多线程可带来一些益处，但线程之间的切换开销对细粒度的作业而言代价很高。\n                <\/p><\/div><h2 id=\"N10071\">让现有代码并行化<\/h2><p>在 “<a href=\"http://www.ibm.com/developerworks/cn/java/j-jn10/index.html\">函数式编码风格<\/a>” 那一期的文章中，我们鼓励您使用更高级的抽象，比如化简、映射和过滤器，而不是迭代。此方法的优势之一是容易并行化。 <\/p><p> 我的 <a href=\"https://www.ibm.com/developerworks/cn/views/global/libraryview.jsp?sort_by=&amp;show_abstract=true&amp;show_all=&amp;search_flag=&amp;contentarea_by=Java+technology&amp;search_by=函数式思维&amp;topic_by=-1&amp;type_by=所有类别&amp;ibm-search=搜索\"><em>函数式思维<\/em><\/a> 系列的读者熟悉包含<em>完美数<\/em> 的数字分类模式（参见 <a href=\"#sidebar1\">完美数<\/a>\n                边栏）。我在该系列中展示的任何解决方案都没有利用并发性。但是因为这些解决方案使用了转换函数，比如 <code>map<\/code>，所以我可以在每种\n                Java.net 语言中做极少的工作来创建并行化的版本。<\/p><p>清单 1 是完美数分类器的一个 Scala 示例。 <\/p><h5 id=\"listing1\">清单 1. Scala\n                中的并行完美数分类器<\/h5><div class=\"codesection\"><pre class=\"displaycode\">object NumberClassifier {\n  def isFactor(factor: Int, number: Int) =\n    number % factor == 0\n\n  def factors(number: Int) = {\n    val factorsBelowSqrt = (1 to Math.sqrt(number).toInt).par.filter (isFactor(_, number))\n    val factorsAboveSqrt = factorsBelowSqrt.par.map(number / _)\n    (factorsBelowSqrt ++ factorsAboveSqrt).toList.distinct\n  }\n\n  def sum(factors: Seq[Int]) =\n    factors.par.foldLeft(0)(_ + _)\n\n  def isPerfect(number: Int) =\n    sum(factors(number)) - number == number\n}<\/pre><\/div><div class=\"dw-sidebar ibm-inset\"><h2 id=\"N10096\">边缘情况<\/h2><p> 在 <a href=\"#listing1\">清单 1<\/a> 的 <code>factors()<\/code>\n                    方法实现中，整数的平方根（例如，16 的平方根：4）显示在两个列表中。因此，<code>factors()<\/code>\n                    方法返回的最后一行是对 <code>distinct<\/code> 函数的调用，它从列表中删除了重复值。您也可以在每一处都使用\n                    <code>Set<\/code>，而不是只在列表中使用它，但 <code>List<\/code> 常常拥有 <code>Set<\/code>\n                    中所没有的有用函数。 <\/p><\/div><p><a href=\"#listing1\">清单 1<\/a> 中的 <code>factors()<\/code> 方法返回一个数的因数列表，使用\n                <code>isFactor()<\/code> 方法过滤所有可能的值。<code>factors()<\/code> 方法使用了我在 “<a href=\"http://www.ibm.com/developerworks/cn/java/j-ft17/index.html\"><em>函数式思维<\/em>：转换和优化<\/a>”\n                中更详细地介绍的一种优化。简单来讲，过滤每个数来查找因素的效率很低，因为根据定义，一个因数是其乘积等于目标数的两个数之一。相反，我仅过滤不超过目标数的平方根的数，然后通过将目标数除以每个小于平方根的因数来生成对称因数列表。在\n                    <a href=\"#listing1\">清单 1<\/a> 中，<code>factorsBelowSqrt<\/code>\n                变量包含过滤操作的结果。<code>factorsAboveSqrt<\/code>\n                的值是现有列表的映射，用于生成这些对称值。最后，<code>factors()<\/code>\n                的返回值是一个串联的列表，它从一个并行的<code>List<\/code> 转换为常规的 <code>List<\/code>。 <\/p><p> 请注意，<a href=\"#listing1\">清单 1<\/a> 中添加了 <code>par<\/code> 修饰符。该修饰符会导致\n                <code>filter<\/code>、<code>map<\/code> 和 <code>foldLeft<\/code>\n                并行运行，从而能够使用多个线程来处理请求。<code>par<\/code> 方法（在整个 Scala\n                集合库中都是一致的）将该序列转换为并行序列。因为两种类型的序列反映了它们的签名，所以 <code>par<\/code>\n                函数变成了并行化某个操作的临时方式。 <\/p><p> 在 Scala 中并行化常见问题的简单性，在语言设计和函数模式上都经过证实。函数式编程鼓励使用通用的函数，比如\n                <code>map<\/code>、<code>filter<\/code> 和\n                <code>reduce<\/code>，运行时以不可见的方式可以进一步优化它们。Scala 语言设计人员考虑到了这些优化，最终产生了集合 API\n                的设计。 <\/p><p> Groovy 也允许轻松地修改现有的函数代码，通过 <a href=\"http://gpars.codehaus.org/\">GPars<\/a>\n                库让它并行化，该库捆绑在各个 Groovy 发行版中。GPars 框架在内置的 Java\n                并行性原语之上创建有用的抽象，常常将它们包装在语法糖中。GPars\n                提供了令人眼花缭乱的并行机制，其中一种机制可用于分配线程池，然后将操作分布到这些池中。清单 2 中给出了一个使用 Groovy 编写的，使用\n                GPars 线程池的完美数分类器。 <\/p><h5 id=\"listing2\">清单 2. Groovy\n                中的并行完美数分类器<\/h5><div class=\"codesection\"><pre class=\"displaycode\">class NumberClassifierPar {\n\n  static def factors(number) {\n    GParsPool.withPool {\n      def factors = (1..round(sqrt(number) + 1)).findAllParallel { number % it == 0 }\n      (factors + factors.collectParallel { number / it }).unique()\n    }\n  }\n\n  static def sumFactors(number) {\n    factors(number).inject(0, { i, j -&amp;gt; i + j })\n  }\n\n  static def isPerfect(number) {\n    sumFactors(number) - number == number\n  }\n\n}<\/pre><\/div><p><a href=\"#listing2\">清单 2<\/a> 中的 <code>factors()<\/code> 方法使用了与 <a href=\"#listing1\">清单 1<\/a> 相同的算法：它生成不超过目标数的平方根的所有因数，然后生成剩余的因数并返回串联的集合。与\n                    <a href=\"#listing1\">清单 1<\/a> 中一样，我使用 <code>unique()<\/code>\n                方法来确保整数的平方根不会生成重复值。 <\/p><p> 无需像 Scala 中一样放大集合来创建对称并行版本，Groovy 的设计人员创建了该语言的转换方法的\n                <code><em>xxx<\/em>Parallel()<\/code> 版本（例如 <code>findAllParallel()<\/code> 和\n                <code>collectParallel()<\/code>）。但除非这些方法包装在 GPars 线程池代码块中，否则它们不会起作用。在 <a href=\"#listing2\">清单 2<\/a> 中，我创建了一个线程池，调用\n                <code>GParsPool.withPool<\/code> 创建一个代码块，支持在该代码块中使用\n                <code><em>xxx<\/em>Parallel()<\/code> 方法。<code>withPool<\/code>\n                方法存在其他变体。例如，您可指定池中的线程数量。 <\/p><p>Clojure 通过 <a href=\"http://clojure.com/blog/2012/05/08/reducers-a-library-and-model-for-collection-processing.html\"><em>化简器<\/em><\/a> 库提供了一种类似的临时并行化机制。使用转换函数的化简器版本来实现自动并行化，例如，<br />使用\n                <code>r/map<\/code> 代替 <code>map<\/code>。（<code>r/<\/code> 是化简器命名空间。）化简器的实现是\n                Clojure 的语法灵活性中的一个引人注目的案例分析，它通过极小的更改实现了强大的添加功能。<\/p><h2 id=\"N10148\">Scala 中的 actor<\/h2><p> Scala 包含众多并发性和并行性机制。一种较流行的机制是 <em>actor<\/em>\n                模型，它提供了将工作分布到线程上的优势，而没有同步的复杂性。在概念上，actor 有能力完成工作，然后将一个非阻塞的结果发送给协调器。要创建一个\n                actor，需要创建 <code>Actor<\/code> 类的子类并实现 <code>act()<\/code> 方法。通过使用 Scala\n                的语法糖，可绕过许多定义仪式，在代码块内定义 actor。 <\/p><p> 我没有为 <a href=\"#listing1\">清单 1<\/a>\n                中的数字分类器执行的一种优化是，使用线程对作业的因数查找部分进行分区。如果我的计算机上有 4\n                个处理器，我可为每个处理器创建一个线程并拆分工作。例如，如果我尝试找到数字 16 的因数之和，那么我可以安排处理器 1 来查找从 1 到 4\n                的因数（并求和），安排处理器 2 来处理 5 到 8，依此类推。使用 actor 是一种自然的选择：我为每个范围创建了一个\n                actor，独立地执行每个 actor（通过语法糖隐式执行或通过调用它的 <code>act()<\/code>\n                方法来显式执行），然后收集结果，如清单 3 所示。 <\/p><h5 id=\"listing3\">清单 3. 使用 Scala 中的 actor\n                识别完美数<\/h5><div class=\"codesection\"><pre class=\"displaycode\">object NumberClassifier extends App {\n\n  def isPerfect(candidate: Int) = {\n    val RANGE = 10000\n    val numberOFPartitions = (candidate.toDouble / RANGE).ceil.toInt\n    val coordinator = self\n\n    for (i &amp;lt;- 0 until numberOFPartitions) {\n      val lower = i * RANGE + 1\n      val upper = candidate.min((i + 1) * RANGE)\n      actor {\n        var partialSum = 0\n        for (j &amp;lt;- lower to upper)\n          if (candidate % j == 0) partialSum += j\n\n        coordinator ! partialSum\n      }\n    }\n    var responsesExpected = numberOFPartitions\n    var sum = 0\n    while (responsesExpected &amp;gt; 0) {\n      receive {\n        case partialSum : Int =&amp;gt;\n          responsesExpected -= 1\n          sum += partialSum\n      }\n    }\n\n    sum == 2 * candidate\n  }\n}<\/pre><\/div><p> 为了保持此示例的简单性，我将 <code>isPerfect()<\/code> 编写为单个完整的函数。我首先基于常量\n                <code>RANGE<\/code> 创建了一些分区。其次，我需要一种方式来收集 actor 所生成的消息。在\n                <code>coordinator<\/code> 变量中，我有一个引用可供 actor 向其发送消息，其中 <code>self<\/code> 是\n                <code>Actor<\/code> 的一个成员，表示 Scala 中获取线程标识符的可靠方式。 <\/p><p> 我然后为分区编号创建一个循环，使用 <code>RANGE<\/code> 偏移来生成范围的下限和上限。接下来，为该范围创建一个 actor，使用\n                Scala 的语法糖来避免正式的类定义。在 actor 内，我为 <code>partialSum<\/code>\n                创建了一个临时保存器，然后分析该范围，将找到的因数收集到 <code>partialSum<\/code>\n                中。收集部分和（此范围内的所有因数的和）后， (<code>coordinator ! partialSum<\/code>)\n                向协调器发回一条消息，使用感叹号运算符。（这种消息传递语法的灵感来源于 Erlang 语言，用作一种对另一个线程执行非阻塞调用的途径。） <\/p><p> 接下来，我启动了一个循环，等待所有 actor 完成处理。在等待过程中，我进入了一个 <code>receive<\/code>\n                代码块。在该代码块内，我想要一条 <code>Int<\/code> 消息，我在本地将它分配给\n                <code>partialSum<\/code>，然后递减想要的响应数量，将该部分添加到总和中。所有 actor\n                完成且报告结果后，该方法的最后一行将该和与候选数的 2 倍相比较。如果比较结果为\n                <em>true<\/em>，那么我的候选数就是一个完美数，该函数的返回值为 <code>true<\/code>。 <\/p><p> actor 的一个不错的优势是所有权分区。每个 actor 都有一个 <code>partialSum<\/code>\n                局部变量，但它们从不彼此联系。通过协调器收到消息时，底层执行机制是不可见的：您创建了一个 <code>receive<\/code>\n                块，其他实现细节是不可见的。 <\/p><p> Scala 中的 actor 机制是 Java 下一代语言封装 JVM 的现有工具并使用一致的抽象来扩展它们的优秀示例。用 Java\n                语言编写类似的代码，并使用低级并发性原语，这些操作都需要非常复杂地协调多个线程。Scala 中的 actor\n                隐藏了所有复杂性，留下的是容易理解的抽象。 <\/p><h2 id=\"N101A1\">结束语<\/h2><p> Java 下一代语言都为 Java 语言中的并发性难题提供了答案，而且每种语言以不同方式解决了这些问题。在本期文章中，我演示了所有三种 Java\n                下一代语言如何实现临时并行化。我还演示了 Scala 中的 actor 模型，构建了一个数字分类器来并行计算因数之和。 <\/p><p> 在下一期文章中，我将分析 Clojure 中采用的 Java 下一代语言中最激进的并发性方法。 <\/p><CMA ID: 973316><Site ID: 10><XSLT stylesheet used to transform this file: dw-document-html-7.0.xsl>\r\n\r\n\r\n<\/div>\r\n<\/div>\r\n","createTime":"2014-06-05 00:00:00","deployTime":"2014-06-05 00:00:00","id":0,"intro":"或许 Java 下一代语言之间的最明显的区别在于线程、并发性和并行性。本文将介绍让 Scala、Groovy 和 Clojure 中现有的函数代码并行化的一些简单方法，然后还会分析 Scala 中的 actor 并发模型。","keyword":"","recommend":false,"source":"http://www.ibm.com/developerworks/cn/java/j-jn13/index.html","title":"Java\n            下一代: 对比并发性","typeId":0,"updateTime":"2014-06-05 00:00:00"}
{"author":"","clickNumber":0,"content":"\r\n<div class=\"ibm-columns\">\r\n<div class=\"ibm-col-1-1\">\r\n\r\n<p>本文将介绍 OpenStack Identity，它提供了对其他所有 OpenStack 项目进行身份验证的一种常见方法。<\/p><p>每项多用户服务都需要一些机制来管理哪些人可以访问应用程序，以及每个人可以执行哪些操作。私有云也不例外，而且 OpenStack\n                已经将这些功能简化为一个单独的称为 Keystone 的项目。<\/p><p>Keystone 是 OpenStack Identity 的项目名称，该服务通过 OpenStack 应用程序编程接口 (API)\n                提供令牌、策略和目录功能。与其他 OpenStack 项目一样，Keystone\n                表示一个抽象层。它并不实际实现任何用户管理功能；而是会提供插件接口，以便组织可以利用其当前的身份验证服务，或者从市场上的各种身份管理系统中进行选择。<\/p><p>Keystone 集成了用于身份验证、策略管理和目录服务的 OpenStack\n                功能，这些服务包括注册所有租户和用户，对用户进行身份验证并授予身份验证令牌，创建横跨所有用户和服务的策略，以及管理服务端点目录。身份管理系统的核心对象是用户\n                &#8212; 使用 OpenStack\n                服务的个人、系统或服务的数字表示。用户通常被分配给称作租户的容器，该容器会将各种资源和身份项目隔离开来。租户可以表示一个客户、帐户或者任何组织单位。<\/p><p>身份验证是确定用户是谁的过程。Keystone\n                确认所有传入的功能调用都源于声明发出请求的用户。该过程通过测试凭证形式的声明来执行这一验证。凭证数据的显著特性就是它应该只供拥有数据的用户访问。该数据中可以只包含用户知道的数据（用户名称和密码或密钥），用户通过物理方式处理的一些信息（硬件令牌），或者是用户的一些\n                ”实际信息”（视网膜或指纹等生物特征信息）。<\/p><p>在 OpenStack Identity\n                确认完用户的身份之后，它会给用户提供一个证实该身份并且可以用于后续资源请求的令牌。每个令牌都包含一个作用范围，列出了对其适用的资源。令牌只在有限的时间内有效，如果需要删除特定用户的访问权限，也可以删除该令牌。<\/p><p>安全策略是借助一个基于规则的授权引擎来实施的。用户经过身份验证后，下一步就是确定身份验证的级别。Keystone\n                利用角色的概念封装了一组权利和特权。身份服务发出的令牌包含一组身份验证的用户可以假设的角色。然后，由资源服务将用户角色组与所请求的资源操作组相匹配，并做出允许或拒绝访问的决定。<\/p><p>Keystone 的一个附加服务是用于端点发现的服务目录。该目录提供一个可用服务清单及其 API 端点。一个端点就是一个可供网络访问的地址（例如\n                URL），用户可在其中使用一项服务。所有 OpenStack 服务，包括 OpenStack Compute (Nova) 和 OpenStack\n                Object Storage (Swift)，都提供了 Keystone 的端点，用户可通过这些端点请求资源和执行操作。<\/p><h2 id=\"architecture\">架构<\/h2><p>从架构方面讲，Keystone 非常简单。它处理所有 API 请求，提供 Identity、Token、Catalog 和 Policy\n                服务。可以通过 API 网络将 Keystone 作为一组已暴露的前端服务进行组织：<\/p><ul class=\"ibm-bullet-list\"><li>Identity 服务验证了身份验证凭证，并提供了所有相关的元数据。<\/li><li>在验证了用户的凭证后，Token 服务将会验证并管理用于验证请求身份的令牌。<\/li><li>Catalog 服务提供了可用于端点发现的服务注册表。<\/li><li>Policy 服务暴露了一个基于规则的身份验证引擎。<\/li><\/ul><p>每个 Keystone 功能都支持用于集成到异构环境并展示不同功能的后端插件。更常见的一些后端包括：<\/p><ul class=\"ibm-bullet-list\"><li><strong>Key Value Store<\/strong>：一个接口，支持主键查找，例如内存中的字典。<\/li><li><strong>Memcached<\/strong>：分布式内存缓冲系统。<\/li><li><strong>Structured Query Language (SQL)<\/strong>：使用 SQLAlchemy（一个\n                    Python SQL 工具包和 Object Relational Mapper）来永久存储数据。<\/li><li><strong>Pluggable Authentication Module (PAM)<\/strong>：使用本地系统的 PAM\n                    服务进行身份验证。<\/li><li><strong>Lightweight Directory Access Protocol (LDAP)<\/strong>：通过 LDAP\n                    连接到一个后端字典，例如 Active Directory&#174;，以便验证用户身份并获取角色信息。<\/li><\/ul><h2 id=\"setup\">设置<\/h2><p>在不同的分发和 OpenStack\n                版本之间，实际的安装说明也大不相同。通常，这些安装说明可在分发过程中提供。但是，必须完成相同的基础任务。本节将介绍其中涉及的一些概念。<\/p><h3 id=\"sys-reqs\">系统要求<\/h3><p>OpenStack 依赖于一种 64 位 x86 架构；另外，它是为商用硬件而设计的，所以具有极低的系统要求。它可以在配有包含 8GB RAM\n                的单个系统上运行整套 OpenStack 项目。对于稍微大一些的安装，可能会将 Keystone 服务与其他项目（例如 Nova\n                控制器）共同放置在一个位置。但是，为了获得高度可扩展实现，最好使用专用系统进行身份管理。对于单一系统，四核 CPU、32GB RAM 和两个\n                Gbit 网络适配器是一个不错的起点。<\/p><h3 id=\"install\">安装<\/h3><p>安装指令取决于发行版本，更具体来讲，取决于您选择的包管理实用程序。在许多情况下，必须声明存储库。所以，举例而言，如果您使用的是\n                Zypper，那么您要用 <code>zypper ar<\/code> 向 <code>libzypp<\/code> 公开：<\/p><div class=\"codesection\"><pre class=\"displaycode\"># zypper ar -f http://download.opensuse.org/repositories/Cloud:/\nOpenStack:/Grizzly/SLE_11_SP3/Cloud:OpenStack:Grizzly.repo<\/pre><\/div><p>然后，安装所需的 Keystone 数据包，而且数据包管理实用程序应该自动安装所有依赖关系。完整的安装过程取决于您想要得到的配置和所用的\n                OpenStack 的准确版本。请务必查看安装指南中的权威说明。出于演示之目的，下面提供了 Debian（例如 Ubuntu）、Red Hat\n                (Red Hat Enterprise Linux&#174;, CentOS, Fedora) 和 openSUSE 的一些主要命令：<\/p><ul class=\"ibm-bullet-list\"><li><strong>Debian<\/strong>。在基于 Debian 的系统（例如 Ubuntu）上安装 Keystone，使用以下命令：\n                        <div class=\"codesection\"><pre class=\"displaycode\">sudo apt-get install keystone\nsudo apt-get install python-keystone\nsudo apt-get install python-keystoneclient<\/pre><\/div><\/li><li><strong>Red Hat<\/strong>。在 Red Hat 系统上，使用的命令是：\n                        <div class=\"codesection\"><pre class=\"displaycode\">sudo yum install openstack-keystone\nsudo yum install python-keystone\nsudo yum install python-keystoneclient<\/pre><\/div><\/li><li><strong>openSUSE<\/strong>。使用以下命令：\n                        <div class=\"codesection\"><pre class=\"displaycode\">sudo zypper install openstack-keystone\nsudo zypper install python-keystoneclient<\/pre><\/div><\/li><\/ul><h3 id=\"config\">配置<\/h3><p>主要 Keystone 配置文件是 keystone.conf，该文件位于 /etc/keystone/ 中。该文件将会识别\n                <code>[auth]<\/code> 一节中指定的所有身份验证插件：<\/p><ul class=\"ibm-bullet-list\"><li><code>methods<\/code>。列出所有身份验证插件名称。<\/li><li><code>&lt;plugin name&gt;<\/code>。指定每种身份验证方法的类。<\/li><\/ul><p>例如：<\/p><div class=\"codesection\"><pre class=\"displaycode\">[auth]\nmethods = password,token,oauth1\npassword = keystone.auth.plugins.password.Password\ntoken = keystone.auth.plugins.token.Token\noauth1 = keystone.auth.plugins.oauth1.OAuth<\/pre><\/div><p>对于插件注册其自己的配置选项来说，目前还没有一种标准机制，但常见的做法是将其自己的部分放入配置文件中。<\/p><h3 id=\"certs\">证书<\/h3><p>许多组织正逐渐转向公钥基础架构 (Public Key\n                Infrastructure)，因为这是一项高度可扩展的、基于标准的技术。该项技术的一个优势是它允许委托信任（delegated\n                trust），这对身份联合至关重要，但同时也意味着有必要通过一个防篡改的链接向公认的可信认证机构 (CA) 展示真实性。<\/p><p>实际上，这意味必须使用 CA 认证的 X.509 证书来签署公钥。对于完全的内部实现，可能会使用\n                <code>keystone-manage<\/code> 来生成一个自签署的证书，但在联合环境中，可能会需要来自外部 CA 的证书。<\/p><p>安装外部 CA 发出的证书涉及到以下操作：<\/p><ul class=\"ibm-bullet-list\"><li>从外部 CA 请求一个签名证书<\/li><li>将证书和私钥转换为 Privacy Enhanced Email (PEM) 格式<\/li><li>通过将 .pem 文件复制到证书目录来安装外部签名证书<\/li><\/ul><h2 id=\"scenarios\">使用场景<\/h2><p>身份管理是一项支持功能，其有形目的（tangible purpose）要少于大多数其他 OpenStack\n                项目。应该将该功能视作一个推动因素，它可以简化服务发现，并提供执行安全策略的统一方法。<\/p><p>或许，虚拟化其使用的最简单的方法是将其划分为两部分。Keystone\n                中的管理功能定义了用户和项目，并分配了适当的授权。在配置好环境之后，项目和应用程序就可以与 Keystone\n                结合使用，以便执行查询和验证访问控制。<\/p><h3 id=\"admin\">管理<\/h3><p>首先来看第一部分，这部分最容易执行，因为该部分映射到了 Horizon\n                仪表板。管理员可以创建项目和用户。可以给用户分配角色并将其聚集成组来简化管理。<\/p><ol><li>第一步通常是创建一个项目。以管理员身份登录到 OpenStack Dashboard。在导航面板中的 Identify Panel 下，单击\n                        <strong>Projects<\/strong> &gt; <strong>Create Project<\/strong>。 <h5 id=\"fig1\">图 1. 创建新项目<\/h5><img alt=\"该图显示了如何在 Create Project 窗口中创建项目\" src=\"/sunshine_new/images/1129414325/figure1.png\" width=\"694\" /><\/li><li>此时，除了名称和描述之外，不需要任何信息。您至少需要一个用户。在 Identity Panel 下，单击\n                        <strong>Users<\/strong> &gt; <strong>Create User<\/strong>。 <h5 id=\"fig2\">图 2. 创建用户<\/h5><img alt=\"该图显示了如何在 Create User 窗口中创建用户\" src=\"/sunshine_new/images/1129414325/figure2.png\" width=\"692\" /><\/li><li>编辑项目。在 Identity Panel 下，单击 <strong>Projects<\/strong> &gt; <strong>Edit\n                        Project<\/strong>。 <h5 id=\"fig3\">图 3. 编辑项目<\/h5><img alt=\"该图显示了如何编辑项目\" src=\"/sunshine_new/images/1129414325/figure3.png\" width=\"800\" height=\"655\" /><p><a href=\"#N1011D\" class=\"ibm-popup-link\" onclick=\"ibmweb.overlay.show('N1011D',this);return false;\">点击查看大图<\/a><\/p><div id=\"N1011D\" class=\"dw-sidefile-overlay ibm-common-overlay ibm-overlay-alt-two\"><div class=\"ibm-head\"><p><a href=\"#close\" class=\"ibm-common-overlay-close\">关闭 [x]<\/a><\/p><\/div><div class=\"ibm-body\"><div class=\"ibm-main\"><div class=\"ibm-title\"><h2>图 3. 编辑项目<\/h2><\/div><div class=\"ibm-container ibm-alternate\"><div class=\"ibm-container-body\"><img alt=\"该图显示了如何编辑项目\" src=\"/sunshine_new/images/1129414325/figure3.png\" width=\"1000\" /><\/div><\/div><\/div><\/div><div class=\"ibm-footer\"><><\/div><\/div><\/li><li>在 Edit Project 窗口中的 Project Members 选项卡下，可以编辑项目成员和更改其角色。 <h5 id=\"fig4\">图 4. 编辑项目成员和更改其角色<\/h5><img alt=\"该图显示了如何编辑项目成员及其角色\" src=\"/sunshine_new/images/1129414325/figure4.png\" width=\"692\" /><\/li><li>还可以使用 Quota\n                    选项卡指定项目的限制条件。这在多租户环境中尤其有用，可确保一个项目不会使用过多的资源，也不会遗漏在同一基础架构上运行的其他关键服务。 <h5 id=\"fig5\">图 5. 指定项目的限制条件<\/h5><img alt=\"该图显示了 Quota 选项卡\" src=\"/sunshine_new/images/1129414325/figure5.png\" width=\"556\" height=\"753\" /><p><a href=\"#N10133\" class=\"ibm-popup-link\" onclick=\"ibmweb.overlay.show('N10133',this);return false;\">点击查看大图<\/a><\/p><div id=\"N10133\" class=\"dw-sidefile-overlay ibm-common-overlay ibm-overlay-alt-two\"><div class=\"ibm-head\"><p><a href=\"#close\" class=\"ibm-common-overlay-close\">关闭 [x]<\/a><\/p><\/div><div class=\"ibm-body\"><div class=\"ibm-main\"><div class=\"ibm-title\"><h2>图 5. 指定项目的限制条件<\/h2><\/div><div class=\"ibm-container ibm-alternate\"><div class=\"ibm-container-body\"><img alt=\"该图显示了 Quota 选项卡\" src=\"/sunshine_new/images/1129414325/figure5.png\" width=\"695\" /><\/div><\/div><\/div><\/div><div class=\"ibm-footer\"><><\/div><\/div><\/li><\/ol><h3 id=\"auth\">身份验证<\/h3><p>该场景的第二部分是在执行操作时对服务进行身份验证。例如，请考虑一个使用 OpenStack Swift 来实现对象存储的应用程序。无论是否作为\n                OpenStack 计算实例的一部分运行，都必须能够进行身份验证，这意味着需要访问有效的凭证。<\/p><p>应用程序首先需要连接到身份验证服务并提供其凭证，然后它会接收到一个身份验证令牌，可将该令牌传递给 OpenStack Object\n                Storage，以实现所有容器和对象操作。在有些情况下，可能会使用所有连接参数预先配置应用程序。也可以从 Keystone\n                中获得这些参数。例如，可以查询 Keystone，发现哪些项目是可以访问的，并请求该项目所需的服务 URL。<\/p><h2 id=\"N10140\">结束语<\/h2><p>只要坚持使用 Horizon 用户界面，用户管理并不太难。该界面隐藏了内部流程，以及与其他用户存储库（例如 Active Directory，或任何\n                LDAP 目录）的一些必要集成。<\/p><CMA ID: 973345><Site ID: 10><XSLT stylesheet used to transform this file: dw-document-html-7.0.xsl>\r\n\r\n\r\n<\/div>\r\n<\/div>\r\n","createTime":"2014-06-05 00:00:00","deployTime":"2014-06-05 00:00:00","id":0,"intro":"本文将介绍 OpenStack Identity (Keystone) 项目，解释它如何融入到整体架构中，并展示它的操作方式。本文还图文并茂的展现了该项目洞察其如何安装、配置以及使用这些组件。","keyword":"","recommend":false,"source":"http://www.ibm.com/developerworks/cn/cloud/library/cl-openstack-keystone/index.html","title":"发现 OpenStack: Identity 组件 Keystone","typeId":0,"updateTime":"2014-06-05 00:00:00"}
{"author":"","clickNumber":0,"content":"\r\n<div class=\"ibm-columns\">\r\n<div class=\"ibm-col-1-1\">\r\n\r\n<h2 id=\"smarterplanet\">做好准备<\/h2><p>IBM 在多年前就引入了 “智慧地球” 这个术语。利用这个术语，可以描述 3 个主要属性：<\/p><div class=\"dw-sidebar ibm-inset\"><h2 id=\"streamsquick\">InfoSphere Streams Quick Start\n                    Edition<\/h2><p>InfoSphere Streams Quick Start Edition 是一个免费的、可下载的 InfoSphere Streams\n                    非生产版本，这是一个高性能的计算平台，支持使用用户开发的应用程序快速地提取、分析和关联从数千种实时数据源提供的信息。如果没有数据或时间限制，InfoSphere\n                    Streams Quick Start Edition\n                        支持您在自己的惟一环境中试用流计算。构建一个功能强大的分析平台，以便处理极其高的数据吞吐量，高吞吐量可能高达每秒多达数百万个事件或消息。<a href=\"http://www.ibm.com/developerworks/cn/downloads/im/streamsquick/\">即刻下载 Streams Quick Start Edition<\/a>。<\/p><\/div><ul class=\"ibm-bullet-list\"><li>物联化<\/li><li>智能化<\/li><li>互连化<\/li><\/ul><p>长久以来，这已经形成一个现实。想象一下智能手机的激增，这实际上可能提供了比保持联系更多的功能。智能手机包括 GPS\n                提供的用于测量温度和湿度的一组传感器。再加上世界各地使用的所有传感器和仪表，我们看到了一个不断演化的真实情况。<\/p><p>这就构成了应该转换成<em>信息<\/em>\n                的大量数据。例如，我们可以利用群众的力量来洞察不断变化的情形。我们可以察觉出可能产生机遇或避免严重灾害的趋势。我们可以看到电信与其他行业中社交媒体观点的实时分析、能量消耗的当前状态、关键性能指标的分析。其他更多示例已超出了本文的讨论范围。<\/p><p>在利用这个新的数据机会时，存在几个重大问题。其中一个就是数据的绝对量，另一个是大量数据的短暂性。我们如何才能快速筛选所获得的数据，关注我们当时感兴趣的部分？<\/p><p>当然，您可能认为我的答案会指向 InfoSphere Streams。首先，我们需要了解静态数据和动态数据之间的差别。<\/p><h2 id=\"dataatrest\">静态数据<\/h2><p>可以大胆地假设每个人都非常了解静态数据：文件和数据库。无论数据来自何处，都会先存储在磁盘上，然后供用户使用。我们见证了数据多年以来的发展变化；文件很难更新，而且并行更新根本不可能实现。然后，分层/网络数据库出现了，但是，随后数据只针对某种特定用例进行了组织，而且最糟糕的访问场景几乎其他所有用例都遭遇过。这就导致了关系数据库的采用。<\/p><p>最终，关系模型稳定下来，并逐渐发展成为包括对象关系模型形式的可扩展性。这一模型的最成功的特征就是能够包含其他数据类型和功能来满足业务需求，比如处理空间数据和进行文本搜索。它还可以进一步扩展为提供专门的存储和处理，如\n                Informix&#174; TimeSeries 功能中所述。<\/p><p>在过去的几年里，我们经历了分析非结构化数据的需求分析的其他发展阶段，这导致了 Hadoop（或是企业就绪的 InfoSphere\n                BigInsights&#8482;\n                以及附属产品）的崛起。这些进展使得分析大量数据变得更加容易，但是它们仍然需要先将数据存储在磁盘上，然后才能对它们进行处理。<\/p><p>静态数据是一种已经稳定下来的模型，而且在帮助大数据挑战的时候还将继续扩展。实时分析的增加要求添加另外一种模型：动态数据。<\/p><h2 id=\"datainmotion\">动态数据<\/h2><p>动态数据也是一个已知概念。想象一部电影 &#8212;\n                电影就是动态数据。不是因为人们在屏幕上移动，而是屏幕上有源源不断的图像经过，每一张图像都是转眼间就消失了。<\/p><p>在许多软件应用中，必须先让数据运动起来，然后才能对其进行处理。数据从一种功能流动到另一种功能，从一个线程流动到另一个线程，从一个流程移动到另一个流程，从一台计算机流动到另一台计算机。<\/p><p>试想一下应用程序的性能应用，如果需要先让数据处于静止状态，然后再对其进行处理，那么动态数据和静态数据之间的常量转换可能会造成一些重要的处理可能性。为了有效地处理数据，应该尽可能地尝试限制静态数据需求，因为磁盘驱动器是计算机系统的最慢组件。<\/p><p>动态数据的另一个优势是，在大量的类似数据中，我们没有必要拥有专门的存储机制来优化数据检索。如果数据处于运动状态，那么您已经拥有了它。如果需要从静态存储库中检索数据，则需要确定如何进行检索。检索可以通过顺序访问或索引访问来完成。无论采用哪种方式，在数据通过时都会执行读取数据之外的更多操作。<\/p><h2 id=\"RTP\">实时处理<\/h2><p>在继续后面的介绍之前，我们需要弄清楚<em>实时处理<\/em>\n                这个术语。在有些情况下，处理数据所需的处理权限和时间量必须得到环境的保证。为了确保指定的响应时间，不能以任何理由暂停执行程序。在这些情况下，处理必须在专门的操作环境中运行，也就是说，在支持这类调度的特定操作系统下进行。<\/p><p>在较宽松的环境中，实时处理意味着随时随地处理数据，时间范围从转眼的瞬间到数分钟甚至数小时不等。而在紧要关头，数据可用性与数据创建之间可能存在延迟性。您的数据可能每隔\n                15 分钟突然出现一次，但延迟性就是数据突然出现和信息可用之间的时间。<\/p><p>在许多商业案例中，比如社交数据分析，会依靠已定义的延迟水平来确定处理的有效性。项目成功的关键在于我们可以降低多少延迟。<\/p><p>请记住，这次我们讨论的并不是要从静态模型的数据中获得什么。在许多情况下，仍然需要将此用于不太严格的 “实时”\n                需求，当然，可以将此用于历史数据的深度分析。对于让实时分析适应业务变化实际情况，这种分析至关重要。<\/p><h2 id=\"N10088\">InfoSphere Streams 是什么？<\/h2><p>我的一个同事提供了这个简短的定义：“InfoSphere Streams 是一个对大数据进行实时分析的平台。”<\/p><p>“大数据” 部分指的是数据的数量、种类和速度。我们会讨论任何类型的数据（<em>种类<\/em>），可能包括以非常快的<em>速度<\/em> 传入的\n                    TB（<em>数量<\/em>）字节的数据。<\/p><p>当说到 “分析” 时，我们指的是通过自定义编程处理/分析数据的能力，包括工具的使用（比如 SPSS&#174;）或 R 项目环境。<\/p><p>“实时” 部分是指通过处理内存中的数据，尽可能多地消除延迟性。<\/p><p>最后，“平台 ... 用于大数据” 指的是 InfoSphere Streams\n                在一个机器集群上通过显式分发处理来实现可扩展性的能力，以及监控和管理环境的能力。<\/p><p>平台提供了哪些功能，我们如何使用它们？问得好。在回答这个问题之前，让我先介绍一下 InfoSphere Streams 信息的一站式商店。<\/p><h2 id=\"WIIS\">InfoSphere Streams Playbook\n                简介<\/h2><p>关于 InfoSphere Streams 的可用信息有许多。这些信息以有文档、IBM 红皮书&#174;、developerWorks\n                文章、培训视频、用例等形式存在。您如何发现并导航这些信息？<\/p><p>一个名为 InfoSphere Streams Playbook 的 developerWorks 维基可以实现此目的（参见 <a href=\"#resources\">参考资料<\/a>）。如果因为某些原因没有记住 URL，那么您可以通过 Google 搜索\n                “Streams Playbook”，URL 会出现在第一个结果页面中。<\/p><p>这个维基包含以下各个部分：<\/p><ul class=\"ibm-bullet-list\"><li>参考资料<\/li><li>视频教程<\/li><li>视频用例<\/li><li>其他用例（当前为空）<\/li><li>生态系统<\/li><li>开发人员一角<\/li><\/ul><p>本文的其余部分参照这个维基的各个部分来提供更多信息。<\/p><h2 id=\"StreamsFor\">InfoSphere Streams\n                的使用目的是什么？<\/h2><p>InfoSphere Streams\n                是为安全应用而开发的，这些应用中有大量数据需要快速处理，以便预防某些问题的发生。由于数据来自不同的系统而且使用的格式也不同，因此需要满足以下需求：<\/p><ul class=\"ibm-bullet-list\"><li>支持任何类型的数据<\/li><li>需要通过内存中处理来降低延迟<\/li><li>能够通过使用集群支持来进行缩放<\/li><\/ul><p>InfoSphere Streams\n                还被用于电信行业中，使电信公司能够快速对客户问题作出反应。当客户体验中断时，公司可以采取积极措施来自动补偿客户并维护客户满意度，而不是等待客户投诉或寻求其他的运营商。在一些竞争相当激烈的市场中，客户满意度就相当于客户保持。消除客户流失非常重要。<\/p><p>InfoSphere Streams 还用于交通运输、医疗保健和其他行业中。参见 Playbook 的 “视频用例”\n                部分，了解有关的更多信息。<\/p><h2 id=\"StreamsEnv\">InfoSphere Streams\n                环境<\/h2><p>Although InfoSphere Streams\n                可在单台计算机上运行，它被设计成可在集群上运行，以提供几乎无限的可扩展性。一台计算机可用作一台管理主机、一台应用程序主机，或是一台混合模式的主机，这种主机既可以运行管理服务，也可以运行应用服务和代码。<\/p><h5 id=\"figure1\">图 1. 集群上的管理主机和应用主机的混合<\/h5><img alt=\"该图显示了运行管理服务和应用程序的管理主机与应用主机\" src=\"/sunshine_new/images/负1085235870/streamsenv.png\" width=\"555\" /><p>请注意，管理节点运行的一组服务将会跟踪集群的健康状况和作业的运行情况。可以将一个作业看作是一个程序。作业和程序之间的区别在于它是由操作符构成，可通过调度在任何可用应用主机上运行。<em>作业<\/em>\n                    由多个流程组成，而<em>程序<\/em> 则在单个流程上运行。在信息中心和 InfoSphere Streams Playbook 的\n                “视频教程” 部分中，了解有关 InfoSphere Streams 运行时的更多信息（参见 <a href=\"#resources\">参考资料<\/a>）。<\/p><p>InfoSphere Streams 包含的一些工具可帮助您管理环境和开发 InfoSphere Streams 应用程序：<\/p><ul class=\"ibm-bullet-list\"><li><strong>FirstSteps<\/strong>：执行安装后的任务，比如配置 SSH、生成公钥和私钥、配置恢复数据库等。<\/li><li><strong>Instances Manager<\/strong>：创建、配置、更新和删除实例与集群。实例管理程序还可以启动\n                    InfoSphere Streams 控制台。<\/li><li><strong>InfoSphere Streams Console<\/strong>：基于 Web 的\n                    GUI，用于监控和管理实例与应用程序。<\/li><li><strong>InfoSphere Streams Studio<\/strong>：基于 Eclipse\n                    的工具，用于开发应用程序。该工具中包含一个图形编辑器和向导，可简化标准开发任务。它还包含运行 InfoSphere Streams\n                    作业及其操作符的可视化。<\/li><li><strong>Streamtool<\/strong>：命令行工具，用于自动化管理和监控任务。<\/li><li><strong>InfoSphere Streams Compiler\n                    (SC)<\/strong>：通过工具来自动化编译任务。还可直接使用或通过生成文件（makefile）使用。<\/li><\/ul><p>一旦掌握了图形工具（列表中的前四个符号），就可以使用它们来帮助大幅提高生产力。学习曲线非常短且值得尝试。<\/p><h2 id=\"StreamsProg\">InfoSphere Streams\n                编程<\/h2><p>InfoSphere Streams\n                编程首先将操作符聚集在一起，以便进行模块化处理并启用并行执行。图形编辑器可以更轻松地将操作符连接在一起，创建一个作业处理图形。<\/p><p>InfoSphere Streams 还使用称为流处理语言 (SPL) 的程序语言。如果您熟悉 C 语言、Java&#8482; 编程语言和\n                Python，那么您应该很快就会熟练使用 SPL。<\/p><p>InfoSphere Streams 与大多数语言不同的其中一个方面是其广泛的可用数据类型集，如下所示。<\/p><h5 id=\"figure2\">图 2. InfoSphere Streams\n                    中可用的数据类型<\/h5><img alt=\"该图显示了 InfoSphere Streams 中可用的数据类型\" src=\"/sunshine_new/images/负1085235870/datatypes.png\" width=\"499\" /><p>利用这些类型，您几乎可以匹配任何数据类型。甚至可以根据所提供的原始类型创建自己的数据类型。<\/p><p>除了数据类型外，InfoSphere Streams\n                还附带了重要的分类功能集，包括集合操作（列表、集合与映射）、文件、数学、字符串、时间和实用功能。除了处理不同数据类型的几个同名功能和特定于给定操作符的功能之外，InfoSphere\n                Streams 总共包含 250 多种功能。您还可以在 InfoSphere Streams 包含的专用工具集中添加技术功能。<\/p><p>InfoSphere Streams 编程从操作符开始。<em>操作符<\/em>\n                管理通过各种方式从外部世界获取数据，执行数据转换，并提供最终结果。它支持您将框架快速凝聚为一个解决方案，并利用该解决方案来解决您的业务问题。<\/p><h2 id=\"OperToolkits\">操作符和工具集<\/h2><p>操作符组成了比程序编程更高级别的抽象层次，利用操作符，您就拥有了对处理的逻辑隔离，从而提供了处理分发。操作符来自称为 “工具集”\n                的不同数据包。尤其是一个标准工具集始终包含在所有 InfoSphere Streams\n                项目中。它提供了产品附带的所有功能。尽管各种功能可能会被视为语言的一部分，但还是会被分隔出来，因为它们是在不同的工具集中定义的。<\/p><p>一个<em>工具集<\/em> 就是一个功能数据包，它通常与某个特定的问题领域相关。这些工具集中可以包括操作符、功能和数据类型。下面是\n                InfoSphere Streams 3.1 中提供的工具集：<\/p><ul class=\"ibm-bullet-list\"><li><strong>标准工具集<\/strong>：包含适配器、关系运算、实用程序和 XML 等操作符<\/li><li><strong>大数据<\/strong>：与 Hadoop 分布式文件系统 (Hadoop Distributed File System,\n                    HDFS) 和 Data Explorer 相配合<\/li><li><strong>复杂事件处理<\/strong>：用来定义如何处理复杂事件<\/li><li><strong>数据库<\/strong>：访问关系数据库，比如 DB2&#174;、Informix、Netezza、Oracle、SQL\n                    Server、Teradata 等。<\/li><li><strong>金融服务<\/strong>：包含一组用来处理金融市场处理的操作符和功能<\/li><li><strong>地理空间<\/strong>：提供一组处理地理空间数据的功能<\/li><li><strong>InfoSphere DataStage&#174; 集成<\/strong>：与 DataStage 相配合<\/li><li><strong>Internet<\/strong>：访问 HTTP(S)、FTP(S) 和 RSS<\/li><li><strong>Messaging<\/strong>：与 WebSphere&#174; MQ 和 ActiveMQ 进行通信<\/li><li><strong>Mining<\/strong>：提供一种对数据进行评分的方法<\/li><li><strong>R Project<\/strong>：与 R Project 统计环境相配合<\/li><li><strong>Text<\/strong>：提供文本分析<\/li><li><strong>TimeSeries<\/strong>：帮助处理时间序列，即基于时间的数据处理<\/li><\/ul><p>标准工具集附带了 36 个操作符以及 256 个以上的功能。其他工具集添加了 40\n                多个操作符和几十个函数。通过所有这些预构建的功能，您可以在创建自定义作业时更有效地满足业务需求。<\/p><p>这篇简短的描述会让您对 InfoSphere Streams 提供的功能有初步的了解。接下来让我们进一步了解 InfoSphere Streams\n                如何适应完整的数据处理环境。<\/p><h2 id=\"integration\">InfoSphere Streams\n                集成<\/h2><p>InfoSphere Streams 并不是在真空中运行，它是 IBM 大数据平台的关键组件。在企业集成的过程中，InfoSphere Streams\n                可以从不同来源读取数据并将数据写入不同的目标，比如文件、网络连接（TCP、UDP、HTTP 等）和消息队列（WebSphere MQ 和\n                Active MQ）。InfoSphere Streams 包含的操作符可与使用金融信息交换 (Financial Information\n                eXchange, FIX) 协议的金融市场相配合。<\/p><p>除了这些接口之外，InfoSphere Streams 还适用于多种 IBM 产品，包括 InfoSphere BigInsights、Data\n                Explorer、SPSS 和 Cognos&#174;。此外，它还可以利用 R Project 统计分析工具。随着 InfoSphere\n                Streams 的发展，还会添加更多的接口。<\/p><p>如欲了解有关的更多信息，请查阅 InfoSphere Streams Playbook 的 “生态系统” 部分。<\/p><h2 id=\"infocenter\">导航信息中心<\/h2><p>信息中心包含的信息适用于系统管理员、InfoSphere Streams 管理员和应用程序编程人员。本节主要介绍应用程序开发人员的信息需求。<\/p><p>图 3\n                该图显示了信息中心的各个主要部分和子部分。作为一名开发人员，您可能想要查看所有部分来了解与 InfoSphere Streams\n                相关的每件事。如欲初步了解编程环境，请参阅 “开发” 部分并学习 InfoSphere Streams Studio，然后根据教程进行试验。<\/p><h5 id=\"figure3\">图 3. 信息中心部分<\/h5><img alt=\"改图显示了信息中心中有关 InfoSphere Streams 的主题\" src=\"/sunshine_new/images/负1085235870/icmenu.jpg\" width=\"417\" /><p>在完成最初的浏览之后，您很可能会花费大量的时间查看参考资料部分。您需要了解 SPL 语言、可用的功能、可用的操作符，以及如何使用它们。<\/p><p>在 <strong>Reference &gt; Language reference<\/strong> 中有两个部分：标注查询语言\n                (Annotation Query Language, AQL) 和流处理语言 (Streams Processing Language,\n                SPL)。如果不打算使用 Text 工具集下的文本分析和 TextExtract 操作符，那么现在可以忽略 AQL\n                部分。当决定进行文本分析时，您可能想要使用 InfoSphere BigInsights 2.1 信息中心，其中包含有关各种主题的信息，这些信息比\n                InfoSphere Streams 信息中心包含的信息还要多。<\/p><p>SPL 语言部分包含了解 SPL\n                    语言、数据类型的使用、功能和如何调用工具集操作符的所有信息。由于已经遇到过这个问题，所以我想指出一个可能会被用户忽略或用户可能会再次遇到麻烦的特定部分：<strong>Streams\n                    Processing Language &gt; Expression language &gt; Expression\n                    operator<\/strong>。如果想要了解如何进行逻辑或按位表达，本节列出了编写代码段函数时可以使用的内容。但在这个列表中没有明显指出的是：如何连接字符串。（您可以使用\n                <code>+<\/code> 操作符来完成此操作。）<\/p><p>一旦掌握了这种语言，下一个问题就可能是 “哪些功能可用来处理我的数据？” 这个问题的简要回答是 SPL\n                不包括任何功能。这可能是真的，但所有应用程序都隐式包含 “标准工具集”。以下是您可以寻找操作功能的位置：<strong>Toolkit\n                    reference &gt; SPL Standard Toolkit &gt; Built-in SPL Functions &gt;\n                    FunctionList<\/strong>。本节包含的功能可用于文件处理、数学运算、字符串处理、时间控制和 XML\n                处理。本小节还包含用于日志记录、跟踪、断言等的实用功能。在查找关于某种功能的信息时，最简单的方法就是在页面中搜索（使用\n                    <strong>Ctrl+f<\/strong>）功能名称或相关关键词。<\/p><h2 id=\"codeExample\">代码示例<\/h2><p>此时此刻，您应该已经掌握了开始使用 InfoSphere Streams 进行编程的所有信息。使用 InfoSphere Streams Studio\n                和 GUI\n                编辑器，您可以轻松拖拽想要使用的操作符，并将它们连接在一起。对于更复杂的处理，您可以考虑添加自己的代码段。有些操作符将需要花费额外的学习时间。<\/p><p>最快学习方法之一就是使用代码示例。您可以在 InfoSphere Streams Playbook 中的 “Developer corner”\n                下发现示例和样例的许多参考资料。另外，在 developerWorks 网站上，可以查看一些有用的资源（参见 <a href=\"#resources\">参考资料<\/a>）：<\/p><ul class=\"ibm-bullet-list\"><li>developerWorks 文章 &#8212; developerWorks 站点上的 InfoSphere Streams\n                    文章。<\/li><li>InfoSphere Streams 博客 &#8212; 有关 InfoSphere Streams\n                    编程的所有领域的条目，从简单到复杂。<\/li><li>流交换 &#8212; 社区提供的代码贡献。示例包括使用 OpenCV 的视频处理和与 HBase 配合使用的工具集。在\n                    “Applications” 下，查看 “Examples for\n                    beginners”，当您使用流和操作符开始入门时，强烈推荐您阅读这些内容。<\/li><\/ul><h2 id=\"Conclusion\">结束语<\/h2><p>InfoSphere Streams 是一种功能强大的 “实时分析大数据的平台”。它是 IBM 大数据平台的关键因素。您可以通过使用\n                InfoSphere Streams\n                提供的工具快速提高生产力，并利用可以用到的所有信息。完成了所有这些之后，您就可以将数据转换为切实可行的洞察。<\/p><p>实时数据处理（可能是数据处理中的下一个重大事件）正被用于许多有趣的、要求严格的应用程序中，以便从大数据中获取洞察和竞争优势。<\/p><CMA ID: 973268><Site ID: 10><XSLT stylesheet used to transform this file: dw-document-html-7.0.xsl>\r\n\r\n\r\n<\/div>\r\n<\/div>\r\n","createTime":"2014-06-05 00:00:00","deployTime":"2014-06-05 00:00:00","id":0,"intro":"使用 InfoSphere Streams 将大量数据转换为信息，这些信息可帮助预测趋势、获取竞争优势、衡量客户满意度、监控能量消耗等。InfoSphere Streams 可以处理动态数据，以便实时分析数据。本文将了解该产品，并找出可获得加速实现的提示和技巧的地方。","keyword":"","recommend":false,"source":"http://www.ibm.com/developerworks/cn/data/library/bd-getstartedstreams/index.html","title":"实时流计算入门","typeId":0,"updateTime":"2014-06-05 00:00:00"}
{"author":"","clickNumber":0,"content":"\r\n<div class=\"ibm-columns\">\r\n<div class=\"ibm-col-1-1\">\r\n\r\n<div class=\"dw-sidebar ibm-inset\"><p>下载 <a href=\"http://www.ibm.com/developerworks/cn/downloads/r/rcq/index.html\">Rational ClearQuest<\/a> 试用版，提前体验它的强大功能！<\/p><\/div><h3 id=\"N1006B\">概述<\/h3><p>ClearQuest 提供了强大的客户订制功能，在用户权限管理方面也不例外。 它允许模式库设计者限制某些用户执行某些操作。 这些限制可以是针对某一用户组的，也可以针对具有某些角色的特定用户的。 这一功能带来很多方便，但也带来一个问题：终端用户不清楚自己不可以执行哪些操作，当试图执行受限操作时，会被错误的消息打扰。<\/p><p>从 8.0.1 版本开始，ClearQuest 针对这一问题提供了解决方案，允许模式库设计人员对终端用户隐藏那些他们无权执行的操作；只显示有权执行的操作，从而减少不必要的打扰，提高了易用性。<\/p><p>完成设置需要两个步骤：开启 HIDE_ACTION 模式以及定制访问控制。其中定制访问控制有三种粒度。此外，当使用脚本（access control hook）来进行访问控制时，我们还提供了新的会话变量 ratl_GetLegalAction 帮助设计者更灵活的定制脚本。<\/p><h3 id=\"N10076\">开启 HIDE_ACTIONS 模式<\/h3><p>首先，必须启用 HIDE_ACTIONS 模式。 方法是运行 packageutil 命令，将 HIDE_ACTIONS 模式属性设置为 1。要禁用该模式，只需将 HIDE_ACTIONS 模式属性设置为 0。<\/p><p>格式如下所示：<\/p><p><strong><em>packageutil setproperty Cdbset &lt;dbset&gt; &lt;user&gt; &lt;password&gt; &lt;schema&gt; HIDE_ACTIONS 1<\/em><\/strong><\/p><p>需要注意的是，将 HIDE_ACTIONS 会话变量值设置为 1 可能会对记录表单显示性能产生影响。该记录上所有操作的访问控制挂钩（access control hook）将被执行以确定是否对用户显示该操作。如果模式库有大量操作，或访问控制挂钩脚本运行缓慢，记录表单加载速度较之前可能稍慢。<\/p><h3 id=\"N10085\">定制访问控制（Access Control）<\/h3><p>接下来，模式设计人员需要定制访问控制权限，令某一操作对某些用户隐藏。有三个粒度可供选择，分别是：所有用户可见；对某用户组可见；调用脚本计算对哪些用户可见。<\/p><p>如果\"访问控制\"设置为所有用户，那么不会隐藏该操作，因为所有用户均允许访问此操作。设置方式如下图：<\/p><h5 id=\"N1008F\">图 1.将访问控制设置为所有用户<\/h5><img alt=\"将访问控制设置为所有用户\" src=\"/sunshine_new/images/939701992/image003.jpg\" width=\"582\" /><p>如果\"访问控制\"设置为用户组，那么该操作对属于指定组中成员的用户可见。对其他组成员隐藏。设置如下图：<\/p><h5 id=\"N1009D\">图 2.通过用户组设置访问控制<\/h5><img alt=\"通过用户组设置访问控制\" src=\"/sunshine_new/images/939701992/image005.jpg\" width=\"582\" /><p>如果\"访问控制\"设置为 SCRIPTS，那么是否对用户隐藏此操作取决于脚本的计算结果。下文的示例部分提供了定制脚本的例子。<\/p><h5 id=\"N100AB\">图 3.通过脚本设置访问控制<\/h5><img alt=\"通过脚本设置访问控制\" src=\"/sunshine_new/images/939701992/image007.jpg\" width=\"582\" /><h3 id=\"N100B6\">使用新增的 ratl_GetLegalAction 会话变量<\/h3><p>当 HIDE_ACTIONS 模式属性设置为 1 以隐藏操作，且访问控制设置为 SCRIPTS 时，访问控制挂钩将会被调用来确定是否在 ClearQuest 客户机菜单中对用户隐藏操作。<\/p><p>另一方面，访问控制脚本还有另一个用途，既控制用户执行该操作时的行为。也就是说，同一段脚本会因为两种用途而被调用。一是计算该操作是否应该被隐藏时；二是执行此操作时。因此，模式库设计人员需要一个独特的会话变量来判断脚本当下被调用的原因，从而设计不同的反应。这就是新增加的会话变量 ratl_GetLegalAction 的设计目的。<\/p><p>具体的，如果脚本被执行是为了计算是否应该隐藏该操作，ratl_GetLegalAction 的值会等于当前记录的显示名称；当脚本被执行是为了执行该操作，ratl_GetLegalAction 的值不等于当前记录的显示名称。通过判断该值，模式库设计者可以从容的定制自己的访问控制脚本。<\/p><h3 id=\"N100C1\">典型应用场景示例<\/h3><p>为了更便于理解，我们以 DefectTracking 样例模式库为基础，模拟这样一种假象的应用场景：我们希望针对 Assign 操作定制一些访问控制。具体的，对于每条记录的所有者(Owner)不隐藏 Assign 操作，但不允许其执行该操作；对于管理员不隐藏该操作，并且允许其执行操作；对于其他用户隐藏 Assign 操作，且不允许其执行操作。<\/p><p>为实现此目的我们不能通过用户组来简单的设置访问控制（如图 2 所示），而要定制自己的访问控制脚本。以下 Perl 示例显示如何定制访问控制脚本以计算是否应该隐藏操作（也可使用 VBScript 编写此类访问控制挂钩）。在该脚本中，模式库设计者需要使用新增的会话变量 ratl_GetLegalAction 来判断脚本当前被执行的原因，从而有区别的做出响应。在此例中，如果客户端为了计算哪些操作应当被隐藏而调用的脚本，则无需弹出错误消息，只需返回适当的值。如果无权限的客户调用了该脚本（既可以通过客户端，也可以通过其他脚本简介调用），则需要弹出错误提示。<\/p><h5 id=\"N100CC\">清单 1. 代码示例<\/h5><div class=\"codesection\"><pre class=\"displaycode\">   # 用户代码开始\n   # 如果赋予用户执行该操作的权限，则将$result 设置为 1\n# 否则，设置为 0\n\n$result = 0;\n   if ($session-&gt;IsUserSuperUser()) {\n       # 对于超级用户，总是令他能看到该操作，并有权执行\n       $result = 1;\n   }\n   else {\n       my $GLA = $session-&gt;GetNameValue(\"ratl_GetLegalAction\");\n       my $myName = $entity-&gt;GetDisplayName();\nmy $user  = $session-&gt;GetUserLoginName();\n       my $owner = $entity-&gt;GetFieldStringValue(\"Owner\");\n\t \n# 如果$GLA 变量的值等于该记录的显示名称$myName\n# 那么当前 hook 被执行是为了计算该操作是否需要对该用户隐藏。\nif ($GLA eq $myName) {\n\t# If user is not the owner of this record, hide the action\n\tif ($user ne $owner) {\n               $result = 0;\n           }else{\n               $result = 1;\n\t}\n       }\n# 如果$GLA 变量的值不等于该记录的显示名称$myName\n# 那么当前 hook 被执行是为了计算该操作是否有权限被该用户执行。\n       else {\n\tdie \"Only the super user can perform this action.\";\n       }\n    }\nreturn $result;\n# End User Code<\/pre><\/div><p>经过这样的配置，就实现了该示例的效果。不同的用户对于同一条记录，享有不同的权限。<\/p><ol type=\"1\"><li>管理员可查看所有操作也可以执行 Assign 操作<\/li><\/ol><h5 id=\"N100D9\">图 4 .管理员可查看 Assign 操作<\/h5><img alt=\"Figure xxx. Requires a heading\" src=\"/sunshine_new/images/939701992/image009.jpg\" width=\"582\" /><h5 id=\"N100E5\">图 5.管理员可执行 Assign 操作<\/h5><img alt=\"管理员可执行 Assign 操作\" src=\"/sunshine_new/images/939701992/image011.jpg\" width=\"582\" /><ol type=\"1\"><li>记录的所有者（owner）有权查看 Assign 操作，但无权执行<\/li><\/ol><h5 id=\"N100F6\">图 6.记录所有者可查看 Assign 操作<\/h5><img alt=\"记录所有者可查看 Assign 操作\" src=\"/sunshine_new/images/939701992/image013.jpg\" width=\"582\" /><p>如果执行，会见到脚本中定制的错误消息。<\/p><h5 id=\"N10104\">图 7.记录所有者无权执行 Assign 操作<\/h5><img alt=\"记录所有者无权执行 Assign 操作\" src=\"/sunshine_new/images/939701992/image015.jpg\" width=\"581\" /><ol type=\"1\"><li>其他用户无权见到 Assign 操作，则该操作对他们隐藏。<\/li><\/ol><h5 id=\"N10115\">图 8.Assign 操作对其他用户隐藏<\/h5><img alt=\"Assign 操作对其他用户隐藏\" src=\"/sunshine_new/images/939701992/image017.jpg\" width=\"582\" /><h2 id=\"1.总结 |outline\">总结<\/h2><p>本文详细介绍了新版 (ClearQuest V8.0.1) 隐藏无权限操作 (Hide action) 功能的使用方式、应用场景。并且通过一个典型的定制案例，让用户直观的体验到该功能为客户带来的强大定制能力。<\/p><CMA ID: 973143><Site ID: 10><XSLT stylesheet used to transform this file: dw-document-html-7.0.xsl>\r\n\r\n\r\n<\/div>\r\n<\/div>\r\n","createTime":"2014-06-05 00:00:00","deployTime":"2014-06-05 00:00:00","id":0,"intro":"软件变更管理产品 ClearQuest 允许管理员对不同角色、分组的用户定制其有权执行的操作。当终端用户试图执行其无权执行的操作时，系统会报错。如果用户量大，模式库复杂，终端用户会经常误选没有权限的操作。自 8.0.1 版本后，产品增加了新功能，允许模式库设计者将此类操作对特定用户隐藏，避免错误消息的干扰。","keyword":"","recommend":false,"source":"http://www.ibm.com/developerworks/cn/rational/1406_lianglu_cq8new2/index.html","title":"Rational ClearQuest V8.0.1 新功能: 隐藏用户无权限的操作","typeId":0,"updateTime":"2014-06-05 00:00:00"}
{"author":"","clickNumber":0,"content":"\r\n<div class=\"ibm-columns\">\r\n<div class=\"ibm-col-1-1\">\r\n\r\n<h2 id=\"major1\">简介<\/h2><p>企业应用程序往往需要访问不同的信息系统，例如 CICS, IMS TM, SAP 等系统以使用其现有的业务逻辑和数据。而应用程序服务器例如 WebSphere Application Server 的资源适配器功能 可以同时提供对异构信息系统的连接，用户通过安装针对不同信息系统的资源适配器，并配置相应的属性，可以建立与 EIS 的连接。WebSphere Application Server 支持 JCA V1.0 和 V1.5 规范，本文将以 IMS TM Resource Adapter 为例讲解其在 WebSphere Application Server 中的配置、与 IMS 系统连接并进行 outbound/inbound 消息处理的过程，最后简要介绍 Resource Adapter 的升级过程。<\/p><h2 id=\"major2\">JCA 架构介绍<\/h2><p>JCA(J2EE Connector Architecture, 也叫 J2C) 是 J2EE 的连接器架构，它提供了 J2EE 服务器和异构的企业信息系统连接的标准 Java 解决方案，使得 J2EE 应用程序服务器能够集成任何符合 JCA 标准的 EIS 的资源适配器，同时，EIS 的资源适配器也可以部署到任何支持 JCA 架构的 J2EE 服务器上。例如，WebSphere Application Server 可以支持 CICS Adapter, IMS TM Adapter，SAP Adapter 等，而 IMS TM Adapter 可以安装在 WebSphere Application Server，WAS CE, JBoss 等服务器上。根据 JCA 规范，J2EE 服务器需要提供一个 JCA 环境，而 EIS 要提供一个资源适配器，将资源适配器部署到 J2EE 应用服务器上，J2EE 应用程序就可以通过资源适配器访问 EIS, 这与通过 JDBC 访问关系数据库是类似的。<\/p><p>资源适配器是特定于某个 EIS 的，安装在应用程序服务器中，它和应用程序服务器合作以实现交易、安全、连接池等机制。一个资源适配器可以提供应用程序和 EIS 之间的多种连接方式。<\/p><ul class=\"ibm-bullet-list\"><li>Outbound 连接：资源适配器允许应用程序连接至 EIS 系统并进行后续工作，所有的通信都是由应用程序发起。在这种情况下，资源适配器是一个运行在应用程序的上下文中的被动的程序库。<\/li><li>Inbound 连接：资源适配器允许 EIS 访问应用程序组件，所有的通信是由 EIS 发起的。<\/li><li>双向连接：资源适配器同时支持 Outbound 和 Inbound 连接。<\/li><\/ul><p>为了实现应用服务器和 EIS 之间的可插拔性（pluggability），JCA 架构定义了一套标准的系统级别的契约（System-Level Contacts）。EIS 端的系统契约通过资源适配器来实现。<\/p><p>JCA 架构系统契约包括：<\/p><ul class=\"ibm-bullet-list\"><li>连接管理：使一个应用服务器能够提供管理特定于某个 EIS 的连接缓冲池，支持大量客户端对 EIS 的并发访问。<\/li><li>事务管理：使得应用程序服务器可以使用事务管理器去管理需要访问多个资源服务器（Resource Manager）的交易（XA 交易），也可以管理只访问某一个资源服务器的交易（local 交易）。<\/li><li>安全管理：提供了对 EIS 的安全访问。支持一个安全的应用程序环境，提供了对 EIS 中重要信息的保护。<\/li><\/ul><p>JCA 架构还定义了 Client API, Client API 可以被定义为特定于某种 EIS 的 API; 或者定义为 CCI(Common Client Interface), CCI 定义了访问 EIS 的通用的客户端编程接口，这是 JCA 架构所推荐的方式。<\/p><p>总之，JCA 架构提供了多种应用程序服务器和不同 EIS 之间的双向通信的 Java 解决方案。使用 JCA 架构，EIS 供应商不需要为不同的应用程序服务器定制不同的资源适配器。同样，应用程序服务器供应商也不必为了支持一个新的 EIS 去修改代码。<\/p><h2 id=\"major3\">在 WebSphere Application Server 中部署资源适配器<\/h2><p>WebSphere Application Server 作为标准的企业应用服务器，支持 JCA V1.0 和 JCA V1.5 架构，允许用户安装针对不同 EIS 系统的资源适配器，以实现与 EIS 的互连，本节将以 IMS TM Resource Adapter 为例讲解其在 WebSphere Application Server 中的安装与配置。IMS TM Resource Adapter 是基于 JCA 架构的资源适配器，它用于 J2EE 的应用程序访问 IMS 的 Transaction Manager(IMS TM)，如前所述，IMS TM Resource Adapter 可以被部署在 WebSphere Application Server, WAS CE, JBoss 等应用服务器中。全球有众多大型企业使用 IMS TM Resource Adapter 来访问 IMS 系统，大多数企业选择把 IMS TM Resource Adapter 安装在 WebSphere Application Server 上，如图 1 所示。<\/p><h5 id=\"img001\">图 1. IMS TM Resource Adapter 部署于 WebSphere Application Server<\/h5><img alt=\"图 1. IMS TM Resource Adapter 部署于 WebSphere Application Server\" src=\"/sunshine_new/images/负1026459461/img001.png\" width=\"572\" /><h3 id=\"major4\">准备工作<\/h3><ol type=\"1\"><li>把 IMS TM Resource Adapter RAR 文件保存到可以被 WebSphere Application Server 访问的文件系统。<\/li><li>启动 WebSphere Application Server 并登陆到管理控制台（Administration Console）。<\/li><\/ol><h3 id=\"major5\">安装 IMS TM Resource Adapter<\/h3><ol><li>从管理控制台左侧的导航栏中找到并点击“Resources”，然后单击“Resource Adapters”选项，在控制台的右侧出现“Resource Adapters”面板，如图 2 所示。\n\t\t\t<h5 id=\"img002\">图 2. 安装 Resource Adapter<\/h5><img alt=\"图 2. 安装 Resource Adapter\" src=\"/sunshine_new/images/负1026459461/img002.png\" width=\"582\" /><\/li><li>在右侧“Resource Adapters”面板中点击“Install RAR”，进入“Install RAR File”页面，然后选择 Resource Adapter 的保存位置，可选择“本地文件系统”或者“远程文件系统”。如果选择本地文件系统，点击“Browse”选择 RAR 文件，例如： D:\\work\\ico1132\\IBM\\IMS\\ICO11\\V1132\\JCA15\\ims1132.rar。<\/li><li>单击“Next”，进入“Configuration”页面，可以为 Resource Adapter 命名，或者使用默认的“IMS TM Resource Adapter”，然后单击“OK”。<\/li><li>保存刚才的配置，点击“Save”。图 3 为安装好的 Resource Adapter。\n\t\t\t<h5 id=\"img003\">图 3. Resource Adapter 部署成功<\/h5><img alt=\"图 3. Resource Adapter 部署成功\" src=\"/sunshine_new/images/负1026459461/img003.png\" width=\"563\" /><\/li><\/ol><h2 id=\"major6\">在 WebSphere Application Server 中部署应用程序并进行 Outbound 通信<\/h2><p>在 Outbound 通信中，EIS 作为服务提供者（Service Provider），J2EE 应用程序可以访问 EIS 的资源，调用 transaction，然后访问数据库。本例中将采用一个 TelephoneBook 应用程序，该程序访问 IMS 的 PhoneBook transaction，输入要查询的人物的名字，输出该人物的电话号码等信息。在部署应用程序之前，应保证 EIS 端的 IMS 系统，IMS Connect 组件，以及 IMS MPP(Message Processing Program) 正常启动。<\/p><h3 id=\"major7\">创建连接工厂（Connection Factory）<\/h3><p>在应用程序与 EIS 系统进行 Outbound 通信之前，首先要创建 Connection Factory，Connection Factory 用于一个或多个程序与 EIS 系统创建连接，步骤如下： <\/p><ol><li>单击部署好的资源适配器的名字，例如“IMS TM Resource Adapter”，进入“Configuration”页面。<\/li><li>在“Additional Properties”中，选择并点击“J2C connection factories”。<\/li><li>单击“New”，进入连接工厂配置页面，在此页面中输入 Connection Factory 的名称，和 JNDI 的名称，并保存配置。例如：\n\t\t\n\t\t\t<ol class=\"ibm-alpha-list\" type=\"a\"><li>Connection Factory name：ims_cf <\/li><li>JNDI name： eis/IMS1<\/li><\/ol><p>图 4 所示为新创建的 Connection Factory。<\/p><h5 id=\"img004\">图 4. J2C Connection Factory<\/h5><img alt=\"图 4. J2C Connection Factory\" src=\"/sunshine_new/images/负1026459461/img004.png\" width=\"552\" /><\/li><li>单击 Connection Factory 名称，例如“ims_cf”，进入配置页面，在右侧的“Additional Properties”中选择并进入“Custom Properties”，在此页面中输入连接 EIS 所需要的信息并保存。例如：\n\t\t\t<ol class=\"ibm-alpha-list\" type=\"a\"><li>DataStoreName: IMS1 (IMS datastore 的名称)<\/li><li>HostName: ec03237.vmec.svl.ibm.com (TCP/IP 主机名称)<\/li><li>PortNumber: 9999 (TCP/IP 端口号)<\/li><\/ol><\/li><\/ol><p>到此为止，已经完成 Connection Factory 的配置。<\/p><h3 id=\"major8\">部署企业应用程序并进行 Outbound 通信<\/h3><p>部署企业应用程序步骤如下：<\/p><ol><li>在 WebSphere Application Server 管理控制台页面中，找到并点击“Applications”，选择“WebSphere enterprise applications”<\/li><li>单击“Install”按钮，然后选择要安装的应用程序，例如 CCIPBook.ear.<\/li><li>选择“Fast Path”安装，Fast Path 在安装的过程中只会提示需要注意的选项（Option）。<\/li><li>单击下一步，进入安装选项页面。在 Step 1 中，指定或者修改安装选项；在 Step 2 中，选择安装的模块所对应的应用程序服务器；在“Summary”页面中，检查配置信息是否正确。<\/li><li>单击“Finish”按钮，会看到安装的 log，包括“Application xxx installed successfully.”信息提示，点击“Save”保存配置。<\/li><\/ol><h3 id=\"major9\">配置 Resource Reference 信息<\/h3><ol><li>在“Enterprise Application”页面，找到并点击部署好的应用程序，例如“CCIPBookAEAR”，进入配置页面。<\/li><li>在配置页面的下端，找到 References -&gt; Resource References, 如果 5 所示。\n\t\t\t<h5 id=\"img005\">图 5. Resource Reference<\/h5><img alt=\"图 5. Resource Reference\" src=\"/sunshine_new/images/负1026459461/img005.png\" width=\"235\" /><\/li><li>点击 Resource Reference，填入资源引用的 JNDI 名称。应用程序中定义的资源引用必须对应一个特定的资源。如图 6 所示。\n\t\t\t<h5 id=\"img006\">图 6. 配置 Resource Reference<\/h5><img alt=\"图 6. 配置 Resource Reference\" src=\"/sunshine_new/images/负1026459461/img006.png\" width=\"581\" /><p>其中：ims_cf 是之前定义的 Connection Factory 名称<\/p><p>eis/IMS1 是之前指定的 JNDI 名称。<\/p><\/li><li>单击“OK”并保存配置，回到“Enterprise Application”页面。选择配置好的应用程序，点击“Start”按钮，启动应用程序。<\/li><\/ol><h3 id=\"major10\">运行应用程序与 IMS 系统 Outbound 通信：<\/h3><p>在 Web 浏览器中，输入 URL: http://localhost:9080/CCIPBookAWeb/CCIBPAAccessBeanInputForm.html<\/p><p>进入“CCIPBookAWeb Input form”页面，填好所需要查询的人的名字，例如“LAST1”，点击“Submit”提交，如图 7 所示。<\/p><h5 id=\"img007\">图 7. CCIPBookAWeb Input form<\/h5><img alt=\"图 7. CCIPBookAWeb Input form\" src=\"/sunshine_new/images/负1026459461/img007.png\" width=\"456\" /><p>点击提交后，得到的查询结果如图 8 所示。<\/p><h5 id=\"img008\">图 8. 返回结果 CCIPBookAWeb Results page<\/h5><img alt=\"图 8. 返回结果 CCIPBookAWeb Results page\" src=\"/sunshine_new/images/负1026459461/img008.png\" width=\"470\" /><p>示例中应用程序 CCIPBook 通过 IMS TM Reource Adapter 与主机端 EIS 系统 IMS 建立连接并进行 Outbound 通信，调用 IMS 系统的 PhoneBook transaction，用户输入要查询的人物的名字，可以得到他的电话号码等信息，在此查询过程中，访问了主机端的 IMS 数据库。<\/p><h2 id=\"major11\">在 WebSphere Application Server 中部署应用程序并进行 Inbound 通信<\/h2><p>Inbound 通信，是由 EIS 向 J2EE 应用程序发起的通信，EIS 扮演了“消费者”的角色（Service Consumer），它可以从应用程序比如 Web Service，EJB 组件中获取所需的信息。图 9 所示为 Inbound 通信模型。<\/p><h5 id=\"img009\">图 9. Inbound 通信模型<\/h5><img alt=\"图 9. Inbound 通信模型\" src=\"/sunshine_new/images/负1026459461/img009.png\" width=\"572\" /><h3 id=\"major12\">MDB<\/h3><p>在 JCA 1.5 Resource Adapter 中，MDB(Message Driven Bean) 可以被配置为监听器（Listener）来监听来自 EIS 端的 Inbound 消息。MDB 是可以被消息激活的 EJB 组件，在 JCA 1.5 中，MDBs 被称为 Message Endpoints。MDB 的好处是它把消息处理和商业逻辑清晰地隔离开，并且可以复用商业逻辑。<\/p><h3 id=\"major13\">创建激活规范（Activation Specification）<\/h3><p>在 Inbound 通信中，要定义 Activation Specification 用于应用程序和 EIS 通信。在 WebSphere Application Server 中，定义 Activation Specification 步骤如下：<\/p><ol><li>在 Resource Adapters 页面，选择部署好的 Resource Adapter，例如“IMS TM Resource Adapter”，点击 Resource Adapter 名称，进入配置页面。<\/li><li>在右侧的“Additional Properties”部分，选择“J2C activation specifications”。<\/li><li>新建一个 J2C activation specification, 在配置页面中，输入要创建的 activation specification 的名称和 JNDI 名称并保存配置。例如：\n\t\t\t<ol class=\"ibm-alpha-list\" type=\"a\"><li>Activation Spec Name：callout<\/li><li>JNDI Name： eis/callout<\/li><\/ol><\/li><li>在 Resource adapters &gt; IMS TM Resource Adapter &gt; J2C activation specifications 页面中，选择要刚创建好的 Activation Spec，点击进入配置页面，在右侧的“Additional Properties”中，选择“J2C activation specification custom properties”，进入定制属性页面。<\/li><li>在定制属性页面中，指定 EIS 所需要的属性。例如：\n\t\t\t<ol class=\"ibm-alpha-list\" type=\"a\"><li>dataStoreName: IMS1<\/li><li>hostName: ec03237.vmec.svl.ibm.com<\/li><li>portNumber: 9999<\/li><li>ueueNames: ICOPIPE1 (用于保存 Inbound 请求消息的队列)<\/li><\/ol><\/li><\/ol><p>保存属性设置后，Activation Specification 配置完成。<\/p><h3 id=\"major14\">部署应用程序并进行 Inbound 通信<\/h3><p>本示例中将采用 MDB(Message Driven Bean) IMSICOCalloutIVP.ear 与 IMS 系统进行 Inbound 通信，该 MDB 监听来自 IMS 系统的 Inbound Request 消息，并作出相应的 Response。本示例较为简单，在 IMS 端由 IMS 程序发起 Inbound Request，并且发送消息“Hello From IMS”，MDB 在接收到消息后返回消息“HELLO FROM WEBSPHERE MDB”。在实际应用中，EIS 可以向 J2EE 应用程序发起 Inbound 请求，请求所需要的服务和数据。本示例需要 EIS 端的 IMS 系统，IMS Connect/OTMA 组件做好 Inbound 功能配置并正常启动。<\/p><p>应用程序安装过程与上一节相同，本节中不再重复。应用程序安装完成后，需要为其指定“Message Driven Bean listener bindings”，步骤如下：<\/p><ol><li>在“Enterprise Applications”页面，选择安装好的应用程序，例如“IMSICOCalloutIVPMDBEAR”，进入配置页面。<\/li><li>在配置页面中的“Enterprise Java Bean Properties”部分，找到“Message Driven Bean listener bindings”。<\/li><li>为 MDB 绑定 ActivationSepc JNDI，在“Target Resource JNDI Name”中，填入所创建的 ActivationSpec JNDI 的名称 eis/callout, 并保存配置。如图 10 所示。\n\t\t\t<h5 id=\"img010\">图 10. 为 MDB 绑定 ActivationSpec JNDI<\/h5><img alt=\"图 10. 为 MDB 绑定 ActivationSpec JNDI\" src=\"/sunshine_new/images/负1026459461/img010.png\" width=\"581\" /><\/li><li>回到“Enterprise Applications”页面，启动 MDB。<\/li><\/ol><p>完成以上步骤，就可以运行 IMS 端的程序发起 Inbound Request。在 WebSphere Application Server SystemOut.log 文件中，可以看到如下输出：<\/p><div class=\"codesection\"><pre class=\"displaycode\">[5/9/14 14:55:57:762 CST] 00000032 SystemOut O Synchronous callout request from IMS:\nHello From IMS \n[5/9/14 14:55:57:762 CST] 00000032 SystemOut O Synchronous callout response from WAS MDB:\nHELLO FROM WEBSPHERE MDB<\/pre><\/div><p>消息“HELLO FROM WEBSPHERE MDB”证实了 MDB IMSICOCalloutIVP.ear 接收到了 Inbound Request，并做出了回应。<\/p><h2 id=\"major15\">Resource Adapter 的升级<\/h2><p>在实际应用中，伴随着 EIS 的升级，企业用户通常需要同步升级 EIS 所对应的 Resource Adapter，而企业用户常常定义众多的（几十个甚至几百个）Connection Factory/Activation Specification，以对应不同的应用，在升级过程中，用户不想破坏或删掉这些已有的 Connection Factory/Activation Specification 去重新定义。因此，怎样方便地升级 Resource Adapter，是企业用户比较关注的问题。在 WebSphere Application Server V7 以及更新的版本中，可以使用“Update RAR”功能来升级 Resource Adapter，在升级的过程中，不会删掉已有的 Connection 的定义。如图 11 所示，在 WebSphere Application Server Admin Console 的 Resource adapter 界面，找到“Update RAR”，选择要升级的 Resource Adapter，点击“Update RAR”进行升级，在升级的过程中，可以定义新版本的 Resource Adapter 所提供的新属性，升级成功后，将会看到“Update was successful for IMS TM Resource Adapter at Node=…”信息提示。<\/p><h5 id=\"img011\">图 11. Resource Adapter 升级<\/h5><img alt=\"图 11. Resource Adapter 升级\" src=\"/sunshine_new/images/负1026459461/img011.png\" width=\"472\" /><h2 id=\"major16\">结束语<\/h2><p>JCA 提供了整合异构企业信息系统的一套标准的体系结构，使用它的企业信息系统供应商不再需要为每个应用服务器定制它们的产品。遵守这个规范的应用程序服务器供应商在想增加新的企业信息系统连接的时候也不需要添加自定义代码。作为标准的企业级应用服务器，WebSphere Application Server 支持 JCA 1.0 和 JCA 1.5 规范，它所提供的资源适配器功能可以让企业用户方便地安装、升级对应于不同企业信息系统的 Resource Adapter，以实现与 EIS 的互连。本文以 IMS TM Resource Adapter 为例，详细描述了 Resource Adapter 的部署、配置，以及企业应用程序通过 Resource Adapter 与 EIS 互连，并进行 Inbound/Outbound 通信的过程，最后介绍了 Resource Adapter 的版本升级，为面临同样任务的系统管理员、开发者和产品支持人员提供帮助和参考。<\/p><CMA ID: 973458><Site ID: 10><XSLT stylesheet used to transform this file: dw-document-html-7.0.xsl>\r\n\r\n\r\n<\/div>\r\n<\/div>\r\n","createTime":"2014-06-05 00:00:00","deployTime":"2014-06-05 00:00:00","id":0,"intro":"WebSphere Application Server 的资源适配器功能（Resource Adapters）可以让用户通过安装针对不同信息系统的资源适配器，并配置相应的连接属性，与企业信息系统（EIS）建立连接并访问相应的资源。本文将首先介绍 JCA 架构，然后以符合 JCA V1.5 规范的资源适配器 IMS TM Resource Adapter 为例讲解其在 WebSphere Application Server 中的安装、配置，以及与 IMS 系统连接并进行 Inbound/Outbound 消息处理的过程，最后将介绍 Resource Adapter 的升级，为应用程序开发人员和应用服务器管理员提供参考和示例。","keyword":"","recommend":false,"source":"http://www.ibm.com/developerworks/cn/websphere/library/techarticles/1406_wangj_wasadapter/index.html","title":"使用 WebSphere Application Server 资源适配器功能访问异构信息系统","typeId":0,"updateTime":"2014-06-05 00:00:00"}
{"author":"","clickNumber":0,"content":"\r\n<div class=\"ibm-columns\">\r\n<div class=\"ibm-col-1-1\">\r\n\r\n<h2 id=\"intro\">简介<\/h2><p>IBM Rational Application Developer for WebSphere Software Version 9.0.1 添加了对 <strong>WebSphere Optimized Local Adapters (WOLA)<\/strong> 的新支持能力。与 Rational Application Developer 中现有的 WebSphere Adapters 功能和工具相结合，这项新功能提供了一种简单方式来将在批处理地址空间、CICS 环境和 IMS 环境中运行的 z/OS 系统上的组件，与 WebSphere Adapters 如今支持的组件（比如 SAP、Oracle、PeopleSoft、Seibel 等）相集成。 <\/p><div class=\"dw-sidebar ibm-inset\"><p>有关优化的本地适配器的更多信息，请参阅 <a href=\"http://pic.dhe.ibm.com/infocenter/wasinfo/v8r5/topic/com.ibm.websphere.zseries.doc/ae/cdat_ola.html\">WebSphere Application Server 信息中心<\/a> 和 <a href=\"http://www.ibm.com/developerworks/websphere/techjournal/1102_mulvey/1102_mulvey.html\" onmouseover=\"linkQueryAppend(this)\">这篇 developerWorks 文章<\/a>。<\/p><\/div><p>本文逐步介绍一个端到端的场景，在该场景中，会更新一个在 z/OS 上的 CICS 上运行的 COBOL 应用程序，以调用一个 SAP R/3 业务对象来获取客户数据。该 COBOL CICS 程序可以是一个简单的 PL/I IMS 事务，甚至可以是一个批处理汇编应用程序，而且目标应用程序可以是一个在 Seibel、Oracle 或其他环境中运行的应用程序。使用 Rational Application Developer 工具生成完成此任务所需的几乎所有内容。从程序设计角度讲，您只需要几行实现代码来将请求数据从一端移动到另一端，然后反方向移动响应。 下面给出了在从 CICS 向 WebSphere Application Server，再向 SAP R/3 移动的客户场景中实现此目的的完整步骤。本文的目的是提供一个很好的用例和模式来演示此功能。<\/p><p>这里提供的信息，与另一篇 <a href=\"http://www.ibm.com/developerworks/websphere/techjournal/1310_korukonda/1310_korukonda.html\" onmouseover=\"linkQueryAppend(this)\">有关从 WebSphere Application Server for z/OS 中的应用程序访问 SAP 系统的最新文章<\/a> 相结合，提高生产力和降低编写一些复合应用程序所涉及的复杂性，这些复合应用程序需要位于多个不同位置的业务逻辑部分。<\/p><h2 id=\"sec1\">端到端场景<\/h2><p>假设希望集成两个应用程序：一个是作为一组 CICS COBOL 程序运行的客户数据应用程序，另一个是在 SAP R/3 服务器上运行的客户处理应用程序。您断定客户编号在两端都可使用，这是将应用程序关联起来的关键。在 CICS 端，您拥有客户编号，但您需要剩余的客户数据（名称、地址等），这些数据由 SAP 服务器上的应用程序维护。您可以使用每一端上的现有工件，结合使用 WebSphere Application Server for z/OS 和 WOLA 与 WebSphere Adapters 支持和 SAP 资源适配器来实现此目的。Rational Application Developer V9.0.1 是将所有部分联系起来的组件。 <\/p><h2 id=\"sec2\">过程<\/h2><p>下面的步骤解释了如何实现此目的。此过程假设使用了 Rational Application Developer V9.0.1 或更高版本，CICS 环境处于 CICS TS 3.1 或更高级别（提供 WOLA 支持的最低级别），而且 WebSphere Application Server for z/OS 处于 V7.0.0.4 或更高级别。WOLA 必须在 WebSphere Application Server 和 CICS 中启用并可供使用。图 1 显示了此场景中涉及的主要组件。<\/p><h5 id=\"fig1\">图 1. 端到端场景<\/h5><img alt=\"端到端场景\" src=\"/sunshine_new/images/1740972288/images/image01.jpg\" width=\"800\" /><p>完成此端到端过程的步骤在 CICS 环境可用且 WebSphere Application Server for z/OS 和 WOLA 安装在同一个 z/OS 系统上时即可开始。下面概述了涉及的主要步骤，以下各节将详细介绍这些步骤： <\/p><ol><li><a href=\"#sec3\">生成启用了 WOLA 的无状态会话 EJB<\/a>，将用作来自 CICS COBOL 程序的调用的目标。   <\/li><li><a href=\"#sec4\">创建调用 CICS COBOL 程序<\/a>，将使用 WOLA Register、Invoke 和 Unregister API 调用目标 EJB 来连接 SAP 服务器。<\/li><li><a href=\"#sec5\">创建业务对象调用代码<\/a>，使用 Rational Application Developer 和 WebSphere Adapters 支持来找到目标 SAP 服务器上的业务对象，生成执行 BAPI 调用的代码。<\/li><li><a href=\"#sec6\">在 WOLA 目标 EJB 中添加实现代码<\/a>，从 CICS COBOL 程序复制客户编号，然后执行 BAPI_CUSTOMER_GETDETAIL 调用来获取客户信息。得益于该工具，只需很少的代码即可完成此任务。<\/li><li><a href=\"#sec7\">生成通过 WOLA 资源适配器调用 CICS COBOL 程序的 WOLA 代码<\/a>。Rational Application Developer 用于生成此代码和生成 JavaServer&#8482; Pages 网页的代码，以执行出站嗲用，将客户编号传递到 CICS 程序。<\/li><li><a href=\"#sec8\">运行完整的端到端场景<\/a>，展示如何接受客户编号作为 JSP 网页上的输入，执行对 CICS COBOL 程序的调用，这会获取客户编号并使用它调用 SAPCustomerGet EJB。EJB 然后使用提供的编号调用 SAP 服务器。返回的客户细节传递回 CICS，然后返回到 WebSphere Application Server 并显示在网页上。<\/li><\/ol><p>这些步骤相结合，提供了生成一个完整的端到端流的操作说明，从 WebSphere Application Server 中开始，然后传递到 CICS，返回到 WebSphere Application Server 和 SAP，然后一直返回到初始网页，使用 Rational Application Developer 生成一些代码。  <\/p><h2 id=\"sec3\">1.生成启用了 WOLA 的无状态会话 EJB<\/h2><p>在此步骤中，您将使用 Rational Application Developer 发起一个请求来创建 WOLA J2C bean。Rational Application Developer 生成的 Java&#8482; 源代码包含一个启用了 WOLA 的 V3.1 EJB，它声明一个 <strong>@RemoteHome<\/strong><strong>com.ibm.websphere.ola.ExecuteHome.class<\/strong>（这从 ola_apis.jar 文件解析而来，Rational Application Developer 工具将确保该文件位于构建路径上）：<\/p><p><code>@RemoteHome(com.ibm.websphere.ola.ExecuteHome.class)<\/code><\/p><p>EJB 将包含一个目标方法：execute():<\/p><p><code>public byte[] execute(byte[] theBytes) {<br />\n\t\texecute();<br />\n\t\treturn (null);<br />\n\t\t}<\/code><\/p><p>这个 <strong>execute()<\/strong> 方法接受一个字节数组并返回一个字节数组。在下面将会看到，Rational Application Developer 生成的方法 execute() 填充一个 Record 对象，该对象映射 COBOL 程序的 copy book，然后委托给另一个方法（也称为 execute），后者接受并返回一个表示请求和响应数据的 Record 对象。<\/p><p>您将实现代码放入第二个 <strong>execute()<\/strong> 方法中，这些代码访问 SAP BAPI 业务对象来获取客户信息。此实现使用 Rational Application Developer 生成的帮助器类读取从 COBOL 程序传来的客户编号键，将它传递给 SAP 来获取客户数据 <strong>BAPI_CUSTOMER_GETDETAIL<\/strong>。实际调用 SAP 服务器并获取数据的代码也从 Rational Application Developer 生成。<\/p><p>假设您有一个名为 <strong>ZCUSTGET<\/strong> 的 CICS COBOL 程序，它从某个位置获取一个客户编号，现在需要确定此客户的联系信息（地址、电话等）。但是，此信息不可在本地使用，而由另一个运行 SAP R/3 服务器的（由您公司拥有或维护的）系统为此用途而实时维护。ZCUSTGET 使用的 COBOL copy book 类似于清单 1。<\/p><h5 id=\"listing1\">清单 1. zcustcpy.cpy<\/h5><div class=\"codesection\"><pre class=\"displaycode\">      *                                                    \n      * zcustcpy.cpy copy book                    \n      *                                                    \n       01  DFHCOMMAREA.                                    \n           02  CustomerNumber PIC X(10).                   \n           02  FirstName  PIC A(15).                       \n           02  LastName   PIC A(25).                       \n           02  Street     PIC X(20).                       \n           02  City       PIC A(20).                       \n           02  State      PIC A(10).                       \n           02  Country    PIC A(10).                       \n           02  Phone      PIC X(15).                       \n           02  PostalCode PIC X(7).<\/pre><\/div><p>在这一步中，您将创建一个启用了 WOLA 的无状态会话 bean，它将是一个来自 CICS 程序的 Invoke WOLA API 调用的目标。此外，包含此 copy book 的文件将导入 Rational Application Developer 中，放入一个包含访问它的帮助器 getter/setter 方法的类中。为此：<\/p><ol><li>将文件 <strong>zcustcpy.cpy<\/strong>（清单 1）复制到您的 Rational Application Developer 工作站，或者将它的内容粘贴到一个文件中，使用 Rational Application Developer 中的 J2C WOLA bean 创建工具和 CICS/IMS Java Data Binding 工具生成帮助器类，提供对传递的数据的访问并复制回响应。请注意，COBOL 会区分列；清单 1 中显示的星号应从第 7 列开始，它是 COBOL 的注释列。<\/li><li>打开一个新的 Rational Application Developer 工作区（图 2）。\n            <h5 id=\"fig2\">图 2. Rational Application Developer 工作区<\/h5><img alt=\"Rational Application Developer 工作区\" src=\"/sunshine_new/images/1740972288/images/image02.jpg\" width=\"599\" /><\/li><li>选择 <strong>File &gt; New &gt; Other &gt; J2C &gt; J2C Bean<\/strong>（图 3），创建一个新 J2C bean。\n            <h5 id=\"fig3\">图 3. New 向导<\/h5><img alt=\"New 向导\" src=\"/sunshine_new/images/1740972288/images/image03.jpg\" width=\"409\" /><\/li><li>选择 <strong>Next<\/strong> then <strong>WOLA<\/strong>（图 4）。\n            <h5 id=\"fig4\">图 4. Resource Adapter Selection<\/h5><img alt=\"Resource Adapter Selection\" src=\"/sunshine_new/images/1740972288/images/image04.jpg\" width=\"409\" /><\/li><li>选择 <strong>Next<\/strong>（图 5），将设置一个新的 Connector 项目。\n            <h5 id=\"fig5\">图 5. Connector Import<\/h5><img alt=\"Connector Import\" src=\"/sunshine_new/images/1740972288/images/image05.jpg\" width=\"464\" /><\/li><li>选择 <strong>Inbound<\/strong>，然后选择 <strong>Next<\/strong>（图 6）。\n            <h5 id=\"fig6\">图 6. Adapter Style<\/h5><img alt=\"Adapter Style\" src=\"/sunshine_new/images/1740972288/images/image06.jpg\" width=\"343\" /><\/li><li>为新的无状态会话 bean 输入一个 JNDI 名称；对于本测试，输入 <code>SAPCustomerGetDetail<\/code>（图 7）。\n            <h5 id=\"fig7\">图 7. Connection Properties<\/h5><img alt=\"Connection Properties\" src=\"/sunshine_new/images/1740972288/images/image07.jpg\" width=\"493\" /><\/li><li>在 Java Bean Output Properties 对话框中，选择 <strong>New<\/strong>（图 8）。\n            <h5 id=\"fig8\">图 8. J2C Java Bean Output Properties<\/h5><img alt=\"J2C Java Bean Output Properties\" src=\"/sunshine_new/images/1740972288/images/image08.jpg\" width=\"354\" /><\/li><li>在 EJB Project 对话框上，输入一个新 Project 名称；对于本测试，输入 <code>SAPWOLATestProject<\/code> 并单击 <strong>Next<\/strong>（图 9）。\n            <h5 id=\"fig9\">图 9. EJB Project<\/h5><img alt=\"EJB Project\" src=\"/sunshine_new/images/1740972288/images/image09.jpg\" width=\"419\" /><\/li><li>接受默认文件夹 <strong>ejbModule<\/strong>（图 10）。\n            <h5 id=\"fig10\">图 10. New EJB Project<\/h5><img alt=\"New EJB Project\" src=\"/sunshine_new/images/1740972288/images/image10.jpg\" width=\"355\" /><\/li><li>单击 <strong>Finish<\/strong>（图 11）。\n            <h5 id=\"fig11\">图 11. EJB Module<\/h5><img alt=\"EJB Module\" src=\"/sunshine_new/images/1740972288/images/image11.jpg\" width=\"413\" /><\/li><li>您将看到在工作区左侧显示了新项目文件。Java Bean Output Properties 对话框显示后（图 12），单击 Package name 上的 <strong>New<\/strong>。为新的 bean 类提供一个包名称 <code>com.ibm.rad.ola.test<\/code> 和一个无状态会话 bean 名称 <code>SAPCustomerGet<\/code>。\n            <h5 id=\"fig12\">图 12. J2C Java Bean Output Properties<\/h5><img alt=\"J2C Java Bean Output Properties\" src=\"/sunshine_new/images/1740972288/images/image12.jpg\" width=\"457\" /><\/li><li>单击 <code>Next<\/code> 打开 Add Java Method 对话框。单击 <strong>Use the input type for output<\/strong>，然后选择 <strong>New<\/strong>（图 13）。\n            <h5 id=\"fig13\">图 13. EJB Method<\/h5><img alt=\"EJB Method\" src=\"/sunshine_new/images/1740972288/images/image13.jpg\" width=\"453\" /><\/li><li>在 Data Import 对话框上（图 14），输入 <code>zcustcpy.cpy<\/code> 作为 COBOL 文件名称，选择 <strong>COBOL to Java<\/strong> 作为想要的映射。单击 <strong>Next<\/strong>。\n            <h5 id=\"fig14\">图 14. Data Import<\/h5><img alt=\"Data Import\" src=\"/sunshine_new/images/1740972288/images/image14.jpg\" width=\"457\" /><\/li><li>在 Importer 对话框上（图 15），选择 <strong>z/OS<\/strong> 作为 Platform 并选择 <strong>IBM-1047<\/strong> 作为 Code page。选择 <strong>DFHCOMMAREA<\/strong> 作为 Data structures 并单击 <strong>Next<\/strong>。\n            <h5 id=\"fig15\">图 15. Importer<\/h5><img alt=\"Importer\" src=\"/sunshine_new/images/1740972288/images/image15.jpg\" width=\"438\" /><\/li><li>在 Saving Properties 对话框上，将 Class Name from DFHCOMMAREA 设置为 <code>CUSTOMER<\/code> 并单击 <strong>Finish<\/strong>（图 16）。\n            <h5 id=\"fig16\">图 16. Saving Properties<\/h5><img alt=\"Saving Properties\" src=\"/sunshine_new/images/1740972288/images/image16.jpg\" width=\"387\" /><\/li><li>单击接下来的两个对话框上的 <strong>Finish<\/strong> 以完成向导。Rational Application Developer 将创建类似于图 17 所示的代码。创建了一个名为 <strong>SAPWOLATestProject<\/strong> 的新项目，以及一个称为 <strong>SAPCustomerGetDetail.java<\/strong> 的部分，该部分是放入您的实现代码的位置（替换注释 TODO - Need to implement business logic here）。它还创建了一个连接器项目 <strong>ola<\/strong>。您现在有一个新部分 <strong>CUSTOMER.java<\/strong>，它包含处理从（和到）COBOL 和 Java 对象的数据绑定转换的 Java 帮助器方法。    （Rational Application Developer 可能要求您在此处执行 <strong>Project &gt; Clean<\/strong>，然后所有引用才会正确解析。）\n            <h5 id=\"fig17\">图 17. EJB 源代码清单<\/h5><img alt=\"EJB 源代码清单\" src=\"/sunshine_new/images/1740972288/images/image17.jpg\" width=\"546\" /><\/li><\/ol><p>WOLA 目标 EJB 现在就完成了。您现在可使用 Rational Application Developer 将此代码导出到一个 EAR 文件并安装到 WebSphere Application Server 中，从您的 CICS  ZCUSTGET 程序调用这个目标 EJB。<\/p><p>安装 EAR 后，通过导航到应用程序 <strong>SAPWOLATestProjectEAR<\/strong>，确认已在 WebSphere Application Server 管理控制台中正确设置了 Remote JNDI 名称，您应在该应用程序中看到 Remote Home JNDI 名称设置为 <strong>SAPCustomerGetDetail<\/strong>（图 18）。<\/p><h5 id=\"fig18\">图 18. WebSphere Application Server 管理控制台<\/h5><img alt=\"WebSphere Application Server 管理控制台\" src=\"/sunshine_new/images/1740972288/images/image18.jpg\" width=\"800\" /><p>我们将等待将实现代码添加到 SAPCustomerGet bean 的 execute() 方法中，直到您完成了 CICS COBOL 调用程序并将它设置为调用 SAP Server 的 BAPI_CUSTOMER_GETDETAIL 业务对象。  <\/p><h2 id=\"sec4\">2.创建调用 CICS COBOL 程序<\/h2><p>现在我们的 COBOL 程序已准备好在名为 SAPCustomerGetDetail 的 JNDI 上调用 EJB 了。清单 2 显示了 ZCUSTGET CICS COBOL 程序的示例 JCL。 <\/p><h5 id=\"listing 2\">清单 2. ZCUSTGET JCL<\/h5><div class=\"codesection\"><pre class=\"displaycode\">//ZCUSTGET JOB MSGCLASS=H,MSGLEVEL=(1,1),REGION=4M,NOTIFY=&amp;SYSUID\n//*                                                              \n//*  Compile Cobol CICS test target program for OLA              \n//*                                                              \n//*  Test being invoked from WebSphere Application Server over WOLA Link Server and then  \n//*  calling back to WAS for a Customer Get Details from an      \n//*  SAP Server using BAPI-CUSTOMER-GETDETAIL.                   \n//*                                                              \n//MYPROCS JCLLIB ORDER=CICSTS42.CICS.SDFHPROC           \n//CMP  EXEC DFHYITVL,INDEX='CICSTS42.CICS',             \n//        PROGLIB='&lt;MY_LOADLIB&gt;',                 \n//        DSCTLIB='&lt;MY.INCLUDE_LIB&gt;',                        \n//        AD370HLQ='COBPFX',                            \n//        LE370HLQ='CEEPFX',                                        \n//        PARM.TRN='COBOL2 NOLINKAGE'                            \n//TRN.SYSIN  DD  *                                               \n       CBL CICS                                                  \n       Identification Division.                                  \n       Program-Id. ZCUSTGET.                                     \n       Environment Division.                                     \n       Data Division.                                            \n       Working-Storage Section.                                  \n       01 olaRegister          PIC X(8)      VALUE 'BBOA1REG'.   \n       01 olaInvoke            PIC X(8)      VALUE 'BBOA1INV'.   \n       01 olaUnRegister        PIC X(8)      VALUE 'BBOA1URG'.   \n       01 reqType              PIC 9(8) COMP VALUE 0.            \n       01 regDaemonName        PIC X(8)      VALUE LOW-VALUES.   \n       01 reqArea              PIC X(100)    VALUE SPACES.       \n       01 reqAreaAddr          USAGE POINTER.                    \n       01 respArea             PIC X(2048)   VALUE SPACES.       \n       01 respAreaAddr         USAGE POINTER.                    \n       01 name                 PIC X(255)    VALUE SPACES.       \n       01 daemonName           PIC X(8)      VALUE 'WAS00   '.   \n       01 nodeName             PIC X(8)      VALUE 'NDN1    '. \n       01 serverName           PIC X(8)      VALUE 'BBOS001 '.                  \n       01 registerName         PIC X(12)     VALUE 'ZCUSTGET'.                  \n       01 serviceName          PIC X(255).                                      \n       01 serviceNameLen       PIC 9(8) COMP VALUE 0.                           \n       01 reqLen               PIC 9(8) COMP VALUE 100.                         \n       01 respLen              PIC 9(8) COMP VALUE 100.                         \n       01 minConn              PIC 9(8) COMP VALUE 1.                           \n       01 maxConn              PIC 9(8) COMP VALUE 10.                          \n       01 waitTime             PIC 9(8) COMP VALUE 0.                           \n       01 regOpts              PIC 9(8) COMP VALUE 0.                           \n       01 rc                   PIC 9(8) COMP VALUE 0.                           \n       01 rsn                  PIC 9(8) COMP VALUE 0.                           \n       01 rv                   PIC 9(8) COMP VALUE 0.                           \n       01 verbose              PIC 9(8) COMP VALUE 0.                           \n       01 result               PIC 9(8) COMP VALUE 0.                           \n       01 reason               PIC 9(8) COMP VALUE 0.                           \n       01 testcase             PIC X(8)      VALUE 'ZCUSTGET'.                  \n       01 endMessage           PIC X(25).                                       \n       Linkage Section.                                                         \n       Copy DFHEIBLK.                                                           \n       Copy ZCUSTCPY.                                                           \n       Procedure Division Using EIBLK DFHCOMMAREA.                              \n       Start-Para.                                                              \n           MOVE 1 to verbose.                                                   \n      *                                                                         \n      * OLA REGISTER                                                            \n      *                                                                         \n           IF verbose = 1 THEN                                                  \n             DISPLAY TESTCASE \": Calling Register for : \" registerName          \n             DISPLAY TESTCASE \": with Daemon name : \" daemonName                \n             DISPLAY TESTCASE \": with Node name : \" nodeName                    \n             DISPLAY TESTCASE \": and Server name : \" serverName                 \n           END-IF.                                                              \n                                                                                \n           Inspect daemonName converting ' ' to low-values. \n\n           CALL olaRegister Using daemonName, nodeName, serverName,      \n                 registerName, minConn, maxConn,                         \n                 regOpts, rc, rsn.                                       \n                                                                         \n           If rc &gt; 0 Then                                                \n             DISPLAY TESTCASE \": Bad RC/RSN from BBOA1REG: \" rc \"/\" rsn  \n             GO TO LEAVE-ZCUSTGET                                        \n           End-IF.                                                       \n                                                                         \n      *    MOVE '0000000001' to CustomerNumber.                          \n           MOVE SPACES to FirstName.                                     \n           MOVE SPACES to LastName.                                      \n           MOVE SPACES to Street.                                        \n           MOVE SPACES to City.                                          \n           MOVE SPACES to Country.                                       \n           MOVE SPACES to Phone.                                         \n           MOVE SPACES to PostalCode.                                    \n           MOVE LENGTH OF DFHCOMMAREA to reqLen.                         \n           MOVE reqLen to respLen.                                       \n           MOVE LOW-VALUES TO serviceName.                               \n           MOVE 'SAPCustomerGetDetail' to serviceName.                   \n           MOVE 20 TO serviceNameLen.                                    \n                                                                         \n      * Null terminate service name.                                     \n           Inspect serviceName converting ' ' to low-values.             \n                                                                         \n           SET reqAreaAddr TO ADDRESS OF DFHCOMMAREA.                    \n           SET respAreaAddr TO ADDRESS OF DFHCOMMAREA.                   \n                                                                         \n       Invoke-WAS.                                                       \n      *                                                                  \n      * OLA INVOKE                                                       \n      *                                                                  \n           MOVE 1 TO reqType.     \n      *                                                                     \n      * Make the ejb call                                                   \n      *                                                                     \n           IF verbose = 1 THEN                                              \n             DISPLAY TESTCASE \": Invoking EJB at ... \" serviceName          \n             DISPLAY TESTCASE \": Service name len: \" serviceNameLen         \n             DISPLAY TESTCASE \": CustomerNumber in \" CustomerNumber         \n             DISPLAY TESTCASE \": First Name In: \" FirstName                 \n             DISPLAY TESTCASE \": Last Name In: \" LastName                   \n             DISPLAY TESTCASE \": Street In: \" Street                        \n             DISPLAY TESTCASE \": City In: \" City                            \n             DISPLAY TESTCASE \": State In: \" State                          \n             DISPLAY TESTCASE \": Country In: \" Country                      \n             DISPLAY TESTCASE \": Phone In: \" Phone                          \n             DISPLAY TESTCASE \": Postal Code In: \" PostalCode               \n           END-IF.                                                          \n                                                                            \n           CALL olaInvoke Using registerName, reqType,                      \n                 serviceName,                                               \n                 serviceNameLen,                                            \n                 reqAreaAddr, reqLen,                                       \n                 respAreaAddr, respLen,                                     \n                 waitTime, rc, rsn, rv.                                     \n                                                                            \n           If rc &gt; 0 Then                                                   \n             DISPLAY TESTCASE \": Bad RC/RSN from BBOA1INV: \" rc \"/\" rsn     \n             GO TO LEAVE-ZCUSTGET                                           \n           End-IF.                                                          \n                                                                            \n           IF verbose = 1 THEN                                              \n             DISPLAY TESTCASE \": Invoke back rc/rsn/rv: \" rc \" \" rsn \" \" rv \n             DISPLAY TESTCASE \": Response length: \" respLen                 \n             DISPLAY TESTCASE \": CustomerNumber: \" CustomerNumber           \n             DISPLAY TESTCASE \": First Name Out: \" FirstName                \n             DISPLAY TESTCASE \": Last Name Out: \" LastName  \n             DISPLAY TESTCASE \": Street Out: \" Street                          \n             DISPLAY TESTCASE \": City Out: \" City                              \n             DISPLAY TESTCASE \": State Out: \" State                            \n             DISPLAY TESTCASE \": Country Out: \" Country                        \n             DISPLAY TESTCASE \": Phone Out: \" Phone                            \n             DISPLAY TESTCASE \": Postal Code Out: \" PostalCode                 \n             DISPLAY TESTCASE \": Returning.\"                                   \n           END-IF.                                                             \n                                                                               \n      *                                                                        \n      * OLA UNREGISTER                                                         \n      *                                                                        \n           IF verbose = 1 THEN                                                 \n             DISPLAY TESTCASE \": Calling UnRegister for : \" registerName       \n           END-IF.                                                             \n                                                                               \n           CALL olaUnRegister Using registerName,                              \n                 regOpts, rc, rsn.                                             \n                                                                               \n           If rc &gt; 0 Then                                                      \n             DISPLAY TESTCASE \": Bad RC/RSN from BBOA1URG: \" rc \"/\" rsn        \n             GO TO LEAVE-ZCUSTGET                                              \n           End-IF.                                                             \n                                                                               \n       LEAVE-ZCUSTGET.                                                         \n           MOVE rc TO RESULT.                                                  \n           MOVE rsn TO REASON.                                                 \n           EXEC CICS RETURN                                                    \n           END-EXEC.                                                           \n//LKED.SYSIN  DD  *                                                            \n  NAME ZCUSTGET(R)<\/pre><\/div><p>此程序需要编译、编辑链接并保存到 CICS 区域的 DFHRPL DD 串联中的一个负载数据集中。可能还需要必要的 CICS 程序定义。<\/p><p>这里的意图是通过 WOLA 并通过 WOLA CICS Link Server 从一个小示例 JSP 调用此程序。Rational Application Developer 生成的 JSP 将传递一个客户编号并使用 WOLA 的出站调用支持来调用此 COBOL 程序。此程序然后将通过 WOLA 的 Invoke API 回调您新创建的 SAPCustomerGet EJB，后者然后通过 SAP 资源适配器将客户移动到 BAPI_CUSTOMER_GETDETAIL 业务对象中，以拉取客户信息。最后，包含客户信息的响应将返回到 WebSphere Application Server 中，然后返回到 CICS 中，返回到您的调用 JSP 中，您将在这里显示详细信息。<\/p><h2 id=\"sec5\">3.创建业务对象调用代码 <\/h2><p>您现在已找到 BAPI_CUSTOMER_GETDETAIL 业务对象并生成代码来从您的 SAPWOLATestProject 工作区内部执行它。为此：<\/p><ol><li>确保 SAP 资源适配器安装在 WebSphere Application Server for z/OS 服务器中，并且指定了连接工厂的 ApplicationServerHost、userName 和 Password 设置。资源适配器配置应类似于图 19。\n            <h5 id=\"fig19\">图 19. WebSphere Application Server 管理控制台 - Resource Adapters<\/h5><img alt=\"WebSphere Application Server 管理控制台 - Resource Adapters\" src=\"/sunshine_new/images/1740972288/images/image19.jpg\" width=\"775\" /><br />\n            资源适配器可能位于 <strong>${CONNECTOR_INSTALL_ROOT}/CWYAP_SAPAdapter.rar<\/strong> 中。对于类路径和原生库路径，您将需要特定于 z/OS 的 DLL 可用，将此路径设置为包含它们的位置。请参阅有关 <a href=\"http://pic.dhe.ibm.com/infocenter/radhelp/v9/topic/com.ibm.wsadapters.rad.jca_sap.doc/env/doc/tsapextdependrun.html\">为 z/OS 配置 SAP 资源适配器<\/a> 的 Rational Application Developer 信息中心文档。\n            \n            <p>您现在已准备好使用 Rational Application Developer 找到您的目标 SAP 服务器上的远程函数调用 (RFC) 或业务对象存储库 (BOR)。选择 <strong>File &gt; New &gt; Other &gt; J2C &gt; J2C Bean<\/strong>，然后选择 <strong>Next<\/strong>。 <\/p><\/li><li>选择 <strong>IBM WebSphere Adapter for SAP Software<\/strong> 并单击 <strong>Next<\/strong>（图 20）。\n            <h5 id=\"fig20\">图 20. Resource Adapter Selection<\/h5><img alt=\"Resource Adapter Selection\" src=\"/sunshine_new/images/1740972288/images/image20.jpg\" width=\"403\" /><\/li><li>在 Connector Import 对话框上，接受默认设置并单击 <strong>Next<\/strong>（图 21）。\n            <h5 id=\"fig21\">图 21. Connector Import<\/h5><img alt=\"Connector Import\" src=\"/sunshine_new/images/1740972288/images/image21.jpg\" width=\"352\" /><\/li><li>请参阅信息中心，找到有关 <a href=\"                 http://pic.dhe.ibm.com/infocenter/radhelp/v9/topic/com.ibm.wsadapters.rad.jca_sap.doc/doc/stbp_sap_welcome.html\">在 Rational Application Developer V9.0.1 环境中使用 WebSphere Adapters SAP 资源适配器<\/a> 的信息。您需要从 SAP 服务器管理员获取这些文件并指定这些文件的路径，如图 22 所示：\n                <ul class=\"ibm-bullet-list\"><li>sapidoc3.jar<\/li><li>sapjco3.dll<\/li><li>sapjco3.jar<\/li><\/ul><p>因为显示的示例在 Windows 7 上运行 Rational Application Developer，所以您将注意到 DLL 为 win64bitx86 版本。<\/p><h5 id=\"fig22\">图 22. Connector Settings<\/h5><img alt=\"Connector Settings\" src=\"/sunshine_new/images/1740972288/images/image22.jpg\" width=\"693\" /><\/li><li>您现在应已准备好找到 SAP RFC 和 BOR，在 Rational Application Developer 中生成代码来处理它们。在 Adapter Style 对话框上，选择 <strong>Outbound<\/strong> 并单击 <strong>Next<\/strong>（图 23）。\n            <h5 id=\"fig23\">图 23. Adapter Style - Outbound Processing<\/h5><img alt=\"Adapter Style - Outbound Processing\" src=\"/sunshine_new/images/1740972288/images/image23.jpg\" width=\"390\" /><\/li><li>在 Discovery Configuration 对话框上（图 24），您将需要识别与连接到目标 SAP 服务器相关的重要数据。Host name、Client、System number、User name 和 Password 都是重要的字段。请与您的 SAP 系统管理员一道检查此信息，以确定这些值。选择 <strong>BAPI<\/strong> 选项。单击 <strong>Next<\/strong>，Rational Application Developer 将向 SAP 服务器发出一个请求并查询它的资源。\n            <h5 id=\"fig24\">图 24. Discovery Configuration<\/h5><img alt=\"Discovery Configuration\" src=\"/sunshine_new/images/1740972288/images/image24.jpg\" width=\"442\" height=\"646\" /><p><a href=\"#N102C3\" class=\"ibm-popup-link\" onclick=\"ibmweb.overlay.show('N102C3',this);return false;\">点击查看大图<\/a><\/p><div id=\"N102C3\" class=\"dw-sidefile-overlay ibm-common-overlay ibm-overlay-alt-two\"><div class=\"ibm-head\"><p><a href=\"#close\" class=\"ibm-common-overlay-close\">关闭 [x]<\/a><\/p><\/div><div class=\"ibm-body\"><div class=\"ibm-main\"><div class=\"ibm-title\"><h2>图 24. Discovery Configuration<\/h2><\/div><div class=\"ibm-container ibm-alternate\"><div class=\"ibm-container-body\"><img alt=\"Discovery Configuration\" src=\"/sunshine_new/images/1740972288/images/image24.jpg\" width=\"553\" /><\/div><\/div><\/div><\/div><div class=\"ibm-footer\"><><\/div><\/div><\/li><li>如果 SAP 服务器已成功联系上，将显示一个类似于图 25 中所示的对话框。 \n            <h5 id=\"fig25\">图 25. Object Discovery and Selection<\/h5><img alt=\"Object Discovery and Selection\" src=\"/sunshine_new/images/1740972288/images/image25.jpg\" width=\"672\" /><\/li><li>选择 RFC，然后单击紧挨上方的 Filter 图标（显示 3 个箭头）（图 26）。\n            <h5 id=\"fig26\">图 26. Object Selection<\/h5><img alt=\"Object Selection\" src=\"/sunshine_new/images/1740972288/images/image26.jpg\" width=\"731\" /><\/li><li>在 Filter Properties for ‘RFC’ 对话框上，将此模式的 Find 对象的值从 \"*\" 更改为 <code>BAPI_CUSTOMER_GETD*<\/code> 并单击 <strong>OK<\/strong>（图 27）。\n            <h5 id=\"fig27\">图 27. Filter Properties for 'RFC'<\/h5><img alt=\"Filter Properties for 'RFC'\" src=\"/sunshine_new/images/1740972288/images/image27.jpg\" width=\"524\" /><\/li><li>您将在 RFC 下获得一组响应（图 28）。单击 <strong>&gt;<\/strong> 按钮展开结果（图 28）。\n            <h5 id=\"fig28\">图 28. Filtered Object Selection<\/h5><img alt=\"Filtered Object Selection\" src=\"/sunshine_new/images/1740972288/images/image28.jpg\" width=\"436\" /><\/li><li>您现在已准备好告诉 Rational Application Developer 要导入什么（或者生成要调用或交互的代码）。选择 <strong>BAPI_CUSTOMER_GETDETAIL<\/strong> 并单击 <strong>&gt;<\/strong> 图标选择导入它（图 28）。您将看到如图 29 中所示的对话框。单击 <strong>Use SAP field names…<\/strong> 值并单击 <strong>OK<\/strong>。\n            <h5 id=\"fig29\">图 29. Configuration Parameters<\/h5><img alt=\"Configuration Parameters\" src=\"/sunshine_new/images/1740972288/images/image29.jpg\" width=\"513\" /><\/li><li>Object Discovery and Selection 对话框应类似于图 30。   单击 <strong>Next<\/strong>。\n            <h5 id=\"fig30\">图 30. Selected object<\/h5><img alt=\"Selected object\" src=\"/sunshine_new/images/1740972288/images/image30.jpg\" width=\"481\" /><\/li><li>Configure Composite Properties 对话框应类似于图 31。输入 <code>ejbModule<\/code> 作为 Folder，以将该代码放在您目前使用的相同位置中。\n            <h5 id=\"fig31\">图 31. Configure Composite Properties<\/h5><img alt=\"Configure Composite Properties\" src=\"/sunshine_new/images/1740972288/images/image31.jpg\" width=\"531\" /><\/li><li>完成 Bean Creation and Deployment Configuration 对话框中的属性字段，如图 32 所示。输入 <code>eis/sap_server<\/code> 作为 JNDI Lookup Name 的值，然后单击 <strong>Finish<\/strong>。\n            <h5 id=\"fig32\">图 32. J2C Bean Creation and Deployment Configuration<\/h5><img alt=\"J2C Bean Creation and Deployment Configuration\" src=\"/sunshine_new/images/1740972288/images/image32.jpg\" width=\"490\" /><\/li><li>您现在已拥有与此业务对象交互所需的代码。在 Rational Application Developer 工作区中，您应看到类似图 33 中所示的信息。您现在已准备好编写从 WOLA EJB 拉取并将请求转发到 SAP 服务器的 BAPI_CUSTOMER_GETDETAIL 业务对象的实现。\n            <h5 id=\"fig33\">图 33. Outbound bean 源代码清单<\/h5><img alt=\"Outbound bean 源代码清单\" src=\"/sunshine_new/images/1740972288/images/image33.jpg\" width=\"753\" /><\/li><\/ol><h2 id=\"sec6\">4.在 WOLA 目标 EJB 中添加实现代码 <\/h2><p>目前为止，创建的所有代码（CICS 中的 COBOL WOLA 调用代码除外）都已由 Rational Application Developer 生成。您使用了 Rational Application Developer 来创建一个名为 SAPCustomerGet 的 WOLA 目标 EJB，并在其中创建一个 execute() 方法来控制来自 CICS  ZCUSTGET COBOL 程序的 WOLA 调用。   您使用了 Rational Application Developer 导入 COBOL copy book 并生成一个帮助器类，这个类将处理来自 COBOL 端的对象只的获取和设置并将其返回到 COBOL 端。为此目的生成的部分称为 CUSTOMER.java。最后，您使用 Rational Application Developer 生成使用 SAP 资源适配器来连接 BAPI_CUSTOMER_GETDETAIL 业务对象的代码。SAP_BAPI_Customer_GetDetail.java 和 SAP_BAPI_Customer_GetDetailImpl.java 部分中的代码就是为此目的而生成的。<\/p><p>现在您已准备放置该代码来将这些部分绑定在一起。<\/p><p>我们返回并修改 <strong>SAPCustomerGet.java<\/strong>。   图 34 显示了一个访问输入的客户编号并仅打印出它的修改版本。修改 execute 方法以输出响应的形式返回输入字节数组。 <\/p><h5 id=\"fig34\">图 34. 实现代码清单<\/h5><img alt=\"实现代码清单\" src=\"/sunshine_new/images/1740972288/images/image34.jpg\" width=\"751\" /><p>在继续之前将此代码放入一个 EAR 中并测试它，可能很有用。要在 CICS 端执行初始请求，可定义一个名为 ZGET 的事务并将它与程序 ZCUSTGET 关联。您可修改该程序来将 copy book 放在 WORKING-STORAGE 节中，将客户编号预设为 0000000001，然后在登录到一个终端会话后在 CICS 中运行该事务。此测试步骤可跳过，因为本文后面将介绍如何在 Rational Application Developer 中生成代码，通过 WOLA 和使用 WOLA CICS Link 服务器从 WebSphere Application Server 调用 CICS ZCUSTGET 程序；这使您能够向 CICS 发出请求，而无需登录到 3270 终端会话并执行 ZGET/ZCUSTGET 事务/程序。<\/p><p>下一步是增强此吃呢供需，添加将调用 BAPI_CUSTOMER_GETDETAIL 业务对象的代码。图 35 显示了向 WebSphere Application Server 日志打印调试信息的代码。该图中的代码显示了如何从 CICS 接受请求，获取客户编号，创建 SapBapiCustomerGetdetail 的一个新实例，填入客户编号，然后通过 SAP 资源适配器对 SAP 服务器执行调用。<\/p><h5 id=\"fig35\">图 35. 调用 SAP 出站 J2C bean<\/h5><img alt=\"调用 SAP 出站 J2C bean\" src=\"/sunshine_new/images/1740972288/images/image35.jpg\" width=\"751\" /><p>图 26 中的代码处理来自 SAP 客户查询的响应，并将它填入到一个要返回给 COBOL CICS 调用方的字节数组中。<\/p><h5 id=\"fig36\">图 36. 映射输出数据<\/h5><img alt=\"映射输出数据\" src=\"/sunshine_new/images/1740972288/images/image36.jpg\" width=\"768\" /><p>执行一个测试来从 CICS 事务中获取此信息，这会在WebSphere Application Server for z/OS SYSPRINT 例程中得到来自 WOLA 目标 EJB SAPCustomerGet 中的以下输出消息（图 37)<\/p><h5 id=\"fig37\">图 37. WebSphere Application Server for z/OS servant 区域作业输出 (SYSPRINT)<\/h5><img alt=\"WebSphere Application Server for z/OS servant 区域作业输出 (SYSPRINT)\" src=\"/sunshine_new/images/1740972288/images/image37.jpg\" width=\"800\" /><p>来自正在运行的 COBOL 程序的 CICS CEEMSG 日志中的输出消息应类似于图 38。再次申明，在 ZCUSTGET 中，您运行位于 WORKING-STORAGE 节中的 ZCUSTCPY copy book 并将要查询的客户编号预设为 <code>0000000001<\/code>。使用 WOLA 从 WebSphere Application Server 调用 ZCUSTGET 时（如下一节中所示），ZCUSTCPY copy book 必须移动到 ZCUSTGET 程序的 LINKAGE-SECTION 并删除硬编码的客户编号；它会作为来自 WebSphere Application Server 和您将构建的测试网页的输入参数被接受。<\/p><h5 id=\"fig38\">图 38. z/OS CICS 作业输出显示 (CEEMSG)<\/h5><img alt=\"z/OS CICS 作业输出显示 (CEEMSG)\" src=\"/sunshine_new/images/1740972288/images/image38.jpg\" width=\"648\" /><h2 id=\"sec7\">第 5 步：生成 WOLA 代码来调用 CICS COBOL 程序 <\/h2><p>Rational Application Developer 中新的支持功能提供了构建将使用 WOLA 从 WebSphere Application Server 调用 CICS、IMS 或一个批处理程序的代码的能力。这一步完成以下任务：生成一个简单的网页，它接受从 SAP 服务器查询的客户编号，将它传递到 ZCUSTGET COBOL CICS 程序，后者进而通过 WOLA 调用 WebSphere Application Server 的 SAPCustomerGet EJB，该 EJB 进而调用 SAP BAPI_CUSTOMER_GETDETAIL 业务对象。响应将从 SAP 应用程序传回到 SAPCustomerGet EJB，然后传回到 ZCUSTGET，然后是将显示客户详细信息的调用 servlet/Web 应用程序。<\/p><ol><li>生成一个 WOLA J2C bean 以用于从 WebSphere Application Server 到 CICS 的出站调用。在 Rational Application Developer 中，选择 <strong>File &gt; New &gt; Other &gt; J2C &gt; J2C Bean<\/strong>（图 39）。\n            <h5 id=\"fig39\">图 39. New J2C Bean 向导<\/h5><img alt=\"New J2C Bean 向导\" src=\"/sunshine_new/images/1740972288/images/image39.jpg\" width=\"361\" /><\/li><li>在 WOLA 目录下，选择 <strong>ola<\/strong> 文件夹并单击 <strong>Next<\/strong>（图 40）。\n            <h5 id=\"fig40\">图 40. Resource Adapter Selection<\/h5><img alt=\"Resource Adapter Selection\" src=\"/sunshine_new/images/1740972288/images/image40.jpg\" width=\"379\" /><\/li><li>选择 <strong>Outbound<\/strong>，然后选择 <strong>Next<\/strong>（图 41）。\n            <h5 id=\"fig41\">图 41. Adapter Style<\/h5><img alt=\"Adapter Style\" src=\"/sunshine_new/images/1740972288/images/image41.jpg\" width=\"439\" /><\/li><li>将 JNDI name 设置为 <code>eis/ola<\/code> 并单击 <strong>Next<\/strong>（图 42）。\n            <h5 id=\"fig42\">图 42. Connection Properties<\/h5><img alt=\"Connection Properties\" src=\"/sunshine_new/images/1740972288/images/image42.jpg\" width=\"612\" /><\/li><li>如图 43 所示定义项目、包和 EJB 名称。\n            <h5 id=\"fig43\">图 43. J2C Java Bean Output Properties<\/h5><img alt=\"J2C Java Bean Output Properties\" src=\"/sunshine_new/images/1740972288/images/image43.jpg\" width=\"529\" /><\/li><li>在 Java Method 面板中，选择 <strong>New<\/strong>（图 44) 以添加一个 Java 方法类型。确保勾选了 <strong>Use the input type for output<\/strong>。输入 <code>zCUSTCPY_Out<\/code> 作为 Name 字段，单击 <strong>Browse<\/strong>，键入 <code>CUSTOMER<\/code> 并选择它。完成后单击 <strong>Finish<\/strong>。\n            <h5 id=\"fig44\">图 44. Java Method<\/h5><img alt=\"Java Method\" src=\"/sunshine_new/images/1740972288/images/image44.jpg\" width=\"463\" /><\/li><li>下一个对话框询问要调用的 WOLA 目标服务名称；这将是 CICS 目标程序 <strong>ZCUSTGET<\/strong>（图 45）。\n            <h5 id=\"fig45\">图 45. Java Methods<\/h5><img alt=\"Java Methods\" src=\"/sunshine_new/images/1740972288/images/image45.jpg\" width=\"475\" /><\/li><li>在 Deployment Information 对话框，勾选 <strong>Create a Web page, Web Services, or EJB from the J2C bean<\/strong> 以表明您想要一个新网页（图 46）。选择 <strong>Simple JSP<\/strong> 并单击 <strong>Next<\/strong>。 \n            <h5 id=\"fig46\">图 46. Deployment Information<\/h5><img alt=\"Deployment Information\" src=\"/sunshine_new/images/1740972288/images/image46.jpg\" width=\"459\" /><\/li><li>要创建一个新 Web 项目，输入 <code>SAPWOLATestWeb<\/code> 作为新项目名称并单击 <strong>Finish<\/strong>（图 47）。\n            <h5 id=\"fig47\">图 47. Web Project<\/h5><img alt=\"Web Project\" src=\"/sunshine_new/images/1740972288/images/image47.jpg\" width=\"365\" /><\/li><li>一个新项目将显示在左侧。确保 EAR Project name 设置为 <strong>SAPWOLATestProjectEAR<\/strong>（图 48）。如果不是，您的新项目将不会集成并包含在该 EAR 中。\n            <h5 id=\"fig48\">图 48. Deployment<\/h5><img alt=\"Deployment\" src=\"/sunshine_new/images/1740972288/images/image48.jpg\" width=\"353\" /><\/li><li>您现在已准备好创建与为测试创建的 servlet 关联的 JSP。在 Simple JSP Creation 对话框中，输入 <code>JSP<\/code> 作为文件夹并单击 <strong>Finish<\/strong>（图 49）。\n            <h5 id=\"fig49\">图 49. Simple JSP Creation<\/h5><img alt=\"Simple JSP Creation\" src=\"/sunshine_new/images/1740972288/images/image49.jpg\" width=\"614\" /><\/li><\/ol><p>此刻，您应看到一个类似图 50 的新部分。它创建一个帮助器并用于处理通过 WOLA 资源适配器与 CICS 的交互。<\/p><h5 id=\"fig50\">图 50. Outbound J2C bean 源代码清单<\/h5><img alt=\"Outbound J2C bean 源代码清单\" src=\"/sunshine_new/images/1740972288/images/image50.jpg\" width=\"719\" /><p>此刻，您应能够看到一组新 JSP，它们是在新的 SAPWOLATestWeb 项目中创建的（图 51）：<\/p><ul class=\"ibm-bullet-list\"><li>TestClient.jsp 是包含其他 JSP 的顶级 JSP。 <\/li><li>Input.jsp 接受输入参数。<\/li><li>Method.jsp 调用资源适配器交互代码。<\/li><li>Result.jsp 包含响应。<\/li><\/ul><h5 id=\"fig51\">图 51. Resource View<\/h5><img alt=\"Resource View\" src=\"/sunshine_new/images/1740972288/images/image51.jpg\" width=\"192\" /><p>图 52 显示了 Input.jsp。<\/p><h5 id=\"fig52\">图 52. Input JSP<\/h5><img alt=\"Input JSP\" src=\"/sunshine_new/images/1740972288/images/image52.jpg\" width=\"505\" /><h2 id=\"sec8\">6.运行完整的端到端场景 <\/h2><p>确保 EAR 项目 SAPWOLATestProjectEAR 的部署程序集设置中包含新的 Web 项目 SAPWOLATestWeb（图 53）。<\/p><h5 id=\"fig53\">图 53. Ear Module Assembly<\/h5><img alt=\"Ear Module Assembly\" src=\"/sunshine_new/images/1740972288/images/image53.jpg\" width=\"654\" /><p>在 Rational Application Developer 中，右键单击 <strong>SAPWOLATestProjectEAR<\/strong> 项目并选择 <strong>Properties and Deployment Assembly<\/strong>。如果未在这里看到 SAPWOLATestWeb.war，现在可单击 <strong>Add<\/strong> 并将它添加到此列表中；否则这些 JSP 将不会捆绑到您的 EAR 文件中。<\/p><p>您现在已构建了完整的应用程序，它已准备好测试。   发出 <strong>Project &gt; Clean<\/strong> 命令并单击 <strong>Run<\/strong>。右键单击 <strong>SAPWOLATestProject<\/strong>  和 <strong>SAPWOLATestProjectEAR<\/strong>，然后选择 <strong>Java EE &gt; Prepare for Deployment<\/strong> 以确保所有内容都已编译并准备好。  <\/p><ol><li>右键单击 <strong>SAPWOLATestProjectEAR<\/strong> 文件并选择 <strong>Export &gt; EAR<\/strong>。为它提供一个名称，如图 54 所示。\n            <h5 id=\"fig54\">图 54. EAR Export<\/h5><img alt=\"EAR Export\" src=\"/sunshine_new/images/1740972288/images/image54.jpg\" width=\"382\" /><\/li><li>登录到 WebSphere Application Server 管理控制台，定义一个 <strong>OptimizedLocalAdapter<\/strong> 类型的连接工厂并将其命名为 <code>eis/ola<\/code>（图 55）。您将需要在 CF 自定义属性面板指定一个与您计划用于 WOLA CICS Link 服务器的名称匹配的 Register Name（参见下面的第 5 步）。  \n            <h5 id=\"fig55\">图 55. WebSphere Application Server 管理控制台 - J2C Connection Factories<\/h5><img alt=\"WebSphere Application Server 管理控制台 - J2C Connection Factories\" src=\"/sunshine_new/images/1740972288/images/image55.jpg\" width=\"360\" /><br />\n            \n            使用名称 <code>OLASERVER<\/code> 作为 Register name（图 56）。\n            <h5 id=\"fig56\">图 56. Register Name Property<\/h5><img alt=\"Register Name Property\" src=\"/sunshine_new/images/1740972288/images/image56.jpg\" width=\"605\" /><\/li><li>使用管理控制台将 EAR 文件安装到您的应用服务器中。<\/li><li>确保 ZCUSTGET COBOL 程序已准备好在您的 CICS 区域调用。它应在 PROCEDURE DIVISION 中指定的 LINKAGE-SECTION 和 DFHCOMMAREA 中包含 ZCUSTCPY copy book。它应已编译和链接，可用在 CICS DFHRPL DD 中的区域启动 JCL 中。如果未使用 CICS 程序自动安装功能，它还将需要 ZCUSTGET 的一个 CICS PPT 定义，表明它是一个 COBOL 程序。linkage 节和过程划分应类似于图 57（请参阅包含的 ZCUSTGET 和 ZCUSTCPY 示例）。\n            <h5 id=\"fig57\">图 57. Linkage 节<\/h5><img alt=\"Linkage 节\" src=\"/sunshine_new/images/1740972288/images/image57.jpg\" width=\"466\" /><\/li><li>登录到 CICS 并启动 WOLA CICS Link Server，指定以下参数；从 CICS 3270 终端会话发出此命令：\n            <p><code>sddd bboc start_srvr rgn=olaserver svn=bbos001 dgn=was00 ndn=ndn1 trc=2 svc=*<\/code><\/p><p>（TRC=2 是扩展的跟踪，只是为了调试才以这种方式设置。）<\/p><p>此命令启动一个名为 BBO$ 的 CICS 后台事务，该事务将捕获来自 WebSphere Application Server 的程序调用请求并为另一个事务 BBO# 发出 START TRANSACTION，该事务是 WOLA 调用任务。此任务向选定的目标程序发出 EXEC CICS LINK。在此情况下，目标程序将是 ZCUSTGET。但任何其他属于此连接工厂的程序也可由此 Link Server 提供，因为它是使用 <strong>SVC=*<\/strong> 运行的（此匹配注册表名称下的任何服务名称都会被接受）。<\/p><p>如果 WOLA CICS Link Server 正确启动，您将在 z/OS 上的 CICS joblog 中看到类似图 58 所示的消息；BBOOUT DD。<\/p><h5 id=\"fig58\">图 58. 控制台输出<\/h5><img alt=\"控制台输出\" src=\"/sunshine_new/images/1740972288/images/image58.jpg\" width=\"800\" /><\/li><li>CICS 和 WebSphere Application Server 服务器重新启动并准备好之后，继续尝试测试整个端到端流。打开一个浏览器并粘贴入一个 URL，比如：\n            \n            <p><code>http://&lt;hostname&gt;:&lt;port&gt;/SAPWOLATestWeb/JSP/TestClient.jsp<\/code><\/p><p>如果所有部分都已正确安装并运行，您应看到一个类似图 59 的页面。<\/p><h5 id=\"fig59\">图 59. 测试客户端<\/h5><img alt=\"测试客户端\" src=\"/sunshine_new/images/1740972288/images/image59.jpg\" width=\"670\" /><\/li><li>要执行测试，可输入 customerNumber <code>0000000002<\/code> 并单击 <strong>Invoke<\/strong>。响应应与图 60 中的 Result 节匹配。\n            <h5 id=\"fig60\">图 60. 测试客户端结果<\/h5><img alt=\"测试客户端结果\" src=\"/sunshine_new/images/1740972288/images/image60.jpg\" width=\"754\" /><p>这意味着对客户编号 0000000002 的请求通过 WOLA 传递到 CICS ZCUSTGET，它进而通过 WOLA 返回到 WebSphere Application Server，返回到您的 SAPCustomerGet EJB，然后返回到业务对象 BAPI_CUSTOMER_GETDETAIL 的 SAP 服务器。响应返回到 WebSphere Application Server，CICS，然后再次返回到 WebSphere Application Server，一直到到上面的响应页面。<\/p><p>图 61 显示了在检查 WebSphere Application Server SYSPRINT 中的日志时可能看到的内容。<\/p><h5 id=\"fig61\">图 61. 控制台日志<\/h5><img alt=\"控制台日志\" src=\"/sunshine_new/images/1740972288/images/image61.jpg\" width=\"800\" /><p>检查 CICS 作业中的 CICS WOLA Link Server BBOOUT 日志时，以及像这里这样使用 TRC=2 运行时，您会看到图 62 中所示的跟踪消息显示 ZCUSTGET 已在运行。<\/p><h5 id=\"fig62\">图 62. CICS 作业输出 WOLA BBOQ 跟踪消息 (BBOOUT)<\/h5><img alt=\"CICS 作业输出 WOLA BBOQ 跟踪消息 (BBOOUT)\" src=\"/sunshine_new/images/1740972288/images/image62.jpg\" width=\"800\" /><\/li><li>最后，查看 ZCUSTGET COBOL 程序的消息日志（图 63）。\n            <h5 id=\"fig63\">图 63. CICS 作业日志中的 ZCUSTGET 输出 (CEEMSG)<\/h5><img alt=\"CICS 作业日志中的 ZCUSTGET 输出 (CEEMSG)\" src=\"/sunshine_new/images/1740972288/images/image63.jpg\" width=\"763\" /><\/li><\/ol><p>使用 WebSphere Application Server for z/OS、WOLA、WebSphere Adapters 和 SAP 资源适配器执行的示例端到端测试，到这里就结束了。正如开头提到的，完成此任务需要的手动创建的代码非常少。实现调用 SAP 资源适配器的 WOLA EJB 时，总代码行数少于 50。还需要调用 COBOL 代码来调用 WOLA EJB。<\/p><h2 id=\"conclusion\">结束语<\/h2><p>Rational Application Developer Version 9.0.1 在应用程序集成领域提供一些真正给人印象深刻的功能，在不同环境之间只需极少的编程工作，这些系统包括 WebSphere Application Server、CICS、IMS、SAP、Oracle、Seibel 和其他支持的企业信息系统。一旦掌握该模式之后，它将为您提供一种途径来将 WebSphere Adapters 支持的任何环境与如今在 z/OS 上以 CICS、IMS、批处理等模式下运行的应用程序匹配。WebSphere Optimized Local Adapters 双向调用功能的集成为过去由于太复杂而无法处理的应用程序之间的实时交互带来了许多可能性。<\/p><CMA ID: 972664><Site ID: 10><XSLT stylesheet used to transform this file: dw-document-html-7.0.xsl>\r\n\r\n\r\n<\/div>\r\n<\/div>\r\n","createTime":"2014-05-29 00:00:00","deployTime":"2014-05-29 00:00:00","id":0,"intro":"IBM Rational Application Developer for WebSphere Software V9.0.1 中的增强添加了针对不同企业环境之间的应用程序集成的新功能，比如包含 IBM WebSphere Application Server、CICS、IMS 和 z/OS 上的批处理功能的环境，以及包含 SAP、Oracle、Seibel 和其他受 IBM WebSphere Adapter 支持的企业信息系统的环境。现在 Rational Application Developer 中包含对优化的本地适配器的支持，在 WebSphere Application Server for z/OS 和同一个 z/OS 系统上的外部地址空间应用程序之间提供了优化的双向调用。优化的本地适配器与 WebSphere Adapters 的集成带来了许多在应用程序和环境之间执行实时交互的新机会，这些交互非常复杂，在过去无法实际处理。本文提供了这样一个场景，该场景中一个 CICS 应用程序使用优化的本地适配器和 WebSphere Application Server for z/OS 与在 SAP 服务器上运行的应用程序进行通信。","keyword":"","recommend":false,"source":"http://www.ibm.com/developerworks/cn/websphere/techjournal/1312_mulvey/1312_mulvey.html","title":"针对 WebSphere Optimized Local Adapters 的 Rational Application Developer 增强为端到端 EIS 集成提供了新的机会","typeId":0,"updateTime":"2014-05-29 00:00:00"}
{"author":"","clickNumber":0,"content":"\r\n<div class=\"ibm-columns\">\r\n<div class=\"ibm-col-1-1\">\r\n\r\n<p>本文将介绍 OpenStack Compute\n                (Nova)，它代表了任何工作负载的核心。如果有些云服务的工作中不包括计算，那么它们充其量只代表静态存储 &#8212;\n                但所有动态活动都会涉及一些计算元素。<\/p><p>OpenStack Compute 这个名称指的是一个特定的项目，该项目也被称为 Nova，但与计算和运行计算的软件相关的项目其实有两个，即\n                Image 和 Compute： <\/p><ul class=\"ibm-bullet-list\"><li>OpenStack Image 管理其中包含可执行代码和操作环境的静态磁盘镜像。<\/li><li>OpenStack Compute (Nova) 管理正在运行的实例。<\/li><\/ul><p>Nova 控制云计算架构，因此形成一个基础架构服务核心。Nova 也是 OpenStack\n                家族中最复杂的组件，主要因为它具有高度分散的性质和多个流程。<\/p><p>Nova 与其他几个 OpenStack 服务都有一些接口：它使用 Keystone 来执行其身份验证，使用 Horizon 作为其管理接口，并用\n                Glance 提供其镜像。它与 Glance 的交互最为密切，Nova 需要下载镜像，以便在加载镜像时使用。<\/p><p>在更详细地讨论 Nova 之前，让我们先仔细了解一下 Image 服务，它按时间顺序表示 Compute 工作负载的开始。Glance 是\n                OpenStack Image Service 的项目名称，它会注册、列出并检索虚拟机（VM）镜像。<\/p><p>Glance 管理在 OpenStack 集群中的镜像，但不负责实际的存储。它为从简单文件系统到对象存储系统（如 OpenStack Swift\n                项目）的多种存储技术提供了一个抽象。除了实际的磁盘镜像之外，它还保存描述镜像的元数据和状态信息。<\/p><p>OpenStack Image Store\n                是虚拟镜像的中央存储库。用户和其他项目可以存储公共和私有镜像，他们可以访问这些镜像来启动实例。他们还可以请求获得可用镜像的列表，检索它们的配置信息，然后将它们作为启动\n                Nova 实例的基础。您还可以从运行实例拍摄快照，作为备份虚拟机及其状态的一种手段。<\/p><p>在创建镜像之后，Nova 就开始起作用。它通常使用一个镜像来启动一个实例，或\n                VM。虽然它本身不包括任何虚拟化软件，但它可以通过与虚拟化技术有关联的驱动程序来集成许多常见的虚拟机管理程序。<\/p><p>从实践角度来看，启动实例涉及到识别并指定虚拟硬件模板（在 OpenStack 中被称为风格）。模板描述被分配给 VM 实例的计算（虚拟\n                CPU）、内存（RAM）和存储配置（硬盘）。默认的安装提供了五种风格，它们由管理员配置。<\/p><p>然后，Nova 通过将执行分配给某个特定的计算节点（在 OpenStack\n                中被称为主机）来调度被请求的实例。每个系统都必须定期报告其状态和能力，<code>tonova-scheduler<\/code>\n                使用数据来优化其分配。<\/p><p>整个分配过程由两个阶段组成。Filtering（过滤）阶段应用了一组过滤器，生成最适合的主机的列表。每个 OpenStack\n                服务都会公布其能力，这些能力是最重要的考虑因素之一。调度程序将会缩小主机的选择范围，以找到符合请求参数的主机。然后，Weighting（加权）阶段使用了一个特殊的函数来计算每个主机的成本，并对结果进行排序。这个阶段的输出是一个主机列表，这些主机可用最少的成本满足用户对给定数量的实例的请求。<\/p><p>Nova 还执行了其他一些函数，其中有许多函数与涵盖网络、安全性和管理的其他 OpenStack 项目有密切的交互。但 Nova\n                一般处理这些项目的特定于实例的方面，如连接和取消连接存储、分配 IP 地址，或拍摄运行实例的快照。<\/p><h2 id=\"architecture\">架构<\/h2><p>Nova 采用的是无共享架构（图 1），这样所有的主要部件都可以在不同的服务器上运行。分布式设计依赖于一个消息队列来处理组件对组件的异步通信。<\/p><h5 id=\"fig1\">图 1. Nova 架构<\/h5><img alt=\"该图显示了 Nova 架构\" src=\"/sunshine_new/images/负512245824/figure1.png\" width=\"422\" /><p>Nova 将虚拟机的状态存储在一个基于结构化查询语言 (SQL) 的中央数据库中，所有的 OpenStack\n                组件都使用该数据库。该数据库保存了可用实例类型、网络（如果正在使用\n                <code>nova-network<\/code>）和项目的详细信息。用户可以使用 SQLAlchem??y 支持的任何数据库。<\/p><h3 id=\"web_dashboard\">Web 仪表板<\/h3><p>OpenStack Compute 的主用户界面是 Web 仪表板（OpenStack Horizon）。这是所有 OpenStack\n                模块的中央门户，为所有项目提供图形界面，并执行应用程序编程接口（API）调用来调用任何被请求的服务。<\/p><div class=\"dw-sidebar ibm-inset\"><h2 id=\"N10082\">动手试试！<\/h2><\/div><h3 id=\"api\">API<\/h3><p>该 API 基于 Representational State Transfer。这是一个 Web Server Gateway Interface\n                应用程序，它将统一资源指示器路由到控制器类上的操作方法。该 API 接收 HTTP 请求，处理命令，然后将任务通过消息队列或 HTTP（在使用\n                <code>ObjectStore<\/code> 的情况下）委派给其他组件。Nova API 支持 OpenStack Compute\n                API、Amazon Elastic Compute Cloud (Amazon EC2) API，以及面向特权用户的 Admin\n                API。它会启动大部分协调活动和策略（如 Quota）。<\/p><h3 id=\"authmgr\">Authorization Manager<\/h3><p>每个 HTTP 请求都需要一个特定的身份验证凭据，它使用了提供商为 Compute 节点配置的身份验证架构。Authorization Manager\n                不是一个独立的二进制文件；相反，它是一个 Python 类，任何 OpenStack 组件都可以使用它进行身份验证。它暴露了用户、项目和角色的\n                API 授权使用情况，并与 OpenStack Keystone 进行通信，以便获得详细信息。实际的用户存储可以是数据库或者 Lightweight\n                Directory Access Protocol（LDAP，轻量级目录访问协议）后端。<\/p><h3 id=\"objectsore\">ObjectStore<\/h3><p><code>ObjectStore<\/code> 是一个基于 HTTP、基于对象的简单存储（如 Amazon Simple Storage\n                Service），专门针对镜像。通常可以用 OpenStack Glance 取代它。<\/p><h3 id=\"message_queue\">消息队列<\/h3><p>消息队列为 OpenStack Nova 中的所有组件提供了相互通信、相互协调的一种手段。它就像所有 Nova\n                组件都共享和更新的一个中心任务列表。<\/p><p>所有这些组件都在一个非阻塞的基于消息的架构上运行，只要它们使用了相同的消息队列服务，就可以在相同或不??同的主机上运行。它们使用了 Advanced\n                Message Queuing Protocol，以面向回调的方式进行交互。在默认情况下，大多数分发实现了通过 Kombu 库访问的\n                RabbitMQ，但也提供了面向 Apache QPID 和 ZeroMQ 的插件。<\/p><p>Nova 组件通过使用 Pub/sub 的 Message Broker，使用远程过程调用实现彼此之间的通信。从技术角度讲，Nova 实现了\n                <code>rpc.call<\/code>（请求/响应；该 API 作为消费者）和 <code>rpc.cast<\/code>（单向；该 API\n                作为发布者）。<\/p><p>Nova API 和调度程序使用消息队列作为 Invoker，而 Network 和 Compute 充当了工人。Invoker 通过\n                <code>rpc.call<\/code> 或 <code>rpc.cast<\/code> 发送消息。Worker\n                模式从队列接收消息，并用适当的响应回答每个 <code>rpc.call<\/code>。<\/p><h3 id=\"daemons\">守护进程<\/h3><p>对于\n                Nova，要考虑的两个主要守护进程是调度程序和计算守护进程。调度程序确定了为虚拟机请求分配哪个计算主机。它采用了上述的过滤和调度算法，并考虑多种参数，包括亲和性（与共置相关的工作负载）、反亲和性（分发工作负载）、可用区、核心\n                CPU 使用率、系统内存，以及自定义的 JavaScript Object Notation\n                时间表。请注意，它只在进行配置时做出此决定，不会重新分配正在运行的实例。<\/p><p>Nova 计算是一个工人守护进程，用于管理与虚拟机管理程序和虚拟机的通信。它从消息队列中检索其订单，并使用虚拟机管理程序的 API\n                执行虚拟机的创建和删除任务。它还在中央数据库中更新其任务状态。<\/p><p>为了获得完整性，一些守护进程将会覆盖原来分配给 Nova 的、正慢慢迁移到其他项目的功能。Network Manager 负责管理 IP\n                转发、网桥和虚拟局域网。它是一个工人守护进程，从消息队列读取与网络有关的任务。OpenStack Neutron\n                现在也涵盖这些功能，可以在适当的位置上选中它。<\/p><p>Volume Manager 负责处理将持久存储的块存储卷附加到虚拟机以及从虚拟机分离持久存储的块存储卷（类似于 Amazon Elastic\n                Block Store）。此功能已被提取到 OpenStack Cinder。这是一个使用 Logical Volume Manager 的\n                iSCSI 解决方案。<\/p><h2 id=\"setup\">设置<\/h2><p>各发行版和 OpenStack\n                版本的实际安装说明差别很大。一般来说，它们是作为分发的一部分提供的。不过，您必须完成相同的基本任务。本节让您了解此基本任务涉及的内容。<\/p><h3 id=\"sys_req\">系统要求<\/h3><p>OpenStack 依赖于一种 64 位 x86 架构；另外，它是为商用硬件而设计的，所以具有极低的系统要求。它可以在配有包含 8GB RAM\n                的单个系统上运行整套 OpenStack\n                项目，但对于任何重大的工作，官方建议是，对于运行网络、卷、API、调度程序和镜像服务的云控制器节点，至少要配有 12GB RAM、两个 2TB\n                硬盘和一个网络适配器。计算节点（运行虚拟实例）的负载将会有更大的差异，但对于简单的系统而言，一个四核 CPU、32GB 的 RAM 和 2Gb\n                的网络适配器就是一个良好的起点。<\/p><h3 id=\"install\">安装<\/h3><p>安装指南取决于所用的发行版，更具体地说，取决于所选择的软件包管理实用工具。在许多情况下，必须声明存储库。因此，举例来说，如果您使用的是\n                Zypper，那么您要用 <code>zypper ar<\/code> 向 <code>libzypp<\/code> 公开： <\/p><p><a href=\"#N100E5\" class=\"ibm-popup-link\" onclick=\"ibmweb.overlay.show('N100E5',this);return false;\">点击查看代码清单<\/a><\/p><div id=\"N100E5\" class=\"dw-sidefile-overlay ibm-common-overlay ibm-overlay-alt-two\"><div class=\"ibm-head\"><p><a href=\"#close\" class=\"ibm-common-overlay-close\">关闭 [x]<\/a><\/p><\/div><div class=\"ibm-body\"><div class=\"ibm-main\"><div class=\"ibm-container ibm-alternate\"><div class=\"ibm-container-body\"><div class=\"codesection\"><pre class=\"displaycode no-auto-overflow\"># zypper ar -f http://download.opensuse.org/repositories/Cloud:/OpenStack:/Grizzly/SLE_11_SP3/Cloud:OpenStack:Grizzly.repo<\/pre><\/div><\/div><\/div><\/div><\/div><div class=\"ibm-footer\"><><\/div><\/div><p>然后，在控制器和计算节点上安装所需的 Nova 包。软件包管理实用工具应该自动安装所有依赖关系。<\/p><p>为了进行说明，我已经提供了适用于 Ubuntu、Red Hat (Red Hat Enterprise\n                Linux&#174;、CentOS、Fedora) 和 openSUSE 的主要命令： <\/p><ul class=\"ibm-bullet-list\"><li><strong>Ubuntu<\/strong>：在控制器节点上，运行：\n                        \n<p><a href=\"#N100F3\" class=\"ibm-popup-link\" onclick=\"ibmweb.overlay.show('N100F3',this);return false;\">点击查看代码清单<\/a><\/p><div id=\"N100F3\" class=\"dw-sidefile-overlay ibm-common-overlay ibm-overlay-alt-two\"><div class=\"ibm-head\"><p><a href=\"#close\" class=\"ibm-common-overlay-close\">关闭 [x]<\/a><\/p><\/div><div class=\"ibm-body\"><div class=\"ibm-main\"><div class=\"ibm-container ibm-alternate\"><div class=\"ibm-container-body\"><div class=\"codesection\"><pre class=\"displaycode no-auto-overflow\">sudo apt-get install nova-novncproxy novnc nova-api nova-ajax-console-proxy nova-cert nova-conductor nova-consoleauth nova-doc nova-scheduler nova-network<\/pre><\/div><\/div><\/div><\/div><\/div><div class=\"ibm-footer\"><><\/div><\/div><p>在计算节点上，运行：<\/p><div class=\"codesection\"><pre class=\"displaycode\">sudo apt-get install nova-compute nova-network\nsudo apt-get install glance<\/pre><\/div><\/li><li><strong>Red Hat<\/strong>：运行以下命令：\n                        \n<div class=\"codesection\"><pre class=\"displaycode\">sudo yum install openstack-nova \nsudo yum install openstack-glance<\/pre><\/div><\/li><li><strong>openSUSE<\/strong>：运行以下命令：\n                        \n<div class=\"codesection\"><pre class=\"displaycode\">sudo zypper install openstack-nova openstack-glance<\/pre><\/div><\/li><\/ul><h3 id=\"config\">配置<\/h3><p>Nova 配置包括几个文件，但最重要的是 nova.conf，它被安装在 /etc/nova\n                中。对于标准安装，一组默认选项就可以正常工作，但对于任何特殊要求，则需要编辑配置。您可以在这里查看 <a href=\"http://docs.openstack.org/havana/config-reference/content/compute-options.html\">nova.conf 文件格式<\/a>，并在此处查看 <a href=\"http://docs.openstack.org/havana/config-reference/content/list-of-compute-config-options.html\">nova.conf 配置选项列表<\/a>。<\/p><h2 id=\"usage_scenario\">使用场景<\/h2><p>要了解如何在实践中使用 OpenStack Compute，可以想象一下自己有一个想在 OpenStack\n                中加载的基本镜像。在配置系统并完成一些个性化的定制后，您可能想获得运行实例的快照，这样就可以加快配置过程，再次执行相同的任务。在完成项目后，您可能会停止实例，甚至可能想要删除镜像。<\/p><ol><li>以具有 Member 角色的用户身份登录到 OpenStack Dashboard。<\/li><li>在导航窗格中，在 Manage Compute 下面，单击 <strong>Images &amp;\n                    Snapshots<\/strong>，然后单击 <strong>Create Image<\/strong>。Create An Image\n                    窗口将会打开（图 2），您可以在该窗口中配置用于定义实例的设置。<\/li><li>输入之前创建或下载的镜像的名称和位置。您需要指定镜像文件的格式，但不需要指定最小磁盘空间或 RAM，除非您想提供它们??。\n<h5 id=\"fig2\">图 2. 创建一个镜像<\/h5><img alt=\"该图显示了 Create An Image 窗口\" src=\"/sunshine_new/images/负512245824/figure2.jpg\" width=\"716\" /><\/li><li>在创建镜像后，在 Manage Compute 下面，单击 <strong>Instances<\/strong>，然后单击\n                        <strong>Launch Instance<\/strong>。\n<h5 id=\"fig3\">图 3. 启动一个实例<\/h5><img alt=\"该图显示了 Launch Instance 窗口\" src=\"/sunshine_new/images/负512245824/figure3.jpg\" width=\"709\" /><\/li><li>系统会提供一个窗口，用于确认您的配置，并允许您指定所需的 Flavor（风格），或基本的硬件配置。单击\n                        <strong>Launch<\/strong>；该实例应该被启动并运行。<\/li><li>考虑拍摄一个快照。同样，在 Manage Compute 下面，单击\n                    <strong>Instances<\/strong>，然后在与感兴趣的实例有关联的行中单击 <strong>Create\n                        Snapshot<\/strong>。\n<h5 id=\"fig4\">图 4. 实例<\/h5><img alt=\"该图显示了 Instances 窗口\" src=\"/sunshine_new/images/负512245824/figure4.jpg\" width=\"845\" height=\"387\" /><p><a href=\"#N10154\" class=\"ibm-popup-link\" onclick=\"ibmweb.overlay.show('N10154',this);return false;\">点击查看大图<\/a><\/p><div id=\"N10154\" class=\"dw-sidefile-overlay ibm-common-overlay ibm-overlay-alt-two\"><div class=\"ibm-head\"><p><a href=\"#close\" class=\"ibm-common-overlay-close\">关闭 [x]<\/a><\/p><\/div><div class=\"ibm-body\"><div class=\"ibm-main\"><div class=\"ibm-title\"><h2>图 4. 实例<\/h2><\/div><div class=\"ibm-container ibm-alternate\"><div class=\"ibm-container-body\"><img alt=\"该图显示了 Instances 窗口\" src=\"/sunshine_new/images/负512245824/figure4.jpg\" width=\"1207\" /><\/div><\/div><\/div><\/div><div class=\"ibm-footer\"><><\/div><\/div><p>您可以在这个窗口中执行其他任务，包括编辑、暂停、挂起和重新启动实例。在使用完实例后，仍将在这里终止实例。<\/p><\/li><li>要删除镜像和任何快照，请回到 Images &amp; Snapshots 菜单，在这里可以找到用来删除不再需要的对象的选项。<\/li><\/ol><h5 id=\"fig5\">图 5. 镜像和快照<\/h5><img alt=\"该图显示了 Images &amp; Shapshots 窗口\" src=\"/sunshine_new/images/负512245824/figure5.jpg\" width=\"850\" height=\"425\" /><p><a href=\"#N10161\" class=\"ibm-popup-link\" onclick=\"ibmweb.overlay.show('N10161',this);return false;\">点击查看大图<\/a><\/p><div id=\"N10161\" class=\"dw-sidefile-overlay ibm-common-overlay ibm-overlay-alt-two\"><div class=\"ibm-head\"><p><a href=\"#close\" class=\"ibm-common-overlay-close\">关闭 [x]<\/a><\/p><\/div><div class=\"ibm-body\"><div class=\"ibm-main\"><div class=\"ibm-title\"><h2>图 5. 镜像和快照<\/h2><\/div><div class=\"ibm-container ibm-alternate\"><div class=\"ibm-container-body\"><img alt=\"该图显示了 Images &amp; Shapshots 窗口\" src=\"/sunshine_new/images/负512245824/figure5.jpg\" width=\"1214\" /><\/div><\/div><\/div><\/div><div class=\"ibm-footer\"><><\/div><\/div><h2 id=\"N10166\">结束语<\/h2><p>这就是开始使用 OpenStack Compute 功能所需的一切。在使用 OpenStack\n                计划并部署计算工作负载时，需要记住的重点是：它不是一个虚拟化平台，而是一个管理抽象，它允许您使用多种可插拔技术来跨多个虚拟机管理程序协调工作流。OpenStack\n                只简化了这些组件的管理和集成。<\/p><CMA ID: 972522><Site ID: 10><XSLT stylesheet used to transform this file: dw-document-html-7.0.xsl>\r\n\r\n\r\n<\/div>\r\n<\/div>\r\n","createTime":"2014-05-29 00:00:00","deployTime":"2014-05-29 00:00:00","id":0,"intro":"本文将介绍 OpenStack Compute (Nova) 和 Image (Glance) 项目，解释它们是如何融入整体 OpenStack 架构的，并展示它们的运作方式。本文在说明这些项目的过程中了解了如何安装、配置和使用各个组件。","keyword":"","recommend":false,"source":"http://www.ibm.com/developerworks/cn/cloud/library/cl-openstack-nova-glance/index.html","title":"发现\n            OpenStack: Compute 组件 Glance 和 Nova","typeId":0,"updateTime":"2014-05-29 00:00:00"}
{"author":"","clickNumber":0,"content":"\r\n<div class=\"ibm-columns\">\r\n<div class=\"ibm-col-1-1\">\r\n\r\n<h2 id=\"2.Objectives|outline\">目标<\/h2><p>在阅读完这篇文章后，您将具备必要的知识来：<\/p><ul class=\"ibm-bullet-list\"><li>理解自定义属性是如何存储在 Rational Team Concert 储存库中的。<\/li><li>如何在 Rational Team Concert 储存库中查看和定位自定义属性。<\/li><li>为每个自定义属性的数据类型创建 BIRT 数据集。<\/li><li>应用 JavaScript 代码到每个数据集来存储自定义属性。<\/li><li>显示自定义属性的值。<\/li><\/ul><h2 id=\"3.Prerequisites|outline\">先决条件<\/h2><div class=\"dw-sidebar ibm-inset\"><h2 id=\"N10073\">还没有 Rational Team Concert？<\/h2><p>下载试用版：<br /><a href=\"http://www.ibm.com/developerworks/cn/downloads/r/rtc/\">Rational Team Concert 客户端及 Rational Team Concert 服务器<\/a><\/p><\/div><p>本系列文章假设读者基本熟悉如何在 Rational Team Concert 中使用 BIRT 报表。包括如何创建报表，如何操作数据源和数据集，以及如何将表添加到报表中。这些主题都已包含在 IBM developerWorks 上的下列文章中。如果您不熟悉 Rational Team Concert 和 BIRT 中的报表，可以通过以下的文章先进行了解：<\/p><ul class=\"ibm-bullet-list\"><li><a href=\"http://www.ibm.com/developerworks/cn/rational/10/creatingcustomreportswithbirtandrtc-part1/\">使用 BIRT 和 Rational Team Concert 创建定制报表，第 1 部分: 基本报表<\/a><\/li><li><a href=\"http://www.ibm.com/developerworks/cn/rational/10/creatingcustomreportswithbirtandrtc-part2/\">使用 BIRT 和 Rational Team Concert 创建定制报表，第 2 部分: 复杂报表与固定数据集<\/a><\/li><li><a href=\"http://www.ibm.com/developerworks/cn/rational/10/creatingcustomreportswithbirtandrtc-part3/\">使用 BIRT 和 Rational Team Concert 创建定制报表，第 3 部分: 高级报表技术<\/a><\/li><\/ul><p>为了学习这些文章，您将需要一个 jazz.net 的免费帐户，以及 Rational Team Concert 服务器和 Rational Team Concert 客户端的完整版或试用版。<\/p><h2 id=\"4.Problemstatement|outline\">问题陈述<\/h2><p>标准和内置的 Rational Team Concert 属性存储在表的列中。然而，自定义的 Rational Team Concert 工作项属性存储在数据仓库中的通用 KEY 和 VAL 列中。这种方法是用来容纳工作项上将会存在的由用户定义的自定义属性。下面的例子显示了如何为一个缺陷工作项目存储 Phase、Release 和 Type 等三个自定义的字符串属性。<\/p><h3 id=\"4.1.Currentschemausedtostorecustomattributes|outline\">当前用来存储自定义属性的模式<\/h3><p>由于 Rational Team Concert 中不能动态地在数据库中为每个自定义属性创建列，为此，已经实现一个通用的存储机制，如表 1 所示。在表 1 中，三个自定义字符串属性被添加到一个工作项类型。对于两个具体的工作项目来说，三个自定义属性都共有六行检索到的行。对于每一个工作项目，为每个自定义属性存储一行。<\/p><h5 id=\"table1\">表 1. 当前自定义属性模式的例子<\/h5><table border=\"0\" cellpadding=\"0\" cellspacing=\"0\" class=\"ibm-data-table\" summary=\"\"><thead xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"><tr><th scope=\"col\">WI_ID<\/th><th scope=\"col\">STRING_KEY<\/th><th scope=\"col\">STRING_VAL<\/th><\/tr><\/thead><tbody xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"><tr><td>1<\/td><td>Phase<\/td><td>Development<\/td><\/tr><tr><td>1<\/td><td>Release<\/td><td>2.1<\/td><\/tr><tr><td>1<\/td><td>Type<\/td><td>Code Error<\/td><\/tr><tr><td>2<\/td><td>Phase<\/td><td>Testing<\/td><\/tr><tr><td>2<\/td><td>Release<\/td><td>2.5<\/td><\/tr><tr><td>2<\/td><td>Type<\/td><td>Bug<\/td><\/tr><\/tbody><\/table><h3 id=\"4.2.Idealschematostorecustomattributes|outline\">用来存储自定义属性的理想模式<\/h3><p>对实现 Rational Team Concert 中报表自定义属性来说最理想的表应包含存储在数据库中每个属性所包含的列。表 2 展示了该表的理想模式和布局。<\/p><h5 id=\"table2\">表 2. 一个理想的自定义属性模式的示例<\/h5><table border=\"0\" cellpadding=\"0\" cellspacing=\"0\" class=\"ibm-data-table\" summary=\"\"><thead xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"><tr><th scope=\"col\">WI_ID<\/th><th scope=\"col\">Phase<\/th><th scope=\"col\">Release<\/th><th scope=\"col\">Type<\/th><\/tr><\/thead><tbody xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"><tr><td>1<\/td><td>Development<\/td><td>2.1<\/td><td>Code Error<\/td><\/tr><tr><td>2<\/td><td>Testing<\/td><td>2.5<\/td><td>Bug<\/td><\/tr><\/tbody><\/table><h3 id=\"4.3.Locationofcustomattributes|outline\">自定义属性的位置<\/h3><p>表 3 概述了哪些字段包含了来自 Rational Team Concert 中数据仓库表的自定义属性。<\/p><h5 id=\"table3\">表 3. 所选择的自定义属性字段的位置<\/h5><table border=\"0\" cellpadding=\"0\" cellspacing=\"0\" class=\"ibm-data-table\" summary=\"\"><thead xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"><tr><th scope=\"col\">Strings<\/th><th scope=\"col\">Timestamps<\/th><th scope=\"col\">Integers<\/th><th scope=\"col\">Long<\/th><\/tr><\/thead><tbody xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"><tr><td>Data source<\/td><td colspan=\"4\">Jazz Data Source<\/td><\/tr><tr><td>Snapshot<\/td><td colspan=\"4\">WORKITEMS_SNAPSHOT<\/td><\/tr><tr><td>Data set<\/td><td colspan=\"4\">Advanced Data Set<\/td><\/tr><tr><td>Table name<\/td><td colspan=\"4\">LIVE_WORKITEM_CNT<\/td><\/tr><tr><td>Filter by<\/td><td colspan=\"4\">PROJECT_AREA_NAME<br />WI_TYPE<\/td><\/tr><tr><td>Column to select<\/td><td>STRING_KEY<br />STRING_VAL<\/td><td>TIMESTAMP_KEY<br />TIMESTAMP_VAL<\/td><td>INTEGER_KEY<br />INTEGER_VAL<\/td><td>LONG_KEY<br />LONG_VAL<\/td><\/tr><\/tbody><\/table><h2 id=\"5.SolutiontocreateaBIRTreportformultipleattributes|outline\">为多个属性创建一个 BIRT 报表的解决方案<\/h2><p>要为多个自定义属性创建自定义 BIRT 报表，请按照下列步骤操作：<\/p><ol type=\"1\"><li>创建全局变量来存储自定义属性数据。<\/li><li>为每个属性类型（例如，字符串、整数和时间戳）创建独立的高级数据集。<\/li><li>使用 JavaScript 来捕获和存储自定义属性数据。<\/li><li>创建一个最终的，主要的，汇总的数据集，以一种可用格式统一所有自定义的属性数据。<\/li><\/ol><h3 id=\"5.1.Createglobalvariablesinthereport|outline\">在报表中创建全局变量<\/h3><p>当您开始一个新的 BIRT 报表后，第一步是创建全局变量来存储自定义属性数据。为每一个自定义属性类型（字符串，整数，时间戳）创建一个单独的全局变量。<\/p><ol type=\"1\"><li>创建一个新的 BIRT 报表模板，并建立必要的数据源到您的 Rational Team Concert 的数据源设置中，在 BIRT 导航（Navigator）窗口中选择 <strong>Report<\/strong>。<\/li><li>从模板视图中，在底部选择 <strong>Script<\/strong> 选项卡来转到报表的 JavaScript 窗口。<\/li><li>在脚本选择的下拉菜单中，选择如图 1 所示的 <strong>initialize<\/strong> 类别。您在 <strong>initialize<\/strong> 初始化段落编写的代码将会在报表启动时执行。<\/li><li>依据属性类型创建新的对象来存储自定义属性。在这个例子中，您将为字符串和时间戳一同创建变量。将下面的代码放在初始化段落，如图 1 所示：<br /><code>\n  Strings = new Object();<br />\n  Timestamps = new Object();\n<\/code><\/li><\/ol><h5 id=\"5.1.2.Figure1.Initializethereportwithglobalvariables|outline\">图 1. 以全局变量初始化报表<\/h5><img alt=\"为字符串和时间戳创建变量\" src=\"/sunshine_new/images/19759421/image001.jpg\" width=\"680\" /><h3 id=\"5.2.Createaseparatedatasetforeachcustomattributetype|outline\">为每个自定义属性类型创建一个单独的数据集<\/h3><p>为每个自定义属性类型创建单独的高级数据集。在这个例子中，您将会把字符串和时间戳的自定义属性一同报表。因此，您需要创建两个高级数据集；一个用于字符串和一个用于时间戳。以下步骤假定您熟悉如何在 BIRT 中创建数据集，数据集将连接到相应的 Rational Team Concert 数据库。<\/p><a id=\"5.2.1.Createanadvanceddatasetforstrings|outline\"><\/a><p><strong>为字符串创建一个高级数据集<\/strong><\/p><p>为了给字符串的属性类型创建一个高级数据集，使用下列值，这些值也示于图 2：<\/p><ul class=\"ibm-bullet-list\"><li><strong>Table<\/strong>: LIVE_WORKITEM_CNT<\/li><li><strong>Columns to include<\/strong>: WI_ID, STRING_KEY, STRING_VAL<\/li><li><strong>Filter by<\/strong>: PROJECT_AREA_NAME and WI_TYPE<\/li><\/ul><h5 id=\"5.2.2.Figure2.Advanceddatasetforstrings|outline\">图 2. 字符串的高级数据集<\/h5><img alt=\"用来为字符串创建数据集的编辑窗口\" src=\"/sunshine_new/images/19759421/image002.jpg\" width=\"577\" /><a id=\"5.2.3.Advanceddatasetfortimestamps|outline\"><\/a><p><strong>时间戳的高级数据集<\/strong><\/p><p>为了给时间戳属性类型创建高级数据集，使用下列值，这些值也示于图 3：<\/p><ul class=\"ibm-bullet-list\"><li><strong>Table<\/strong>: LIVE_WORKITEM_CNT<\/li><li><strong>Columns to include<\/strong>: WI_ID, TIMESTAMP_KEY, TIMESTAMP_VAL<\/li><li><strong>Filter by<\/strong>: PROJECT_AREA_NAME and WI_TYPE<\/li><\/ul><h5 id=\"5.2.4.Figure3.Advanceddatasetfortimestamps|outline\">图 3. 时间戳的高级数据集<\/h5><img alt=\"用来为时间戳创建数据集的编辑窗口\" src=\"/sunshine_new/images/19759421/image003.jpg\" width=\"574\" /><h3 id=\"5.3.UseJavaScripttocaptureandstorethecustomattributedata|outline\">使用 JavaScript 来捕获和存储自定义属性数据<\/h3><p>在为字符串和时间戳自定义属性创建高级数据集后，使用 JavaScript 来存储数据到全局变量中的。在每个数据集里，取每个自定义属性值，并将其以数组的形式存储在一个相应的全局变量里。<\/p><a id=\"5.3.1.Fetchthecustomattributedataforthestringsadvanceddataset|outline\"><\/a><p><strong>为字符串高级数据集获取自定义属性数据<\/strong><\/p><ol type=\"1\"><li>选择我们所创建的字符串高级数据集，并选择如图 4 中的 <strong>Script<\/strong> 选项卡。<\/li><li>在 <strong>onFetch<\/strong> 脚本段落添加以下 JavaScript 代码：<br /><code>Strings[row[\"WI_ID\"] + row[\"STRING_KEY\"]] = row[\"STRING_VAL\"];<\/code><\/li><\/ol><h5 id=\"5.3.3.Figure4.JavaScriptforthestringsadvanceddataset|outline\">图 4. 用于字符串高级数据集的 JavaScript<\/h5><img alt=\"为字符串的 onFetch 创建脚本\" src=\"/sunshine_new/images/19759421/image004.jpg\" width=\"680\" /><a id=\"5.3.4.Fetchthecustomattributedataforthetimestampadvanceddataset|outline\"><\/a><p><strong>为时间戳高级数据集获取自定义属性数据<\/strong><\/p><ol type=\"1\"><li>选择我们创建的时间戳高级数据集，并访问 <strong>Script<\/strong> 选项卡，如图 5 所示。<\/li><li>在 <strong>onFetch<\/strong> 脚本段落添加以下 JavaScript 代码：<br /><code>Timestamps[row[\"WI_ID\"] + row[\"TIMESTAMP_KEY\"]] = row[\"TIMESTAMP_VAL\"];<\/code><\/li><\/ol><h5 id=\"5.3.6.Figure5.JavaScriptforthetimestampadvanceddataset|outline\">图 5. 用于时间戳高级数据集的 JavaScript<\/h5><img alt=\"用于时间戳 onFetch 的脚本\" src=\"/sunshine_new/images/19759421/image005.jpg\" width=\"683\" /><a id=\"5.3.7.ResultoftheJavaScriptusedtocaptureandstoredata|outline\"><\/a><p><strong>用于捕获和存储数据的 JavaScript 的结果<\/strong><\/p><p>当高级数据集中的每一行被取出时，每个自定义属性数据类型的数据被存储在全局一维数组中。例如，存储在表 1 中的下列信息，以 WI_ID 和 STRING_KEY 作为索引值的组合形式被存储在一维数组中。<\/p><h5 id=\"5.3.8.Listing4.Exampleofaglobal,one-dimensionalarray|outline\">清单 4. 一个全局一维数组的示例<\/h5><div class=\"codesection\"><pre class=\"displaycode\">\tStrings [1Phase] = \"Development\"\n\tStrings [1Release] = \"2.1\"\n\tStrings [1Type] = \"Code Error\"\n\tStrings [2Phase] = \"Testing\"\n\tStrings [2Release] = \"2.5\"\n\tStrings [2Type] = \"Bug\"<\/pre><\/div><p><strong>将数据绑定到报表中来运行 JavaScript<\/strong><\/p><p>为确保您所创建的 JavaScript 代码在报表显示时运行，您需要将一个动态文本元素绑定到该报表本身及其高级数据集上。<\/p><ol type=\"1\"><li>创建一个动态文本元素，并将其添加到报表中。<\/li><li>选择动态文本元素，然后选择 <strong>Binding<\/strong> 选项卡来设置一些数据绑定的参数。<\/li><li>在 <strong>Binding<\/strong>选项卡，选择字符串数据集，以确保字符串高级数据集在报表显示时会运行，如图 6 所示。<\/li><\/ol><h5 id=\"5.3.10.Figure6.Bindthedynamictexttothereport|outline\">图 6. 给报表绑定动态文本<\/h5><img alt=\"动态文本元素的绑定选项\" src=\"/sunshine_new/images/19759421/image006.jpg\" width=\"672\" /><ol start=\"4\"><li>隐藏动态文本元素，以便使之不在报表中显示。在选中 Dynamic Text 框后，访问 Visibility 设置，然后选择 <strong>Hide Element<\/strong>选项，如图 7。<\/li><\/ol><h5 id=\"5.3.11.Figure7.Hidethedynamictextbox|outline\">图 7. 隐藏动态文本框<\/h5><img alt=\"动态文本元素的可见性设置\" src=\"/sunshine_new/images/19759421/image007.jpg\" width=\"468\" /><h2 id=\"6.Displaythevaluesofthecustomattributes|outline\">显示的自定义属性的值<\/h2><p>我们已经创建了两个高级数据集用来存储的自定义属性的值。接下来，我们创建主数据集来以有组织的方式显示自定义属性。第一步是创建引用全局数组来显示相应自定义属性的计算列：<\/p><ol type=\"1\"><li>创建名为 Main 的最终高级数据集。<\/li><li>选择适当的列值。选择 <code>WI_ID<\/code> 的值，因为以下的步骤需要用到它。不要选择字符串或时间戳的 KEY 和 VAL 属性。<\/li><li>在 Main 高级数据集里创建一个计算列（Computed Column）。计算列是用来显示存储在全局数组的自定义属性的值。<\/li><li>在计算列，添加以下表达式来引用全局数组和必要的属性值：<br /><code>Strings[row[\"WI_ID\"] + \"&lt;id of custom attribute&gt;\"];<\/code><\/li><\/ol><p>在这个例子中，三个自定义属性有三个计算列：Phase、Release 及 Type，如图 8 所示。 <\/p><h5 id=\"6.0.1.Figure7.Computedcolumnsforstrings|outline\">图 8. 字符串的计算列<\/h5><img alt=\"设定计算列的属性\" src=\"/sunshine_new/images/19759421/image008.jpg\" width=\"773\" /><p><strong>注意：<\/strong><br />由于数组与报表布局绑定在一起，当您预览数据集中的结果时，这些字段显示空白。不过当您实际运行报表时，实际的值将会正确地显示。<\/p><p>在完成数据集之后，如图 8 所示，显示来自于 BIRT 报表的主数据集中的字段。上传您的报表到 Rational Team Concert 并运行报表。自定义属性将以有序的方式显示，如图 9 所示。<\/p><h5 id=\"6.0.2.Figure8.Completeddataset|outline\">图 9. 完整的数据集<\/h5><img alt=\"在报表 Data Explorer 中的数据集清单\" src=\"/sunshine_new/images/19759421/image009.jpg\" width=\"291\" /><h5 id=\"6.0.3.Figure9.Finalreportdisplay|outline\">图 10. 最终的报表显示情况<\/h5><img alt=\"最终的报表布局及显示情况\" src=\"/sunshine_new/images/19759421/image010.jpg\" width=\"566\" /><h2 id=\"7.Summary|outline\">总结<\/h2><p>这篇文章解释了如何捕获自定义属性的值并以有序的方式显示它们。通过使用这种方法，您可以轻松地基于您添加到 Rational Team Concert 的自定义属性创建报表。<\/p><h2 id=\"8.Acknowledgements|outline\">致谢<\/h2><p>本文作者要感谢自己队友 Amin Eskooch 和 Karen Steele 的支持和指导。作者同时也要感谢众多提供建议和支持 jazz.net 及 jazz.net 论坛的 Rational Jazz 社区成员。<\/p><CMA ID: 972620><Site ID: 10><XSLT stylesheet used to transform this file: dw-document-html-7.0.xsl>\r\n\r\n\r\n<\/div>\r\n<\/div>\r\n","createTime":"2014-05-29 00:00:00","deployTime":"2014-05-29 00:00:00","id":0,"intro":"IBM Rational Team Concert 帮助软件开发团队存储和组织大量的信息，包括工作计划与任务、构建和测试，以及源代码和其他文件。IBM Rational Team Concert 也可以进行定制，以配合项目团队的流程和数据采集的要求。本文演示了如何使用 Eclipse Business Information and Reporting Tools（BIRT）及 Rational Team Concert，来从多个自定义属性创建定制报表。","keyword":"","recommend":false,"source":"http://www.ibm.com/developerworks/cn/rational/create-custom-reports-birt-rtc/index.html","title":"使用 BIRT 和 Rational Team Concert 创建定制报表","typeId":0,"updateTime":"2014-05-29 00:00:00"}
{"author":"","clickNumber":0,"content":"\r\n<div class=\"ibm-columns\">\r\n<div class=\"ibm-col-1-1\">\r\n\r\n<h2 id=\"Introduction\">简介<\/h2><p>IBM&#174; HTTP Server (IHS) 将所有浏览器请求记录在 &lt;IHSInstalldir&gt;/logs 目录下的\n                access.log 文件中。访问日志中的信息对于解决会话管理问题、安全问题和性能问题至关重要。本文将介绍利用强大的 IHS 日志功能的一些实用技巧，使您能够更快地解决问题。<\/p><h2 id=\"Custom access logging\">设置自定义访问日志<\/h2><p>IHS（和 Apache&#174;）提供强大而又灵活的日志功能。通过使用主 IHS 配置文件 httpd.conf，您可以完全控制创建什么样的日志、请求在什么条件下被记录，以及记录哪些请求和响应属性。<\/p><p>定义一个新的日志程序的标准方法是创建一个格式，并为该格式指定一个昵称。本例显示了名称为 “common” 的格式，默认情况下会在 &lt;IHSInstalldir&gt;/conf 目录下的 httpd.conf 中定义它：<\/p><p><code>LogFormat \"%h %l %u %t \\\"%r\\\" %&gt;s %b\" common<\/code><\/p><h5 id=\"table1\">表 1. 在 \"common\" 格式中的注释<\/h5><table border=\"0\" cellpadding=\"0\" cellspacing=\"0\" class=\"ibm-data-table\" summary=\"Table using a heading element for the caption, all columns                 left-aligned\"><thead xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"><tr><th scope=\"col\">Common 格式<\/th><th scope=\"col\">描述<\/th><\/tr><\/thead><tbody xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"><tr><td><code>%h<\/code><\/td><td>远程主机 (IP)<\/td><\/tr><tr><td><code>%l<\/code><\/td><td>远程登录名称（来自 identd，如果已提供）。这返回 adash，除非 IdentityCheck 被设置为 On。（通常不会与 WC 一起使用）<\/td><\/tr><tr><td><code>%u<\/code><\/td><td>远程用户（通常不会与 WC 一起使用）<\/td><\/tr><tr><td><code>%t<\/code><\/td><td>接收到请求的时间（标准英文格式）<\/td><\/tr><tr><td><code>%r<\/code><\/td><td>请求的第一行（包括方法、URL 和协议）<\/td><\/tr><tr><td><code>%&gt;s<\/code><\/td><td>状态。对于在内部被重定向的请求，这是 *original* 请求的状态--- %...&gt;s 是最后的状态。<\/td><\/tr><tr><td><code>%b<\/code><\/td><td>响应的大小，以字节为单位，不包括 HTTP 标头。<\/td><\/tr><\/tbody><\/table><p>对于在 LogFormat 指令中可包含的格式字符串的详细列表，请参阅 <a href=\"#resources\">参考资料<\/a> 中所列出的 Apache 官方产品文档。<\/p><p>CustomLog 指令可以用于指定访问日志的位置，以及所使用的格式。CustomLog 指令示例使用 common 格式：\n                <code>CustomLog \"/httplogs/access.log\" common<\/code><\/p><p>您可以定义多个级别的自定义日志指令。例如，如果在虚拟主机内定义，则只有该虚拟主机的请求被记录。该指令还可以使用环境变量来控制是否记录某个特定的请求。有关 CustomLog 指令的详细信息，请参阅 <a href=\"#resources\">参考资料<\/a> 中所列出的 Apache 官方产品文档。<\/p><p>当您通过指定 CustomLog \"/httplogs/access.log\"\n                common 来使用 common 格式时，IHS 将会创建一个日志，类似于 <a href=\"#list1\">清单 1<\/a>：<\/p><h5 id=\"list1\">清单 1. 通过指定 CustomLog\n                \"/httplogs/access.log\" common 来使用 common 格式。<\/h5><div class=\"codesection\"><pre class=\"displaycode\">9.26.190.217 - - [20/Jul/2012:15:08:21 -0400] \"GET\n                /webapp/wcs/stores/servlet/en/madisons/electrical HTTP/1.1\" 200 334735\n9.26.190.217 - - [20/Jul/2012:15:36:20 -0400] \"GET\n                /wcsstore/ExtendedSitesCatalogAssetStore/images/Brake_Pad1-70.png\n                HTTP/1.1\" 200 3322<\/pre><\/div><a id=\"_Toc331024904\"><\/a><a id=\"__RefHeading__868_1994157604\"><\/a><h2 id=\"Tips\">故障排除技巧<\/h2><p>现在，您已经设置了自定义日志，这里有几个技巧，可帮助您利用 IHS 访问日志的最大优势。这些技巧的介绍顺序并没有特别的含义。<\/p><h2 id=\"Tip 1\">技巧 #1 - 记录响应时间<\/h2><p>在调试性能或时序问题时，记录每个请求的响应时间会非常有用。<\/p><p>通过将 ％D 添加到访问日志格式，服务器将会保存响应时间，以微秒为单位。例如：<\/p><p><code>LogFormat \"%h %l %u %t \\\"%r\\\" %&gt;s %b <strong>%D<\/strong>\" common<\/code><\/p><p><br />一微秒是百万分之一秒。这个指标通常太小，不实用；大多数人会选择使用毫秒。（毫秒数 = 微秒数/1000）<\/p><p>当使用通过 ％D 记录的值时，请记住，这些数字包括一个网络组件。％D 格式字符串计算时间，直到所有的响应字节都被传递到 IHS 系??统中的 TCP 层。如果存在网络或配置问题，访问日志中记录的值会比 WebSphere Commerce JVM 执行请求并将该请求返回给 IHS 中的插件组件所用的实际时间要高得多。<\/p><p>一般来说，％D 日志是一个很好的 JVM 性能参考，如果您怀疑这些数字相对于预期的 JVM 性能来说过高，那么您应该在 JVM 和网络层中启用其他监控。<\/p><p>有关 ％D 访问日志格式的更多详细信息，请参阅 <a href=\"#resources\">参考资料<\/a> 中列出的 IHS 官方产品文档。<\/p><h2 id=\"Tip 2\">技巧 #2 - 记录处理请求的 JVM<\/h2><p>在故障排除过程中，着可能有助于您了解哪个 JVM 处理了某个特定请求。记录 JVM 处理请求的方式有多种。两种最流行的方式是处理 %{WAS}e 环境变量，或使用 JESSIONID cookie。<\/p><h3 id=\"Using the WAS environment variable 1\">使用 %{WAS}e 环境变量<\/h3><p>对于那些使用 WebSphere 插件处理的请求，插件模块创建了一个名为 WAS 的环境变量，其中包含处理请求的服务器。通过将以下代码添加到 LogFormat 语句，可将 WAS 环境变量记录在访问日志中：%{WAS}e。<\/p><p><code>LogFormat \"%h %l %u %t \\\"%r\\\" %&gt;s %b %{WAS}e\" common<\/code><\/p><p><br />在添加 %{WAS}e 时，用于服务请求的 JVM 的主机名和传输端口号被记录下来。例如，\"app1.torolab.ibm.com:9091\"。<\/p><h3 id=\"Using the JSESSIONID cookie\">使用\n                JSESSIONID cookie<\/h3><p>JSESSIONID 是 WebSphere 用于会话管理的 cookie 的默认名称。此 cookie 有两个组件，一个惟一的 ID，后跟一个克隆 ID。克隆 ID 集群中惟一地标识一个 JVM。例如：<code>JSESSIONID=0000r2yG7KvBKWaTMUv-5IsCMC7:n1s1br/<\/code>。通过使用 %{JSESSIONID}C 在访问日志中记录 JSESSIONID cookie，还可以在日志中提供标识 JVM 的克隆 ID。然后，通过使用 plugin-cfg.xml 配置文件，您可以找到与克隆 ID 有关联的 JVM。<br /><a href=\"#listing2\">清单 2<\/a> 显示，CloneID n1s1 被映射到在主机 app1.torolab.ibm.com 的端口 9109 上运行的 JVM。<\/p><h5 id=\"listing2\">清单 2. Clone ID n1s1<\/h5><div class=\"codesection\"><pre class=\"displaycode\">&lt;Server CloneID=\"n1s1\" ConnectTimeout=\"0\" ExtendedHandshake=\"false\"\nLoadBalanceWeight=\"2\" MaxConnections=\"-1\"\nName=\"WC_demo_node_node1_server2\" ServerIOTimeout=\"0\"\nWaitForContinue=\"false\"&gt;\n&lt;Transport Hostname=\"app1.torolab.ibm.com\" Port=\"9109\" Protocol=\"http\"/&gt;\n&lt;/Server&gt;<\/pre><\/div><p>由于默认克隆 ID 可能很难记住，您可以使用 HttpSessionCloneId 自定义属性为 JVM 分配一个新的克隆 ID。不要使用过于描述性的名称来命名克隆 ID，因为这可能会产生安全问题。有关使用 HTTPSessionClondId 的更多信息，请参见 <a href=\"#resources\">参考资料<\/a>。<\/p><p><a href=\"#Figure1\">图 1<\/a> 显示了 HttpSessionCloneId 会话管理的自定义属性的设置，用于设置一个新的克隆 ID。<\/p><h5 id=\"Figure1\">图 1. 设置 HttpSessionCloneId 自定义属性<\/h5><img alt=\"图 1 显示了 HttpSessionCloneId 会话管理自定义属性的设置，用于设置一个新的克隆 ID。\" src=\"/sunshine_new/images/2134419356/Figure-2.jpg\" width=\"580\" /><p>使用 JSESSIONID cookie 确定 JVM 的优点是：cookie 告诉 JVM，您正在浏览器中使用它（通过检查 cookie）。缺点是：在每个会话的第一个请求中，都会缺少此 cookie，如果请求被故障转移到另一个 JVM，那么克隆 ID 可能是不正确的。<\/p><h2 id=\"Tip 3\">技巧 #3 C 关联请求<\/h2><p>对于性能分析，或在一般的故障排除过程中，往往需要识别属于某个特定用户或会话的所有请求。下面介绍的技巧包括使用客户端 IP、JSESSIONID 或 WebSphere Commerce 会话管理 cookie。<\/p><h3 id=\"clientIP\">使用客户端 IP<\/h3><p>默认的格式包括使用远程主机 (%h) 作为访问日志中的第一个元素。使用客户端 IP 是识别来自单一数据源的请求的常用方法。<br />在使用负载均衡器时，所报告的 IP 有可能是负载平衡器的 IP。可能需要进行额外的配置才能改为记录真实客户端的 IP。<\/p><h3 id=\"JESSIONID\">使用 JSESSIONID cookie<\/h3><p><br />如前面所述，JSESSIONID cookie 可用来惟一地标识某个会话。“Grepping”含特定 JSESSIONID 值的日志是一种常见的技巧，用于提取属于同一会话的请求。<\/p><h3 id=\"Using WebSphere Commerce session management cookies\">使用 WebSphere Commerce 会话 cookie<\/h3><p>WebSphere Commerce 有自己的一组会话管理 cookie，比如\n                WC_AUTHENTICATION_&lt;userID&gt;、WC_USERACTIVITY_&lt;userID&gt; 或\n                WC_PERSISTENT，也使用它们来请求关联。<\/p><p><br />使用 WebSphere Commerce 会话管理 cookie 进行关联的优点是，它们包含实际的 WebSphere Commerce 用户 ID，这使您能够识别来自某个特定非泛型用户的请求。<\/p><p><a href=\"#listing3\">清单 3<\/a> 显示了如何从 WC_USERACTIVITY cookie 的名称中提取用户 ID。<\/p><h5 id=\"listing3\">清单 3. 提取用户 ID<\/h5><div class=\"codesection\"><pre class=\"displaycode\">SetEnvIf Cookie \"WC_USERACTIVITY_(\\d+|-\\d+)=\" wcUserId=$1\nSetEnvIf wcUserId ^$ wcUserId=-1002\nLogFormat \"%h %l %u %t \\\"%r\\\" %&gt;s %b %{wcUserId}e\" user\nCustomLog \"/httplogs/user_log\" user<\/pre><\/div><p><strong>备注<\/strong>：<a href=\"listing3\">清单 3<\/a> 假设存在单一 WC_USERACTIVITY cookie。有些场景（比如多个存储）中可以有多个有效的活动 cookie。<\/p><h2 id=\"Tip 4\">技巧 #4 - 限制所记录的请求的数量<\/h2><p>Web 服务器通常不仅处理由应用服务器进行处理的动态请求，还可以处理静态内容，比如图片、css、js 文件等。由于默认情况下会记录所有的请求，对于繁忙的站点，访问日志会迅速增长，产生难以管理的大型日志。<\/p><p>IHS 提供的配置选项可以筛选所记录的请求。管理员可以使用这些选项，仅记录从 WebSphere Commerce JVM 提供的服务请求，或在一个单独的文件中记录这些请求。这可以大大缩小日志，并简化分析。<\/p><p>使用下面的技术来限制所记录的请求：<\/p><h3 id=\"Using the WAS environment variable 2\">使用 WAS 环境变量<\/h3><p>对于那些被转发到 WebSphere JVM 的请求，插件模块创建了一个名为 \"WAS\" 的环境变量，其中包含处理请求的 JVM 的名称。然后，可以使用该变量作为记录请求的条件。如果没有为请求定义变量（这意味着它不是由 WebSphere Application Server 处理），则不记录该日志条目。<\/p><p><code>LogFormat \"%h %l %u %t \\\"%r\\\" %&gt;s %b\" custom<\/code><\/p><p><code>CustomLog logs/access.log common <strong>env=WAS<\/strong><\/code><\/p><h3 id=\"Logging requests that have a particular root\">记录具有特定根的请求<\/h3><p>下面的示例说明了如何记录以一个 common 上下文根开头的请求：<\/p><div class=\"codesection\"><pre class=\"displaycode\">SetEnvIf Request_URI \"^/shop/\" storereq\nCustomLog logs/access.log common env=storereq<\/pre><\/div><h3 id=\"Excluding files with specific extensions\">排除带有特定扩展名的文件<\/h3><p><a href=\"#listing4\">清单 4<\/a> 显示了如何排除特定扩展名，如图片：<\/p><h5 id=\"listing4\">清单 4. 排除扩展名<\/h5><div class=\"codesection\"><pre class=\"displaycode\">SetEnvIf Request_URI \\.gif nolog\nSetEnvIf Request_URI \\.jpg nolog\nCustomLog logs/access.log combined env=!nolog<\/pre><\/div><h3 id=\"Defining logs at the virtual host level\">在虚拟主机级别上定义日志<\/h3><p>默认情况下，日志是在根级别定义的，这意味着它们适用于所有的虚拟主机。如果在虚拟主机定义中移动 CustomLog 条目，日志只适用于该虚拟主机的请求。这种技术可以用来为 SSL 和非 SSL 创建单独的日志，或者为工具创建单独的日志。<\/p><p><a href=\"#listing5\">清单 5<\/a> 显示了如何在 8002 虚拟机中创建 cmc.log 日志：<\/p><h5 id=\"listing5\">清单 5. 在 8002 虚拟机中定义 cmc.log 日志<\/h5><div class=\"codesection\"><pre class=\"displaycode\">&lt;VirtualHost app01.torolab.ibm.com:8002&gt;\nSSLEnable\nSSLClientAuth 0\nServerName mystore.torolab.ibm.com\nAlias   /adminconsole \"/app/profiles/demo/\ninstalledApps/WC_demo_cell/WC_demo.ear/SiteAdministration.war/tools/adminconsole/\n    wcsadmincon.html\"\nAlias   /wcsstore \"/app/profiles/demo/installedApps/WC_demo_cell/WC_demo.ear/Stores.war\"\nAlias   /wcadmin \"/app/profiles/demo/installedApps/WC_demo_cell/WC_demo.ear/\n    SiteAdministration.war\"\nCustomLog logs/cmc.log common\n&lt;/VirtualHost&gt;<\/pre><\/div><p>如果您在根级别上维护日志定义，可通过添加 ％p 将端口号添加到日志格式，这非常有用。％p 表示在请求中使用的典型端口，您可以用它来区分来自 WebSphere Commerce 工具的请求与存储的请求，或者区分 HTTP 请求与 HTTPS 请求。<\/p><h2 id=\"Tip 5\">技巧 #5 - 在页面使用 Dynacache 服务时进行记录<\/h2><p>对于性能分析，知道是否从缓存返回了一个页面非常重要。从 WebSphere Application Server V7.0.0.11 开始，如果使用 DynaCache 在 servlet 或整页缓存级别缓存响应，那么 JVM 会在日志中增加了一个响应标头，其名称为 CACHED_RESPONSE。有关 DynaCache 的更多信息，请参阅 <a href=\"#resources\">参考资源<\/a> 中的文档页面。<\/p><p>这个标头可以添加到访问日志中，如以下示例所示：<\/p><p><code>%{CACHED_RESPONSE}o<\/code>。<\/p><p>如果从缓存检索页面，那么日志将会添加 “yes”。如果标头缺失，该日志会改为添加一个破折号 (-)。<\/p><h2 id=\"Tip 6\">技巧 #6 - 记录请求和响应 cookie<\/h2><p>日志请求和响应 cookie 对于故障排除会话管理问题非常有用。记录请求和响应 cookie 会让日志变得大很多。不过，这个选项仍然比在应用服务器层启用跟踪要轻巧一些。要记录请求和响应 cookie，可在 httpd.conf 中添加以下参数，以便在访问日志中将更多信息添加到 cookie：<\/p><h5 id=\"table2\">表 2. httpd.conf 参数<\/h5><table border=\"0\" cellpadding=\"0\" cellspacing=\"0\" class=\"ibm-data-table\" summary=\"\"><thead xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"><tr><th scope=\"col\">参数<\/th><th scope=\"col\">描述<\/th><\/tr><\/thead><tbody xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"><tr><td style=\"text-align:left\"><code>{Cookie}i<\/code><\/td><td style=\"text-align:left\"> 将 cookie 的请求标头添加到日志。<\/td><\/tr><tr><td style=\"text-align:left\"><code>{Set-Cookie}o<\/code><\/td><td style=\"text-align:left\"> 将包含响应的 cookie 添加到日志。<\/td><\/tr><\/tbody><\/table><p>如果您只关心特定的请求 cookie，那么可以使用\n                <code>%{COOKIE}C<\/code> 格式代替它。这种做法不能与名称中包括用户 ID 的 WebSphere Commerce cookie 配合使用，比如\n                <code>WC_USERACTIVITY_&lt;number&gt;<\/code>。<\/p><h2 id=\"Tip 7\">技巧 #7 - 创建一个可解析的日志格式<\/h2><p>如果没有正确定义日志格式，则很难解析或拆分不同元素来分析它们。要创建一个可分析性更强的日志格式，您需要在创建日志格式的每一步中考虑将如何分析该格式。虽然 grep 等工具通常用于在日志中查找关键字，但这些工具可能会帮助您找到自己需要分析的那一部分，但将日志导入数据库表或执行脚本将会实现更深入的分析。<\/p><p>例如，如果您计划将访问日志加载到数据库表中，那么您可以将日志格式配置为用引号包围值，并用逗号分隔它们，以便使用支持 CSV 格式的标准导入工具将日志直接加载到数据库表中。如果不使用引号和逗号，则很难将访问日志加载到数据库中。<a href=\"#listing6\">清单 6<\/a> 演示了如何使用引号和逗号：<\/p><h5 id=\"listing6\">清单 6. 在日志中使用逗号和引号<\/h5><div class=\"codesection\"><pre class=\"displaycode\">LogFormat \"\\\"%h\\\",\\\"%{%Y-%m-%d-%H.%M.%S.000000}t\\\",%p,\\\"%H\\\",\\\"%m\\\",\\\"%U\\\",\n                    \\\"%q\\\",%&gt;s,\\\"%b\\\",\\\"\n%{WAS}e\\\",%D,\\\"%{CACHED_RESPONSE}o\\\"\" csv\n\nCustomLog \"/httplogs/access_csv\" csv<\/pre><\/div><p>使访问日志的可分析性更强的另一个选项是实现自己的自定义工具。在网络上有很多不同的库，它们可帮助您解析访问日志文件。例如，对于 Perl 应用程序，Apache::LogRegex 库可以解析给定 LogFormat 的日志条目。有关 Apache::LogRegex 的更多信息，请参见 <a href=\"#resources\">参考资料<\/a>。\n<a href=\"#listing7\">清单 7<\/a> 演示了如何使用 Apache::LogRegex 库从一个日志条目中检索 ％D 的值：<\/p><h5 id=\"listing7\">清单 7. 从一个日志条目中检索 ％D<\/h5><div class=\"codesection\"><pre class=\"displaycode\">my $lr = Apache::LogRegex-&gt;new($log_format);\n....\n# For each line\nmy %parsed_data = $lr-&gt;parse($line);\nprint \"Response Time = \" .$parsed_data{\"%D\"};<\/pre><\/div><h2 id=\"Tip 8\">技巧 #8 C 实现日志循环<\/h2><p>鉴于访问日志的增长速度，您可以设置日志循环，让它不断地写入指定日志大小的多个日志。IHS 包括 rotatelogs 实用程序，该应用程序可以根据时间间隔或大小自动循环。<br />本例显示，每当当前日志的大小达到 00 时就会创建一个新的日志： <code>MB:CustomLog\n                \"|bin/rotatelogs /httplogs/access.log 500M\" common<\/code><\/p><p>有关如何配置和使用日志循环的更多信息，请参阅 <a href=\"#resources\">参考资料<\/a> 中列出的 Apache 产品文档。Apache 文档还提到了 cronolog 工具，这是一个更灵活的选项。如欲了解有关的更多信息，请参阅 <a href=\"#resources\">参考资料<\/a> 中列出的该工具的主页。除了日志循环之外，您还可以实现更多（cron）脚本来压缩、归档和删除旧日志。<\/p><h2 id=\"Tip 9\">技巧 #9 - 记录压缩统计信息<\/h2><p>大多数访问日志格式都包括 ％b，这是响应的大小，以字节为单位，有助于识别非常大的响应。<\/p><p>由于大多数站点启用了压缩 (mod_deflate)，%b 显示了在完成压缩后的响应的大小，而不是它原来的大小。有关 mod_deflate 模块的更多详细信息，请参阅 <a href=\"#resources\">参考资料<\/a>。<\/p><p><a href=\"#listing8\">清单 8<\/a> 显示了如何将压缩后的大小、未压缩的大小和压缩比添加到访问日志：<\/p><h5 id=\"listing8\">清单 8. 将压缩后的大小、未压缩的大小和压缩比添加到访问日志<\/h5><div class=\"codesection\"><pre class=\"displaycode\">DeflateFilterNote Input instream&gt;\nDeflateFilterNote Output outstream&gt;\nDeflateFilterNote Ratio ratio&gt;\nLogFormat \"%h %l %u %t \\\"%r\\\" %&gt;s %b %{outstream}n/%{instream}n(%{ratio}n%%)\"<\/pre><\/div><h2 id=\"Conclusion\">结束语<\/h2><p>凭借本文中的技巧，您可以利用 IBM HTTP 服务器强大的访问日志功能。这些技巧提供了性能分析、安全性和故障排除的可能性，有助于您管理自己的日志并从中提取信息。<\/p><CMA ID: 972642><Site ID: 10><XSLT stylesheet used to transform this file: dw-document-html-7.0.xsl>\r\n\r\n\r\n<\/div>\r\n<\/div>\r\n","createTime":"2014-05-29 00:00:00","deployTime":"2014-05-29 00:00:00","id":0,"intro":"本文讨论 WebSphere Commerce 站点的 IHS 访问日志特性的优化。优化的日志特性有助于对一般的问题进行故障排除，并分析性能和安全问题，比如确定响应时间、响应 cookie 和限制请求的数量。","keyword":"","recommend":false,"source":"http://www.ibm.com/developerworks/cn/commerce/library/co-websphere-access-feature/index.html","title":"使用 WebSphere Commerce 站点的 IHS Access Log 特性的技巧","typeId":0,"updateTime":"2014-05-29 00:00:00"}
{"author":"","clickNumber":0,"content":"\r\n<div class=\"ibm-columns\">\r\n<div class=\"ibm-col-1-1\">\r\n\r\n<h2 id=\"2. 引言|outline\">引言<\/h2><p>Cognos BI 10.2.1 是 Cognos\n                家族的最新产品，无论是趋于完善的人性化界面，大数据处理能力和性能的提升，功能的扩展和丰富，还是对新数据源和新使用平台的扩展支持，都给人耳目一新的感觉。Power\n                系统是 IBM 主流的服务器产品，在业内很受欢迎并有着广泛使用，而 Cognos 和 Power 系统官方网站都没有任何针对在 Power\n                Linux 上如何安装和使用 Cognos 的文章。本文旨在介绍如何在 Power Linux 上准备和搭建 Cognos BI 10.2.1\n                的数据分析环境，为基于 PLinux 的 Cognos 用户提供参考和带来帮助。<\/p><h5 id=\"2.0.1. 表 1. Cognos 10.2.1 功能、特性和模块列表|outline\">表 1. Cognos 10.2.1 功能、特性和模块列表<\/h5><table border=\"0\" cellpadding=\"0\" cellspacing=\"0\" class=\"ibm-data-table\"><thead xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"><tr><th>功能<\/th><th>说明<\/th><\/tr><\/thead><tbody xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"><tr><td><strong>报表<\/strong><\/td><td> 为用户提供根据事实制定决策所需的数据信息。<\/td><\/tr><tr><td><strong>仪表板<\/strong><\/td><td> 帮助用户以支持其制定决策的方式来访问内容、与之交互，并对其进行个性化设置。<\/td><\/tr><tr><td><strong>分析<\/strong><\/td><td> 功能使您能够从多个角度和方面对信息进行访问，从而可以查看和分析信息，帮助您做出明智的决策。<\/td><\/tr><tr><td><strong>协作<\/strong><\/td><td> 功能包括通信工具和社交网络，用于推动决策过程中的意见交流。<\/td><\/tr><tr><td><strong>记分卡<\/strong><\/td><td> 功能可实现业务指标的捕获、管理和监控的自动化，使您可将这些指标与自己的战略和运营目标进行比较。<\/td><\/tr><tr><td><strong>数据查询<\/strong><\/td><td> 支持多样的数据源连接、查询和建模方式，支持海量数据，响应时间迅速。<\/td><\/tr><\/tbody><\/table><h2 id=\"3. 环境准备|outline\">环境准备<\/h2><p>在安装 Cognos 之前，我们需要在 Power Linux 上做环境的准备，比如安装 VNC、JAVA 和 Cognos BI 10.2.1\n                所需的依赖包。<\/p><h3 id=\"3.1.VNC 安装|outline\">VNC 安装<\/h3><p>Cognos 的安装需要 UI 界面的支持，所以为了远程访问 Power Linux 系统，我们需要安装和启动 VNC Server。关于\n                PLinux 所需的软件安装包，可以从 <a href=\"https://ftp3.linux.ibm.com/\">https://ftp3.linux.ibm.com<\/a> 站点下载，基本上所需的软件都能找到。以 RED HAT 为例，从 <a href=\"https://ftp3.linux.ibm.com/\">https://ftp3.linux.ibm.com<\/a> 下载\n                    <a href=\"https://ftp3.linux.ibm.com/dl.php?file=/redhat/ibm-yum.sh\">ibm-yum.sh<\/a> 脚本，然后所需的基本软件包的下载和安装都可以用这个 SHELL 脚本完成。<\/p><p>在命令行输入 <code>sh ibm-yum.sh install vnc-server 命令。<\/code><\/p><h5 id=\"3.1.1. 图 1. ibm-yum.sh 使用|outline\">图 1.\n                    ibm-yum.sh 使用<\/h5><img alt=\"图 1. ibm-yum.sh 使用\" src=\"/sunshine_new/images/负2032369742/img001.png\" width=\"576\" /><p>同样运行以下命令\n                <code>sh ibm-yum.sh install gnome-session<\/code>，<code>安装 <\/code>VNC<code> 的图形界面支持。<\/code>之后需要用\n                GNOME 初始化图形界面，运行命令 <code>vi /root/.vnc/xstartup <\/code>在 VI 编辑器中，更改 VNC\n                启动设置如下。<\/p><h5 id=\"3.1.2. 清单 1. VNC 启动配置|outline\">清单 1. VNC\n                    启动配置<\/h5><div class=\"codesection\"><pre class=\"displaycode\">#!/bin/sh\n# Uncomment the following two lines for normal desktop: # unset SESSION_MANAGER\n# exec /etc/X11/xinit/xinitrc\n[ -x /etc/vnc/xstartup ] &amp;&amp; exec /etc/vnc/xstartup\n[ -r $HOME/.Xresources ] &amp;&amp; xrdb $HOME/.Xresources\nxsetroot -solid grey\nvncconfig -iconic &amp;\nxterm -geometry 80x24+10+10 -ls -title \"$VNCDESKTOP Desktop\" &amp;\nunset SESSION_MANAGER\nexec /etc/X11/xinit/xinitrc\ngnome-session\n#kde &amp;<\/pre><\/div><p>最后运行 <code>vncserver :1<\/code> 命令，设置 password 并启动 VNC<\/p><h5 id=\"3.1.3. 图 2. VNC Server 启动|outline\">图 2. VNC\n                    Server 启动<\/h5><img alt=\"图 2. VNC Server 启动\" src=\"/sunshine_new/images/负2032369742/img002.png\" width=\"575\" /><p>之后我们就可以用 VNC 客户端远程访问 Power Linux。<\/p><h5 id=\"3.1.4. 图 3. VNC 界面|outline\">图 3. VNC\n                    界面<\/h5><img alt=\"图 3. VNC 界面\" src=\"/sunshine_new/images/负2032369742/img003.png\" width=\"576\" /><h3 id=\"3.2.JRE 安装|outline\">JRE 安装<\/h3><p>Cognos BI 10.2.1 需要高版本的 JRE 的支持，例如 JRE6.0 或 JRE7.0，以 RED HAT 为例，同理我们可以运行命令\n                <code>sh ibm-yum.sh install java<\/code> 来安装 JRE。安装完成后，记得配置 JAVA_HOME\n                环境变量。<\/p><h5 id=\"3.2.1. 清单 2. JAVA 环境变量配置|outline\">清单 2. JAVA\n                    环境变量配置<\/h5><div class=\"codesection\"><pre class=\"displaycode\">export JAVA_HOME=/usr/lib/jvm/java-1.7.0-ibm-1.7.0.5.0.ppc64/jre<\/pre><\/div><h3 id=\"3.3.Cognos 依赖包|outline\">Cognos\n                依赖包<\/h3><p>在 Power Linux 上安装和运行 Cognos BI\n                10.2.1，需要提前安装一些依赖软件包。所需的所有软件包都列在了以下表格中，当然我们也可以到 Cognos 网站查询所需的依赖包：<a href=\"http://www-01.ibm.com/support/docview.wss?uid=swg27014432\">http://www-01.ibm.com/support/docview.wss?uid=swg27014432<\/a>。<\/p><h5 id=\"3.3.1. 表 2. Cognos 10.2.1 在 Power Linux 安装所需要的依赖包|outline\">表\n                    2. Cognos 10.2.1 在 Power Linux 安装所需要的依赖包<\/h5><table border=\"0\" cellpadding=\"0\" cellspacing=\"0\" class=\"ibm-data-table\"><thead xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"><tr><th>No.<\/th><th>RPM 安装包<\/th><\/tr><\/thead><tbody xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"><tr><td> 1 <\/td><td> glibc-2.12-1.25.el6.ppc <\/td><\/tr><tr><td> 2 <\/td><td> libstdc++-4.4.5-6.el6.ppc <\/td><\/tr><tr><td> 3 <\/td><td> nspr-4.8.7-1.el6.ppc <\/td><\/tr><tr><td> 4 <\/td><td> nss-3.12.9-9.el6.ppc <\/td><\/tr><tr><td> 5 <\/td><td> openmotif-2.3.3-1.el6.ppc <\/td><\/tr><tr><td> 6 <\/td><td> vacpp.rte-8.0.0-4.ppc64 <\/td><\/tr><\/tbody><\/table><p>除了 vacpp.rte-8.0.0-4.ppc64，其它的都可以用 ibm-yum.sh 脚本从 <a href=\"https://ftp3.linux.ibm.com/\">IBM ftp3<\/a> 网站安装。<\/p><p>我们可以从 <a href=\"https://www-304.ibm.com/support/docview.wss?uid=swg24030460\">https://www-304.ibm.com/support/docview.wss?uid=swg24030460<\/a> 获得和下载\n                vacpp.rte-8.0.0-4.ppc64 安装包。<\/p><p>解压后，用 RPM 命令 <code>rpm -ivh ./vacpp.rte-xxx.ppc64.rpm<\/code> 安装该依赖包。<\/p><h5 id=\"3.3.2. 图 4. RPM 包安装|outline\">图 4. RPM\n                    包安装<\/h5><img alt=\"图 4. RPM 包安装\" src=\"/sunshine_new/images/负2032369742/img004.png\" width=\"576\" /><h3 id=\"3.4.Apache HTTP Server 安装|outline\">Apache HTTP Server 安装<\/h3><p>Cognos BI 需要 HTTP Server 作为 WEB 访问的 UI 容器。这里以 Apache HTTP Server 为例。我们可以从\n                Apache 的网站 <a href=\"http://httpd.apache.org/download.cgi\">http://httpd.apache.org/download.cgi<\/a> 下载最新版本来安装，也可以继续使用 ibm-yum.sh\n                脚本从 <a href=\"https://ftp3.linux.ibm.com/\">IBM ftp3<\/a> 网站安装。<\/p><p>运行命令 <code>sh ibm-yum.sh install httpd<\/code> 安装 HTTP。安装完成后，可以用\n                <code>apachectl<\/code> 命令来起停 HTTP Server。<\/p><h5 id=\"3.4.1. 清单 3. HTTP Server 启动和停止|outline\">清单 3.\n                    HTTP Server 启动和停止<\/h5><div class=\"codesection\"><pre class=\"displaycode\">[root@netsr56 sbin]# ./apachectl start\n[root@netsr56 sbin]# ./apachectl stop<\/pre><\/div><h3 id=\"3.5. 数据库安装|outline\">数据库安装<\/h3><p>Cognos BI 需要数据库作为数据源，Cognos 10.2.1 更是增加了对 DB2 10.5 的支持，这里就以 IBM 的 DB2 为例。从\n                IBM 网站，下载 DB2 并解压，然后用 VNC 进入 Power Linux 的界面，到 DB2 解压目录，运行命令\n                <code>./db2setup<\/code> 启动安装界面。<\/p><h5 id=\"3.5.1. 图 5. DB2 安装界面|outline\">图 5. DB2\n                    安装界面<\/h5><img alt=\"图 5. DB2 安装界面\" src=\"/sunshine_new/images/负2032369742/img005.png\" width=\"576\" /><p>然后按照提示，一步一步完成安装，唯一需要注意的是记住创建的 DB2 用户密码，登录的时候要用到。看到如下界面，说明安装成功。<\/p><h5 id=\"3.5.2. 图 6. DB2 安装成功界面|outline\">图 6. DB2\n                    安装成功界面<\/h5><img alt=\"图 6. DB2 安装成功界面\" src=\"/sunshine_new/images/负2032369742/img006.png\" width=\"576\" /><h2 id=\"4.Cognos BI 产品安装|outline\">Cognos BI\n                产品安装<\/h2><p>在环境准备完成之后，我们就可以进入 Cognos BI 的具体安装和配置过程。<\/p><h3 id=\"4.1.BI Server 安装|outline\">BI Server\n                安装<\/h3><p>从 IBM 网站，下载 Cognos BI 10.2.1 的安装包。解压后运行命令 <code>./issetup<\/code> 启动 Cognos\n                10.2.1 与旧版本完全不同的安装界面。另外 Cognos BI 10.2.1 的默认安装是不包含 Content Store\n                数据库的，这个步骤需要在 Cognos BI Server 配置和初次启动时完成。<\/p><h5 id=\"4.1.1. 图 7. Cognos BI Server 安装界面|outline\">图\n                    7. Cognos BI Server 安装界面<\/h5><img alt=\"图 7. Cognos BI Server 安装界面\" src=\"/sunshine_new/images/负2032369742/img007.png\" width=\"575\" /><p>然后按照提示，一步一步默认安装。安装完成界面出现后，需要从 DB2 安装目录 /home/db2inst1/sqllib/java 目录 复制 DB2\n                的 JDBC 到 Cognos 的目录下。<\/p><h5 id=\"4.1.2. 清单 4. DB2 JDBC Driver 的复制|outline\">清单\n                    4. DB2 JDBC Driver 的复制<\/h5><div class=\"codesection\"><pre class=\"displaycode\">cp ./db2jcc.jar /opt/ibm/cognos/c10_64/webapps/p2pd/WEB-INF/lib/\ncp ./db2jcc_license_cu.jar /opt/ibm/cognos/c10_64/webapps/p2pd/WEB-INF/lib/<\/pre><\/div><p>然后选择 Start IBM Cognos Configuration 选项，点击 Finish 按钮来完成安装并启动配置页面。<\/p><h5 id=\"4.1.3. 图 8. Cognos BI Server 安装完成界面|outline\">图\n                    8. Cognos BI Server 安装完成界面<\/h5><img alt=\"图 8. Cognos BI Server 安装完成界面\" src=\"/sunshine_new/images/负2032369742/img008.png\" width=\"575\" /><h3 id=\"4.2.BI Server 配置和启动|outline\">BI Server\n                配置和启动<\/h3><p>Cognos BI 10.2.1 的配置界面，也与以往的版本有所不同，特别是提供了 Generate DDL 选项去自动生成所需的 Content\n                Store 数据源。以下的内容里，我们会进行详细的介绍。<\/p><p>IBM Cognos Configuration 打开以后，我们需要配置 Content Store，连接我们在前面步骤创建的 DB2。<\/p><h5 id=\"4.2.1. 图 9. Cognos Configuration 数据库连接|outline\">图 9. Cognos\n                    Configuration 数据库连接<\/h5><img alt=\"图 9. Cognos Configuration 数据库连接\" src=\"/sunshine_new/images/负2032369742/img009.png\" width=\"576\" /><p>配好数据库连接之后，选择 Generate DDL 选项来生成 SQL 文件。<\/p><h5 id=\"4.2.2. 图 10. Generate DDL 选项|outline\">图 10.\n                    Generate DDL 选项<\/h5><img alt=\"图 10. Generate DDL 选项\" src=\"/sunshine_new/images/负2032369742/img010.png\" width=\"575\" /><p>这个生成的 createDb.sql 批处理文件用于创建 Cognos Content Store 具体所需要的 DB2 数据库实例。<\/p><h5 id=\"4.2.3. 图 11. DB2 DLL 生成路径|outline\">图 11. DB2\n                    DLL 生成路径<\/h5><img alt=\"图 11. DB2 DLL 生成路径\" src=\"/sunshine_new/images/负2032369742/img011.png\" width=\"557\" /><p>然后我们要根据窗口里提示的生成路径，去 DB2 里运行 SQL 文件来自动生成具体的数据库实例。<\/p><h5 id=\"4.2.4. 清单 5. 生成数据库的 SQL 语句|outline\">清单 5.\n                    生成数据库的 SQL 语句<\/h5><div class=\"codesection\"><pre class=\"displaycode\">db2 Ctvf /opt/ibm/cognos/c10_64/configuration/schemas/content/db2/createDb.sql\nCREATE DATABASE cm ALIAS cm USING CODESET UTF-8 TERRITORY US\nDB20000I The CREATE DATABASE command completed successfully\nCOMMENT ON SCHEMA db2COGNOS IS 'IBM Cognos Content Store\nDB20000I The SQL command completed successfully<\/pre><\/div><p>等数据库创建完成，我们就可以尝试启动 Cognos BI Server 了。在配置页面点击 Start 按钮。<\/p><h5 id=\"4.2.5. 图 12. Cognos Server 启动页面|outline\">图 12.\n                    Cognos Server 启动页面<\/h5><img alt=\"图 12. Cognos Server 启动页面\" src=\"/sunshine_new/images/负2032369742/img012.png\" width=\"576\" /><p>Cognos BI 10.2.1 提供了详尽的启动信息，点击 Details 按钮查询启动过程的细节和状态。等启动完成后，我们还需要把 Cognos\n                Service 加到 HTTP Sever 的容器中。添加如下内容到 Apache HTTP Server 的配置 httpd.conf\n                文件。<\/p><h5 id=\"4.2.6. 清单 6. 配置 HTTP Server 加载 Cognos BI Portal|outline\">清单\n                    6. 配置 HTTP Server 加载 Cognos BI Portal<\/h5><div class=\"codesection\"><pre class=\"displaycode\">ScriptAlias /ibmcognos/cgi-bin \"&lt;Cognos_Install_Path&gt;/cgi-bin\"\n&lt;Directory \"&lt;Cognos_Install_Path&gt;/cgi-bin\"&gt;\nAllowOverride None\nOptions None\nOrder allow,deny\nAllow from all\n&lt;/Directory&gt;\nAlias /ibmcognos \"&lt;Cognos_Install_Path&gt;/webcontent\"\n&lt;Directory \"&lt;Cognos_Install_Path&gt;/webcontent\"&gt;\nOptions Indexes MultiViews\nAllowOverride None\nOrder allow,deny\nAllow from all\n&lt;/Directory&gt;<\/pre><\/div><p>改完并保存 httpd.conf 文件后，需要重启 HTTP Server。<\/p><h5 id=\"4.2.7. 清单 7. 起停 HTTP Server|outline\">清单 7. 起停\n                    HTTP Server<\/h5><div class=\"codesection\"><pre class=\"displaycode\">[root@netsr56 sbin]# ./apachectl stop\n[root@netsr56 sbin]# ./apachectl start<\/pre><\/div><h3 id=\"4.3.BI Server 日志检查|outline\">BI Server\n                日志检查<\/h3><p>在 Cognos BI 10.2.1 的安装和启动中如果有任何的问题，我们可以查阅 Cognos Server\n                的日志文件。文件的目录是：&lt;Cognos_Install_Path&gt;/logs/localhost.&lt;year&gt;-&lt;month&gt;-&lt;day&gt;.log<\/p><h5 id=\"4.3.1. 图 13. 日志目录和文件|outline\">图 13.\n                    日志目录和文件<\/h5><img alt=\"图 13. 日志目录和文件\" src=\"/sunshine_new/images/负2032369742/img013.png\" width=\"576\" /><h3 id=\"4.4.BI Server 访问页面|outline\">BI Server\n                访问页面<\/h3><p>然后，我们就可以通过 http://localhost/ibmcognos 来访问 Cognos BI 10.2.1\n                与旧版本比较完全焕然一新的界面了，如果是远程访问，直接把访问地址里的 localhost 替换成所需要的 IP 地址或主机域名即可。<\/p><h5 id=\"4.4.1. 图 14. Cognos BI 10.2.1 的界面|outline\">图\n                    14. Cognos BI 10.2.1 的界面<\/h5><img alt=\"图 14. Cognos BI 10.2.1 的界面\" src=\"/sunshine_new/images/负2032369742/img014.png\" width=\"575\" /><h2 id=\"5. 产品卸载|outline\">产品卸载<\/h2><p>最后再介绍一下 Cognos 的卸载。首先进入卸载目录 &lt;Cognos_Install_Path&gt;/uninstall/，然后运行\n                <code>./uninst Cu<\/code> 命令启动卸载的窗口，然后一步一步点击 Next 按钮完成卸载。<\/p><h5 id=\"5.0.1. 图 15. Cognos BI 卸载窗口|outline\">图 15.\n                    Cognos BI 卸载窗口<\/h5><img alt=\"图 15. Cognos BI 卸载窗口\" src=\"/sunshine_new/images/负2032369742/img015.png\" width=\"576\" /><h2 id=\"6. 结束语|outline\">结束语<\/h2><p>本文到这里就算全部结束了。通篇详细的介绍了 Power Linux 下 Cognos BI 10.2.1\n                的安装、配置、启动和卸载。根据本文，用户可以很轻松的在 Power Linux 上安装和使用 Cognos BI 10.2.1，开始其妙的\n                Cognos 数据报表和分析的体验之旅。<\/p><CMA ID: 972418><Site ID: 10><XSLT stylesheet used to transform this file: dw-document-html-7.0.xsl>\r\n\r\n\r\n<\/div>\r\n<\/div>\r\n","createTime":"2014-05-29 00:00:00","deployTime":"2014-05-29 00:00:00","id":0,"intro":"Cognos BI 10.2.1 是 Cognos 家族的最新产品，无论是重新设计的 UI 界面，大数据处理能力的加强，还是对新数据源和新使用平台的扩展支持，都给人耳目一新的感觉。本文将介绍如何一步一步的在 Power Linux 上准备和搭建 Cognos BI 10.2.1 的数据分析环境。","keyword":"","recommend":false,"source":"http://www.ibm.com/developerworks/cn/data/library/ba/ba-1405powerlinuxinstallcognos/index.html","title":"Power Linux 下 Cognos BI 10.2.1 的安装","typeId":0,"updateTime":"2014-05-29 00:00:00"}
{"author":"","clickNumber":0,"content":"\r\n<div class=\"ibm-columns\">\r\n<div class=\"ibm-col-1-1\">\r\n\r\n<div class=\"dw-sidebar ibm-inset\"><p><a href=\"https://www.ibm.com/developerworks/cn/cloud/bluemix/\"><img alt=\"BlueMix 资源中心\" src=\"/sunshine_new/images/1862870793//developerworks/i/bluemix-300x140.png\" width=\"300\" />访问 Codename:BlueMix\n                资源中心，了解更多相关资源！<\/a><\/p><\/div><h2 id=\"1.1.Introduction|outline\">简介<\/h2><p>如果您正在构建与在线产品或服务交互的应用程序，那么很可能您正在使用 REST API 提取数据或推入数据。在过去几年里，REST API 越来越受欢迎，因为它们易于理解，可以快速编码，并且可以通过内置 HTTP 支持在所有编程语言中使用。<\/p><p>如果您正在开发自己的云服务，那么 REST API 是一种促进数据共享和重用的出色方式。如果允许外部开发人员通过 REST 访问您的数据，他们就可以轻松地构建酷炫的新应用程序，并以一些有趣的方式利用您的产品或数据。考虑一下围绕 Facebook、Twitter 或 Instagram 开发的应用程序生态系统，好处显而易见。<\/p><div class=\"ibm-pull-quote ibm-inset\"><blockquote><p><em><span class=\"ibm-pullquote-open\">“<\/span> “如果允许外部开发人员通过 REST 访问您的数据，他们就可以轻松地构建酷炫的新应用程序，并以一些有趣的方式利用您的产品或数据。”<span class=\"ibm-pullquote-close\">”<\/span><\/em><\/p><\/blockquote><p class=\"ibm-pullquote-source\"/><\/div><p>本文提供了一个速成课程，介绍了如何使用 PHP 微型框架 Bullet 创建 REST API。除了解释如何实现 4 种基本的 REST 方法之外，本文还介绍了如何为常见的功能（比如 API 身份验证和多种数据格式支持）添加支持，然后将 API 部署到 BlueMix。来吧，让我们开始吧！<\/p><div class=\"ibm-columns\"><div class=\"ibm-col-6-2\"><p class=\"ibm-button-link-alternate\"><a href=\"http://products-api.ng.bluemix.net/api-docs/swagger-ui/#!/products?cm_mmc=developerWorks-_-dW%20CloudOE%20content-_-wa-deployrest-app-_-article\">探索 API<\/a><\/p><\/div><div class=\"ibm-col-6-2\"><p class=\"ibm-button-link-alternate\"><a href=\"https://hub.jazz.net/project/vvaswani/products-api/?utm_source=developerWorks&amp;utm_medium=article&amp;utm_content=wa-deployrest-app&amp;utm_campaign=dW%20CloudOE%20content\">获取代码<\/a><\/p><\/div><\/div><h2 id=\"1.2.UnderstandingRESTAPIBasics|outline\">了解 REST API 基础知识<\/h2><p class=\"dw-article-ps-see-blk\"><span class=\"dw-article-ps-see-head\">阅读：<\/span><a class=\"dw-article-ps-see\" href=\"http://en.wikipedia.org/wiki/Representational_state_transfer\">关于 REST 的 Wikipedia 页面<\/a><\/p><p>首先，我们需要花费几分钟时间了解一下 REST，即 Representational State Transfer（具象状态传输）。REST 是一种基于 “资源” 和 “操作” 的 API 开发风格。资源是引用想要执行操作的对象或实体的 URL（例如，/users 或 /photos），而操作是 4 个 HTTP 动词之一：<\/p><ul class=\"ibm-bullet-list\"><li>GET（检索）<\/li><li>POST（创建）<\/li><li>PUT （更新）<\/li><li>DELETE（删除）<\/li><\/ul><p>下面的示例明确说明了这一点。假设您有一个专为跟踪软件缺陷设计的应用程序，而且您想轻松地重用和操作应用程序数据库中的数据。您已经显示了一个 URL 端点（将其称为 /bugs），并允许外部开发人员使用不同的 HTTP 方法和内容访问此端点（例如，使用 GET /bugs 列出所有缺陷，或者是使用 DELETE /bugs/78 删除编号为 78 的缺陷）。<\/p><p>基于 HTTP 方法和内容，可以推导出正在请求的操作，并对数据采取相应的操作。下面是一些示例：<\/p><ul class=\"ibm-bullet-list\"><li>GET /documents：检索一个文档列表。<\/li><li>GET /bugs/123：检索编号为 123 的缺陷。<\/li><li>POST /photos：使用 POST 请求正文创建一个新照片。<\/li><li>PUT /photos/123：使用 PUT 请求正文更新编号为 123 的照片。<\/li><li>DELETE /orders/123：删除编号为 123 的订单。<\/li><\/ul><h2 id=\"1.3.WhatYoullNeed|outline\">您需要的内容<\/h2><p>本文中开发的示例 REST API 假设一个产品数据库，并侧重于使用常规 REST 协定支持您检索、添加、删除和更新这些产品。为简单起见，Product 资源仅有三个属性：惟一的标识符、名称和价格。我还进一步假设产品数据保存在一个 MySQL 数据库中，并且 API 请求和响应是使用 JSON 编码的（尽管在后面的部分中，我还介绍了使用 XML 作为一种替代方法）。<\/p><p>下面是您需要的内容：<\/p><ul class=\"ibm-bullet-list\"><li>基本熟悉 <a href=\"http://www.php.net/\">PHP<\/a>、<a href=\"http://mysql.com/\">MySQL<\/a> 和 <a href=\"http://httpd.apache.org/\">Apache<\/a> 或 <a href=\"http://wiki.nginx.org/\">nginx<\/a><\/li><li>一个本地 PHP/MySQL 开发环境或一个 BlueMix 帐户<\/li><li><a href=\"https://getcomposer.org/\">Composer<\/a>，PHP 依赖关系管理器<\/li><li><a href=\"https://github.com/cloudfoundry/cli\">Cloud Foundry 命令行工具<\/a>（仅在 BlueMix 部署时才需要）<\/li><li>一个文本编辑器或 IDE<\/li><\/ul><h2 id=\"1.4.Step1:SetUptheApplicationDatabase|outline\">步骤 1：设置应用程序数据库<\/h2><p>使用下列 MySQL 表定义和示例数据设置应用程序数据库。<\/p><ul class=\"ibm-bullet-list\"><li>如果您只在本地进行开发和部署，那么可以使用这种方法针对要连接的 API 初始化 MySQL 数据库表。<\/li><li>如果在 BlueMix 上进行部署，那么暂时可以跳过这一步；完成了步骤 7 在 BlueMix 上初始化和绑定 MySQL 服务实例后，再返回到这一步。<\/li><\/ul><div class=\"codesection\"><pre class=\"displaycode\">CREATE TABLE IF NOT EXISTS `products` (\n  `id` int(10) unsigned NOT NULL AUTO_INCREMENT,\n  `name` varchar(255) COLLATE utf8_unicode_ci NOT NULL,\n  `price` decimal(5,2) NOT NULL,\n  PRIMARY KEY (`id`)\n) ENGINE=InnoDB  DEFAULT CHARSET=utf8 COLLATE=utf8_unicode_ci;\n\nINSERT INTO `products` (`id`, `name`, `price`) VALUES\n(1, 'Garden spade', 15.99),\n(2, 'Cotton hammock', 54.50),\n(3, 'Single airbed', 35.49);<\/pre><\/div><h2 id=\"1.5.Step2:InstallBulletPHPandEloquent|outline\">步骤 2：安装 Bullet 和 Eloquent<\/h2><p>下一步是下载并设置 <a href=\"http://bulletphp.com/\">Bullet<\/a> 微型框架。为什么要使用 Bullet 呢？因为它包含一个灵活的 URL 路由器，可以轻松地在自定义 URL 上创建和响应不同的 HTTP 方法，它还包含一个嵌套路由回调，可以简化常见重复任务（比如 API 身份验证）的执行。<\/p><p>为了简化数据库访问，我将使用 <a href=\"http://laravel.com/docs/eloquent\">Eloquent<\/a>，这是一个受欢迎的对象关系映射器（Object Relational Mapper，ORM），它使用 ActiveRecord 实现来简化数据库记录的使用。Eloquent 是 Laravel PHP 框架的一部分，但它也可以单独使用。<\/p><p>我将使用 Composer（PHP 依赖关系管理器）来下载和设置 Bullet 与 Eloquent。下面是 Composer 配置文件，可以将它保存到 $APP_ROOT/composer.json。在本文中，$APP_ROOT 指应用程序工作目录。<\/p><div class=\"codesection\"><pre class=\"displaycode\">{\n    \"require\": {\n        \"vlucas/bulletphp\": \"*\",\n        \"illuminate/database\": \"*\"\n    }\n}<\/pre><\/div><p>现在，可以使用 Composer 的下列命令安装 Bullet 和 Eloquent：<\/p><div class=\"codesection\"><pre class=\"displaycode\">shell&gt; <strong>php composer.phar install<\/strong><\/pre><\/div><p>为了简化应用程序访问，还可以在开发环境中定义新的虚拟主机，并将其文档根目录指定为 $APP_ROOT。尽管此步骤是可选的，但建议使用它，因为它在 BlueMix 上创建了一个更接近目标部署环境的副本。<\/p><ul class=\"ibm-bullet-list\"><li>要在 Apache 中为应用程序设置一个命名的虚拟主机，请打开 Apache 配置文件（httpd.conf 或 httpd-vhosts.conf）并添加下列行。<\/li><\/ul><div class=\"codesection\"><pre class=\"displaycode\">\tNameVirtualHost 127.0.0.1\n\t&lt;VirtualHost 127.0.0.1&gt;\n\t    DocumentRoot \"/usr/local/apache/htdocs/api\"\n\t    ServerName api.localhost\n\t&lt;/VirtualHost&gt;<\/pre><\/div><ul class=\"ibm-bullet-list\"><li>要在 nginx 中为应用程序设置一个命名的虚拟主机，请打开 nginx 配置文件 (nginx.conf) 并添加下列行。<\/li><\/ul><div class=\"codesection\"><pre class=\"displaycode\">\tserver {\n\t    server_name api.localhost;\n\t     root /usr/local/apache/htdocs/api;\n\t     try_files $uri /index.php;\n\t     \n\t     location ~ \\.php$ {\n\t        try_files $uri =404;            \n\t        include fastcgi_params;\n\tfastcgi_param SCRIPT_FILENAME $document_root$fastcgi_script_name;\n        # assumes you are using php-fcgi\n        fastcgi_pass 127.0.0.1:90;\n\t    }        \n\t}<\/pre><\/div><p>这些行定义一个新的虚拟主机，<code>http://api.localhost/<\/code>，它的文档根目录对应于 $APP_ROOT 目录（记住更新此目录以反映您自己的本地设置）。重启 Web 服务器以激活这些新的设置。请注意，您可能需要更新网络的本地 DNS 服务器，让它知道新的主机。<\/p><h2 id=\"1.6.Step3:HandleGETRequestsforResourceCollections|outline\">步骤 3：处理资源集合的 GET 请求<\/h2><p>Bullet 每次解析一个 URL 段并使用回调响应特定的路径或参数模式。可以在每个 HTTP 方法上定义回调，这允许您对 GET 请求而不是 POST 请求执行不同的操作。<\/p><p>典型的 REST API 支持两种 GET 请求：第一种请求针对资源集合 (GET /products) ，而第二种请求针对具体资源 (GET /products/123)。首先编写代码来处理第一种场景：使用数据库的所有可用产品列表响应 GET /products 请求。使用下列代码更新 $APP_ROOT/index.php 文件。<\/p><div class=\"codesection\"><pre class=\"displaycode\">&lt;?php\n// set up Composer autoloader\nrequire __DIR__ . '/vendor/autoload.php';\n\n\n// initialize application\n$app = new Bullet\\App();\n$app-&gt;path('v1', function($request) use ($app) {\n\n  $app-&gt;path('products', function($request) use ($app) {\n    // GET /v1/products\n    // list all products\n    $app-&gt;get(function() use ($app)  {\n      $products = Product::all();\n      return $products-&gt;toArray();\n    });\n\n  });\n    \n});\n\necho $app-&gt;run(new Bullet\\Request());<\/pre><\/div><p>第一步是初始化 Composer 自动加载器，它负责根据需要加载所需的类。然后，创建一个新的 Bullet\\App 对象来表示应用程序，并使用此应用程序对象的 <code>path()<\/code> 方法来设置端点 <code>/v1/products<\/code> 的嵌套 URL 路径。最里面的 <code>path()<\/code> 回调定义此端点支持的方法 &#8212; 在本例中，使用应用程序对象的 <code>get()<\/code> 方法来定义 GET 请求的处理程序。<\/p><p>路由处理程序使用 Eloquent 模型返回数据库的所有产品。由于此处理程序返回的是一个数组，因此 Bullet 自动假设响应格式应该是 JSON，使用 <code>'Content-Type: application/json'<\/code> 标头和 200 OK 成功代码来转换此数组，并将它发送回客户端。如果有任何错误，异常处理程序会捕捉错误，并使用 500 Internal Server Error 和一个包含错误消息的 JSON 正文将错误返回给客户端。<\/p><p>当收到传入请求时，通过执行 Bullet 应用程序，应用程序对象的 <code>run()<\/code> 方法（如上一个清单的最后一行所示）将所有内容聚集在一起。<\/p><p>此时，您可能会认为这一切都是有意义的，除了一个问题：此 Eloquent 模型来自何处？下一个清单会将会说明这一点，使用 GET 处理程序添加使用 Eloquent 所需的代码，如上所述。<\/p><div class=\"codesection\"><pre class=\"displaycode\">&lt;?php\n// set up Composer autoloader\nrequire __DIR__ . '/vendor/autoload.php';\n\n// use Eloquent ORM\nuse Illuminate\\Database\\Capsule\\Manager as Capsule;  \nuse Illuminate\\Database\\Schema\\Blueprint as Schema;  \n \n// create model for Eloquent ORM mapped to REST API resource\nclass Product extends Illuminate\\Database\\Eloquent\\Model {\n  public $timestamps = false;\n}\n\n// get MySQL service configuration from BlueMix\n$services = getenv(\"VCAP_SERVICES\");\n$services_json = json_decode($services, true);\n$mysql_config = $services_json[\"mysql-5.5\"][0][\"credentials\"];\n$db = $mysql_config[\"name\"];\n$host = $mysql_config[\"host\"];\n$port = $mysql_config[\"port\"];\n$username = $mysql_config[\"user\"];\n$password = $mysql_config[\"password\"];\n\n// initialize Eloquent ORM\n$capsule = new Capsule;\n \n$capsule-&gt;addConnection(array(\n  'driver'    =&gt; 'mysql',\n  'host'      =&gt; $host,\n  'port'      =&gt; $port,\n  'database'  =&gt; $db,\n  'username'  =&gt; $username,\n  'password'  =&gt; $password,\n  'charset'   =&gt; 'utf8',\n  'collation' =&gt; 'utf8_unicode_ci',\n  'prefix'    =&gt; ''\n));\n\n$capsule-&gt;setAsGlobal();\n$capsule-&gt;bootEloquent();\n\n\n// initialize application\n$app = new Bullet\\App();\n$app-&gt;path('v1', function($request) use ($app) {\n\n  $app-&gt;path('products', function($request) use ($app) {\n    // GET /v1/products\n    // list all products\n    $app-&gt;get(function() use ($app)  {\n      $products = Product::all();\n      return $products-&gt;toArray();\n    });\n\n  });\n    \n});\n\necho $app-&gt;run(new Bullet\\Request());<\/pre><\/div><p>Eloquent 随附提供了一个 Capsule 管理器实例，旨在简化 Laravel 外部的 Eloquent 使用。上一个清单演示了实际的 Capsule 实例，建立了一个到 MySQL 数据库的新连接，并使 Capsule 实例在全局可用。<\/p><p>由于本文的最终目的是将应用程序部署到 BlueMix，因此会从特殊的 BlueMix <code>VCAP_SERVICES<\/code> 环境变量提取 MySQL 连接的凭据；但是，如果您打算在本地进行部署，那么可以使用特定于本地数据库服务器的值取代这些值。<\/p><p>您还会注意到扩展 Illuminate\\Database\\Eloquent\\Model 类的 Product 模型。此 Product 模型提供了许多预定义的方法，可以简化相应数据库记录的使用。您已经看到了其中的一个实际方法 &#8212;<code>Product::all()<\/code>&#8212;，它负责在内部生成对 \"return all products in the database\" 的 SELECT 查询。<\/p><p>下面是成功的 <code>/v1/products<\/code> GET 请求的结果。<\/p><img alt=\"/v1/products 的 GET 请求\" src=\"/sunshine_new/images/1862870793/image001.jpg\" width=\"400\" /><h2 id=\"1.7.Step4:HandlePOSTRequestsforNewResources|outline\">步骤 4：处理新资源的 POST 请求<\/h2><p class=\"dw-article-ps-see-blk\"><span class=\"dw-article-ps-see-head\">阅读：<\/span><a class=\"dw-article-ps-see\" href=\"https://developer.yahoo.com/social/rest_api_guide/http-response-codes.html\">HTTP 响应状态代码<\/a><\/p><p>可以类似的方式处理 POST 请求并将它们转换为新产品记录。<\/p><div class=\"codesection\"><pre class=\"displaycode\">&lt;?php\n// set up Composer autoloader\nrequire __DIR__ . '/vendor/autoload.php';\n\n// initialize Eloquent ORM and model\n// snipped\n\n// initialize application\n$app = new Bullet\\App();\n$app-&gt;path('v1', function($request) use ($app) {\n\n  $app-&gt;path('products', function($request) use ($app) {\n    // POST /v1/products\n    // create new product\n    $app-&gt;post(function($request) use ($app) {\n      $product = new Product();\n      $product-&gt;name = trim(htmlentities($request-&gt;name));\n      $product-&gt;price = round(trim(htmlentities($request-&gt;price)), 2);\n      if ($product-&gt;name &amp;&amp; $product-&gt;price) {\n        $product-&gt;save();\n        return $app-&gt;response(201, $product-&gt;toArray());\n      } else {\n        return 400;\n      }\n\n    });\n\n  });\n    \n});\n\necho $app-&gt;run(new Bullet\\Request());<\/pre><\/div><p>此清单为 <code>/v1/products<\/code> 的 POST 请求添加了一个新处理程序。当应用程序收到 POST 请求时，会创建一个空白的 Product 对象，根据请求对象设置 Product 'name' 和 'price'，并调用模型的 <code>save()<\/code> 对象来为数据库添加新记录。<\/p><p>如果成功添加了记录，那么处理程序将会返回 201 Created 状态代码和新 Product 资源的 JSON 表示形式。如果没有成功，则会返回 400 Bad Request 或 500 Internal Server Error 错误代码和一条解释错误的 JSON 消息。在下面查看成功和失败的 POST 请求和响应示例。<\/p><img alt=\"/v1/products 的成功 POST 请求\" src=\"/sunshine_new/images/1862870793/image002.jpg\" width=\"400\" /><img alt=\"/v1/products 的失败 POST 请求\" src=\"/sunshine_new/images/1862870793/image003.jpg\" width=\"400\" /><p>值得注意的一个有趣现象是：在 POST 正文内容中，已创建的新 Product 资源被作为 JSON 对象传递给 API。但是，在 POST 处理程序中，您会看到没有使用 PHP 的 <code>json_decode()<\/code> 函数来解码 POST 有效负载。这是因为在 POST 或 PUT 请求中遇到 JSON 有效负载时 Bullet 会自动进行解码。然后，可以直接使用 JSON 对象属性作为请求对象的属性。<\/p><h2 id=\"1.8.Step5:HandleGET,PUTandDELETERequestsforIndividualResources|outline\">步骤 5：处理各个资源的 GET、PUT 和 DELETE 请求<\/h2><p class=\"dw-article-ps-see-blk\"><span class=\"dw-article-ps-see-head\">阅读：<\/span><a class=\"dw-article-ps-see\" href=\"https://developer.yahoo.com/social/rest_api_guide/http-response-codes.html\">HTTP 响应状态代码<\/a><\/p><p>在上一部分中，我介绍了如何处理资源集合的 GET 请求 (<code>GET /<\/code><code>v1/<\/code><code>products<\/code>)。但是，REST API 应该还支持使用惟一资源标识符直接访问资源（<code>GET /<\/code><code>v1/<\/code><code>products/123<\/code> 或 <code>DELETE /<\/code><code>v1/<\/code><code>products/123<\/code>）。这使得可以使用 API 检索、更新或删除各个资源。<\/p><p>与之前看到的 <code>path()<\/code> 方法（针对静态 URL 路径）类似，Bullet 还包含一种 <code>param()<\/code> 方法，它旨在处理包含变量的 URL 路径。下列清单在具体资源的 GET 请求处理程序上下文中演示了这一方法。<\/p><div class=\"codesection\"><pre class=\"displaycode\">&lt;?php\n// set up Composer autoloader\nrequire __DIR__ . '/vendor/autoload.php';\n\n// initialize Eloquent ORM and model\n// snipped\n\n// initialize application\n$app = new Bullet\\App();\n$app-&gt;path('v1', function($request) use ($app) {\n\n  $app-&gt;path('products', function($request) use ($app) {\n      \n    $app-&gt;param('int', function($request, $id) use($app) {\n\n      $product = Product::find($id);\n      if(!$product) {\n        return 404;\n      }\n           \n      // GET /v1/products/:id\n      // list single product by id\n      $app-&gt;get(function($request) use($product, $app) {\n        return $product-&gt;toArray();\n      });\n           \n      \n    });        \n\n  });\n    \n});\n\necho $app-&gt;run(new Bullet\\Request());<\/pre><\/div><p>此清单以 <code>/v1/products/[id]<\/code> 的形式设置了 URL 的回调处理程序，其中 <code>[id]<\/code> 是一个变量路径段，表示惟一资源标识符。'int' 参数进一步指定了此变量是一个分配给 <code>$id<\/code> 变量的整数。<\/p><p>在此清单中，从 URL 路径捕获的资源标识符被传递给了 Product 模型，并且此模型的 <code>find()<\/code> 方法用于返回相应的数据库记录。然后，Bullet 将记录转换为 JSON 格式并将它返回给客户端。如果没有找到匹配的记录，处理程序会返回 404 Not Found 错误代码。如果存在错误，则异常处理程序会捕获错误并将它传递回 500 Internal Server Error 错误代码。<\/p><p>下面是成功的 GET 请求和响应的结果。<\/p><img alt=\"/v1/products/:id 的 GET 请求\" src=\"/sunshine_new/images/1862870793/image004.jpg\" width=\"400\" /><p>有了此结构，针对具体资源添加 DELETE 和 PUT 请求的支持就会非常简单。查看下列清单，此清单包含了此额外功能。<\/p><div class=\"codesection\"><pre class=\"displaycode\">&lt;?php\n// set up Composer autoloader\nrequire __DIR__ . '/vendor/autoload.php';\n\n// initialize Eloquent ORM and model\n// snipped\n\n// initialize application\n$app = new Bullet\\App();\n$app-&gt;path('v1', function($request) use ($app) {\n\n  $app-&gt;path('products', function($request) use ($app) {\n      \n    $app-&gt;param('int', function($request, $id) use($app) {\n\n      $product = Product::find($id);\n      if(!$product) {\n        return 404;\n      }\n                \n      // GET /v1/products/:id\n      // list single product by id\n      $app-&gt;get(function($request) use($product, $app) {\n        return $product-&gt;toArray();\n      });\n\n      // PUT /v1/products/:id\n      // update product by id\n      $app-&gt;put(function($request) use($product, $app) {\n        $product-&gt;name = trim(htmlentities($request-&gt;name));\n        $product-&gt;price = round(trim(htmlentities($request-&gt;price)), 2);\n        if ($product-&gt;name &amp;&amp; $product-&gt;price) {\n          $product-&gt;save();\n          return $app-&gt;response(200, $product-&gt;toArray());\n        } else {\n          return 400;          \n        }\n      });\n          \n      // DELETE /v1/products/:id\n      // delete product by id\n      $app-&gt;delete(function($request) use($product) {\n        $product-&gt;delete();\n        return 204;\n      });\n      \n    });        \n\n  });\n    \n});\n\necho $app-&gt;run(new Bullet\\Request());<\/pre><\/div><ul class=\"ibm-bullet-list\"><li>PUT 请求意味着使用 PUT 请求正文的更新信息更新现有资源。此清单定义 PUT 处理程序，该程序读取 PUT 请求中的 JSON 文档，并使用 Eloquent 更新检索的 Product 对象的属性。然后，会使用此对象的 <code>save()<\/code> 方法将更新资源保存回数据库，并会将 200 Accepted 服务器响应代码返回给客户端，以此表示操作获得了成功并更新了资源。<\/li><li>DELETE 请求意味着要从数据存储区删除 DELETE URL 中引用的资源，而上面的 DELETE 处理程序正在进行这样的操作：它调用检索 Product 对象的 <code>delete()<\/code> 方法从 MySQL 数据库删除产品记录。在本例中，我们使用了 204 No Content 响应代码和一个空白的响应正文来表示成功。<\/li><\/ul><p>下列图像显示了成功的 PUT 和 DELETE 请求。<\/p><img alt=\"/v1/products/:id 的 PUT 请求\" src=\"/sunshine_new/images/1862870793/image005.jpg\" width=\"400\" /><img alt=\"/v1/products/:id 的 DELETE 请求\" src=\"/sunshine_new/images/1862870793/image006.jpg\" width=\"400\" /><p>在这里需要注意的一个有趣现象是：上面的三个嵌套路由处理程序都使用了父处理程序中创建的 <code>$product<\/code> 实例。在父处理程序中定义常见例程或对象，然后在所有子闭包或块中使用它们，这样做可以使得重复的代码变得更少，使维护和更新变得更简单。<\/p><h2 id=\"1.9.Step6:SupportMultipleFormats|outline\">步骤 6：支持多种格式<\/h2><p>大多数情况下，使用 JSON 请求和响应正文就可以了。但是，如果您想要支持另一种格式（比如 XML）会怎么样？使用 Bullet，您可以为不同格式定义自定义响应器，这样您就可以轻松处理此需求。<\/p><p>为了说明这点，请考虑下一个清单，它为 <code>/v1/products<\/code> GET 端点的 XML 输出添加了支持：<\/p><div class=\"codesection\"><pre class=\"displaycode\">&lt;?php\n// set up Composer autoloader\nrequire __DIR__ . '/vendor/autoload.php';\n\n// initialize Eloquent ORM and model\n// snipped\n\n// function to convert array to XML\nfunction convert_array_to_xml($data) {\n  $xml = new SimpleXMLElement('&lt;root/&gt;');\n  foreach ($data as $r) {\n    $item = $xml-&gt;addChild('product');\n    $item-&gt;addChild('id', $r['id']);\n    $item-&gt;addChild('name', $r['name']);\n    $item-&gt;addChild('price', $r['price']);\n  }\n  return $xml-&gt;asXml();\n}\n\n// initialize application\n$app = new Bullet\\App();\n\n$app-&gt;path('v1', function($request) use ($app) {\n\n  $app-&gt;path('products', function($request) use ($app) {\n    // GET /v1/products[.xml|.json]\n    // list all products\n    $app-&gt;get(function() use ($app)  {\n\n      $products = Product::all();         \n      \n      // handle requests for XML content\n      $app-&gt;format('xml', function($request) use($app, $products) {\n        return $app-&gt;response(200, convert_array_to_xml($products-&gt;toArray()))\n                      -&gt;header('Content-Type', 'application/xml');\n      });\n        \n      // handle requests for JSON content\n      $app-&gt;format('json', function($request) use($app, $products) {\n        return $products-&gt;toArray();\n      });  \n            \n    });\n        \n  });    \n  \n});\n\necho $app-&gt;run(new Bullet\\Request());<\/pre><\/div><p>应用程序对象的 <code>format()<\/code> 方法用于针对 XML 和 JSON 输出定义单独的回调处理程序。当 Bullet 遇到 URL <code>/v1/products.xml<\/code> 的请求，或者具有 <code>'Accept: application/xml'<\/code> 标头的 URL <code>/v1/products<\/code> 请求时，它会自动调用 XML 回调处理程序。在后一种情况下，Bullet 使用了自动内容协商功能，以便了解请求格式并提供相应的输出。<\/p><p>从上一个清单中可以看出，此处理程序仅将从数据库检索到的一系列产品信息转换为 XML 文档，并将它返回给客户端。下列图像显示了输出。<\/p><img alt=\"/v1/products.xml 的 GET 请求\" src=\"/sunshine_new/images/1862870793/image007.jpg\" width=\"400\" /><p>要以 JSON 格式获得输出，客户端应该使用 <code>'Accept: application/<\/code><code>json<\/code><code>'<\/code> 标头请求 URL <code>/v1/products.json<\/code> 或 URL <code>/v1/products<\/code>，如下列输出所示。<\/p><img alt=\"/v1/products.json 的 GET 请求\" src=\"/sunshine_new/images/1862870793/image008.jpg\" width=\"400\" /><p>可以类似的方式更新 POST 处理程序，因此它可以接受 XML 和 JSON 格式的输入。<\/p><div class=\"codesection\"><pre class=\"displaycode\">&lt;?php\n// set up Composer autoloader\nrequire __DIR__ . '/vendor/autoload.php';\n\n// initialize Eloquent ORM and model\n// snipped\n\n// function to convert array to XML\nfunction convert_array_to_xml($data) {\n  $xml = new SimpleXMLElement('&lt;root/&gt;');\n  foreach ($data as $r) {\n    $item = $xml-&gt;addChild('product');\n    $item-&gt;addChild('id', $r['id']);\n    $item-&gt;addChild('name', $r['name']);\n    $item-&gt;addChild('price', $r['price']);\n  }\n  return $xml-&gt;asXml();\n}\n\n// initialize application\n$app = new Bullet\\App();\n\n$app-&gt;path('v1', function($request) use ($app) {\n\n  $app-&gt;path('products', function($request) use ($app) {\n  \n    // POST /v1/products[.xml|.json]\n    // create new product\n    $app-&gt;post(function($request) use ($app) {\n\n      // handle requests for XML content\n      $app-&gt;format('xml', function($request) use($app) {\n        $input = simplexml_load_string($request-&gt;raw());\n        $product = new Product();\n        $product-&gt;name = trim(htmlentities((string)$input-&gt;name));\n        $product-&gt;price = round(trim(htmlentities((string)$input-&gt;price)), 2);\n        if ($product-&gt;name &amp;&amp; $product-&gt;price) {\n          $product-&gt;save();\n          return $app-&gt;response(201, convert_array_to_xml(array($product-&gt;toArray())))\n                    -&gt;header('Content-Type', 'application/xml');          \n        } else {\n          return 400;\n        }\n      });\n        \n      // handle requests for JSON content\n      $app-&gt;format('json', function($request) use($app) {          \n        $product = new Product();\n        $product-&gt;name = trim(htmlentities($request-&gt;name));\n        $product-&gt;price = round(trim(htmlentities($request-&gt;price)), 2);\n        if ($product-&gt;name &amp;&amp; $product-&gt;price) {\n          $product-&gt;save();\n          return $app-&gt;response(201, $product-&gt;toArray());\n        } else {\n          return 400;\n        }\n      });   \n\n    });   \n        \n  });    \n  \n});\n\necho $app-&gt;run(new Bullet\\Request());<\/pre><\/div><p>在这里，使用了 <code>simplexml_load_string()<\/code> 方法将发送给 <code>/v1/products.xml<\/code> 的基于 XML 的 POST 对象转换为 PHP 对象，并且使用此对象的属性填充新的 Product 实例。保存之后，会将新创建的 Product 资源的 XML 表示返回给客户端。<\/p><p>下列图像显示了 XML POST 请求和响应的一个示例。<\/p><img alt=\"/v1/products.xml 的 POST 请求\" src=\"/sunshine_new/images/1862870793/image009.jpg\" width=\"400\" /><p>如果客户端想使用 JSON，那么可以将 JSON 请求正文发送给 URL <code>/v1/products.json<\/code>。在本例中，Bullet 自动将 JSON 请求正文解码为对象，此对象可以转换为 Product 实例并保存到数据库。客户端接收所保存 Product 资源的 JSON 表示，如下所示。如前所述，通过将 <code>'<\/code><code>Accept: application/json<\/code><code>'<\/code> 标头作为 POST 请求的一部分发送给 URL <code>/v1/products<\/code>，可以获得相同的结果。<\/p><img alt=\"/v1/products.json 的 POST 请求\" src=\"/sunshine_new/images/1862870793/image010.jpg\" width=\"400\" /><h2 id=\"1.10.Step7:HandleErrorsandAddAuthentication|outline\">步骤 7：处理错误并添加身份验证<\/h2><p>BulletPHP 随附提供了一个强大的事件处理系统，该系统可以基于特定的服务器代码、响应格式或异常类型来执行自定义操作。为了说明这点，请考虑下一个清单，该清单使用事件处理程序自动捕获异常，并将它们作为用 JSON 编码的数据包发送给客户端。<\/p><div class=\"codesection\"><pre class=\"displaycode\">&lt;?php\n// set up Composer autoloader\nrequire __DIR__ . '/vendor/autoload.php';\n\n// initialize application\n$app = new Bullet\\App();\n\n// global 'Exception' handler event\n$app-&gt;on('Exception', function($request, $response, Exception $e) use ($app) {\n  // send 500 error with JSON info about exception\n  $response-&gt;status(500);\n  $response-&gt;content(array(\n    'exception' =&gt; get_class($e),\n    'message' =&gt; $e-&gt;getMessage()\n  ));\n});\n\n// route handlers\n// snipped\n\necho $app-&gt;run(new Bullet\\Request());<\/pre><\/div><p>下面是 API 如何响应异常的一个示例。<\/p><img alt=\"API 异常处理\" src=\"/sunshine_new/images/1862870793/image011.jpg\" width=\"500\" /><p>在处理请求之前或之后，还可以使用此事件处理系统执行操作或自定义事件。一种常见用法是身份验证：可以针对受保护的路由触发自定义的 'authentication required' 事件，然后为此事件编写一个处理程序，以检查发送请求的客户端是否具有访问这些路由所需的凭据。<\/p><p>下一个清单演示了一个简单的示例。在受保护的路由上触发了自定义 'auth' 事件；这将控制转交给了一个事件处理函数，它在进一步处理请求之前检查身份验证凭据（在本例中是 plaintext cookies）。<\/p><div class=\"codesection\"><pre class=\"displaycode\">&lt;?php\n// set up Composer autoloader\nrequire __DIR__ . '/vendor/autoload.php';\n\n// initialize application\n$app = new Bullet\\App();\n\n// runs when 'auth' event is triggered on protected API routes to check that\n// credentials (here, plaintext cookies) are present\n// replace with more complex authentication function in production\n$app-&gt;on('auth', function($request, $response) use ($app) {\n\n  if (!$request-&gt;cookie('uid') == 'demo' || !$request-&gt;cookie('pass') == 'demo') {\n    $response-&gt;status(401);\n    $response-&gt;send();\n    exit;\n  }\n  \n});\n\n// unprotected API route to set authentication cookies\n$app-&gt;path('set-auth-cookies', function($request) use ($app) {\n\n  $app-&gt;get(function() use ($app)  {\n    setcookie('uid', 'demo');\n    setcookie('pass', 'demo');\n    return 200;\n  });\n  \n});\n\n// protected API route\n$app-&gt;path('v1', function($request) use ($app) {\n\n  $app-&gt;path('products', function($request) use ($app) {\n  \n    // trigger authentication event\n    $app-&gt;filter('auth');\n\n    // route handler code\n    // snipped\n    }\n}\n\necho $app-&gt;run(new Bullet\\Request());<\/pre><\/div><p>在此示例场景中，用户可以创建 cookies，方法是请求特殊的 <code>/set-auth-cookies<\/code> 路径；在生产环境中，用户可能需要通过注册来获得一个 API 密钥，并为每个请求提供它。<\/p><p>下面的图像显示了 API 如何使用 401 Unauthorized 代码响应未授权的请求。<\/p><img alt=\"未授权请求的 API 响应\" src=\"/sunshine_new/images/1862870793/image012.jpg\" width=\"400\" /><div class=\"dw-sidebar ibm-inset\"><p>本文顶部链接的 API 演示版本可在未授权的情况下使用。要启用授权，从 Devops Services 下载 API 的源代码，取消相关部分的注释并部署一个新实例。<\/p><\/div><h2 id=\"1.11.Step8:DeploytoIBMBlueMix|outline\">步骤 8：部署到 BlueMix<\/h2><p class=\"dw-article-ps-see-blk\"><span class=\"dw-article-ps-see-head\">阅读：<\/span><a class=\"dw-article-ps-see\" href=\"http://clouds-with-carl.blogspot.sk/2014/02/deploy-hello-world-php-application-to.html\">将 Hello World PHP 应用程序部署到 BlueMix 上的 Zend Server<\/a><\/p><p>现在已经完成了 API 的所有编码，最后一步是部署它。<\/p><ul class=\"ibm-bullet-list\"><li>如果在本地部署，则已经完成了相应的操作。跳到本部分末尾，因为末尾部分列出了可与 API 交互的一些有用工具。<\/li><li>如果在 BlueMix 上部署，则需要使用 BlueMix 帐户，并需要下载和安装 Cloud Foundry 命令行客户端。按照下面的步骤完成部署过程。<\/li><\/ul><h3 id=\"1.11.1.1.Createyourapplicationmanifest|outline\">a. 创建应用程序清单<\/h3><p class=\"dw-article-ps-see-blk\"><span class=\"dw-article-ps-see-head\">阅读：<\/span><a class=\"dw-article-ps-see\" href=\"http://clouds-with-carl.blogspot.in/2014/02/deploy-minimal-nodejs-application-to.html\">将最小的 Node.js 应用程序部署到 BlueMix<\/a><\/p><p>应用程序清单文件告诉 BlueMix 如何部署应用程序。具体地讲，它指定要使用的 PHP 运行时环境（\"构建包\"）。在 $APP_ROOT/manifest.yml 中创建此文件，使用下列信息填充它。<\/p><div class=\"codesection\"><pre class=\"displaycode\">---\napplications:\n- name: products-api-[random-number]\nmemory: 256M\ninstances: 1\nhost: products-api-[random-number]\nbuildpack: <a href=\"https://github.com/dmikusa-pivotal/cf-php-build-pack.git\">https://github.com/dmikusa-pivotal/cf-php-build-pack.git<\/a><\/pre><\/div><p>记住更新主机和应用程序名，让它们保持惟一，方法是更改它或为它添加一个随机数字。我使用的是 Cloud Foundry PHP 构建包，但还有其他选项可用。<\/p><h3 id=\"1.11.2.2.SetupURLroutingforBulletPHP|outline\">b. 为 Bullet 设置 URL 路由<\/h3><p class=\"dw-article-ps-see-blk\"><span class=\"dw-article-ps-see-head\">阅读：<\/span><a class=\"dw-article-ps-see\" href=\"http://vikram-vaswani.in/weblog/2014/04/11/configure-url-rewriting-for-framework-based-php-applications-on-ibm-bluemix/\">在 IBM BlueMix 上为基于框架的 PHP 应用程序配置 URL 重写<\/a><\/p><p>默认情况下，Cloud Foundry PHP 构建包使用 Apache 作为其 Web 服务器。Nginx 是一种轻型替代方法，在本步骤中，我们需要覆盖构建包的默认设置，以便使用 nginx 作为 Web 服务器。在开始之前，记住您可以从项目的 DevOps Services 源代码库获得此部分的所有文件。<\/p><p>首先，需要创建一个 $APP_ROOT/.bp-config 目录，然后使用下列内容创建 $APP_ROOT/.bp-config/options.json。<\/p><div class=\"codesection\"><pre class=\"displaycode\">{\n    \"WEB_SERVER\": \"nginx\"\n}<\/pre><\/div><p>此时，还必须为 nginx 设置 URL 重写规则，这样才能将 API 路径正确地传递给 Bullet 的 URL 路由器。首先，使用下列内容创建 $APP_ROOT/.bp-config/nginx/server-defaults.conf。<\/p><div class=\"codesection\"><pre class=\"displaycode\">        listen @{VCAP_APP_PORT};\n        server_name _;\n\n        fastcgi_temp_path @{TMPDIR}/nginx_fastcgi 1 2;\n        client_body_temp_path @{TMPDIR}/nginx_client_body 1 2;\n        proxy_temp_path @{TMPDIR}/nginx_proxy 1 2;\n\n        real_ip_header x-forwarded-for;\n        set_real_ip_from 10.0.0.0/8;\n        real_ip_recursive on;\n\n        try_files $uri /index.php;<\/pre><\/div><p>然后，使用下列内容创建 $APP_ROOT/.bp-config/nginx/server-locations.conf。<\/p><div class=\"codesection\"><pre class=\"displaycode\">        # Some basic cache-control for static files to be sent to the browser\n        location ~* \\.(?:ico|css|js|gif|jpeg|jpg|png)$ {\n            expires max;\n            add_header Pragma public;\n            add_header Cache-Control \"public, must-revalidate, proxy-revalidate\";\n        }\n\n        # Deny hidden files (.htaccess, .htpasswd, .DS_Store).\n        location ~ /\\. {\n            deny all;\n            access_log off;\n            log_not_found off;\n        }\n\n        # pass .php files to fastcgi\n        location ~ .*\\.php$ {\n            try_files $uri =404;\n            include fastcgi_params;\n            fastcgi_param SCRIPT_FILENAME $document_root$fastcgi_script_name;\n            fastcgi_pass php_fpm;\n        }<\/pre><\/div><h3 id=\"1.11.3.3.ConnecttoBlueMixanddeploytheapplication|outline\">c. 连接到 BlueMix 并部署应用程序<\/h3><p>凭借 'cf' 命令行工具使用 IBM id 和密码登录到 BlueMix。<\/p><div class=\"codesection\"><pre class=\"displaycode\">shell&gt; cf api https://api.ng.bluemix.net\nshell&gt; cf login<\/pre><\/div><p>更改到 $APP_ROOT 目录并将应用程序推送到 BlueMix。<\/p><div class=\"codesection\"><pre class=\"displaycode\">shell&gt; cf push<\/pre><\/div><p>下面是您在此过程中看到的内容示例。<\/p><img alt=\"将应用程序部署到 BlueMix\" src=\"/sunshine_new/images/1862870793/image013.jpg\" width=\"600\" /><p>此时，您的应用程序应该已经部署到了 BlueMix。但是还没有完成所有操作！<\/p><h3 id=\"1.11.4.4.BindaMySQLserviceinstancetotheapplication|outline\">d. 将 MySQL 服务实例绑定到应用程序<\/h3><p>现在已经部署了应用程序，但您仍然需要将它与 MySQL 数据库实例连接起来，这样您的 API 才有一些数据可供使用。为此，访问 BlueMix 管理仪表板并使用您的 id 和密码登录。您应该会看到 'Apps' 菜单栏列出了您的应用程序。<\/p><img alt=\"BlueMix 应用程序仪表板\" src=\"/sunshine_new/images/1862870793/image014.jpg\" width=\"500\" /><p>选择您的应用程序，在生成的页面上，使用 'Add new service' 选项将 'mysql' 服务添加到您的应用程序。<\/p><img alt=\"在 BlueMix 上将 MySQL 服务绑定到应用程序\" src=\"/sunshine_new/images/1862870793/image015.jpg\" width=\"500\" /><p>您现在应在 BlueMix 管理仪表板中看到 MySQL 服务实例已经绑定到了应用程序。<\/p><img alt=\"MySQL 服务实例已经绑定到了 BlueMix 应用程序\" src=\"/sunshine_new/images/1862870793/image016.jpg\" width=\"500\" /><p>具体地讲，如果您查看应用程序细节，应该能够在 VCAP_SERVICES 环境变量中看到 MySQL 访问凭据。<\/p><img alt=\"BlueMix 应用程序环境变量\" src=\"/sunshine_new/images/1862870793/image017.jpg\" width=\"400\" /><h3 id=\"1.11.5.5.Installtheexampleschema|outline\">e. 安装示例模式<\/h3><p>此时，可以使用如步骤 1 所示的示例模式初始化应用程序数据库。尽管在 BlueMix 环境中没有办法直接运行步骤 1 中的 SQL 命令，但应用程序包含一个名为 <code>/install-schema<\/code> 的特殊路径，可以通过浏览器请求它，以便设置数据库表和示例数据。尽管本文没有记录此路径，但可以在应用程序的源代码库中找到它。<\/p><p>下面的图像显示了通过 /install-schema 路径成功安装模式的结果。<\/p><a id=\"1.11.6.SchemainstallationonBlueMix6.StartusingyourRESTAPI|outline\"><\/a><h5 id=\"N10301\">6. 开始使用 REST API<\/h5><img alt=\"BlueMix 上的模式安装\" src=\"/sunshine_new/images/1862870793/image018.jpg\" width=\"446\" /><p>部署 REST API 之后，可以向它发送 GET、POST、PUT 和 DELETE 请求。<\/p><ul class=\"ibm-bullet-list\"><li>Firefox 的 <a href=\"https://addons.mozilla.org/En-us/firefox/addon/httprequester/\">HttpRequest<\/a><a href=\"https://addons.mozilla.org/En-us/firefox/addon/httprequester/\">er<\/a> 和 Chrome 的 <a href=\"https://chrome.google.com/webstore/detail/postman-rest-client/fdmmgilgnpjigdojojpjoooidkmcomcm\">Postman<\/a> 扩展是通过浏览器构建和发送不同 API 请求类型的强大工具。本文中的大部分屏幕截图都是使用 Postman 扩展生成的。<\/li><li>可以使用任意流行的客户端或服务器端编程语言向 API 提交请求：jQuery、PHP、Perl、Java 和 Python（以及其他语言）都支持 HTTP 请求提交和响应处理。<\/li><li>本文还包含使用 <a href=\"https://helloreverb.com/developers/swagger\">Swagger<\/a> 的生动 API 演示，Swagger 为 API 探索提供了一个基于浏览器的工具。可以使用此演示添加和更新产品，删除产品或检索各个产品。下面的图像显示了实际的 Swagger 前端。<img alt=\"Swagger API 浏览器\" src=\"/sunshine_new/images/1862870793/image019.jpg\" width=\"500\" /><\/li><\/ul><h2 id=\"1.12.Conclusion|outline\">结束语<\/h2><p>如本文所述，BlueMix 为在基于云的平台上创建和部署 REST API 奠定了坚实的基础。通过添加针对常见 REST 协定的 Bullet 灵活支持和 Eloquent 非常直观的 ORM，您可以获得快速制作原型和部署自定义 REST API 所需的一切内容。<\/p><p>您可以从本文的 Devops Services 存储库下载本文实现的所有代码和所用 PHP 构建包的配置文件。建议您获取这些代码并运行它们，然后添加新的功能。我可以保证您不会有任何损失，而且可以学到更多的东西。<\/p><CMA ID: 972663><Site ID: 10><XSLT stylesheet used to transform this file: dw-document-html-7.0.xsl>\r\n\r\n\r\n<\/div>\r\n<\/div>\r\n","createTime":"2014-05-29 00:00:00","deployTime":"2014-05-29 00:00:00","id":0,"intro":"REST API 越来越受与库无关的数据访问和操作的欢迎，因为它们易于理解，可以快速编码，并且可以通过内置 HTTP 支持在所有编程语言中使用。本文展示了在 Codename: BlueMix 上如何使用 PHP 和 MySQL 构建并立即部署 REST API。本文使用 Bullet 微型框架和 Eloquent ORM 以及 PHP Cloud Foundry 构建包和绑定的 MySQL 服务实例来实现 API。","keyword":"","recommend":false,"source":"http://www.ibm.com/developerworks/cn/web/wa-deployrest-app/index.html","title":"在 Codename: BlueMix 上使用 PHP 和 MySQL 构建和部署 REST API","typeId":0,"updateTime":"2014-05-29 00:00:00"}
{"author":"","clickNumber":0,"content":"\r\n<div class=\"ibm-columns\">\r\n<div class=\"ibm-col-1-1\">\r\n\r\n<h2 id=\"thecontext\">相关背景<\/h2><p>IBM&#174; Rational&#174; Quality Manager 是一个基于 web 的测试管理软件，提供质量保证手段来管理和追踪整个质量生命周期。<\/p><p>这是一个协作化和可定制化的解决方案：<\/p><ul class=\"ibm-bullet-list\"><li>创建和维护测试计划<\/li><li>测试，设计和运行手动或自动测试<\/li><li>管理目标<\/li><li>调度、跟踪和报告关于测试阶段的健康度及总进度的指标<\/li><\/ul><p>正如图 1 所示，Rational Quality Manager 简化了测试管理的各个方面。此外，它还包括用于管理需求和缺陷的支持。<\/p><h5 id=\"fig1\">图 1. Rational Quality Manager 测试周期管理<\/h5><img alt=\"测试管理关键行动\" src=\"/sunshine_new/images/1195712682/image001.png\" width=\"284\" /><p>Rational Test Lab Manager，是 Rational Quality Manager 中的一个嵌入式组件，可以使测试团队将测试实验室资源（虚拟或物理）的管理纳入其组织的质量管理生命周期。<\/p><p>Rational Test Lab Manager 就是以管理实验室资源为目的设计的，可以对 Rational Quality Manager 中定义为竖井的每一个独立项目进行管理。实验室资源可以在同一个项目的范围内进行预订和分配，这是 Rational Quality Manager 中的主要构建模块。在大多数情况下，软件开发实验室是在不同的组和项目之间共享的。理想情况下，一个实验室管理工具可以通过优化实验室资源跨团队和项目的利用，来最大限度地提高资源的使用。本文介绍了一个试点项目，跨 Rational Quality Manager 中定义的多个项目扩展 Rational Test Lab Manager 的能力，使软件开发实验室的<strong><em>共享实验室<\/em><\/strong>得以进行管理。试点借用了 Rational Quality Manager 与 Tivoli Provisioning Manager 集成的能力。这一集成在另外一篇文章中进行介绍（查看<a href=\"#resources\">参考资料<\/a>获取相关链接），并且贯穿本文都会引用这篇文章中的观点。<\/p><h2 id=\"thearchitectureofthepilotproject\">该试点项目的架构<\/h2><p>在罗马的 IBM Tivoli 实验室已经逐渐，而且是广泛采用基于 Jazz 技术的 Rational 协同生命周期管理（Collaborative Lifecycle Management，CLM）解决方案作为工作方式。对 IBM&#174; Rational Team Concert&#8482;、IBM&#174; Rational&#174; Requirements Composer 以及 Rational Quality Manager 的采用会根据团队的成熟度而有很大不同。在 2013 年 8 月，实施了版本 4.0.3。图 2 示出包括在每个产品中的任务。<\/p><h5 id=\"fig2\">图 2. 在罗马的 IBM Tivoli 实验中实现的 CLM 架构<\/h5><img alt=\"基于 Jazz 实现的关键组件\" src=\"/sunshine_new/images/1195712682/image002.png\" width=\"850\" /><p><a href=\"#N100AF\" class=\"ibm-popup-link\" onclick=\"ibmweb.overlay.show('N100AF',this);return false;\">点击查看大图<\/a><\/p><div id=\"N100AF\" class=\"dw-sidefile-overlay ibm-common-overlay ibm-overlay-alt-two\"><div class=\"ibm-head\"><p><a href=\"#close\" class=\"ibm-common-overlay-close\">关闭 [x]<\/a><\/p><\/div><div class=\"ibm-body\"><div class=\"ibm-main\"><div class=\"ibm-title\"><h2>图 2. 在罗马的 IBM Tivoli 实验中实现的 CLM 架构<\/h2><\/div><div class=\"ibm-container ibm-alternate\"><div class=\"ibm-container-body\"><img alt=\"基于 Jazz 实现的关键组件\" src=\"/sunshine_new/images/1195712682/image002_lg.png\" width=\"1183\" /><\/div><\/div><\/div><\/div><div class=\"ibm-footer\"><><\/div><\/div><p>除了这些 Rational 产品之外，IBM Tivoli Provisioning Manager 被用于发现和管理罗马 IBM Tivoli 实验室物理实验室资源可用的库存。<\/p><p>基于 Rational Quality Manager 与 IBM Tivoli Provisioning Manager 的集成，Tivoli 实验室希望通过让他们的团队能方便地访问测试实验室资源，来提高测试团队的工作效率。我们的目标是充分整合测试定义阶段和实际测试周期的管理。SmarTest Asset Management（STAM adapter）使得测试团队可以更容易地在不同组之间共享资源，来获得更好的资源利用，并给他们提供一个关于实验室资源、资源可获得性及资源预定情况的整体视图。<\/p><h5 id=\"fig3\">图 3. 罗马 IBM Tivoli 实验室实施的扩展 Rational CLM 架构<\/h5><img alt=\"IBM 罗马 Tivoli 实验室中 SmarTest 的关键组件\" src=\"/sunshine_new/images/1195712682/image003.png\" width=\"850\" /><p><a href=\"#N100C3\" class=\"ibm-popup-link\" onclick=\"ibmweb.overlay.show('N100C3',this);return false;\">点击查看大图<\/a><\/p><div id=\"N100C3\" class=\"dw-sidefile-overlay ibm-common-overlay ibm-overlay-alt-two\"><div class=\"ibm-head\"><p><a href=\"#close\" class=\"ibm-common-overlay-close\">关闭 [x]<\/a><\/p><\/div><div class=\"ibm-body\"><div class=\"ibm-main\"><div class=\"ibm-title\"><h2>图 3. 罗马 IBM Tivoli 实验室实施的扩展 Rational CLM 架构<\/h2><\/div><div class=\"ibm-container ibm-alternate\"><div class=\"ibm-container-body\"><img alt=\"IBM 罗马 Tivoli 实验室中 SmarTest 的关键组件\" src=\"/sunshine_new/images/1195712682/image003_lg.png\" width=\"1166\" /><\/div><\/div><\/div><\/div><div class=\"ibm-footer\"><><\/div><\/div><h2 id=\"afirstlookattestlabmanagementinrationalqualitymanager\">先来看看 Rational Quality Manager 中的测试实验室管理<\/h2><p>Rational Quality Manager 使得可以为端到端的测试管理更容易地管理测试实验室资源。由于能够定义您的测试环境并将其链接到测试用例，为您提供了测试执行的全程追溯，帮助您了解测试的覆盖情况，并且使您的组织能够更有效地利用资源。因为您可以通过使用预订来跟踪和管理您的实验室资源，或通过按分组来组织的资源，等等。<\/p><p>第一步是确保 Rational Quality Manager 了解您的实验室资源。其基本方法是手动创建实验室资源的定义，或从外部文件导入资源的定义。<\/p><p>更高级的方法利用 Rational Quality Manager 中与发现和配给工具集成的能力，如 IBM Tivoli Service Request Manager、 IBM Tivoli Application Dependency Discovery Manager 和 IBM Tivoli Provisioning Manager（查看<a href=\"#resources\">参考资料<\/a>获取关于相关细节的链接），来提供请求履行，库存察觉和自动化方面的能力。<\/p><p>这种集成是通过可被调用的适配器来进行的，被调用的适配器可以通过使用 Rational Quality Manager 的 web 用户界面来触发这些产品的操作。<\/p><h2 id=\"anoverviewofadapters\">适配器的概述<\/h2><p>适配器是 Rational Quality Manager 用于扩展所提供特定接口的实现。三种类型的适配器可以被用于实现扩展实验室管理的能力：<\/p><dl><dt><strong>库存（Inventory）：集成<\/strong><\/dt><dd>Rational Quality Manager 与具有库存清点功能的外部应用程序。通过这种集成，Lab Manager 可以更新实验室资源数据，以显示最新的实验室资源配置和新的实验室资源。<br />&#160;<\/dd><dt><strong>自动化（Automation）：集成<\/strong><\/dt><dd>Rational Quality Manager 与具有自动化功能的外部应用程序。有了这样的集成，Lab Manager 可以运行脚本、项目，或者在远程实验室资源的外部应用程序中配置的库。<br />&#160;<\/dd><dt><strong>虚拟化（Virtualization）：<\/strong><\/dt><dd>集成的 R??ational Quality Manager 与用于管理虚拟镜像和虚拟机的外部应用程序。<br />&#160;<\/dd><\/dl><p>这些适配器被称为 <strong><em>Lab Manager 适配器<\/em><\/strong>（Lab Manager adapter），这样您就可以与另一个特殊的适配器类型来区分扩展测试脚本的自动化运行。 <\/p><h2 id=\"tivoliprovisioningmanageradapter\">Tivoli Provisioning Manager 适配器<\/h2><p>Tivoli Provisioning Manager 适配器可用于集成 Rational Quality Manager 与 Tivoli Provisioning Manager。Rational Quality Manager 使用这一适配器来：<\/p><ul class=\"ibm-bullet-list\"><li>导入已由 Tivoli Provisioning Manager 所发现的资源信息<\/li><li>驱动 Tivoli Provisioning Manager 来运行已经发现硬件和软件的盘点工作<\/li><li>为已发现的计算机运行自动化任务或配给（provision）软件（当它可用时）<\/li><\/ul><p>查看<a href=\"#resources\">参考资料<\/a>来获得关于如何配置和定制 Tivoli Provisioning Manager adapter 的更多细节信息。<\/p><h2 id=\"thesmartestassetmanagersolution\">SmarTest Asset Manager（STAM）解决方案<\/h2><p>使用 Rational Quality Manager 预订实验室资源的用户有两个途径：<\/p><dl><dt><strong>快速通道（Fast path）<\/strong><\/dt><dd>预订资源以便可以直接使用，用户预订与测试需求相匹配的硬件和软件配置实验室资源。<br />&#160;<\/dd><dt><strong>间接路径（Indirect path）<\/strong><\/dt><dd>用户创建一个实验室资源的特定要求，详细介绍所需的软件和硬件配置以及 Lab Manager 进程的要求；识别和准备的实验室资源，以满足需求，储备资源，并将其分配给请求者。<br />&#160;<\/dd><\/dl><p>图 4 演示了使用快速路径的一个预订流。<\/p><h5 id=\"fig4\">图 4. Rational Quality Manager 中的快速路径预订流<\/h5><img alt=\"从测试人员到经理的资源预订流程\" src=\"/sunshine_new/images/1195712682/image004.png\" width=\"507\" /><p>快速路径预订只能用于为单个项目预留资源。它不能在资源跨团队和项目共享的测试实验室中使用，因为在这种情况下，它必须立即知道哪些是可利用的资源，而且保证预期实验室资源在请求时可用。此外，在一个共享的实验室中，在预订流程中必须能够考虑任何未来的硬件采购，以避免影响项目的成功。<\/p><p>建议的 STAM 解决方案是创建一个<strong><em>共享项目<\/em><\/strong>（shared project），这是一个额外的项目区域，以保持跟踪在测试实验室的所有资产，并引进和管理一个新的预订过程。这种新流程是一级预订，使测试人员和测试负责人可以以安全的方式为自己的项目预留一个或多个实验室资源。<\/p><p>该 STAM 解决方案使用 Tivoli Provisioning Manager 适配器来跟踪在测试实验室中所有可用的物理资源和 STAM 适配器来管理一级预订。<\/p><p>图 5 展示出了这个过程，并说明该解决方案的优点。<\/p><h5 id=\"fig5\">图 5. 在 Rational Quality Manager 与 STAM 解决方案中的预订流程<\/h5><img alt=\"一级和二级预订\" src=\"/sunshine_new/images/1195712682/image005.png\" width=\"848\" /><p>在此图中，假定共享实验室项目已经被链接到 Tivoli Provisioning Manager适配器，并且发现和同步的过程已经完成。所有在测试实验室中可用的物理资源已被发现，并在 Rational Quality Manager 中的共享实??验室项目显示作为实验室资源，如图 6 中所示。<\/p><h5 id=\"fig6\">图 6. 资源发现并导入到 Rational Quality Manager 中<\/h5><img alt=\"清点历史显示了列表的导入过程\" src=\"/sunshine_new/images/1195712682/image006.jpg\" width=\"850\" /><p>使用 STAM 解决方案进行预订的流包括以下几个步骤：<\/p><ol type=\"1\"><li>创建一个一级预订。<\/li><li>管理该一级预订的请求。<\/li><li>创建一个二级预订。<\/li><\/ol><h3 id=\"N10159\">步骤 1. 创建一个一级预订<\/h3><p>当一个测试人员为特定项目中的测试需要一个新的实验室资源时，测试人员需要登陆共享项目，并确定与所要求特性相符的实验室资源的可用性。<\/p><p>用在一级预订的预约过程包括三个基本步骤：<\/p><ol type=\"1\"><li><strong>用户创建<\/strong> 一个包含以下信息的请求：<ul class=\"ibm-bullet-list\"><li>预订的开始和结束日期<\/li><li>所需的硬件和软件<\/li><li>持有该预订的 Rational Quality Manager 的项目名称<\/li><li>测试人员的电子邮件地址，用于在预订发生冲突和任何潜在问题时的通知（可选）<\/li><li>在评论部分，使用命名约定（<em>％项目名称％<\/em> 和 <em>$用户电子邮件地址$<\/em>）留下项目名称及用户的电子邮件地址<\/li><\/ul><\/li><li>如果该系统<strong>满足<\/strong>该请求，则为请求分配一个或多个实验室资源。<\/li><li>如图 7 所示，系统为该请求所有的测试人员按所要求的时限<strong>预留<\/strong>实验室资源，并防止其他测试者在该段期间再次预约这些资源。<\/li><\/ol><h5 id=\"fig7\">图 7. 某个一级预订已履行请求的示例<\/h5><img alt=\"为 TEM_Rome(BigFix) 项目预留的资源预订\" src=\"/sunshine_new/images/1195712682/image007.jpg\" width=\"850\" /><h3 id=\"N1018D\">步骤 2. 使用 STAM 适配器管理该一级预订的请求<\/h3><p>在所述一级预订已经创建并履行之后，它将由 STAM 适配器进行管理。该测试可以明确要求 STAM 适配器开始管理新的请求，或测试人员可以等待 Rational Quality Manager 调度器（如果配置了的话）来触发这个动作。<\/p><p>STAM 适配器管理该请求以及两个主要自动化任务和一个次要任务：<\/p><ul class=\"ibm-bullet-list\"><li>管理预订任务<\/li><li>删除预订任务<\/li><li>导出资源列表任务（次要）<\/li><\/ul><p><em>管理预订<\/em>（manage reservation）任务管理已履行的预订，目的在于使资源在目标项目中可用，并且只在预留期限内有效。这个过程也被称为<em>资源克隆<\/em>（resource cloning），并遵循以下流：<\/p><ul class=\"ibm-bullet-list\"><li>寻找那些需要被管理的任何预订（例如，匹配开始日期的预订）。<\/li><li>使用在预订请求中注释部分的信息，在目标项目中克隆实验室资源。<\/li><li>添加实验室资源到实验室资源组共享项目中具有相同名称的目标项目。<\/li><li>在目标项目中为刚刚克隆的资源创建一个<em>反<\/em>预约（negative reservation），以便使资源在项目可用，并只在指定的预订期限内有效。<\/li><li>发送电??子邮件给在初始请求的注释部分指定的用户（可选）<\/li><\/ul><p>在图 8 中，该实验室资源在整个 2013 年中已经被分配给了 TEM_Rome 项目。<\/p><h5 id=\"fig8\">图 8. 该共享实验室项目实验室资源的细节情况<\/h5><img alt=\"R为 TEM_Rome 在 2013 年预约的资源预订\" src=\"/sunshine_new/images/1195712682/image008.jpg\" width=\"796\" /><p>在克隆过程之后，该实验室的资源显示在目标项目 TEM_Rome（BigFix，如图 9 所示。请注意，该资源在整个 2013 年可用于该项目，但它似乎从 2014 年开始已经被其他人预订了。该项目的目标用户可以清楚地看到资源提供给他们使用的时间段，什么时候资源将会被重新释放回社区。在可利用的时间里，他们可以使用二级预订来规划团队内对资源的使用。<\/p><h5 id=\"fig9\">图 9. 在目标项目中克隆资源的详细信息<\/h5><img alt=\"克隆资源的预订 -- 已预留给 2013 年\" src=\"/sunshine_new/images/1195712682/image009.jpg\" width=\"824\" /><p><em>删除预订<\/em>（delete reservation）任务管理预约结束时的清理。作为该工作的结果，所克隆的资源将从目标项目以及实验室资源组中删除，并且有一封电子邮件将被发送给用户（如果指定的话）。该资源可重新被用于新的预订。<\/p><p><em>导出实验室资源列表任务<\/em>（export lab resource list）任务用注释分隔值（CSV）格式创建的一个所有实验室资源的列表，并通过电子邮件发送给请求者。<\/p><h3 id=\"N101D2\">步骤 3. 创建一个二级预订<\/h3><p>一旦实验室资源在目标项目中已被克隆，用户就可以使用 Rational Quality Manager 中内置可用的预约过程进行管理，和根据特定项目的需要进行预留。我们把这种预订过程作为二级预订。<\/p><h3 id=\"N101D9\">在 Rational Quality Manager 中配置 STAM 适配器<\/h3><p>要启用 Rational Quality Manager 来识别 STAM 适配器，要添加一个新的段落到 integration_configuration.xml 文件，它通常是托管在 <em>RQM 安装路径\\<\/em>server\\conf\\qm 目录。<\/p><p>新段落定义 STAM 适配器为自动化适配器的一个实现，automationExtensionId。该适配器使 Rational Quality Manager 可以调用由适配器发现或部署的资源自动化任务。通过这种手段，STAM 适配器创建或发现一个假的资源，smartest.romelab.it.ibm.com 被作为任何自动化调用的目标。该 STAM 适配器还实现了一个盘点适配器，inventoryExtensionId。<\/p><p>在清单 1 代码中的 &lt;instance&gt; 标签，您可以看到适配器的配置细节。您可以修改的细节，以满足您的需求：<\/p><dl><dt><strong>项目区域（projectArea）<\/strong><\/dt><dd>定义适配器与 Rational Quality Manager 中特定项目的链接，这将是唯一一个授权与适配器进行交互的链接<br />&#160;<\/dd><dt><strong>实例（instance）<\/strong><\/dt><dd>定义了 STAM 适配器需要处理的不同的服务器实例：Rational Quality Manager 服务器本身和用于电子邮件通知的 SMTP 服务器<br />&#160;<\/dd><dt><strong>主机名（hostname）和端口（port）<\/strong><\/dt><dd>其中定义了服务器驻留和用于通信的端口<br />&#160;<\/dd><dt><strong>凭据（credential）段落<\/strong><\/dt><dd>提供可用于建立与服务器通信的用户名和密码<br />&#160;<\/dd><\/dl><p>应注意在代码中，文件名或路径使用下列缩写：<\/p><ul class=\"ibm-bullet-list\"><li>RQM: Rational Quality Manager<\/li><li>RTLM: Rational Test Lab Manager<\/li><\/ul><h5 id=\"listing1\">清单 1. 适配器配置<\/h5><div class=\"codesection\"><pre class=\"displaycode\">&lt;adapter&gt;\n    &lt;name&gt;STAM RTLM Integration Adapter&lt;/name&gt;\n    &lt;version&gt;1.0&lt;/version&gt;\n    &lt;APIVersionSupported&gt;1.0&lt;/APIVersionSupported&gt;\n    &lt;inventoryExtensionId&gt;com.ibm.tivoli.stam.rtlm.spi.inventory.STAMInventorySPI\n&lt;/inventoryExtensionId&gt;\n    &lt;automationExtensionId&gt;com.ibm.tivoli.stam.rtlm.spi.automation.STAMAutomationSPI\n&lt;/automationExtensionId&gt;\n    &lt;pluginId&gt;com.ibm.tivoli.stam.rtlm.spi&lt;/pluginId&gt;\n    &lt;instance&gt;\n        &lt;instanceId&gt;STAMadapter&lt;/instanceId&gt;\n        &lt;projectArea&gt;<em>Shared Project<\/em>&lt;/projectArea&gt;\n        &lt;hostname&gt;<em>my server name<\/em>&lt;/hostname&gt;\n        &lt;port&gt;<em>9443<\/em>&lt;/port&gt;\n        &lt;credential&gt;\n            &lt;username&gt;<em>user<\/em>&lt;/username&gt;\n            &lt;password&gt;<em>password<\/em>&lt;/password&gt;\n        &lt;/credential&gt;\n        &lt;secure&gt;true&lt;/secure&gt;\n        &lt;smtpserver&gt;\n            &lt;hostname&gt;emea.relay.ibm.com&lt;/hostname&gt;\n            &lt;credential&gt;\n                &lt;username&gt;user&lt;/username&gt;\n                &lt;password&gt;password&lt;/password&gt;\n            &lt;/credential&gt;\n        &lt;/smtpserver&gt;\n    &lt;/instance&gt;\n&lt;/adapter&gt;<\/pre><\/div><p>要完成适配器的安装，您需要重新启动 Rational Quality Manager。<\/p><h2 id=\"thesmartestsearchwebuserinterface\">SmarTest 搜索 Web 用户界面<\/h2><p>搜索可用资源的能力使实验室管理员、测试人员、资本支出经理能更好地了解资源的使用情况：<\/p><ul class=\"ibm-bullet-list\"><li>什么是被请求最多的资源？<\/li><li>在测试实验室中有哪些硬件和软件是可用的？<\/li><li>谁应该负责定义如何花钱来扩大测试实验室？<\/li><\/ul><p>一个新的搜索界面-SmarTest 搜索，大大提高了搜索实验室资源的能力，包括虚拟和物理资源。这个搜索界面通过 Rational Quality Manager 中的 Web 用户界面的相关网站（Related Site）部分即可轻松找到，如图 10 所示。<\/p><h5 id=\"fig10\">图 10. Rational Quality Manager 中的 SmarTest 搜索链接<\/h5><img alt=\"在 RQM 中哪里可以找到 SmarTest 搜索链接\" src=\"/sunshine_new/images/1195712682/image010.jpg\" width=\"850\" /><p><a href=\"#N1023A\" class=\"ibm-popup-link\" onclick=\"ibmweb.overlay.show('N1023A',this);return false;\">点击查看大图<\/a><\/p><div id=\"N1023A\" class=\"dw-sidefile-overlay ibm-common-overlay ibm-overlay-alt-two\"><div class=\"ibm-head\"><p><a href=\"#close\" class=\"ibm-common-overlay-close\">关闭 [x]<\/a><\/p><\/div><div class=\"ibm-body\"><div class=\"ibm-main\"><div class=\"ibm-title\"><h2>图 10. Rational Quality Manager 中的 SmarTest 搜索链接<\/h2><\/div><div class=\"ibm-container ibm-alternate\"><div class=\"ibm-container-body\"><img alt=\"在 RQM 中哪里可以找到 SmarTest 搜索链接\" src=\"/sunshine_new/images/1195712682/image010_lg.jpg\" width=\"1920\" /><\/div><\/div><\/div><\/div><div class=\"ibm-footer\"><><\/div><\/div><p>SmarTest 搜索是基于 FLEX 技术，提供了三个主要视图：<\/p><ul class=\"ibm-bullet-list\"><li>实验室资源图表（Lab Resource Charts）：饼图依据特性显示资源，如主机类型，操作系统等等<\/li><li>实验室资源列表（Lab Resource List）：具有所要求特性的实验室资源列表<\/li><li>未预留资源列表（Not Reserved Resource List）：符合所要求的特性，但尚未被预留的资源列表<\/li><\/ul><p><strong>实验室资源图表视图<\/strong><\/p><p>如图 11 中所示的实验室资源图表（Lab Resource Charts），显示了关于各主要实验室资源特性数据汇总的三个图表。该视图可被采购管理员或 IT 管理员所使用，用来对实验室中硬件和操作系统的分布获得一个全局概览。<\/p><p>对于图 11 我们选择了以下的特性：<\/p><ul class=\"ibm-bullet-list\"><li>主机类型（虚拟或物理）<\/li><li>操作系统分布<\/li><li>操作系统版本<\/li><\/ul><p>相同的信息可以按项目进行筛选，因此该项目的测试负责人可以对实验室资源的可用性得出结论，并可以主动管理诸如缺少的操作系统版本等问题。<\/p><h5 id=\"fig11\">图 11. Lab Resource Charts<\/h5><img alt=\"依据操作系统、主机类别显示的分布情况\" src=\"/sunshine_new/images/1195712682/image011.jpg\" width=\"850\" /><p>要进一步过滤资源在主机类型和操作系统分布方面的图表，可以双击饼图的切片进行查看。该筛选器操作也动态地影响到其他图表，如图 12 所示，其中操作系统版本的图表以 AND 模式显示了基于上一个图表的过滤结果。<\/p><h5 id=\"fig12\">图 12. 已进一步过滤的图表<\/h5><img alt=\"实验室资源图表的进一步过滤\" src=\"/sunshine_new/images/1195712682/image012.jpg\" width=\"850\" /><p><a href=\"#N1026F\" class=\"ibm-popup-link\" onclick=\"ibmweb.overlay.show('N1026F',this);return false;\">点击查看大图<\/a><\/p><div id=\"N1026F\" class=\"dw-sidefile-overlay ibm-common-overlay ibm-overlay-alt-two\"><div class=\"ibm-head\"><p><a href=\"#close\" class=\"ibm-common-overlay-close\">关闭 [x]<\/a><\/p><\/div><div class=\"ibm-body\"><div class=\"ibm-main\"><div class=\"ibm-title\"><h2>图 12. 已进一步过滤的图表<\/h2><\/div><div class=\"ibm-container ibm-alternate\"><div class=\"ibm-container-body\"><img alt=\"实验室资源图表的进一步过滤\" src=\"/sunshine_new/images/1195712682/image012_lg.jpg\" width=\"1903\" /><\/div><\/div><\/div><\/div><div class=\"ibm-footer\"><><\/div><\/div><p>通过双击操作系统版本的图表，它可以显示实验室??资源属性的一个列表，如图 13 所示。<\/p><h5 id=\"fig13\">图 13. 按所选中操作系统版本显示的实验室资源属性列表<\/h5><img alt=\"双击显示资源属性列表\" src=\"/sunshine_new/images/1195712682/image013.jpg\" width=\"850\" /><p><a href=\"#N10281\" class=\"ibm-popup-link\" onclick=\"ibmweb.overlay.show('N10281',this);return false;\">点击查看大图<\/a><\/p><div id=\"N10281\" class=\"dw-sidefile-overlay ibm-common-overlay ibm-overlay-alt-two\"><div class=\"ibm-head\"><p><a href=\"#close\" class=\"ibm-common-overlay-close\">关闭 [x]<\/a><\/p><\/div><div class=\"ibm-body\"><div class=\"ibm-main\"><div class=\"ibm-title\"><h2>图 13. 按所选中操作系统版本显示的实验室资源属性列表<\/h2><\/div><div class=\"ibm-container ibm-alternate\"><div class=\"ibm-container-body\"><img alt=\"双击显示资源属性列表\" src=\"/sunshine_new/images/1195712682/image013_lg.jpg\" width=\"1918\" /><\/div><\/div><\/div><\/div><div class=\"ibm-footer\"><><\/div><\/div><p><strong>实验室资源列表及未预留资源列表视图<\/strong><\/p><p>实验室资源列表（Lab Resource List）及及未预留资源列表（Not Reserved Lab Resource List）视图拥有相同的属性。实验室资源列表显示了所有实验室资源，如图 14 所示。未预留资源列表显示未被预留的实验室资源，这其实是实验室资源列表的一个子集。<\/p><h5 id=\"fig14\">图 14. 实验室资源列表<\/h5><img alt=\"基于名称、组别、操作系统等等的清单\" src=\"/sunshine_new/images/1195712682/image014.jpg\" width=\"850\" /><p><a href=\"#N10296\" class=\"ibm-popup-link\" onclick=\"ibmweb.overlay.show('N10296',this);return false;\">点击查看大图<\/a><\/p><div id=\"N10296\" class=\"dw-sidefile-overlay ibm-common-overlay ibm-overlay-alt-two\"><div class=\"ibm-head\"><p><a href=\"#close\" class=\"ibm-common-overlay-close\">关闭 [x]<\/a><\/p><\/div><div class=\"ibm-body\"><div class=\"ibm-main\"><div class=\"ibm-title\"><h2>图 14. 实验室资源列表<\/h2><\/div><div class=\"ibm-container ibm-alternate\"><div class=\"ibm-container-body\"><img alt=\"基于名称、组别、操作系统等等的清单\" src=\"/sunshine_new/images/1195712682/image014_lg.jpg\" width=\"1569\" /><\/div><\/div><\/div><\/div><div class=\"ibm-footer\"><><\/div><\/div><p>所有列都可以基于其内容进行过滤。内容可以是自由格式的文本，关于操作系统版本的复选框，或为关于内存的滑块，等等。搜索功能使您能够横跨所有列搜索内容。<\/p><p>列可以基于它们的内容进行过滤。每一列提供了一个取决于上下文的不同类型的过滤。例如，某些列可以被过滤自由格式文本，其他的可以有一个复选框（例如用于操作系统）或可以一个滑块来控制的过滤器（例如用于内存）。图 15、16 和图 17 显示出了过滤器的一些例子。<\/p><h5 id=\"fig15\">图 15. 自由格式文本过滤器的例子<\/h5><img alt=\"基于自由格式文本过滤\" src=\"/sunshine_new/images/1195712682/image015.jpg\" width=\"351\" /><h5 id=\"fig16\">图 16. 复选框过滤器的例子<\/h5><img alt=\"基于复选框过滤\" src=\"/sunshine_new/images/1195712682/image016.jpg\" width=\"631\" /><h5 id=\"fig17\">图 17. 滑块过滤器的例子<\/h5><img alt=\"基于滑块过滤\" src=\"/sunshine_new/images/1195712682/image017.jpg\" width=\"528\" /><p>包含较少的重要信息（例如，CPU 数量或操作系统内核）的列被隐藏；不过，单击复选框，您可以查看隐藏的列。一个预留的资源是由一个红色图标来指示的（绿色图标表示资源没有被预留）。单击时，会显示一个弹出窗口（Pop-up），显示了保留期，如图 18 所示。<\/p><h5 id=\"fig18\">图 18.16 保留期弹出窗口<\/h5><img alt=\"红色图或绿色图标来表示资源的预留状态\" src=\"/sunshine_new/images/1195712682/image018.jpg\" width=\"850\" /><p>单击时，Ping 按钮会显示该资源是否响应，并可导出有关资源的信息为 Excel 文件，以供离线参考。<\/p><h2 id=\"conclusion\">结论<\/h2><p>SmarTest 解决方案是由罗马 IBM Tivoli 实验室开发的一个概念验证的项目。它旨在通过集成 Rational 和 Tivoli 产品来提供完整的端到端系统的质量保证，以流水线化产品开发周期。SmarTest Asset Manager 仅仅是 SmarTest Asset Manager 解决方案的一个构建模块。<\/p><p>要了解更多关于其他构建模块的信息，请查看关于使用 Rati??onal Quality Manager 与 IBM SmartCloud Provisioning 来在您的测试管理中轻松整合虚拟实验室（请参阅参考资料以获得链接来查看 developerWorks 文章“扩展 Rational Quality Manager 来管理云中的实验室资产”）。<\/p><CMA ID: 972610><Site ID: 10><XSLT stylesheet used to transform this file: dw-document-html-7.0.xsl>\r\n\r\n\r\n<\/div>\r\n<\/div>\r\n","createTime":"2014-05-29 00:00:00","deployTime":"2014-05-29 00:00:00","id":0,"intro":"通过扩展 IBM Rational Quality Manager 中的 Test Lab Manager 组件，您可以放心地管理测试实验室中在不同团队和项目之间共享的测试资产。本文为您介绍了罗马 IBM Tivoli 实验室如何试行 IBM Tivoli Provisioning Manager 和 IBM Rational Quality Manager 的集成，来帮助测试团队实现提高生产力和改善生产周期，并提高他们的成本效益。","keyword":"","recommend":false,"source":"http://www.ibm.com/developerworks/cn/rational/manage-lab-assets-shared-lab/index.html","title":"使用 Rational Quality Manager 在共享实验室中管理实验室资产","typeId":0,"updateTime":"2014-05-29 00:00:00"}
{"author":"","clickNumber":0,"content":"\r\n<div class=\"ibm-columns\">\r\n<div class=\"ibm-col-1-1\">\r\n\r\n<h2 id=\"1.Introduction|outline\">简介<\/h2><p><a href=\"https://en.wikipedia.org/wiki/ZYpp\">Zypper<\/a> 是一个命令行包管理器，用于安装、更新和删除包，以及管理存储库。它对完成远程软件管理任务尤为重要，SUSE Linux 操作系统中已默认提供此包。有时，您希望执行一些更新时，由于显示问题或 YaST 实用程序未正常工作，您可能无法使用 DVD 执行任务。在这些情况下，您可以使用 Zypper 实用程序。<\/p><p>执行以下任务来从 SUSE Linux Enterprise Server (SLES) 11 SP0 升级到 SLES 11 SP03。 <\/p><ol type=\"1\"><li>列出已添加的存储库。 <img alt=\"\" src=\"/sunshine_new/images/负1500023443/image001.jpg\" width=\"543\" /><p> 消息 “No repositories defined” 表明还未添加任何存储库。<\/p><\/li><li>依据您的环境添加文件传输协议 (FTP) 存储库。 <img alt=\"\" src=\"/sunshine_new/images/负1500023443/image002.jpg\" width=\"612\" /><\/li><li>添加超文本传输协议 (HTTP) 和网络文件系统 (NFS) 存储库。 <img alt=\"\" src=\"/sunshine_new/images/负1500023443/image003.jpg\" width=\"611\" /><\/li><li>列出 SLES 服务器中的所有存储库。 <img alt=\"\" src=\"/sunshine_new/images/负1500023443/image004.jpg\" width=\"611\" /><\/li><li>此刻，我们只需要一个存储库是活动的。为此， 关闭所有存储库并仅开启需要的存储库。要关闭存储库，可输入 <code>zypper modifyrepo Call\n                        --disable<\/code> 命令。您需要以 root用户身份执行此任务。 <img alt=\"\" src=\"/sunshine_new/images/负1500023443/image005.jpg\" width=\"611\" /><\/li><li>使用 <code>zypper modifyrepo\n                    C-enable repo-update <\/code> 命令打开需要的存储库。 <img alt=\"\" src=\"/sunshine_new/images/负1500023443/image006.jpg\" width=\"611\" /><\/li><li>刷新存储库。 <img alt=\"\" src=\"/sunshine_new/images/负1500023443/image007.jpg\" width=\"576\" /><\/li><li>现在，使用 <code>zypper\n                    dup<\/code> 命令运行完整的发行版升级。 <\/li><\/ol><p>请注意，当前版本为 SLES 11 SP0，它需要升级到 SLES 11 SP03。<\/p><img alt=\"\" src=\"/sunshine_new/images/负1500023443/image008.jpg\" width=\"611\" /><p> 加载了升级需要的所有包。输入 <strong>yes<\/strong> 继续操作，再输入 <strong>yes<\/strong> 接受许可协议。<\/p><img alt=\"\" src=\"/sunshine_new/images/负1500023443/image009.jpg\" width=\"611\" /><p>可以注意到，操作系统已成功升级到 SLES 11 SP03。使用此方法，您将能够在 15 分钟内完成升级。现在，重新启动系统以让更改生效。<\/p><img alt=\"\" src=\"/sunshine_new/images/负1500023443/image010.jpg\" width=\"611\" /><h3 id=\"2.General usage|outline\">一般用途<\/h3><p>Zypper 的一般语法为<\/p><div class=\"codesection\"><pre class=\"displaycode\"> zypper [global-options]command[command-options][arguments] ...<\/pre><\/div><p>括号中包含的组件是可选的。运行 Zypper 的最简单方式键入它的名称，然后键入一个命令。<\/p><CMA ID: 972640><Site ID: 10><XSLT stylesheet used to transform this file: dw-document-html-7.0.xsl>\r\n\r\n\r\n<\/div>\r\n<\/div>\r\n","createTime":"2014-05-29 00:00:00","deployTime":"2014-05-29 00:00:00","id":0,"intro":"本文介绍了如何使用 Zypper 升级 SUSE Linux Enterprise Server (SLES)，还介绍了创建和修改存储库配置文件的流程。","keyword":"","recommend":false,"source":"http://www.ibm.com/developerworks/cn/linux/l-sles-with-zapper/index.html","title":"使用 Zypper 升级 SUSE Linux Enterprise Server","typeId":0,"updateTime":"2014-05-29 00:00:00"}
{"author":"","clickNumber":0,"content":"\r\n<div class=\"ibm-columns\">\r\n<div class=\"ibm-col-1-1\">\r\n\r\n<h2 id=\"overview\">概述<\/h2><p>DB2 10.5 构建于 “DB2 支柱优势” 之上：低操作成本、易开发性和可靠性。去年 4 月份发布的 DB2 for Linux, UNIX, and Windows 引入了 <a href=\"#cot\">按列组织的表<\/a> 功能。DB2 10.5 for Linux, UNIX, and Windows 将帮助您节省时间和资金，提供顶级性能，并通过对大量数据的高速分析更轻松地捕获业务洞察。<\/p><p>这些优势很大程度上归功于 BLU Acceleration，这是一组来自 IBM 研发实验室的技术创新，加速了报告和分析。BLU Acceleration 无需索引、聚合或耗时的数据库调优就可以实现顶级的性能和存储效率，它最初是作为 DB2 10.5 for Linux, UNIX, and Windows 中的一个全面集成的功能来提供的。<\/p><p>本文将介绍 DB2 10.5 中按列组织的表，还将简要概述这个版本中的其他重要改进，包括 <a href=\"#ts\">DB2 Text Search 增强<\/a>、<a href=\"#sqlce\">SQL 兼容性增强<\/a>、<a href=\"#db2pse\">DB2 pureScale 增强<\/a>、<a href=\"#bar\">数据恢复和 HADR 增强<\/a>，以及一些 <a href=\"#appl\">提高应用程序性能和可靠性的额外特性<\/a>。<\/p><h2 id=\"cot\">按列组织的表<\/h2><p>DB2 10.5 为 DB2 数据库引入了压缩的按列组织的表。在<em>按列组织的表<\/em> 中，数据页面包含列数据而不是行数据。按列组织的表方便了使用复杂查询对分析工作负载的处理，比如包含多表联接、分组和聚合，以及对星形模式的表扫描的查询。按列组织和按行组织的表可共存于同一个数据库、模式、表空间或查询中。<\/p><p>DB2 10.5 中对按列组织的数据的处理优化了内存、CPU 和 I/O，提供了以下收益：<\/p><ul class=\"ibm-bullet-list\"><li><strong>内存中优化<\/strong>能够实现最高性能。压缩的按列组织的数据可非常高效地存储，这减少了查询处理所需的内存量（并提高了查询处理的速度）。在内存中优化的数据库中，所有数据都可以加载到内存中，从而可以避免性能瓶颈。<\/li><li>一个<strong>不受主要内存大小约束的<\/strong>系统，其中处理的数据可能比 RAM 大得多。<\/li><li>跨核心<strong>改进的系统扩展<\/strong>。<\/li><li>一个<strong>增强的缓冲池缓存战略<\/strong>，显著降低了 I/O 成本。<\/li><li>比 E+DB2 10 <strong>更小的数据库存储资源占用<\/strong>。<\/li><li><strong>延迟解压<\/strong>，能够直接在压缩数据上执行某些操作，从而减少内存使用。<\/li><li>成倍的 CPU 处理能力，使用<strong>单指令多数据 (SIMD) 处理<\/strong>许多操作。<\/li><li>一次对多列数据值执行<strong>矢量处理<\/strong>，而不是处理单个值。<\/li><\/ul><p>为了支持这一新能力，DB2 10.5 提供了以下新的或增强的功能：<\/p><ul class=\"ibm-bullet-list\"><li>一种<strong>单一设置<\/strong> (<code>DB2_WORKLOAD=ANALYTICS<\/code>) 支持使用列组织，列组织是一种自动化、特殊化的初始内存配置，页面和区段大小配置，空间回收，以及自动工作负载管理。在创建数据库<em>之前<\/em>，确保将 DB2_WORKLOAD 注册表变量设置为 ANALYTICS。<\/li><li>CREATE TABLE 语句上新的<strong>指定表存储组织的语法<\/strong>（图 1）。如果指定了 ORGANIZE BY COLUMN 子句，数据会按列存储在表的数据页面中。一个给定的数据页面存储表的一列数据。如果指定 ORGANIZE BY ROW 子句，数据会按行存储在表的数据页面中。一个给定的数据页面存储表的一行或多行数据。如果未指定 ORGANIZE BY 子句，默认的 ROW 或 COLUMN 组织是通过新的 dft_table_org 数据库配置参数的值来确定的，默认值为 ROW。 <h5 id=\"figure1\">图 1. 显示了新的 ORGANIZE BY ROW 或 COLUMN 子句的 CREATE TABLE 语法片段<\/h5><img alt=\"该图显示了 CREATE TABLE 语法\" src=\"/sunshine_new/images/负1362657262/syntax.jpg\" width=\"580\" /><\/li><li>如果在 CREATE TABLE 语句上既没有指定 ORGANIZE BY COLUMN 子句，也没有指定 ORGANIZE BY ROW 子句，一个新的 <strong>数据库配置参数 dft_table_org<\/strong> 会指定将某个用户表将创建为按列组织的表还是按行组织的表。<\/li><li>一个新的<strong>实用程序 (db2convert)<\/strong> 可将一个指定数据库中一个或所有按行组织的用户表都转换为按列组织的表。在处理期间，按行组织的表会保持在线，该命令将会显示转换统计数据以供监视。请记住，这个转换过程目前是一个单向过程，所以在将表转换为列组织结构之前，一定要执行备份。<\/li><li>对 REORG TABLE 命令的增强支持您通过指定 RECLAIM EXTENTS 选项来<strong>回收按列组织的表上的存储<\/strong>。如果喜欢使用自动化的方法，那么可以设置 <code>DB2_WORKLOAD=ANALYTICS<\/code>。这会导致安装一个默认策略并启用 auto_reorg 数据库配置参数，以便为所有按列组织的表激活自动回收。<\/li><li><strong>自动工作负载管理<\/strong>，它可以通过一次运行多个查询，显著提高性能和工作负载的系统使用。为了确保在同时提交许多查询时，并且按列组织的数据上更多的工作负载不会让系统负担过重，在数据库上同时执行的 “重量级” 查询的数量是有限制的。可以通过使用默认的工作负载管理并发性阈值来实现此限制，该阈值在 DB2_WORKLOAD 注册表变量被设置为 ANALYTICS 时在新数据库上自动启用，或者可在现有数据库上手动启用。\n                            <p>DB2 10.5 中<em>默认的查询并发性管理<\/em> 在现有的 DB2 工作负载管理基础架构中实现，而且将在升级和新创建的数据库上创建以下新的默认工作负载管理对象：<\/p><ul class=\"ibm-bullet-list\"><li>现有的 SYSDEFAULTUSERCLASS 超类下存在一个服务子类 SYSDEFAULTMANAGEDSUBCLASS，重量级查询可在这个子类中运行，并作为一个组进行控制和监视。<\/li><li>一个 CONCURRENTDBCOORDACTIVITIES 阈值 SYSDEFAULTCONCURRENT，它被应用于 SYSDEFAULTMANAGEDSUBCLASS 子类，以便控制在这个子类中运行的并发执行查询的数量。<\/li><li>一个工作类集 SYSDEFAULTUSERWCS 和一个新的工作类 SYSMANAGEDQUERIES，它们识别要控制的重量级查询的类。SYSMANAGEDQUERIES 工作类包含分类为 READ DML（一个针对工作类的现有的工作类型）的查询，这些查询落在一个反映更重量级的查询的 timeron 阈值上方。<\/li><li>一个工作操作集 SYSDEFAULTUSERWAS 和工作操作 SYSMAPMANAGEDQUERIES，它们将所有归为 SYSMANAGEDQUERIES 工作类的查询映射到 SYSDEFAULTMANAGEDSUBCLASS 服务子类。<\/li><\/ul><\/li><li><strong>动态列表预取<\/strong>，这是访问按列组织的表的查询执行计划中使用的一种新预取类型，用于准确地预取在扫描表的一个特定部分时将要访问的页面。通过一直排队，直到需要的页面已加载到缓冲池中，这种预取方法最大程度地提高了异步预取所获得的页面数量（同时最大程度地减少了同步读取）。<\/li><li>捕获新的 <strong>DB2 解释信息<\/strong>，帮助您确定应用程序如何执行新的按列组织表功能。DB2 10.5 包含一个新的 CTQ 计划操作符，它代表着按列组织的数据处理与按行组织的数据处理之间的过渡。<\/li><li>对查询的<strong>半联接支持<\/strong>减少了大型内部表所使用的内存量。半联接是一种优化技术，在查询中利用了外部表和其他内部表上的一个或多个断言。DB2 解释输出得到了扩展，以表明某个特定的哈希联接操作符的内部表是否是一个将应用半联接优化技术的大型内部表。<\/li><li>DB2 10.5 引入了<strong>新的监视元素<\/strong>，这些元素将帮助您调优涉及到对按列组织表的查询的数据库服务器工作负载。 <ul class=\"ibm-bullet-list\"><li><strong>评估缓冲池效率<\/strong>：一组新的监视元素支持与按行组织的表独立地监视按列组织的表的数据页面 I/O。<\/li><li><strong>度量预取程序效率<\/strong>：一组新的监视元素可帮助您跟踪提交到预取程序的对按列组织的表中的数据请求量，以及由于页面已在内存中而被预取程序而跳过读取的页面数。<\/li><li><strong>度量列数据大小<\/strong>：一个按列组织的表与一个新的表对象关联，该表对象中存储了列数据。新监视元素可帮助估算列数据的大小。<\/li><li><strong>度量所花费的时间<\/strong>：新的所用时间监视元素提供了有关 DB2 数据库管理器如何花费时间处理按列组织的表的信息。<\/li><\/ul><\/li><\/ul><p>有关所有这些新功能的完整细节，请参阅 DB2 10.5 for Linux, UNIX, and Windows 信息中心。<\/p><p>按列组织的表仅支持 Linux（x86-x64、Intel 和 AMD 处理器）和 AIX（POWER 处理器）。按列组织的表处理功能在 DB2 Advanced Workgroup Server Edition、DB2 Advanced Enterprise Server Edition 和 DB2 Developer Edition 中提供。<\/p><h2 id=\"ts\">DB2 Text Search 增强<\/h2><p>您可以使用 DB2 Text Search 快速获取存储在 DB2 表中的文本数据。通过将 Text Search 功能合并在您的查询中，您可以创建强大的多功能文本检索应用程序。<\/p><p>在 DB2 10.5 中，DB2 Text Search 包含以下改进：<\/p><ul class=\"ibm-bullet-list\"><li>索引对搜索的影响变得更小。<\/li><li>对多语言集合的更强支持。<\/li><li>对嵌入式文档、归档文件和压缩文件的支持。<\/li><li>增强的配置功能，包括定义系统级默认值的能力。<\/li><li>新的 db2ts SET COMMAND LOCKS FOR TEXT 命令为您提供了对您数据库中的某个特定文本搜索索引手动设置命令锁的能力，这对在索引可能受未通过 DB2 Text Search 管理的操作影响时预防冲突很有用。<\/li><li>两个新的文本搜索索引配置选项 INITIALMODE 和 LOGTYPE，有助于控制更新的处理。这些选项在 db2ts CREATE INDEX FOR TEXT 命令上指定。在创建索引时使用 INITIALMODE 选项运行初始更新。LOGTYPE 选项用于确定如何管理日志表。db2ts CREATE INDEX FOR TEXT 命令为一个文本列创建一个文本搜索索引。您可以使用文本搜索功能来搜索列数据。<\/li><li>用于细粒度控制更新处理的更多选项：您现在可以为一个 COMMIT 操作指定批次大小，以及在更新会话期间要完成多少个提交周期。您还可以指定提交大小基于处理的行数还是提交经过的小时数。<\/li><\/ul><h2 id=\"sqlce\">SQL 兼容性增强<\/h2><p>如果您更加熟悉其他关系数据库产品，DB2 10.5 包含的一些增强使得 DB2 产品更容易使用。以下增强根据以前的 DB2 for Linux, UNIX, and Windows 的版本中发布的丰富的 SQL 兼容性增强，减少了一些应用程序在 DB2 环境中运行的时间和复杂性：<\/p><ul class=\"ibm-bullet-list\"><li><strong>扩展的行大小支持<\/strong>：您现在可以创建一个表，其中的行可超出表空间的页面大小的最大行长度。使用扩展的行大小支持将行大小超出 32 KB 的表迁移到 DB2 10.5，或者创建包含更多 VARCHAR 或 VARGRAPHIC 列的表。您可修改现有的表，以便利用扩展的行大小支持，该支持通过将 extended_row_sz 数据库配置参数设置为 ENABLE 来启用。在数据插入操作期间，如果数据超出了最大行长度，一个 VARCHAR 或 VARGRAPHIC 数据子集会移动到行外部，并被存储为 LOB 数据。<\/li><li><strong>对排除空键支持<\/strong>：您可以在 CREATE INDEX 语句上使用新的 EXCLUDE NULL KEYS 子句，预防在键的所有列或表达式为空值时将该键插入索引对象中，从而在您不希望查询访问与空键关联的数据时减少稀疏索引的大小并增强性能。在惟一索引执行期间，会忽略其中的索引键为空值的行。<\/li><\/ul><h2 id=\"db2pse\">DB2 pureScale 增强<\/h2><p><em>DB2 pureScale 特性<\/em> 是一种集群技术，支持您以近线性的效率和可预测的查询性能扩展您的系统，您无需修改您的应用程序或更改数据的分发方式。<\/p><p>在 DB2 10.5 中，DB2 pureScale 特性包含以下增强：<\/p><ul class=\"ibm-bullet-list\"><li><strong>改进的可用性<\/strong>：您可以在线添加 DB2 成员，不会产生任何宕机时间。如果离线添加成员，不再需要再次使用数据库之前执行数据库备份操作。此外，从 DB2 10.5 开始，在应用在线修复包更新时，您一次可更新一个成员或集群缓存工具 (caching facility, CF)，同时让成员和 CF 继续处理事务，保持持续可用性。<\/li><li><strong>自定义的工作负载平衡（也支持分区数据库环境）<\/strong>：您现在可以通过定义支持，将应用程序工作负载隔离到一个特定的成员集的成员子集，实现成员级工作负载管理。<\/li><li><strong>更轻松的恢复<\/strong>：DB2 pureScale 环境现在支持 DB2 高可用性灾难恢复 (HADR)，将前者的持续可用性特性与后者健全的灾难恢复功能相结合。您现在还可以将一个离线备份镜像从 IBM DB2 10.5 Enterprise Server Edition (ESE) 实例还原到 DB2 pureScale 实例，或者将一个镜像从 DB2 pureScale 实例还原到 ESE 实例。您可以将数据库备份镜像还原到一个具有不同拓扑结构的 DB2 pureScale 实例，或者将在 DB2 pureScale 实例上创建的在线数据库或表空间备份镜像还原到某个具有超集拓扑结构的 DB2 pureScale 实例。此还原支持包括通过成员添加事件执行前滚操作。<\/li><li><strong>增强的表重组<\/strong>：现在 DB2 pureScale 环境中支持原地（在线）表重组。<\/li><li><strong>通过特定于成员的 STMM 实现增强的性能<\/strong>：DB2 pureScale 环境中的自调优内存管理得到了增强，在每个成员上有一个独立的 STMM 调优程序。这些调优程序可适当地响应每个成员上的可用内存的更改，该调优可以更恰当地反映工作负载的特征。<\/li><li><strong>减少的索引页争用<\/strong>：索引键列上的随机排序有助于在某些插入操作期间减轻被频繁访问的页面上的页面争用。在 DB2 pureScale 环境中频繁访问索引叶页面时，这项新功能特别有用。<\/li><li><strong>简化的根登录设置<\/strong>：您现在可以安装和配置 DB2 pureScale 特性，无需删除根登录和无密码的 SSH，这消除了一些安全问题。<\/li><li><strong>简化的修复包安装<\/strong>：您可以使用 DB2 installFixPack 命令在单个步骤中同时更新 DB2 pureScale 实例和 DB2 ESE 实例类型。<\/li><\/ul><h2 id=\"bar\">数据恢复和 HADR 增强<\/h2><ul class=\"ibm-bullet-list\"><li><strong>DB2 Advanced Copy Services 接口方便了自定义脚本的使用<\/strong>：实现快照备份和还原操作的自定义脚本，现在可以更加无缝地与 DB2 数据服务器集成，从而减少用户错误和改善这些快照操作的监视和管理。\n                        <p>使用一个存储设备的快速复制技术，比如 DB2 Advanced Copy Services (ACS) 提供的技术，可让备份和还原操作中的数据复制运行得比传统备份或还原操作快得多。使用 DB2 ACS 的备份操作被称为<em>快照备份操作<\/em>，使用 DB2 ACS 的还原操作被称为<em>快照还原操作<\/em>。要执行快照备份和还原操作，需要使用存储驱动器或不受支持的存储设备的 DB2 ACS API 驱动程序，这是一段支持您的存储设备执行快照操作的自定义脚本。尽管这些脚本在您可使用的存储设备方面提供了灵活性，但它们可能很容易出错，而且无法生成历史文件条目。<\/p><p>在 DB2 10.5 中，DB2 ACS API 包装在 DB2 ACS 库中。以前容易出错的操作（比如在正确的时刻发出 SET WRITE SUSPEND 和 SET WRITE RESUME 命令）由 DB2 数据库管理器处理。此外，每个快照操作的条目被写入到恢复历史文件中，这使得您能够监视这些操作的最终状态。<\/p><\/li><li><strong>改进的 HADR 监视<\/strong>：MON_GET_HADR 表功能和 db2pd 命令（在您指定 -hadr 选项时）会返回以下新字段： <ul class=\"ibm-bullet-list\"><li>HEARTBEAT_MISSED，自数据库在本地成员上启动以来未在此日志流上按时收到的检测消息数量。<\/li><li>HEARTBEAT_EXPECTED，自数据库在本地成员上启动以来，此日志流上应该收到的检测消息数量；将此值与 HEARTBEAT_MISSED 的值进行比较，可以衡量在特定的时间间隔内网络的健康状况。<\/li><li>STANDBY_SPOOL_PERCENT，所使用的假脱机空间占配置的假脱机限制的百分比；这是一个表明使用了多少 HADR 日志假脱机空间的指标。<\/li><li>STANDBY_ERROR_TIME，备用数据库上一次遇到重大错误的时间。<\/li><\/ul><\/li><\/ul><h2 id=\"appl\">其他提高应用程序性能和可靠性的特性<\/h2><ul class=\"ibm-bullet-list\"><li>支持 <strong>NOT ENFORCED 主键和惟一约束<\/strong>，这使您在知道数据已符合约束时能够避免性能成本和空间需求。在对数据库的索引访问无法提供额外的收益时，这些参考性约束可帮助查询优化器选择最佳的数据访问计划。<\/li><li><strong>基于表达式的索引<\/strong>：您现在可以创建一个索引，它包含一个基于表达式的键，而不是表中存储的数据，而且表达式的结果存储在索引中。如果查询优化器选择一个包含基于表达式的键的索引，那么在断言中包含相同表达式的查询的性能就会得到改善。<\/li><li>DB2 10.5 包含许多 IBM <strong>数据服务器客户端和驱动程序增强<\/strong>。要利用这些改进，则必须升级到 10.5 版的 IBM 数据服务器客户端或驱动程序。这些增强与以下部分相关： <ul class=\"ibm-bullet-list\"><li>常见客户端和驱动程序<\/li><li>调用级接口 (CLI) 驱动程序<\/li><li>IBM Data Server Provider for .NET<\/li><li>IBM Data Server Driver for JDBC and SQLJ<\/li><\/ul><p>有关的完整细节，请参阅 DB2 10.5 for Linux, UNIX, and Windows 信息中心。<\/p><\/li><\/ul><h2 id=\"tools\">一个包含丰富工具的环境使 DB2 10.5 更容易使用<\/h2><p>支持数据库管理和应用程序开发的工具可真正增强您的性能获益和总体生产力。<\/p><ul class=\"ibm-bullet-list\"><li><a href=\"http://www-01.ibm.com/software/data/optim/data-studio/\">IBM Data Studio<\/a> 包含在 DB2 10.5 的每个版本中。Data Studio 在单个基于 Eclipse 的产品中合并了高级的开发、管理和监视工具。<\/li><li>DB2 Advanced Enterprise Server Edition 包含 <a href=\"http://www-01.ibm.com/software/data/optim/data-architect/\">IBM InfoSphere Data Architect<\/a>，您可以使用它发现、建模、可视化、关联和标准化整个企业中多样性和分散的数据资产。<\/li><li><a href=\"http://www-01.ibm.com/software/data/optim/performance-manager/\">InfoSphere Optim Performance Manager<\/a> 提供了多项增强来支持 DB2 pureScale。<\/li><li>包含了 <a href=\"http://www-01.ibm.com/software/data/optim/query-workload-tuner-db2-luw/\">InfoSphere Optim Query Workload Tuner<\/a>，以便提供最大程度地提高应用程序性能的专家建议。Optim Query Workload Tuner 4.1 中的 Workload Table Organization Advisor 检查一个查询工作负载中引用的表，提供用于提高查询工作负载的性能的建议。该工具识别推荐从行组织结构转换列组织结构的表。<\/li><li>包含了 <a href=\"http://www-01.ibm.com/software/data/optim/configuration-manager-db2-luw/\">InfoSphere Optim Configuration Manager<\/a>，以便提供数据库和客户端配置的集中化管理。<\/li><\/ul><h2 id=\"Conclusion\">结束语<\/h2><p>DB2 10.5 提供了大量增强和创新，可帮助用户节省时间和资金，实现更高的性能。DB2 10.5 中按列组织的功能的优势（及其行业领先的压缩和针对大数据量的分析查询上的巨大性能获益）包括显著减少的价值实现时间和更高的实用性，实现此目标只需满足极低的 DBA 设计需求并执行更少的查询调优和调试工作。<\/p><CMA ID: 972794><Site ID: 10><XSLT stylesheet used to transform this file: dw-document-html-7.0.xsl>\r\n\r\n\r\n<\/div>\r\n<\/div>\r\n","createTime":"2014-05-29 00:00:00","deployTime":"2014-05-29 00:00:00","id":0,"intro":"本文将介绍 IBM DB2 10.5 for Linux, UNIX, and Windows 中的关键特性和增强。这个版本于 2013 年 6 月发布，它提供了丰富的新功能，这些功能直接解决了您在削减成本、提高应用程序性能、生产力和可靠性方面的业务需求。","keyword":"","recommend":false,"source":"http://www.ibm.com/developerworks/cn/data/library/techarticle/dm-1304whatsnewdb2105/index.html","title":"DB2 10.5 for Linux, UNIX, and Windows 中的新功能","typeId":0,"updateTime":"2014-05-29 00:00:00"}
{"author":"","clickNumber":0,"content":"\r\n<div class=\"ibm-columns\">\r\n<div class=\"ibm-col-1-1\">\r\n\r\n<h2 id=\"major1\">概述<\/h2><p>DB2 V10.5 于 2013 年 6 月发布，其中引入了许多新特性，而最为重要的一个就是引入了列存储表，这种不同于以前的行存储表的表结构在很大程度上提高了数据的查询速度。但是数据库在使用过程，数据的更新或删除操作时难以避免的，随着数据库的使用存储数据的块中必然会产生空洞，这会造成很大的空间浪费，用户往往都希望这些空间能及时的释放从而被其它的数据所用，从而能使得数据库的大小保持在最小的状态。本文主要介绍了在引入列存储表之后，其删除数据与更新数据的空间浪费是如何造成的，并且对存储空间的回收主要有哪些手段以及具体的操作过程进行了详细的讲解。<\/p><h2 id=\"major2\">DB2 v10.5 中列存储表（Column）介绍<\/h2><p>首先对 V10.5 进行简单的介绍，列存储表是 DB2 V10.5 BLU 中的一个新的技术，我们知道在此之前 DB2 中的表都是按行来组织存储数据的，这种行存储的表有一个缺陷就是，当批量数据时，必然会选取其中的某列或者某些列，而行存储只能把整个行取出然后再进行过滤，这样不仅会增加 CPU 的消耗，而且相应的 IO 也会增加。列存储表中的数据是按照列组织存储的，这样读取数据时只需要读取查询语句中指定的列即可，这就大大较少了数据量，从而降低了 IO，并且数据是按照列组织存储的，我们知道同一列的数据往往具有较高的重复率以及相似度，从而 DB2 采用类哈弗曼编码可以获取更高的压缩比，并且数据在查询过程中不需要解压缩，这就减少了内存以及磁盘的存储，更加降低了 IO。<\/p><p>单点查询是列存储表的一个略势，查询或者修改某一行的数据，相对行存储表而言这是列存储表的不足之处，因此对于 OLTP 的系统采用列存储表就相对不太适合，但是对于需要执行很多批量查询的 OLAP 系统而言，列存储表则是更好的选择。<\/p><p>要创建列存储表，首先要对 DB2 10.5 进行如下的设置：<\/p><ul class=\"ibm-bullet-list\"><li>\nDB2_WORKLOAD 注册变量设置为 ANALYTICS，顺便说一下 SAP 中的 DB2 V10.5 不需要设置此参数。<\/li><li>\nDB2 数据库必须是单节点，UNICODE 编码<\/li><li>\nDB 的参数 auto_runstats 设置为 OFF，因为列存储表不支持自动收集统计信息。<\/li><li>\nDB 的参数 util_heap_sz 至少设置为 1,000,000 个页。<\/li><\/ul><p>这些设置完成之后就可以创建列存储表了，列存储表的创建语句很简单，只需要在之前的表创建语句后面加上 organize by column 即可。<\/p><h2 id=\"major3\">删除与更新操作的空间回收<\/h2><h3 id=\"major4\">删除操作之后的空间回收<\/h3><p>当列存储表中的一行数据被删除后，实际上这一行只是从逻辑层面上删除，并没有再物理层面上删除，因此这样就使得这一行所占用的空间并不能被后面的事务插入的数据所使用，直到执行空间回收之后才可以被使用。例如：Job A 创建了表 Table，并且往里面插入了 100 万条数据，插入数据之后这个表占用 5MB 的存储空间。一段时间过后 Job B 又向表 Table 插入了 100 万条数据，同样数据也是 5MB，那么现在这个表就占用磁盘 10MB，随后把 Job A 的 100 万条数据全部删除，我们发现表 Table 仍然占用 10MB 的存储空间。然后 Job C 又插入 100 万条记录到表中，则仍然需要 5MB 的存储空间，即现在的表 Table 共占用了 15MB 的存储空间。然而对比行存储的表，Job C 的 100 万条记录则会放在 Job A 中被删除记录的空间中，即如果是行存储表则 Job C 插入 100 万条数据之后，表 Table 仍是 10MB 的存储空间。因此对比行存储表，列存储表在数据删除之后的空间浪费更为严重，于是对列存储表而言，REORG 操作更为重要，当大量的记录被删除之后就需要执行 Reorg Table 来对空间进行回收，这样才能提高空间的利用率，减少空洞。<\/p><h3 id=\"major5\">删除操作之后的空间浪费模拟试验<\/h3><p>操作系统版本：LINUXAMD，DB2 版本：V10.5。<\/p><p>本实验是为了验证前一节所讲的，列存储表的数据删除确实会造成非常严重的空间浪费，从而证明列存储表进行及时的 REORG 是非常重要的。<\/p><p><strong>(1) 创建列存储表<\/strong><\/p><p>列存储表的创建语句非常简单就是在之前的 create table 语句之后添加 organize by column，另外如果把 db2set 的参数 DB2_WORKLOAD 设置为 ANALYTICS 之后，即便不加最后的 organize by column，默认创建的表也为列存储表。<\/p><p>列存储表创建成功之后，还需要设置以下的参数：<\/p><ul class=\"ibm-bullet-list\"><li>\n要确定 DBM 的参数 INTRA_PARALLEL 设置为 YES，否则当执行插入操作的时候会报错误 SQL1668N。<\/li><li>\nDB 的参数 CUR_COMMIT 设置为 ON，如果 CUR_COMMIT 的值为 DISABLED 则在执行查询操作时会出现错误。<\/li><li>\n查看 SORTHEAP 的大小，如果比较小，查询时也会报错 SQL0955C。在 LINUXAMD 系统上，参数 SORTHEAP 最小为 2560。<\/li><\/ul><p>在本实验里，创建的列存储表 sales_fact_col 的定义如下：<\/p><h5 id=\"listing1\">清单 1. 列存储表的创建<\/h5><div class=\"codesection\"><pre class=\"displaycode\">saplxvm55:db2lr1 67&gt; db2 \"create table sales_fact_col (day_date date, prod_code char(6),\nstore_num char(5), quantity integer) organize by column\"\nDB20000I The SQL command completed successful<\/pre><\/div><p><strong>(2) 我们定义存储过程来模拟 JOB1，JOB2，JOB3<\/strong><\/p><p>其中为了方便计算插入的数据量所需要占用的存储空间，使 JOB3 的定义与 JOB1 相同，这样 JOB3 和 JOB1 插入的数据是相同的，从而 JOB3 插入数据所需要的存储空间肯定就小于或者等于 JOB1 插入数据的存储空间，其 JOB1（JOB3）和 JOB2 的定义代码如下：<\/p><h5 id=\"listing2\">清单 2. JOB1（JOB3）<\/h5><div class=\"codesection\"><pre class=\"displaycode\">db2 \"create procedure job1()\nBEGIN\ndeclare @i int;\ndeclare @j int;\n declare @value int;\nset @j=0;\nwhile @j&lt;10\nset @i=1;\ndo\n while @i&lt;100001\n do \n set @value=i;\n insert into DB2LR1.sales_fact_col values('09/09/2009','P12100','A2000',@value);\n set @i=@i+1;\n end while;\n commit;\n set @j=@j+1;\nend while;\nEND\"<\/pre><\/div><h5 id=\"listing3\">清单 3. JOB2<\/h5><div class=\"codesection\"><pre class=\"displaycode\">db2 \"create procedure job2()\nBEGIN\ndeclare @i int;\ndeclare @j int;\n declare @value int;\nset @j=0;\nwhile @j&lt;10\nset @i=1;\ndo\n while @i&lt;100001\n do \n set @value=i;\n insert into DB2LR1.sales_fact_col values('12/10/2009','P12101','A2001',@value);\n set @i=@i+1;\n end while;\n commit;\n set @j=@j+1;\nend while;\nEND\"<\/pre><\/div><p><strong>(3) 调用存储过程 job1<\/strong><\/p><p>在 CLP 中执行 db2 call job1，插入 100 万条数据，之后其查询结果如下。<\/p><h5 id=\"listing4\">清单 4. JOB1 插入 100 万条数据<\/h5><div class=\"codesection\"><pre class=\"displaycode\">saplxvm55:db2lr1 103&gt; db2 \"select count(*) from SALES_FACT_COL \"\n1\n-----------\n 1000000\n 1 record(s) selected.<\/pre><\/div><p><strong>(4) 查看表 SALES_FACT_COL 的大小<\/strong><\/p><p>查询表 SALES_FACT_COL 所占用的 page 页数，开始其结果为-1，这是因为 DB2 还没收集统计信息，对于列存储表不能自动执行 runstats，这一点需要注意，因此首先需要收集统计信息，之后再对表的页数进行查询，其执行结果如下。<\/p><h5 id=\"listing5\">清单 5. 查看表 SALES_FACT_COL 所占用的 PAGE 页<\/h5><div class=\"codesection\"><pre class=\"displaycode\">saplxvm55:db2lr1 116&gt; db2 runstats on table SALES_FACT_COL\n DB20000I The RUNSTATS command completed successfully.\nsaplxvm55:db2lr1 117&gt; db2 \"select fpages from syscat.tables where TABNAME=' SALES_FACT_COL'\"\nNPAGES\n--------------------\n 423\n 1 record(s) selected.<\/pre><\/div><p>由此可知 job1 插入的 100 万条数据共占用了 423 个 page 页。而当前 DB 的 PAGE SIZE 为 16K(如下图)，因此当前表 SALES_FACT_COL 所占用的存储空间大小为 423*16K。<\/p><h5 id=\"img001\">图 1.DB 的 PAGE SIZE 参数大小<\/h5><img alt=\"图 1.DB 的 PAGE SIZE 参数大小\" src=\"/sunshine_new/images/负42519656/img001.png\" width=\"554\" /><p>除了上述方法外，我们也可以用以下的 SQL 语句直接查询出具体的空间大小，如清单 6 可知，该表所占用的存储空间为 6944KB。<\/p><h5 id=\"listing6\">清单 6. 查询表 SALES_FACT_COL 所占用的存储空间<\/h5><div class=\"codesection\"><pre class=\"displaycode\">saplxvm55:db2lr1 333&gt; db2 \"select 'SALES_FACT_COL' as TableName, (data_object_p_size +\n                             index_object_p_size + col_object_p_size) as total_p_size_by_kb from\n                             TABLE(SYSPROC.ADMIN_GET_TAB_INFO('DB2LR1','SALES_FACT_COL'))\"\nTABLENAME TOTAL_P_SIZE_BY_KB\n-------------- --------------------\nSALES_FACT_COL 6944\n 1 record(s) selected.<\/pre><\/div><p><strong>(5) 执行 JOB2<\/strong><\/p><p>调用 job2, 执行完成之后，其查询记录条数如下，累加 JOB1 的 100 万条，共计 200 万条。<\/p><h5 id=\"listing7\">清单 7. JOB2 完成后的数据记录数<\/h5><div class=\"codesection\"><pre class=\"displaycode\">saplxvm55:db2lr1 107&gt; db2 \"select count(*) from SALES_FACT_COL\"\n1\n-----------\n 2000000\n 1 record(s) selected.<\/pre><\/div><p><strong>(6) 再次查看表 SALES_FACT_COL 所占用的页数<\/strong><\/p><p>对比步骤（4），发现增加了 1000 多个 page 页。<\/p><h5 id=\"listing8\">清单 8. JOB2 完成后表所占用的页数<\/h5><div class=\"codesection\"><pre class=\"displaycode\">saplxvm55:db2lr1 119&gt; db2 runstats on table SALES_FACT_COL\n DB20000I The RUNSTATS command completed successfully.\nsaplxvm55:db2lr1 120&gt; db2 \"select fpages from syscat.tables where TABNAME=' SALES_FACT_COL'\"\nNPAGES\n--------------------\n 1539\n 1 record(s) selected.<\/pre><\/div><p><strong>(7) 删除 job1 插入的数据<\/strong><\/p><p>同时删除完成之后，再次确认表所占用的存储空间。JOB1 的数据删除之后，表 SALES_FACT_COL 仍然占用 1539 个 PAGE 页，对比第（6）步，说明数据只是从逻辑层面删除了。<\/p><h5 id=\"listing9\">清单 9. 删除 JOB1 插入的数据<\/h5><div class=\"codesection\"><pre class=\"displaycode\">saplxvm55:db2lr1 122&gt; db2 \"delete SALES_FACT_COL where prod_code ='P12100'\"\nDB20000I The SQL command completed successfully.\nsaplxvm55:db2lr1 123&gt; db2 \"select count(*) from SALES_FACT_COL \"\n1\n-----------\n 1000000\n 1 record(s) selected.<\/pre><\/div><h5 id=\"listing10\">清单 10. JOB1 的数据删除后的表占用空间<\/h5><div class=\"codesection\"><pre class=\"displaycode\">saplxvm55:db2lr1 130&gt; db2 runstats on table SALES_FACT_COL \nThe RUNSTATS command completed successfully.\nsaplxvm55:db2lr1 131&gt; db2 \"select fpages from syscat.tables where TABNAME=' SALES_FACT_COL '\"\nNPAGES\n--------------------\n1539\n1 record(s) selected.<\/pre><\/div><p><strong>(8) 执行 job3<\/strong><\/p><p>即再次调用 job1 的存储过程，再插入 100 万条数据，其数据和之前的 job1 完全相同。然后再次查看表中所占的 page 页的数量，对比步骤（7）页的数量增加了 200 多，其实考虑到 job1 是初次执行，需要创建 metadata 等，job1 中的数据所占用的存储空间必然会大于 job3 的，因此 job1 占用的存储空间完全足够存放 job3 的数据，但是发现 job3 完成之后，表所占用的 page 页增加了 200 多，这就说明 job3 新插入的数据是存储在新的 page 页中，而没有占用之前 job1 删除的数据所占用的 page 页，也就是造成了空间的浪费。<\/p><h5 id=\"listing11\">清单 11. JOB3 完成后表所占用的存储空间<\/h5><div class=\"codesection\"><pre class=\"displaycode\">saplxvm55:db2lr1 233&gt; db2 runstats on table SALES_FACT_COL\n                 DB20000I The RUNSTATS command completed successfully.\nsaplxvm55:db2lr1 234&gt; db2 \"select fpages from syscat.tables where\n                 TABNAME='SALES_FACT_COL'\"\nFPAGES\n--------------------\n 1753\n 1 record(s) selected.<\/pre><\/div><p>至于行存储表的相关试验，这里就不再进行详细的介绍，需要说明的是行存储表中第 8 和第 10 步所得的 page 页的值是相同的，感兴趣的可以把 表 SALES_FACT_COL 创建成行存储表，进行相同的试验进行验证。<\/p><p>试验发现，列存储表的数据删除确实区别于行存储表，会造成严重的空间浪费，因此大量的删除操作之后需要及时的 REORG，这对于列存储表是非常重要的，可以从很大程度上节约存储空间。<\/p><h3 id=\"major6\">更新操作之后的空间回收<\/h3><p>前面讲了删除操作后的空间回收，这里对于更新操作的空间回收就简单的介绍下，不再进行相关的实验模拟。当列存储表中的一行记录被更新时，首先 DB2 要先删除这一行数据，与此同时这行数据的一个带有更新数据的拷贝将会插入到这个表的尾部。实际上就是如果不执行空间回收，那么某一行占用空间的比例是由它被更新的次数决定的。在执行更新操作的扩展数据块中的所有行再空间回收操作之前都将被删除，因此更新操作如果不及时的进行空间回收就会造成大量的空间浪费。<\/p><h2 id=\"major7\">回收列存储表的空闲存储空间<\/h2><h3 id=\"major8\">自动回收<\/h3><p>首先需要说明的是当 DB2_WORKLOAD 设置成 ANALYTICS 的时候，对于列存储表一个默认的自动 Reorg 的策略会被设定，这时列存储表的自动维护机制处于激活状态，DB2 会自动对列存储表中的空闲的块进行回收，这个进程在后台进行，DBA 完全不用干涉，之后这些回收的存储空间可以被相同表空间的任意表所使用。<\/p><p>如图（2），在这个例子当中展示了一个带着八个扩展数据块三列数据的存储表，其中 4 个扩展数据块存储 2013 年的数据，另外的 4 个扩展数据块存储 2012 年的数据，一个 SQL 语句执行删除某一时间段的所有数据之后，这个例子中，这个时间点是 2012 年，自动存储回收机制检测到这 4 个扩展数据块的数据已经被删除，然后回收这些存储空间，从而这些存储空间能再被该表或者其他表所用。<\/p><h5 id=\"img002\">图 2 自动回收示例<\/h5><img alt=\"图 2 自动回收示例\" src=\"/sunshine_new/images/负42519656/img002.png\" width=\"289\" /><p>开启自动空间回收主要有以下几点好处：<\/p><ul class=\"ibm-bullet-list\"><li>\nDBA 不需要花费精力对空间进行管理以及定期做一些 REORG 的操作，减轻了 DBA 的工作量。<\/li><li>\nDB2_WORKLOAD 设置成 ANALYTICS 之后，列存储表的存储块的自动回收功能会被自动启用。<\/li><li>\n存储空间可以在线释放，不会影响到系统的正常运行。<\/li><li>\n规律性的空间回收可以在一定程度上提高 runstats 和查询的性能。<\/li><\/ul><p>我们也可以自己来开启数据库的自动维护与回收机制，并且设置相应的维护策略，这样数据库自己就会监控表状态，并且根据策略来对表进行维护，同时还会对空闲的扩展数据块进行回收。开启自动回收的步骤如下：<\/p><p>1）开启 Database 的三个参数 auto_maint，auto_tbl_maint，以及 auto_reorg。其命令如下：<\/p><h5 id=\"listing12\">清单 12. 更新 DB 参数<\/h5><div class=\"codesection\"><pre class=\"displaycode\">db2 update db cfg for &lt;db_name&gt; using auto_maint on\ndb2 update db cfg for &lt;db_name&gt; using auto_tbl_maint on\ndb2 update db cfg for &lt;db_name&gt; using auto_reorg on<\/pre><\/div><p>其中 db_name 为数据库的名字。<\/p><p>2）通过命令行设定 reorg 策略，这个策略主要是定义对表和索引维护些什么。设置策略可以用以下两个存储过程中的一个来实现 (关于这个存储过程的详细用法可以参考 DB2 信息中心 <a href=\"http://publib.boulder.ibm.com/infocenter/db2luw/v9r7/topic/com.ibm.db2.luw.sql.rtn.doc/doc/r0052292.html\">“AUTOMAINT_SET_POLICY procedure - configure automatic maintenance policy”<\/a>)：<\/p><ul class=\"ibm-bullet-list\"><li>\n―AUTOMAINT_SET_POLICY<\/li><\/ul><p>该存储过程的 schema 是 SYSPROC，其用法如下：<\/p><p>AUTOMAINT_SET_POLICY(&lt;<a href=\"https://db2id.torolab.ibm.com/db2doc_kepler/topic/com.ibm.db2.luw.sql.rtn.doc/doc/r0052292.html?resultof=%22AUTOMAINT_SET_POLICY%22%20\">policy_type<\/a>&gt;,&lt;<a href=\"https://db2id.torolab.ibm.com/db2doc_kepler/topic/com.ibm.db2.luw.sql.rtn.doc/doc/r0052292.html?resultof=%22AUTOMAINT_SET_POLICY%22%20\">policy<\/a>&gt;)<\/p><p>其中有两个参数<a href=\"https://db2id.torolab.ibm.com/db2doc_kepler/topic/com.ibm.db2.luw.sql.rtn.doc/doc/r0052292.html?resultof=%22AUTOMAINT_SET_POLICY%22%20\">policy_type<\/a>和 policy，其中 policy_type 为自动维护策略的类型，主要有 AUTO_BACKUP、AUTO_REORG、AUTO_RUNSTATS 和 MAINTENANCE_WINDOW，当然我们这里要设置自动内存回收策略，必然要选择 AUTO_REORG，第二个参数<a href=\"https://db2id.torolab.ibm.com/db2doc_kepler/topic/com.ibm.db2.luw.sql.rtn.doc/doc/r0052292.html?resultof=%22AUTOMAINT_SET_POLICY%22%20\">policy<\/a>是以 XML 格式指定具体的策略，在目录/sqllib/samples/automaintcfg 下，对应每一种自动维护类型都有相应的例子，我们可以参考这个例子：DB2AutoReorgPolicySample.xml 来制定具体的维护策略。<\/p><p>该存储过程示例如下 (可以参考 DB2AutoReorgPolicySample.xml)：<\/p><h5 id=\"listing13\">清单 13. AUTOMAINT_SET_POLICY 存储过程示例<\/h5><div class=\"codesection\"><pre class=\"displaycode\">CALL SYSPROC.AUTOMAINT_SET_POLICY\n ('AUTO_REORG', \n BLOB(' &lt;?xml version=\\\"1.0\\\" encoding=\\\"UTF-8\\\"?&gt;\n &lt;DB2AutoReorgPolicy \n xmlns=\\\"http://www.ibm.com/xmlns/prod/db2/autonomic/config\\\"&gt;\n &lt;ReorgOptions dictionaryOption=\"Rebuild\" indexReorgMode=\"offline\" \n useSystemTempTableSpace=\"true\" reclaimExtentSizeForTables =\"52\" &gt;\n &lt;ReorgTableScope&gt;\n &lt;FilterClause&gt;TABSCHEMA NOT LIKE 'EMP%'&lt;/FilterClause&gt;\n &lt;/ReorgTableScope&gt;\n &lt;/DB2AutoReorgPolicy&gt;')\n )<\/pre><\/div><p>在文件 DB2AutoReorgPolicySample.xml 里面已经对参数进行详细的说明，这里简单的介绍一下，dictionaryOption 决定压缩词典是否需重建，indexReorgMode 指定索引的重组是在线模式还是离线模式，useSystemTempTableSpace 指定在 Reorg 过程中是否启用临时表空间。要列存储表在数据库自动重组的时候执行回收空间的操作，那么就必须要指定参数 reclaimExtentSizeForTables 的值，且该值必须大于 0，这个值指定了回收内存的一个阀值，比如在上面的示例中该参数的值是 52 即 52K，那么意思就是当表的可回收空间大于 52K 时才会执行回收扩展数据块的操作。同时我们可以用 FilterClause 来对表进行筛选，如本示例中即把 EMP 开头的表过滤掉了。<\/p><ul class=\"ibm-bullet-list\"><li>\n―AUTOMAINT_SET_POLICYFILE<\/li><\/ul><p>该存储过程的 schema 是 SYSPROC，其用法如下：<\/p><p>AUTOMAINT_SET_POLICYFILE (&lt;<a href=\"https://db2id.torolab.ibm.com/db2doc_kepler/topic/com.ibm.db2.luw.sql.rtn.doc/doc/r0052291.html?resultof=%22AUTOMAINT_SET_POLICYFILE%22%20\">policy_type<\/a>&gt;,&lt;<a href=\"https://db2id.torolab.ibm.com/db2doc_kepler/topic/com.ibm.db2.luw.sql.rtn.doc/doc/r0052291.html?resultof=%22AUTOMAINT_SET_POLICYFILE%22%20\">policy_file_name<\/a>&gt;)<\/p><p>其中有两个参数<a href=\"https://db2id.torolab.ibm.com/db2doc_kepler/topic/com.ibm.db2.luw.sql.rtn.doc/doc/r0052291.html?resultof=%22AUTOMAINT_SET_POLICYFILE%22%20\">policy_type<\/a>和<a href=\"https://db2id.torolab.ibm.com/db2doc_kepler/topic/com.ibm.db2.luw.sql.rtn.doc/doc/r0052291.html?resultof=%22AUTOMAINT_SET_POLICYFILE%22%20\">policy_file_name<\/a>，<a href=\"https://db2id.torolab.ibm.com/db2doc_kepler/topic/com.ibm.db2.luw.sql.rtn.doc/doc/r0052291.html?resultof=%22AUTOMAINT_SET_POLICYFILE%22%20\">policy_type<\/a>与前面的存储过程 AUTOMAINT_SET_POLICY 中的参数<a href=\"https://db2id.torolab.ibm.com/db2doc_kepler/topic/com.ibm.db2.luw.sql.rtn.doc/doc/r0052291.html?resultof=%22AUTOMAINT_SET_POLICYFILE%22%20\">policy_type<\/a>相同，而第二个参数不再是策略的 XML 文件的内容而是文件名，在 UNIX 中需要把需要设置策略的 XML 文件放在目录：$HOME/sqllib/tmp/automaint 下，该存储过程的用法示例如下：<\/p><p>call sysproc.automaint_set_policyfile( 'AUTO_REORG', 'AutoReorg.xml' )<\/p><p>3）通过命令行设置自动维护窗口<\/p><p>自动 REORG 的维护策略设置完成之后，自动维护策略还不能被运行，还需要指定一个维护窗口，即一个可以调动并且运行自动维护的时段。在一个 DB2 数据库中最多可以设定两个维护窗口，即在线窗口和离线窗口，其中在线窗口时间段，在执行维护操作期间被维护对象保持在可访问状态，其在此时间段用户可以访问这些维护对象，其中离线窗口是可选的，在此期间用户不能访问进行维护的对象。维护窗口有起始时间和持续时间组成，在实际的应用环境当中，用户可以根绝时间的情况需要设定维护窗口的大小，但是需要注意的是尽量选择一个对数据访问最少的时间段，这样可以把对数据库的影响降到最小，降低维护的消耗。关于自动维护窗口的具体参数设置，可以参考目录/sqllib/samples/automaintcfg 下的示例：DB2MaintenanceWindowPolicySample.xml。<\/p><p>关于自动回收以及维护的更多细节这里就不再赘述，感兴趣的可以参考 developerWorks 上的这篇文章“<a href=\"http://www.ibm.com/developerworks/db2/library/techarticle/dm-0707tang/index.html\" onmouseover=\"linkQueryAppend(this)\">How does auto reorg actually work?<\/a>”。<\/p><h3 id=\"major9\">手动回收<\/h3><p>下面来具体的讲一下如何对这些存储空间进行手动的回收。<\/p><p>在 V10.5 中，我们可以用函数 ADMIN_GET_TAB_INFO 来估算对一个列存储表进行 Reclaim 之后所能释放的存储空间。<\/p><p>该函数的定义如下：<\/p><p>ADMIN_GET_TAB_INFO (&lt;<a href=\"https://db2id.torolab.ibm.com/db2doc_kepler/topic/com.ibm.db2.luw.sql.rtn.doc/doc/r0052897.html?resultof=%22ADMIN_GET_TAB_INFO%22%20\">tabschema<\/a>&gt;,&lt;<a href=\"https://db2id.torolab.ibm.com/db2doc_kepler/topic/com.ibm.db2.luw.sql.rtn.doc/doc/r0052897.html?resultof=%22ADMIN_GET_TAB_INFO%22%20\">tabname<\/a>&gt;)<\/p><p>其中<a href=\"https://db2id.torolab.ibm.com/db2doc_kepler/topic/com.ibm.db2.luw.sql.rtn.doc/doc/r0052897.html?resultof=%22ADMIN_GET_TAB_INFO%22%20\">tabschema<\/a>为待查询表的 SCHEMA，<a href=\"https://db2id.torolab.ibm.com/db2doc_kepler/topic/com.ibm.db2.luw.sql.rtn.doc/doc/r0052897.html?resultof=%22ADMIN_GET_TAB_INFO%22%20\">tabname<\/a>为表名。<\/p><p>在这里我们用前面定义的列存储表 SALES_FACT_COL 来对该该函数的使用进行演示。<\/p><h5 id=\"listing14\">清单 14. 查看表 SALES_FACT_COL 的可回收空间<\/h5><div class=\"codesection\"><pre class=\"displaycode\">saplxvm55:db2lr1 358&gt; db2 \"select RECLAIMABLE_SPACE from\n                 Table(SYSPROC.ADMIN_GET_TAB_INFO('DB2LR1','SALES_FACT_COL'))\"\nRECLAIMABLE_SPACE\n--------------------\n 6592\n 1 record(s) selected.<\/pre><\/div><p>可以对比之前 job1 完成之后 SALES_FACT_COL 表所占用的空间大小 6944KB，和这个查询结果的大小基本吻合。下面我们就可以用 Reorg 命令来对该表空闲的存储空间进行回收。<\/p><p>在前面提到，列存储表不支持自动收集统计信息，我们在进行 Reorg 之前统计信息可能已经过时，如果统计信息过时就会严重影响 Reorg 的效率，因此在 reorg 之前，先执行 Runstat，收集统计信息。<\/p><p>RUNSTATS ON TABLE &lt;object-name&gt;<\/p><p>执行 Runstats 的示例：<\/p><p>db2 runstats on table DB2LR1. SALES_FACT_COL<\/p><p>统计信息收集完成之后我们就可以对表执行 Reorg 来收集空闲的 Extent。<\/p><p>其用法如下：<\/p><p>db2 reorg table &lt;column table name&gt; reclaim extents only<\/p><p>执行 reorg 的示例：<\/p><h5 id=\"listing15\">清单 15. 对表 SALES_FACT_COL 进行 REORG<\/h5><div class=\"codesection\"><pre class=\"displaycode\">saplxvm55:db2lr1 360&gt; db2 reorg table DB2LR1.SALES_FACT_COL reclaim extents only\nDB20000I The REORG command completed successfully.<\/pre><\/div><p>之后，我们再次查询该表的可回收空间，其结果如下：<\/p><h5 id=\"listing16\">清单 16. 查询表 SALES_FACT_COL 的可回收空间<\/h5><div class=\"codesection\"><pre class=\"displaycode\">saplxvm55:db2lr1 358&gt; db2 \"select RECLAIMABLE_SPACE from\n                 Table(SYSPROC.ADMIN_GET_TAB_INFO('DB2LR1','SALES_FACT_COL'))\"\nRECLAIMABLE_SPACE\n--------------------\n 0\n 1 record(s) selected.<\/pre><\/div><p>最后需要说明的是列存储表不支持 Allow Access Write，即在对列存储表进行 reorg 的过程中，不允许对表进行写操作，但是可以进行读，即 Allow Access Read 是可以的。<\/p><h2 id=\"major10\">总结<\/h2><p>本文首先对列存储表进行了简单的介绍，之后针对删除和更新操作分别阐述了在列存储表中，这些操作是如何造成存储空间的浪费的，以及与行存储表有和区别。本文着重介绍了删除后的空间回收问题，并且针对删除的操作如何造成空间浪费进行了实验模拟，这使读者更容易理解列存储表的空间浪费问题，从而更能理解 REORG 的重要性，并且附上了相关的代码，读者可以很容易在自己的环境上进行实验。<\/p><p>同时本文还分别介绍了空间回收的实现方法，分别对自动回收的设置以及手动回收的步骤进行了详细的讲解。<\/p><CMA ID: 972521><Site ID: 10><XSLT stylesheet used to transform this file: dw-document-html-7.0.xsl>\r\n\r\n\r\n<\/div>\r\n<\/div>\r\n","createTime":"2014-05-28 00:00:00","deployTime":"2014-05-28 00:00:00","id":0,"intro":"BLU 是 DB2 V10.5 的一个非常重要的新特性，本文主要对 BLU 中的列存储表的空间回收进行了详细的介绍，并用试验验证了 DB2 列存储表在数据删除时的空间是如何浪费掉的，以及如何对这些空间进行回收。","keyword":"","recommend":false,"source":"http://www.ibm.com/developerworks/cn/data/library/techarticle/dm-1405db2-tsrecycle/index.html","title":"DB2 V10.5 新特性之列存储表的空间回收","typeId":0,"updateTime":"2014-05-28 00:00:00"}
{"author":"","clickNumber":0,"content":"\r\n<div class=\"ibm-columns\">\r\n<div class=\"ibm-col-1-1\">\r\n\r\n<p>IBM RTW 8.5 版本增加了针对移动应用的 App 自动化测试功能，目前支持 Android、Apple iOS 两个版本的 App 应用。本文将介绍如何通过将 RTW\n    与 RQM 集成来实现移动应用（以 Android 应用为例）的自动化测试，同时总结常用问题解决方法。<\/p><h2 id=\"1.RTW 与 RQM 集成预览 |outline\">RTW 与 RQM 集成预览<\/h2><p>RTW8.5 提供了移动应用自动化测试功能，本文主要讨论其与 RQM 的集成方法及集成后的测试运行。RQM 由于其协作性好，基于 Web 等性能，作为一款出色的质量管理软件，用于贯穿软件生命周期的综合测试规划和测试资源管理，管理并运行由其他任何测试工具创建的自动测试脚本。该软件建立在 Jazz&#8482; 平台的基础之上，适用于所有规模大小的测试团队，并支持不同的用户角色，例如测试管理员、测试结构师、测试负责人、测试员以及实验管理员，甚至测试组织以外的角色。基于以上优点，我们选择二者的集成以提升移动应用自动化测试的效率，削减成本。<\/p><p>集成后运行测试项目的优势:RQM 支持项目成员共享，将 RQM 与 RTW 集成起来后，不同的项目成员都可以登录 RQM 查看我们的测试套件、用例和脚本，并直接执行脚本、查看运行结果；<\/p><p>将不同 RTW 端分散运行的数据收集起来，更好地查看测试计划总体的执行状态、进度等。<\/p><p>Report 比 RTW 本身的更为丰富，并且可以定制。<\/p><h2 id=\"2.配置 RQM 适配器 |outline\">配置 RQM 适配器<\/h2><p>总体来说，RTW 与 RQM 的集成有三种方式，即平台|服务和命令行（workbench、service、command line）。接下来将详细说明该过程，但是无论用哪一种方式，首先需要进行 RQM 适配器的配置。<\/p><p>明确了 RTW 中的测试脚本将关联至哪个 RQM 服务器的项目域中后，我们需要在 RTW 工具的首选项配置中进行 RQM 适配器的配置。如图 1 所示，打开 RTW 工具，点击 Windows-&gt;Preferences (首选项) ，选择\"Quality Manager Adapter\", 填写右边对应的 RQM URL 及登录信息.点击应用按钮并提示成功，意味着 RQM 适配器已经配置成功。<\/p><p>RQM 的服务器 URL 通常格式为可以访问到的 RQM 服务器地址，例如 https://RQM01:9443/qm. 登录账号和密码要求有权限访问该 RQM 服务器。对于 Adapter Name，为 RTW 输入一个可以唯一识别该 RQM 适配器的名字, 默认情况下，该适配器使用此台电脑的主机名，如果用户需要创建多个 RQM 服务器的适配器，则建议修改。最后如果希望将适配器指向一个特定的项目区域（RTW 上的脚本需要导入到的项目区域），则将项目区域的名字加上。<\/p><h5 id=\"N1008A\">图 1. 配置 RQM 适配器<\/h5><img alt=\"\" src=\"/sunshine_new/images/1455765032/image004.jpg\" width=\"394\" /><p>注意，这里是以 RTW 为例进行介绍的，此外 Rational Performance Tester, Rational Functional Tester, Rational Service Tester 等工具有类似的方式来配置其参数。<\/p><p>前文提到，RTW 支持三种运行适配器的方式：平台、服务和命令行。该首选项配置完成后，可以完成由 workbench 运行集成过程，如果需要通过服务和命令行方式，还需要对修改其中的配置文件。首先进入 RTW 的安装目录（例如：C:\\Program Files\\IBM\\SDP\\），进入 RPT-RST_RQMAdapter\\config 文件夹，打开 adapter.config 文件。可以看到图 2 所示，该文件中 WORKSPACE_DIR 变量的属性为空，这里需要添加 RTW 项目所使用的 workspace 路径，即希望导入 RQM 的脚本文件所在的项目空间，例如 C:\\Users\\IBM_ADMIN\\IBM\\rationalsdp\\workspace_rtwse。<\/p><h5 id=\"N1009A\">图 2. Adapter.config 文件<\/h5><img alt=\"\" src=\"/sunshine_new/images/1455765032/image006.jpg\" width=\"599\" /><h2 id=\"3.三种运行适配器的方式介绍：平台，服务和命令行 |outline\">三种运行适配器的方式介绍：平台，服务和命令行<\/h2><p>配置完成后，可以由以下三种方式中的任一种来启动适配器服务。<\/p><p>平台方式<\/p><p>打开 RTW，点击 Window &gt; Show View &gt; Quality Manager Adapter，来打开 Quality Manager Adapter 视图。在该视图中，分别有 Connect to RQM 和 Disconnect from RQM 两个图标，我们可以直接在这儿点击进行与 RQM 的连接。注意，Connect 过程需要等待一些时间，通常都是在后台运行。<\/p><h5 id=\"N100B1\">图 3. RTW 中的 RQM 适配器管理视图<\/h5><img alt=\"\" src=\"/sunshine_new/images/1455765032/image008.jpg\" width=\"599\" /><p>服务方式<\/p><p>如果您使用的时 Window 系统，当安装了 RTW 后，其实您已经将适配器作为 Windows service 安装成功了，而且默认情况下，该服务为手动启动。入口：右键点击\"我的电脑\"，选择\"管理\"，然后进入\"服务和应用\"，即 Services and Applications 功能。<\/p><p>使用该功能需要计算机支持微软的.NET 2.0 或更高的框架。<\/p><h5 id=\"N100C3\">图 4. Window Service 管理界面<\/h5><img alt=\"\" src=\"/sunshine_new/images/1455765032/image010.jpg\" width=\"599\" /><p><strong>命令行方式<\/strong><\/p><p>首先打开一个命令行窗口，定位至 RTW 的安装目录，例如 C:\\Program Files\\IBM\\SDP. 然后接着定位至 RPT-RST_RQMAdapter\\bin\\目录，因为在该目录下有可以通过命令行启动适配器的可运行文件。<\/p><p>启动适配器的命令：<\/p><p>Windows 下，输入：RQMAdapter.bat START；<\/p><p>Linux 下，输入：RQMAdapter.sh START<\/p><p>停止适配器的命令：<\/p><p>Windows 下，输入：RQMAdapter.bat STOP；<\/p><p>Linux 下，输入：RQMAdapter.sh STOP<\/p><h2 id=\"4.在 RTW 上运行移动测试脚本 |outline\">在 RTW 上运行移动测试脚本<\/h2><p>此章节讲述如何在 RTW 上创建脚本，如果这个过程已完成，请直接跳转至下一节<strong>从 RQM 运行测试对象<\/strong>。<\/p><p>如前文所说，RTW 8.5 版本支持移动 App 的自动化测试功能，本文以 Android 移动应用为例来完成其自动化脚本的录制、修改、添加验证点等功能，得到一个简单的自动化测试脚本，以此脚本为例，实现与 RQM 的集成，最终从 RQM 端自动运行该脚本。关于如何安装 RTW 8.5, Android SDK 以及进行配置实现 RTW 与 Android 模拟器的连接、录制过程，在参考文献 4 中有详细的说明，在此不在详述，仅以一个例子简单说明脚本录制、修改和添加验证点的过程。<\/p><p><strong>脚本录制<\/strong><\/p><p>脚本录制的前提是：RTW 8.5、Android SDK 正确安装；Android 设备上的 RTW Mobile 应用正确安装；Android 设备已并与 RTW 成功连接。此时在 RTW 的控制界面，可以看到该 Android 设备处理连接状态，在 Android 设备的 RTW 应用上，可以管理 RTW 上导入的 App 应用。如图 5 所示。<\/p><h5 id=\"N100F1\">图 5. RTW 与 Android 设备正确相连<\/h5><img alt=\"\" src=\"/sunshine_new/images/1455765032/image012.jpg\" width=\"581\" /><p>本文要进行测试的 App 是一款百度推出的课表管理软件-\"超级课程表\"，因为 RTW 8.5 目前对 hybrid 结构的 App 测试支持不不好，因此选用了该款 Native 类型的应用，本文仅对应用开始的选择学校、专业和年份功能进行测试（相当于 Welcome 功能），以说明脚本的基本录制过程和对脚本的简单修改、添加验证点。<\/p><p>首先在 RTW 上新建测试项目 ClassTableClass（如图 5 所示），在该项目中导入\"超级课程表\"App。然后进入 Android 终端上的 RTW 应用，选择 active 模式（设备可选 active 和 passive 模式，active 模式可以在手机终端上操作应用，passive 模式被动接受 RTW 的驱动）以便在终端上进行应用管理。其工作原理为：在 RTW mobile 中录制脚本，传递回 RTW Eclipse 上编辑。在 RTW 或者在移动终端上发起录制皆可。<\/p><p>录制步骤如下：<\/p><p>\tRTW 中，菜单栏依次选择：<strong>新建<\/strong> --〉<strong>录制产生脚本<\/strong> --〉录制类型选择<strong>移动测试<\/strong>，继续。测试名称中输入\"TestScript1\", 点击完成，会自动弹出录制窗口，开始录制。<\/p><p>\t移动终端上，进入 RTW 应用, 选择<strong>管理的应用程序<\/strong>，选择<strong>超级课程表<\/strong>，进入选择 Record。这时候针对该 App 所做的记录都会被自动录制下来，我们仅录制到提示使用邮箱登录界面，关闭该 App 后，这些动作会保存为脚本传递回 RTW 客户机。如图 6 所示为录制过程部分截图以及 RTW 中得到脚本。录制结束后在 RTW 客户机中点击传回的脚本文件并保存即可。<\/p><h5 id=\"N10116\">图 6. 录制过程截图以及得到的脚本<\/h5><img alt=\"\" src=\"/sunshine_new/images/1455765032/image014.jpg\" width=\"582\" /><p><strong>修改脚本<\/strong><\/p><p>双击项目列表中的 TestScript1 脚本文件，在 RTW 窗口的右侧打开脚本视图。修改脚本主要包括对现有的脚本进行添加、修改、删除。<\/p><p>由于我们在录制脚本的最后，还有一些返回操盘，但这些操作并不是我们想要测试的内容，因此可以在编辑脚本页面直接选中它们，然后选择\"Remove\"按纽即可将其删除。<\/p><p>此外，由于我们进行脚本录制的过程，一定是时间不均匀的，特别是如果有些事中途打扰了录制过程，两个操作之间会有很长时间的间隔，对于自动化测试来说，修改这些脚本步骤之间的 ThinkTime 是十分有必要的。单击某条脚本，在其右侧是这条脚本对应的各个参数。我们可以修改包括 ThinkTime 在内的所有参数，例如文本内容、控件位置等。<\/p><p>添加一个验证点<\/p><p>最后，我们需要添加一个验证点。在本例中，我们在最后提示进行邮箱登录界面添加一条验证点，验证\"Hint 为\"请输入常用邮箱\"的 EditText 控件是 editable 的\"，即如果在该页面发现一个可编辑文本框里的提示内容为\"请输入常用邮箱\"，而且这个控制是可以编辑的，那么就认为通过。添加完验证点的脚本视图如图 7 所示。<\/p><h5 id=\"N1012F\">图 7. 修改后的脚本视图<\/h5><img alt=\"\" src=\"/sunshine_new/images/1455765032/image016.jpg\" width=\"599\" /><p>最后保存我们的脚本 TestScript1，其位于项目 ClassTableTest 项目下。<\/p><h2 id=\"5.向 RQM 导入测试对象 |outline\">向 RQM 导入测试对象<\/h2><p>至此我们已经完成了 RTW 与 RQM 的集成过程中基本的配置过程，以前脚本的创建，接下来可以切换至 Rational Quality Manager 来导入测试脚本。<\/p><p>进入 RQM 的相应项目区域首页，点击 <strong>Construction<\/strong> 图标，然后点击 <strong>Import Test Script<\/strong>，如图 8 所示。<\/p><h5 id=\"N1014D\">图 8. 在 RQM 中导入脚本<\/h5><img alt=\"\" src=\"/sunshine_new/images/1455765032/image018.jpg\" width=\"386\" /><p>然后打开的界面上，选择 <strong>Rational Test Workbench<\/strong>作为 <strong>Script Type<\/strong>，选择\"Use test resources that are local to a test machine\"，点击 <strong>Select Adapter<\/strong> 按钮。在列出的适配器列表中，会出现前面配置好的 Adapter 所在机器的机器名，如图 9 所示，适配器名称显示为 RTW on TESTDOMO（TESTDEMO 即我们对该适配器取的命名）。选中该适配器并点击继续。<\/p><h5 id=\"N10164\">图 9. 选择适配器<\/h5><img alt=\"\" src=\"/sunshine_new/images/1455765032/image020.jpg\" width=\"581\" /><p>图 10 所示，在打开的 Import Test Script 界面中，输入 RTW 中您要导入的脚本所在的项目名称，该项目则会出现在列表中。选中它并单击<strong>Ne<\/strong><strong>xt<\/strong>。然后就能够选择您想要导入的测试脚本了。选择脚本以后，点击<strong>Finish<\/strong>。需要注意的是，此时不能退出，还需要点击<strong>IMPORT<\/strong>按钮将刚才的脚本导入才真正将 RTW 中相应的测试脚本导入 RQM。<\/p><h5 id=\"N1017E\">图 10. 选择测试项目中的测试脚本进行导入<\/h5><img alt=\"\" src=\"/sunshine_new/images/1455765032/image022.jpg\" width=\"600\" /><p>导入成功后，从<strong>Construction<\/strong> 图标&gt;<strong>Browse<\/strong><strong> Test Script<\/strong>入口进入，查看当下所有的脚本信息，即可以看到自己刚刚导入的脚本文件，图 11 所示为本文前面导入的示例。<\/p><h5 id=\"N10194\">图 11. 查看已导入的脚本<\/h5><img alt=\"\" src=\"/sunshine_new/images/1455765032/image024.jpg\" width=\"581\" /><p>在导入测试脚本之后，需要新建测试用例将其与该测试脚本联系起来，然后还可以通过新建一个测试组件（Test Suite）将测试用例管理起来。通过为该测试组件建立一个测试执行记录，来执行这个自动化的脚本。脚本执行过程在<strong>后文<\/strong>中展示。<\/p><h2 id=\"6.从 RQM 运行测试对象 |outline\">从 RQM 运行测试对象<\/h2><p>在前文中已经详细描述了如何集成 RTW 与 RQM，现在我们就在 RQM 端运行已经建立的测试脚本。现在我们已经得到一个录制好的移动应用的脚本文件 TestScript1，并将其导入了 RQM。接下需要通过 RQM 来调用这个脚本，通过观察 RQM 的运行结果报告以及脚本在移动终端上的自动运行，来成功验证 RQM 与 RTW 的集成。<\/p><p>点击 <strong>Construction<\/strong> 图标，然后点击 <strong>Create<\/strong><strong> Test <\/strong><strong>Case<\/strong>，新建一个测试用例：ClassTableTest_Welcome。在新建的测试用例界面，点击左侧导航栏中的 <strong>Test Script<\/strong>, 展开 Test Script 栏目。然后点击该栏右上角的\"+\"按钮，即 Add Test Script。在弹出的窗口中选择我们在前文中导入的测试脚本，如图 12 所示。保存该测试用例。<\/p><h5 id=\"N101BB\">图 12. 创建测试用例并添加测试脚本<\/h5><img alt=\"\" src=\"/sunshine_new/images/1455765032/image026.jpg\" width=\"581\" /><p>在 Android 移动终端（或模拟器）上，打开 RTW Mobile 应用，将其设置为\"Passive\"模式，以支持 RTW，或者说从 RQM 端直接启动移动终端运行脚本。在 Passive 模式下，Manage Applications 和 Upload Application 都是不可用状态。图 13 所示。<\/p><h5 id=\"N101C9\">图 13. 将移动终端调成 Passive 模式<\/h5><img alt=\"\" src=\"/sunshine_new/images/1455765032/image028.jpg\" width=\"260\" /><p>进入 RQM 中刚才测试的测试用例界面，点击执行按钮为该条测试用例新建一条执行记录并直接执行，如图 14 所示。在弹出窗口中选择了运行环境之后，点击确定就开始该条测试用例的执行过程了。此时，您可以通过观察 RQM 中显示的进度条，或者直接观察移动终端界面的变化看到我们所录制的脚本的自动化运行过程。<\/p><h5 id=\"N101D7\">图 14. 创建测试用例并添加测试脚本<\/h5><img alt=\"\" src=\"/sunshine_new/images/1455765032/image030.jpg\" width=\"581\" /><p>脚本执行结束后，RQM 端会显示执行结果：Failed 或者 Passed，并且附带执行完成后各类 report、执行详细数据等信息。在本文中仅执行两种情况：1）成功执行；2）将 App 预先安装在终端上，以使其没有欢迎界面，执行失败。分别在这两种情况下运行该测试用例，可以得到两个执行结果，分别是失败和成功。图 15 为执行失败后的截图示例，执行成功有相似的界面，都可以通过点击结果显示来查看具体的执行结果。<\/p><p>图 15. 用例执行结果失败示图<\/p><h5 id=\"N101E7\">图 15. 用例执行结果失败示图<\/h5><img alt=\"\" src=\"/sunshine_new/images/1455765032/image032.jpg\" width=\"582\" /><p>此外 RQM 还提供了几个可供查看具体执行细节的报告，列表如图 16 所示。其中，MobileReport 是在 RTW 客户机也可以看到的，关于移动应用具体脚本执行情况的报表，从这个报表中可以读出哪些步骤执行失败，并且所有的操作步骤、验证点步骤都有系统界面截图，方便用户跟踪用例执行情况。其他三个报告都是从不同维度，用不同的图表呈现形式来反应该测试用例的执行情况，在此不做详细说明。<\/p><h5 id=\"N101F6\">图 16. 执行结果 report 列表<\/h5><img alt=\"\" src=\"/sunshine_new/images/1455765032/image034.jpg\" width=\"367\" /><h5 id=\"N10202\">图 17. MobileReport 示例<\/h5><img alt=\"\" src=\"/sunshine_new/images/1455765032/image036.jpg\" width=\"581\" /><h2 id=\"7.创建定制报告并远程访问 |outline\">创建定制报告并远程访问<\/h2><p>在创建定制报告之前，用户先确认需要哪种报告：类似于系统提供的报告，还是完全不同于已提供的报告。如果是类似的，只需要稍加修改已有的模板，编辑关注的系统参数和计数器；如果是定制全新报告，需要先清楚当前协议的计数器。<\/p><p>选择文件菜单中的新建――性能测试报告，输入定制报告的名称并点击插入按钮，如图 18 所示。<\/p><h5 id=\"N10218\">图 18 新建测试报告窗口<\/h5><img alt=\"\" src=\"/sunshine_new/images/1455765032/image038.jpg\" width=\"368\" /><p>插入需要定制的已有标签还是特殊的定制标签，文中选择单幅图的定制标签，并点击下一步。如图 19 所示。<\/p><h5 id=\"N10226\">图 19.选择需要添加的报告<\/h5><img alt=\"\" src=\"/sunshine_new/images/1455765032/image040.jpg\" width=\"350\" /><p>下一步选择定制页图像显示的属性，文中选择饼图，并定制显示效果和显示色彩，最后点击完成。如图所示。<\/p><h5 id=\"N10234\">图 20. 报告显示图像的配置选择<\/h5><img alt=\"\" src=\"/sunshine_new/images/1455765032/image042.jpg\" width=\"280\" /><p>点击插入按钮后可以添加计数器，设置阀值显示等，如图 21 所示。<\/p><h5 id=\"N10242\">图 21.选择添加计数器<\/h5><img alt=\"\" src=\"/sunshine_new/images/1455765032/image044.jpg\" width=\"368\" /><p>点击添加后即可选择多个性能监控参数，如图所示。<\/p><h5 id=\"N10251\">图 22.可选的性能计数器<\/h5><img alt=\"\" src=\"/sunshine_new/images/1455765032/image046.jpg\" width=\"374\" /><p>在 RTW 客户端应用的窗口菜单中选择偏好（Preference），并在弹出窗口中选择测试――性能测试报告――网页报告，就会显示如图所示的配置界面。在\"通用访问\"中勾选检查框可以远程访问报告，在\"远程访问\"中勾选可以远程控制计划执行的任务。通常来说，网页报告的端口号是 8080，如果已被其他服务占用，可以配置为其他端口号。如果需要给网页报告加密，可以勾选检查框，并设置安全端口号为 8443（如果被占用则为其他），以及用户名密码，使得远程访问的用户在提供了正确的认证信息后才可正常访问网页版报告。<\/p><h5 id=\"N10260\">图 23.远程访问报告配置方法<\/h5><img alt=\"\" src=\"/sunshine_new/images/1455765032/image048.jpg\" width=\"488\" /><p>如果需要在另外一台电脑上远程访问网页版报告，只需要打开浏览器，输入地址 <em>http://host_name:port_number/RPTWeb/WebAnalytics/<\/em>，并回车，其中主机名称是 RTW 所在台式机的主机名，端口号是在上图中配置的端口号，如果设置了加密，还需要输入正确的用户名密码，用户就可在任意一台机器上远程查看网页版的运行报告了，或者将链接和密码用邮件发出给相关人员随时查看网页版运行报告。<\/p><h2 id=\"8.常见问题分析及解决方案 |outline\">常见问题分析及解决方案<\/h2><p>1.为什么我的 RTW 不能正确集成连接 RQM？<\/p><p>请首先确认您的 RQM 的版本号是否是 4.0 或以上，本文的集成过程不支持 RQM4.0 以下版本。<\/p><p>2.RQM 中连接的用户账户的最低权限是什么？<\/p><p>连接账户首先需要在 RQM 中有连接客户端访问许可证，并且被加入适配器可访问的项目，具有写权限。推荐赋予缺省的测试组人员的角色。<\/p><p>3.我能同时启动几个适配器？<\/p><p>每台电脑上只能启动一个。如果您需要在同一台机器上运行多个适配器，请首先确认他们使用不同的工作空间。<\/p><p>4.平台和适配器的启动先后顺序要注意什么？<\/p><p>当适配器在运行过程中不建议使用平台，因为这样做会影响适配器运行测试脚本的能力，所以打开平台之前需要先停止适配器。<\/p><p>5.适配器默认安装路径是哪里？<\/p><p>C:\\Program Files\\IBM\\SDP\\RPT-RST_RQMAdapter\\bin\\，出错后可以去查看日志，观察相关信息。<\/p><p>6.我可以随时编辑测试资源吗？<\/p><p>不可以在适配器的工作空间编译测试资源，因为很可能会丢失您所做的所有改动。只有在运行测试和设置计划安排的时候使用测试资源。<\/p><p>7.我应该怎样使用定制的 Java 代码？<\/p><p>在工作空间外，共享资源中定制的 Java 代码类是不能使用函数库的。如果您的定制代码必须要用到这种函数库，那么就将函数库拷贝到项目里，并更新类路径（classpath）来使用本地备份。<\/p><p>8.为什么我的运行总是提示失败？<\/p><p>请检查 Adaptor 的连接是否断开；确认模拟器必须是被动（passive）模式下才能正常运行，主动模式是不行的。<\/p><p>9.对移动应用的版本有什么要求？<\/p><p>移动应用需要是 native 的,移动应用的最低支持版本是 Android 2.2 以上。<\/p><p>10.用手机和模拟器测试有什么区别？<\/p><p>把模拟器或终端的连接模式调成 passive，可直接在 RTW 端/RQM 端调用脚本进行执行，这是推荐过程，如果自己在手机上进行测试，往往系统不能识别测试的终结状态，生成的报告会始终显示正在运行的状态（running），且不停的刷新，影响使用者直观的查看。<\/p><p>如下图标显示两种报告的区别：<\/p><img alt=\"\" src=\"/sunshine_new/images/1455765032/image050.jpg\" width=\"247\" /><CMA ID: 972351><Site ID: 10><XSLT stylesheet used to transform this file: dw-document-html-7.0.xsl>\r\n\r\n\r\n<\/div>\r\n<\/div>\r\n","createTime":"2014-05-28 00:00:00","deployTime":"2014-05-28 00:00:00","id":0,"intro":"IBM Rational Test Workbench （简称 RTW) 是 IBM Rational 的统一的测试工具集，包括功能测试、性能测试、接口 SOA 测试等模块。IBM Rational Quality Manager(简称 RQM）则是 IBM 针对测试管理的解决方案，提供了诸如测试用例、测试执行进度、缺陷关联及测试统计等功能。IBM 提供了 RTW 和 RQM 的集成功能，通过进行相应的配置设置，可以在 RQM 上调用 RTW 来完成相应的脚本的测试执行，生成和管理测试执行的结果，提供相应的 report 以便对结果进行分析。通过二者的集成，可以有助于对于大规模测试项目的测试管理，提升测试效率，并方便跨区域团队的团队合作。本文将介绍如何用 RTW 与 RQM 进行集成来实现上述目标。","keyword":"","recommend":false,"source":"http://www.ibm.com/developerworks/cn/rational/1405_zhengjie_rtwrqm/index.html","title":"将 IBM Rational Quality Manager 与 IBM Rational Test Workbench 集成进行移动终端应用测试","typeId":0,"updateTime":"2014-05-28 00:00:00"}
{"author":"","clickNumber":0,"content":"\r\n<div class=\"ibm-columns\">\r\n<div class=\"ibm-col-1-1\">\r\n\r\n<div class=\"dw-sidebar ibm-inset\"><h2 id=\"N10069\">IBM PureFlex System<\/h2><p>IBM Flex System Manager 是 <a href=\"http://www.ibm.com/developerworks/cn/puresystems/pureflexsystem.html\">IBM PureFlex System<\/a>\n                    的一个管理组件，后者是一个集成的基础架构解决方案，将计算、存储、网络、虚拟化和管理组合到了单个系统中。IBM PureFlex\n                    支持在同一个机架中灵活地选择基于 x86 或 Power 处理器的计算节点，您可以进一步定制这些节点来满足您的需求。<\/p><\/div><p>在 IBM PureFlex System 中，Flex System Manager\n                自动化了重复性的任务，以减少典型管理任务的手动导航步骤数量。Flex System Manager 还提供了丰富的 API 和命令行接口\n                (CLI)，帮助您实现高级管理场景。您还可以将这些场景编写成脚本，以实现重用和可重复性。通过具体的示例，本文将展示如何使用 Flex System\n                Manager 作为管理基础架构，为 KVM 虚拟机管理程序实现高级的虚拟化和云管理场景。 <\/p><h2 id=\"N10075\">先决条件<\/h2><p>要实现本文中提供的示例解决方案，您需要配置 Flex System Manager 高级或基础版的 IBM PureFlex。还必须在 System\n                x 节点 (x ITE) 上正确安装和配置 Red Hat Enterprise Linux (RHEL) 6.2 或更高版本。<\/p><p>本文中使用的环境包含：<\/p><div class=\"dw-sidebar ibm-inset\"><p>有关 IBM PureFlex System 组件的详细描述，请参阅 <a href=\"http://www.redbooks.ibm.com/Redbooks.nsf/RedbookAbstracts/sg247984.html?OpenDocument\">IBM PureFlex System and IBM Flex System Products and\n                        Technology<\/a>。这本 IBM 红皮书介绍了机架的技术和特性、计算节点、管理特性、连接和存储选项。<\/p><\/div><ul class=\"ibm-bullet-list\"><li>RHEL 6.4。<\/li><li>包含由 Flex System Manager 高级版管理的 x ITE 的 IBM PureFlex System。<\/li><li>IBM Storewize v7000 存储区域网络 (SAN)，包含通过光纤通道连接到服务器的存储逻辑单元编号 (LUN)。<\/li><\/ul><p>我们使用 Python 编写本文的脚本示例。<\/p><h2 id=\"N1008E\">扩展 Flex System Manager<\/h2><p>我们演示了利用 <a href=\"http://pic.dhe.ibm.com/infocenter/flexsys/information/index.jsp?topic=%2Fcom.ibm.acc.8731.doc%2Fusing_the_cli.html\">CLI<\/a> 扩展 Flex System Manager（高级或基础版）有多轻松。本文包含（参见 <a href=\"#download\">下载<\/a>）一组使用 CLI 配置自定义 KVM 管理场景的 Python 脚本。这些脚本可在任何能对\n                PureFlex 组件进行 SSH 访问的 Linux 主机上运行。图 1 显示了这些脚本用于处理高级管理任务的工具（称为\n                flex-pack）的主菜单： <\/p><h5 id=\"fig1\">图 1. 用于高级管理场景的 Flex-pack 工具<\/h5><img alt=\"用于高级管理场景的 Flex-pack 工具\" src=\"/sunshine_new/images/1694889615/Figure1.jpg\" width=\"539\" /><p>在 <a href=\"#fig1\">图 1<\/a> 中，可以看到您可通过 flex-pack 执行的任务。各个菜单项及其功能包括：<\/p><ul class=\"ibm-bullet-list\"><li><strong>Configure Energy Policy for System Pool\n                    Hosts<\/strong>：对于配置的系统池中的某个特定的系统池，指定一个能源节省策略，比如 power save、balanced 或\n                    performance。<\/li><li><strong>Configure Security Policy for System Pool\n                    Hosts<\/strong>：对于配置的系统池中的一个特定的系统池，指定一个安全策略 &#8212; 防火墙或强制性访问控制策略。 <\/li><li><strong>Configure Resource Controls for VM<\/strong>：指定一个特定的\n                    VM（正在运行或离线）的资源（CPU、内存、网络和 I/O）控制。<\/li><li><strong>Configure Network Switch policy for VM<\/strong>：设置选定的 VM\n                    的网络交换机策略。<\/li><li><strong>Group VMs of Host in System Pool into a Workload<\/strong>：从现有\n                    VM 创建一个工作负载。<\/li><li><strong>Configure Auto-NUMA bindings for VM<\/strong>：将 VM 绑定到 NUMA\n                    节点。<\/li><li><strong>Refresh Environment<\/strong>：刷新 flex-pack。<\/li><\/ul><h2 id=\"N100CB\">使用 flex-pack 工具<\/h2><p><a href=\"#download\">下载<\/a> flex-pack 并将它解压到任何能够访问所有 PureFlex 组件（Flex System\n                Manager、交换机、x ITE 等）的 Linux 机器上（最好在一个 x ITE 上）。<\/p><p>在 flex-pack 文件夹中：<\/p><ul class=\"ibm-bullet-list\"><li>Main_disp.py 是主要的 flex-pack 脚本。<\/li><li>README 帮助您设置该工具。 <\/li><li>Environment.json.template 模板提供了您的 PureFlex 环境的细节。 <\/li><li>scripts/README 显示了更改一个 VM 或主机的资源的各种选项。<\/li><\/ul><p>将 Environment.json.template 复制到一个名为 Environment.json 的文件中。在文本编辑器中打开\n                Environment.json 并添加您的特定于环境的信息。以下是一个示例： <\/p><div class=\"codesection\"><pre class=\"displaycode\">{\n\"FSM\" : {\"encrypted\": \"no\", \"hostos\":\"FSM\", \"hostosip\":\"10.10.1.1\", \"user\":\"USERID\", \"password\":\"pwd1\"},\n\"KVM1\" : {\"encrypted\": \"no\", \"hostos\":\"kvm1\", \"hostosip\":\"10.10.1.2\", \"user\":\"root\", \"password\":\"pwd\"},\n\"KVM2\" : {\"encrypted\": \"no\", \"hostos\":\"kvm2\", \"hostosip\":\"10.10.1.3\", \"user\":\"root\", \"password\":\"pwd\"}\n}<\/pre><\/div><p><code>hostos<\/code> 值是 Flex System Manager 中列出的机器名称。<code>hostip<\/code> 和\n                <code>password<\/code> 值是机器凭据。最初的 <code>encrypted<\/code> 值应为\n                <code>no<\/code>。<\/p><p>在命令行输入 <code>python main_disp.py [options]<\/code> 会显示运行的 main_disp.py\n                的可用选项。显示的选项包括：<\/p><div class=\"codesection\"><pre class=\"displaycode\">Options:\n  -h, --help         show this help message and exit\n  -d, --debug        Write to debug log (flex_debug.log)\n  -b, --build        Re-build persistent environment \n  -s, --simulate     Run simulation mode\n  -m FSM_MODE, --mode=FSM_MODE     FSM Adv or Basic mode (basic|adv)<\/pre><\/div><p>命令示例：<\/p><ul class=\"ibm-bullet-list\"><li>运行基本用法：<code>python main_disp.py<\/code><\/li><li>启用高级日志记录：<code>python main_disp.py -d<\/code><\/li><li>重建持久性环境：<code>python main_disp.py -b<\/code><\/li><li>在模拟模式下运行：<code>python main_disp.py -s <\/code><\/li><\/ul><h3 id=\"N10110\">使用示例 1：为一个系统池设置一个安全策略<\/h3><p>按照图 2 到图 4 中的步骤为一个系统池设置一个安全策略：<\/p><h5 id=\"fig2\">图 2. 选择 Configure Security Policy for System Pool\n                    Hosts<\/h5><img alt=\"选择 Configure Security Policy for System Pool Hosts\" src=\"/sunshine_new/images/1694889615/Figure2.jpg\" width=\"531\" /><h5 id=\"fig3\">图 3. 选择系统池 <\/h5><img alt=\"选择系统池\" src=\"/sunshine_new/images/1694889615/Figure3.jpg\" width=\"323\" /><h5 id=\"fig4\">图 4. 更改池的安全策略并确认\n                    <\/h5><img alt=\"更改池的安全策略并确认\" src=\"/sunshine_new/images/1694889615/Figure4.jpg\" width=\"361\" /><h3 id=\"N10133\">使用示例 2：配置 VM 的资源<\/h3><p>可更改在虚拟机管理程序上运行的特定 VM 的内存和 CPU，如图 5 到图 10 中的步骤所示。<\/p><h5 id=\"fig5\">图 5. 选择 Configure Resource Controls for VM\n                    选项<\/h5><img alt=\"选择 Configure Resource Controls for VM 选项\" src=\"/sunshine_new/images/1694889615/Figure5.jpg\" width=\"541\" /><h5 id=\"fig6\">图 6. 阅读 Information\n                    屏幕上的内容，以确定希望执行永久更改还是临时更改<\/h5><img alt=\"阅读 Information 屏幕上的内容，以去顶希望执行永久更改还是临时更改\" src=\"/sunshine_new/images/1694889615/Figure6.jpg\" width=\"438\" /><h5 id=\"fig7\">图 7. 选择虚拟机管理程序和 VM<\/h5><img alt=\"选择虚拟机管理程序和 VM\" src=\"/sunshine_new/images/1694889615/Figure7.jpg\" width=\"367\" /><h5 id=\"fig8\">图 8. 选择一个要更改的资源（CPU 或内存）<\/h5><img alt=\"选择一个要更改的资源（CPU 或内存）\" src=\"/sunshine_new/images/1694889615/Figure8.jpg\" width=\"343\" /><h5 id=\"fig9\">图 9. 选择 VM<\/h5><img alt=\"选择 VM\" src=\"/sunshine_new/images/1694889615/Figure9.jpg\" width=\"367\" /><h5 id=\"fig10\">图 10. 编辑所选 VM 的 vCPU 共享、期限和配额值<\/h5><img alt=\"编辑所选 VM 的 vCPU 共享、期限和配额值\" src=\"/sunshine_new/images/1694889615/Figure10.jpg\" width=\"570\" /><p>scripts/README 文件中的使用示例展示了可为某个 VM 或虚拟机管理程序更改的所有资源选项。<\/p><h2 id=\"N10172\">结束语<\/h2><p>我们的 flex-pack 示例演示了如何通过 Flex System Manager\n                的命令行接口和脚本高级管理场景扩大它的应用范围。借助进一步的工作，可向 flex-pack 工具添加其他高级功能（比如 VM ready、VM\n                克隆和 VM 快照）。\n                <\/p><CMA ID: 972462><Site ID: 10><XSLT stylesheet used to transform this file: dw-document-html-7.0.xsl>\r\n<h2 id=\"download\">下载<\/h2><table class=\"ibm-data-table dw-download-table\" cellpadding=\"0\" cellspacing=\"0\" border=\"0\"><thead><tr><th scope=\"col\">描述<\/th><th scope=\"col\">名字<\/th><th scope=\"col\">大小<\/th><\/tr><\/thead><tbody><tr><th scope=\"row\" class=\"ibm-table-row\">flex-pack<\/th><td nowrap=\"nowrap\"><a href=\"http://www.ibm.com/developerworks/apps/download/index.jsp?contentid=972462&amp;filename=flex-pack-dw.tgz&amp;method=http&amp;locale=zh_CN\">flex-pack-dw.tgz<\/a><\/td><td nowrap=\"nowrap\">381KB<\/td><\/tr><\/tbody><\/table>\r\n\r\n<\/div>\r\n<\/div>\r\n","createTime":"2014-05-27 00:00:00","deployTime":"2014-05-27 00:00:00","id":0,"intro":"包含集成的网络和存储虚拟化和 KVM（Kernel-based virtual machine，基于内核的虚拟机）虚拟机管理程序的 IBM PureFlex System，提供了一个开放的、具有成本效益的虚拟化和云解决方案。本文将向 PureFlex System 管理员展示如何扩展 Flex System Manager 的功能，实现 KVM 虚拟化环境中的高级管理场景。利用您选择的脚本语言，您还可以将这些场景编写成脚本，以实现重用和可重复性。一些可供下载的 Python 脚本示例展示了您该如何做。","keyword":"","recommend":false,"source":"http://www.ibm.com/developerworks/cn/cloud/library/cl-extendFSM/index.html","title":"扩展 Flex System Manager","typeId":0,"updateTime":"2014-05-27 00:00:00"}
{"author":"","clickNumber":0,"content":"\r\n<div class=\"ibm-columns\">\r\n<div class=\"ibm-col-1-1\">\r\n\r\n<h2 id=\"major1\">摘要<\/h2><p>流水号管理作为很多信息系统的一种基础功能，对于一些具有业务含义的流水号，一般由多个具有不同意义的组成部分组成，其格式会相对比较复杂，如何快速灵活的支持不同的流水号格式，十分有现实意义。本文介绍了一种基于自定义格式字符串，应用\n                Command\n                模式的流水号管理方案。在本方案中，对复杂的的流水号进行分析分解，拆分为更细小的子序列，再分别调用相应的生成接口生成，最终生成的流水号。使用本方案，流水号的生成规则定义在格式字符串中，如要生成不同格式的流水号，只需要修改格式字符串即可，生成和扩展都十分方便。<\/p><h2 id=\"major2\">背景<\/h2><p>在信息系统中流水号作为一项必不可少的基础功能，流水号的生成、控制和管理十分重要。一般一个信息系统中，不同的流水号序列有不同的生成规则。如果我们对这些流水号进行进一步分析，这些不同的流水号序列又可细分为多个规则固定的子序列。基于这种分析，对于这种实际应用需求，如何来高效灵活的生成所需的流水号，就显得十分有意义。<\/p><h2 id=\"major3\">场景分析<\/h2><p>首先看几个我们身边常见的流水号：身份证号、税务票、银行的业务流水号、排队号、国务院办公厅发文号（国办发〔2011〕48\n                号）等。如果对这些流水号进一步分析，我们可以得出，流水号一般由多个规则固定的子序列组成，常见的子序列规则如下：<\/p><ul class=\"ibm-bullet-list\"><li> 1. 数字序列：1，2，3 … 或者 00001，00002，00003<\/li><li> 2. 字母序列：如 ‘A-Z’<\/li><li> 3. 固定字符串：如固定的字符前缀或后缀<\/li><li> 4. 时间戳：如 yyyyMMdd 格式对应的为 20130201<\/li><li> 5. 其他序列：如罗马字符 ‘I-X’<\/li><\/ul><p>从另一个角度我们可以说，一个流水号就是上面子序列的排列组合。<\/p><p>基于这样的分析，我们可以创建一个流水号生成引擎，这个引擎可以读取和解析给定的流水号规则，将流水号规则拆分成多个子序列规则，并根据子序列规则生成子序列串，拼接返回最终的流水号。有了这个流水号生成引擎，在系统实际应用的时候，只需要对所需的流水号配置相应的生成规则即可。并且本方案还预留扩展接口，如果实际中遇到个性化的序列生成规则，开发者也可以根据实际需要进行扩展开发，这样也能有效覆盖个性化的需求。<\/p><p>说了这么多，不如图形展示来得直观，整个解决方案的流程见下图：<\/p><h5 id=\"img001\">图 1. 流水号生成流程图<\/h5><img alt=\"图 1. 流水号生成流程图\" src=\"/sunshine_new/images/132415973/img001.png\" width=\"582\" /><ul class=\"ibm-bullet-list\"><li> 1. 流水号规则读取<\/li><li> 2. 流水号规则解析、分割、获取子序列规则<\/li><li> 3. 生成子序列任务的派发<\/li><li> 4. 子序列汇总和合并<\/li><li> 5. 返回最终的生成流水号实例<\/li><\/ul><h5 id=\"img002\">图 2. 流水号生成过程实例<\/h5><img alt=\"图 2. 流水号生成过程实例\" src=\"/sunshine_new/images/132415973/img002.png\" width=\"582\" /><p>在上图中，这里需要说明如下几点：<\/p><ul class=\"ibm-bullet-list\"><li> 1. 流水号规则用格式字符串表示为：<strong>Str@ 国办发〔# DateTime@yyyy # Str@〕#\n                        NumSeq@0C0 # Str@\n                    号，其中： “#” 为子序列间的分隔符，“@” 为子序列内部的分隔符。<\/strong>当然实际应用时，读者也可以按照自己的规则创建格式字符串。<\/li><li> 2.\n                    在每个子序列规则定义的内部，用 “@” 分为两部分，前面一部分（Str/DateTime/NumSeq）表明该子序列的类型，用于确定调用哪个类型的\n                    Generator 来生成该子序列串，后面一部分是用于生成子序列串所需的信息。举例来讲，如 “Str@\n                    国办发〔”，“Str” 表示为固定字符串类型，固定字符串为 “国办发〔”；类似的 “DateTime@yyyy”，“DateTime” 表示时间日期类型，格式为四位的年代号，根据当前时间生成。<\/li><li> 3. 在各个 Generator 生成完毕之后，自动拼接并返回最终生成的流水号。<\/li><\/ul><p>我们可以认为，对于每一个流水号生成规则，似乎可以看做是一个命令队列；对于流水号生成引擎，一方面按照顺序接收生成子序列规则的命令，逐个读取并解析子序列规则，再根据类型分发给各个\n                Generator 来生成子序列传，最后合并返回最终需要的流水号；每个子序列的 Generator，即为最终的命令的执行者。<\/p><p>经过如上的分析并结合应用场景，我们很容易想到，可以使用 Command 模式来实现。Command\n                模式，一个典型的应用场景就是处理命令队列，减少行为请求者和动作执行者的耦合，提高灵活性和降低代码冗余。<\/p><h2 id=\"major4\">Command 模式简介<\/h2><p>命令（Command）模式属于对象的行为模式【GOF95】。命令模式又称为行动（Action）模式或事务（Transaction）模式。命令模式把一个请求或者操作封装到一个对象中。命令模式允许系统使用不同的请求把客户端参数化，对请求排队或者记录请求日志，可以提供命令的撤销和恢复功能。<\/p><p>适用性：在软件系统中，行为请求者与行为实现者之间通常呈现一种紧耦合的关系。但在某些场合，比如要对行为进行记录撤销重做事务等处理，这种无法抵御变化的紧耦合是不合适的。这种情况下，使用\n                command 模式将行为请求者与行为实现者进行解耦。<\/p><p>说到这里，我们来看看 Command 模式 UML 类图。<\/p><h5 id=\"img003\">图 3. Command 模式的 UML 类图<\/h5><img alt=\"图 3. Command 模式的 UML 类图\" src=\"/sunshine_new/images/132415973/img003.png\" width=\"581\" /><p>这里对上图做一个简单的解释，命令模式涉及到五个角色，分别为：<\/p><p><strong>客户（Client）角色：<\/strong>创建一个具体命令（ConcreteCommand）对象，并设置命令的接收者。<\/p><p><strong>命令（Command）角色：<\/strong>定义一个给所有命令类的抽象接口，定义了统一的 execute() 接口方法。<\/p><p><strong>具体命令（ConcreteCommand）角色：<\/strong>定义一个接受者和行为之间的弱耦合；实现 Command 接口，并实现\n                execute() 方法，负责调用接收者的相应操作。<\/p><p><strong>请求者（Invoker）角色：<\/strong>负责调用由 Client 下达的对象执行请求。<\/p><p>接收者（Receiver）角色：负责具体实施和执行一个请求。任何一个类都可以成为接收者，实施和执行请求的方法为行动方法。<\/p><p><strong>【注意】：<\/strong>在某些简单业务场景下，可在 ConcreteCommand 类的 execute\n                方法中直接编写实现代码，而省去接收者（Receiver）类以简化代码。如在本应用场景中省去 Receiver 类的创建。<\/p><p>在本应用场景中，正是利用了 Command 模式将行为请求者与行为实现者进行解耦，用于处理命令队列，实现了原子操作上的复用。Command\n                是对行为进行封装的典型模式，这样做有利于代码的健壮性，可维护性，还有复用性。<\/p><h2 id=\"major5\">实现代码<\/h2><p>对应 Command 模式，简单介绍一下本方案中使用到的核心的类和方法：<\/p><ul class=\"ibm-bullet-list\"><li>1. <strong>Client - <\/strong>SNGenerateApp.java： <\/li><\/ul><p>具体的命令请求者，通过调用 <code>addBuildInGenerator() 方法创建内置 generator，暴露 addGenerator() 方法供进一步扩展<\/code>。<\/p><ul class=\"ibm-bullet-list\"><li>2. <strong>Invoker - <\/strong>SNGeneratorEngine.java：<\/li><\/ul><p>为命令的直接接收者和分派者。<\/p><ul class=\"ibm-bullet-list\"><li>3. <strong>ICommand - <\/strong>IGenerator.java：<\/li><\/ul><p>定义生成接口，子类通过实现 generate() 方法来生成具体的子序列串。<\/p><ul class=\"ibm-bullet-list\"><li>4. <strong>ConcreteCommand - <\/strong>XXXXGenerator.java：<\/li><\/ul><p>各个具体的子序列生成类，实现 generate() 方法，负责最终的的子序列生成，为 Command 的最终执行者。这里简单实现了四个\n                generator。<\/p><ul class=\"ibm-bullet-list\"><li> a). 字符序列生成器：CharacterSequenceGenerator.java<\/li><li> b). 日期时间生成器：DateTimeGenerator.java<\/li><li> c). 数字序列生成器：NumberSequenceGenerator.java<\/li><li> d). 固定字符串生成器：StringGenerator.java<\/li><\/ul><ul class=\"ibm-bullet-list\"><li>5. <strong>Receiver<\/strong>：<\/li><\/ul><p>在本例中由于业务场景简单，为简化代码而直接将实现代码写在各 Generator 的 generate() 方法中，无独立的 Receiver\n                类。<\/p><p>另外还有两个辅助类简单提一下，MockDB.java 用于模拟数据库，存取自增序列；ParamConsts.java\n                为常量变量类，GeneratorTypeSet.java 定义子序列类型常量。<\/p><h5 id=\"img004\">图 4. 包结构及类清单图<\/h5><img alt=\"图 4. 包结构及类清单图\" src=\"/sunshine_new/images/132415973/img004.png\" width=\"257\" /><p>下面是具体的代码展示和介绍。<\/p><h3 id=\"major6\">Generator 接口<\/h3><p>定义 Generator，这里只有两个方法，一个是 getGeneratorType() 用于返回 Generator 类型，另一个是\n                generate() 方法用于生成子序列串。<\/p><h5 id=\"listing1\">清单 1. Generator 接口<\/h5><div class=\"codesection\"><pre class=\"displaycode\">public interface IGenerator {\n\t/**\n\t * 获取子序列类型\n\t * @return\n\t */\n\tpublic String getGeneratorType();\n\t/**\n\t * 生成子序列串\n\t * @param formatStr\n\t * @return\n\t */\n\tpublic String generate(String formatStr,Map paraMap);\n}<\/pre><\/div><h3 id=\"major7\">数字序列 Generator<\/h3><p>Generator\n                接口的实现类，用于处理数字序列的生成。下面的代码考虑到变长字符串和定长字符串两种不同情形。在实际中，序列号的生成还需要考虑按照一定的周期重置的情况（如每年都从\n                1 重新开始计数），可以在扩展实现的时候加以考虑。<\/p><h5 id=\"listing2\">清单 2. 数字序列 Generator<\/h5><div class=\"codesection\"><pre class=\"displaycode\">public class NumberSequenceGenerator implements IGenerator{\n\tprivate static final String type = GeneratorTypeSet.NUMBER_SEQUENCE;\n\tprivate String splitC = \"C\";\n\t@Override\n\tpublic String getGeneratorType() {\n\t\t// TODO Auto-generated method stub\n\t\treturn type;\n\t}\n\t@Override\n\tpublic String generate(String formatStr,Map paraMap) {\n\t\tString seqId = (String)paraMap.get(ParamConsts.PARAM_SEQ_ID);\n\t\t//从数据库中获取当前数值，并自动加 1\n\t\tint seqNum = MockDB.getSeqNumAndIncrease(seqId);\t\t\n\t\tString[] charArray = formatStr.split(splitC);\n\t\tint seqNumLength = Integer.parseInt(charArray[0]);\n\t\tchar prefixChar = charArray[1].charAt(0);\n\t\tif(seqNumLength == 0)\n\t\t\treturn String.valueOf(seqNum);\n\t\telse\n\t\t\treturn appendPrefixChar(seqNum,seqNumLength,prefixChar);\n\t}\n\t/**\n\t * 补足前缀以保证序列定长，如 0001, 保持 4 位，不足 4 位用'0'补齐\n\t * @param seqNum 当前数值\n\t * @param seqNumLength 需要返回的字符串长度\n\t * @param prefixChar 用于补齐的前置字符串\n\t * @return\n\t */\n\tprivate String appendPrefixChar(int seqNum,int seqNumLength,char prefixChar)\n\t{\n\t\tString seqNumStr = String.valueOf(seqNum);\n\t\tfor(int i = seqNumStr.length();i&lt;seqNumLength;i++)\n\t\t{\n\t\t\tseqNumStr = prefixChar + seqNumStr;\n\t\t}\n\t\treturn seqNumStr;\n\t}\n}<\/pre><\/div><h3 id=\"major8\">字符序列 Generator<\/h3><p>Generator 接口的实现类，用于处理字符序列。这里只是一个简单的例子，比如车牌号的生成就可以使用到字符序列。<\/p><h5 id=\"listing3\">清单 3. 字符序列 Generator<\/h5><div class=\"codesection\"><pre class=\"displaycode\">public class CharacterSequenceGenerator implements IGenerator{\n\tprivate static final String type = GeneratorTypeSet.CHARATER_SEQUENCE;\n\t//从’A’开始，自动增长\n\tprivate char c = 'A'; \n\t@Override\n\tpublic String getGeneratorType() {\n\t\t// TODO Auto-generated method stub\n\t\treturn type;\n\t}\n\t@Override\n\tpublic String generate(String formatStr,Map paraMap) {\n\t\treturn String.valueOf((char)c++);\n\t}\n}<\/pre><\/div><h3 id=\"major9\">日期序列 Generator<\/h3><p>Generator 接口的实现类，用于生成时间日期戳。下面的代码基于 java.text.SimpleDateFormat 实现。<\/p><h5 id=\"listing4\">清单 4. 日期序列 Generator<\/h5><div class=\"codesection\"><pre class=\"displaycode\">public class DateTimeGenerator implements IGenerator{\n\tprivate static final String type = GeneratorTypeSet.DATE_TIME;\n\t@Override\n\tpublic String getGeneratorType() {\n\t\t// TODO Auto-generated method stub\n\t\treturn type;\n\t}\n\t@Override\n\tpublic String generate(String formatStr,Map paraMap) {\n\t\tSimpleDateFormat sdf = new SimpleDateFormat();\n\t\tsdf.applyPattern(formatStr);\n\t\treturn sdf.format(new Date());\n\t}\n}<\/pre><\/div><h3 id=\"major10\">固定字符 Generator<\/h3><p>Generator 接口的实现类，用于生成固定字符。固定字符 Generator 比较简单，即直接返回配置的字符串。<\/p><h5 id=\"listing5\">清单 5. 固定字符 Generator<\/h5><div class=\"codesection\"><pre class=\"displaycode\">public class StringGenerator implements IGenerator{\n\tprivate static final String type = GeneratorTypeSet.STRING;\n\t@Override\n\tpublic String getGeneratorType() {\n\t\t// TODO Auto-generated method stub\n\t\treturn type;\n\t}\n\t@Override\n\tpublic String generate(String format,Map paraMap) {\n\t\treturn format;\n\t}\t\n}<\/pre><\/div><h3 id=\"major11\">流水号生成引擎 Engine<\/h3><p>流水号引擎需要负责接收流水号生成规则，根据类型调用对应的各个 Generator 生成子序列串，最后将子序列串并拼接并返回最终的流水号。<\/p><h5 id=\"listing6\">清单 6. 流水号生成引擎 Engine<\/h5><div class=\"codesection\"><pre class=\"displaycode\">public class SNGeneratorEngine {\n\tprivate static SNGeneratorEngine snGeneratorEngine = new SNGeneratorEngine();\n\tprivate static Map&lt;String,IGenerator&gt; generatorMap = new HashMap&lt;String,IGenerator&gt;();\n\t/**流水号生成规则*/\n\tprivate String formatStr; \n\t/**子序列间分隔符*/\n\tprivate String splitChar = \"#\";\n\t/**子序列内部分隔符*/\n\tprivate String innerChar = \"@\";\n\t/**流水号子序列生成规则*/\n\tprivate String[] subFormatStr;\n\t/**\n\t * 按照类型和 Generator 实例存放\n\t * @param Generator\n\t */\n\tpublic void addGenerator(IGenerator Generator)\n\t{\n\t\tgeneratorMap.put(Generator.getGeneratorType(),Generator);\n\t}\n\tprivate SNGeneratorEngine()\n\t{\n\t}\n\tpublic static SNGeneratorEngine getInstance()\n\t{\n\t\treturn snGeneratorEngine;\n\t}\n\t/**\n\t * 接收流水号格式字符串，并分割成子序列\n\t * @param formatStr\n\t */\n\tpublic void setFormatStr(String formatStr)\n\t{\n\t\tthis.formatStr = formatStr;\n\t\tsubFormatStr = this.formatStr.split(splitChar);\n\t}\n\t/**\n\t * 生成流水号：分发给各个子序列 Generator 生成\n\t * @param parameterMap\n\t * @return\n\t */\n\tpublic String generate(Map parameterMap)\n\t{\n\t\tStringBuffer seriableNumber = new StringBuffer();\n\t\tfor(String format:subFormatStr)\n\t\t{\n\t\t\tseriableNumber.append(generateSubSN(format,parameterMap));\n\t\t}\n\t\treturn seriableNumber.toString();\n\t}\n\t/**\n\t * 根据类型调用子序列 Generator 生成\n\t * @param generateSubSN\n\t * @param parameterMap\n\t * @return\n\t */\n\tprivate String generateSubSN(String subFormatStr,Map parameterMap)\n\t{\n\t\tString[] innerSubStr = subFormatStr.split(innerChar);\n\t\tIGenerator Generator = this.getGenerator(innerSubStr[0]);\n\t\treturn Generator.generate(innerSubStr[1],parameterMap);\n\t}\n\t/**根据 GeneratorType 获取 Generator 实例*/\n\tprivate IGenerator getGenerator(String generatorType)\n\t{\n\t\treturn generatorMap.get(generatorType);\n\t}\n}<\/pre><\/div><h3 id=\"major12\">流水号生成应用 App<\/h3><p>流水号应用 SNGenerateApp.java 类，声明了 SNGeneratorEngine 对象的实例，并通过调用\n                addBuildInGenerator() 创建内置的 Generator 类并添加到 SNGeneratorEngine 中，通过\n                generateSN() 方法来发送生成流水号的请求。<\/p><h5 id=\"listing7\">清单 7. 流水号生成应用 App<\/h5><div class=\"codesection\"><pre class=\"displaycode\">public class SNGenerateApp {\n\tprivate SNGeneratorEngine snGenEngine = SNGeneratorEngine.getInstance();\n\t/**\n\t * 设置内置的生成器\n\t */\n\tprivate void addBuildInGenerator(){\n\t\tsnGenEngine.addGenerator(new CharacterSequenceGenerator());\n\t\tsnGenEngine.addGenerator(new DateTimeGenerator());\n\t\tsnGenEngine.addGenerator(new NumberSequenceGenerator());\n\t\tsnGenEngine.addGenerator(new StringGenerator());\n\t}\n\t/**\n\t * 添加 Generator，提供扩展功能\n\t * @param generator\n\t */\n\tpublic void addGenerator(IGenerator generator)\n\t{\n\t\tsnGenEngine.addGenerator(generator);\n\t}\n\t/**\n\t * 生成序列号\n\t * @param snFormatStr 流水号格式字符串\n\t * @param parameterMap 参数列表\n\t * @return\n\t */\n\tpublic String generateSN(String snFormatStr,Map parameterMap)\n\t{\n\t\tsnGenEngine.setFormatStr(snFormatStr);\n\t\treturn snGenEngine.generate(parameterMap);\n\t}\n}<\/pre><\/div><h3 id=\"major13\">应用举例<\/h3><p>现在，我们就通过创建 SNGenerateApp 实例并执行相应方法来模拟流水号的生成。<\/p><p>这里仍然以前文提到的国务院办公厅发文号（国办发〔2011〕48 号）为例来说明，其格式字符串为：“<strong>Str@\n                    国办发〔#DateTime@yyyy#Str@〕#NumSeq@0C0#Str@ 号<\/strong>”，使用\n                MockDB.SEQ_ID_1 的 sequence 获取自增数值，示例代码如下：<\/p><h5 id=\"listing8\">清单 8. 应用示例代码 1<\/h5><div class=\"codesection\"><pre class=\"displaycode\">SNGenerateApp appication = new SNGenerateApp();//创建 App 实例\nappication.addBuildInGenerator(); //设置内置 Generator\n//1. 设定流水号生成规则 国务院办公厅发文号（国办发〔2014〕48 号）\nSystem.out.println(\"1. 生成 国务院办公厅发文号（国办发〔2014〕48 号）\");\n//设定流水号生成规则\nString snFormatStr = \"Str@ 国办发〔#DateTime@yyyy#Str@〕#NumSeq@0C0#Str@ 号\"; \nMap parameterMap1 = new HashMap(); //设定参数\nparameterMap1.put(ParamConsts.PARAM_SEQ_ID, MockDB.SEQ_ID_1); //使用 sequence id 1 进行流水自增\nfor(int i=1;i&lt;=5;i++)//生成 5 个流水号\n{\n System.out.println(\"流水号\"+i+\":\"+appication.generateSN(snFormatStr,parameterMap1));\n}<\/pre><\/div><p>输出结果：<\/p><div class=\"codesection\"><pre class=\"displaycode\">1. 生成 国务院办公厅发文号（国办发〔2014〕48 号）\n流水号 1:国办发〔2014〕48 号\n流水号 2:国办发〔2014〕49 号\n流水号 3:国办发〔2014〕50 号\n流水号 4:国办发〔2014〕51 号\n流水号 5:国办发〔2014〕52 号<\/pre><\/div><p>如果我们要模拟生成常见的 ICP 备案号（（沪 ICP 备 05172190\n                    号））呢？很简单，只需要规则重新配置流水号的格式字符串，在这里对应的为“<strong>Str@ 沪 ICP 备\n                    #NumSeq@8C0#Str@ 号<\/strong>”，无需修改任何代码。注意，一般来讲不同的流水号会用到不同的 sequence\n                数值，我们也做了模拟，这里传入 MockDB.SEQ_ID_2 的 sequence ID 来获取自增数值。<\/p><h5 id=\"listing9\">清单 9. 应用示例代码 2<\/h5><div class=\"codesection\"><pre class=\"displaycode\">//2. 例如生成 ：ICP 备案号（沪 ICP 备 05172190 号）\nSystem.out.println(\"2. 生成 ICP 备案号（沪 ICP 备 05172190 号）\");\n//设定规则\nsnFormatStr = \"Str@ 沪 ICP 备 #NumSeq@8C0#Str@ 号\";\nMap parameterMap2 = new HashMap();//设定参数\nparameterMap2.put(ParamConsts.PARAM_SEQ_ID, MockDB.SEQ_ID_2);//使用 sequence id 2 进行流水自增\nfor(int i=1;i&lt;=5;i++)//生成 5 个流水号\n{\n\tSystem.out.println(\"流水号\"+i+\":\"+ appication.generateSN(snFormatStr,parameterMap2));\n}<\/pre><\/div><p>输出结果：<\/p><div class=\"codesection\"><pre class=\"displaycode\">2. 生成 ICP 备案号（沪 ICP 备 05172190 号）\n流水号 1:沪 ICP 备 05172190 号\n流水号 2:沪 ICP 备 05172191 号\n流水号 3:沪 ICP 备 05172192 号\n流水号 4:沪 ICP 备 05172193 号\n流水号 5:沪 ICP 备 05172194 号<\/pre><\/div><p>想必有读者会问，如果我想生成的流水号还有一些其他特殊的生成规则怎么办？也很简单，只需要编写符合你业务要求的 Generator，然后将这个\n                Generator 通过 SNGenerateApp.addGenerator()\n                添加进去，最后再配置相应的流水号格式字符串即可。这样我们就会发现，只要新添加了一个\n                Generator，那么这个应用就具备相应的子序列生成功能，能够为以后生成含有该子序列的任意流水号提供支持。换句话说，我们可以生成出任意流水号，只要其生成规则是基于当前已有的\n                Generator 的排列组合，所需要做的只是配置一下流水号格式字符串，是不是非常方便和灵活呢？这也正是应用 Command\n                模式给我们带来的巨大好处。<\/p><h2 id=\"major14\">总结<\/h2><p>本文简单介绍了应用 Command 模式及其优点，并通过一个基于自定义的格式字符串的流水号生成的方案，进一步让读者了解应用场景。采用 Command\n                模式，我们将原本复杂的流水号生成过程化整为零，分解成各个可以重用的子序列，根据各子序列的类型派发给对应的\n                Generator，最终在拼接返回流水号。该实现方案适用于各种复杂规则流水号的生成，并且十分易于扩展和维护，在实际应用中也取得了不错的效果。通过本例，希望读者能够进一步了解\n                Command 模式，应用到适合的场景中。<\/p><CMA ID: 972370><Site ID: 10><XSLT stylesheet used to transform this file: dw-document-html-7.0.xsl>\r\n\r\n\r\n<\/div>\r\n<\/div>\r\n","createTime":"2014-05-26 00:00:00","deployTime":"2014-05-26 00:00:00","id":0,"intro":"本文介绍了一种基于自定义格式字符串, 应用 Command 模式的流水号管理功能，可以让用户灵活设定流水号的格式，具备非常好的灵活性和可扩展性。","keyword":"","recommend":false,"source":"http://www.ibm.com/developerworks/cn/java/j-lo-serialNo/index.html","title":"应用 Command 模式进行流水号管理的最佳实践","typeId":0,"updateTime":"2014-05-26 00:00:00"}
{"author":"","clickNumber":0,"content":"\r\n<div class=\"ibm-columns\">\r\n<div class=\"ibm-col-1-1\">\r\n\r\n<h2 id=\"1.Introduction|outline\">简介<\/h2><p>IBM Pattern Lab 采用基于资产的方法来创建可重用并且可自定义的组件，它们共同组成了用于一次给定软件产品和解决方案部署的自动化包。 <\/p><h2 id=\"2.Step1:IntroducingtheMicrosoftExchangeServerv2013CU1Patterncapabilities|outline\">第 1 步：Microsoft Exchange Server v2013 CU1 Pattern 功能介绍<\/h2><p>这个脚本包安装了附带累积更新包 1 的 Microsoft Exchange Server 2013 版。<\/p><p>基础操作系统部分（用于测试这个脚本包的操作系统）是 64 位的 Windows Server 2012 Standard。<\/p><p>这种 Microsoft Exchange Server 产品部署机制支持以下拓扑结构： <\/p><ul class=\"ibm-bullet-list\"><li>单个服务器、单个 Exchange 角色<\/li><li>单个服务器、多个 Exchange 角色<\/li><li>多个服务器、单个具有 DAG 的 Exchange 角色<\/li><li>多个服务器、多个具有 DAG 的 Exchange 角色<\/li><\/ul><p>有关上述拓扑结构的详细信息将在下一节介绍。 <\/p><h2 id=\"_Step_2:_Identifying\">第 2\n                步：确定脚本包和它们的参数<\/h2><p>表 1 列出并描述了将用于这个 Microsoft Exchange Pattern 的脚本包。 <\/p><h5 id=\"N10069\">表 1. 确定此模式的脚本包部分<\/h5><table border=\"0\" cellpadding=\"0\" cellspacing=\"0\" class=\"ibm-data-table\" summary=\"Identifying the script packages part of this pattern\"><thead xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"><tr><th style=\"text-align:left; vertical-align:top\"><strong>脚本包<\/strong><\/th><th style=\"text-align:left; vertical-align:top\"><strong>用途<\/strong><\/th><\/tr><\/thead><tbody xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"><tr><td style=\"vertical-align:top\"><code>RDS-Exchange-v2013-PRQ-install.zip<\/code><\/td><td style=\"vertical-align:top\"> 准备用于 Exchange 安装的操作系统：<br />- 安装\n                            Windows 角色。<br />- 禁用 UAC。<br />- 禁用\n                            IEESC。<br />此脚本包运行后，需要重新引导。参见 <a href=\"#Table_2._RDS-Exchange-v2013-PRQ-install_\">表 2<\/a>\n                            了解这个脚本包需要的参数。 <\/td><\/tr><tr><td style=\"vertical-align:top\"><code>RDS-Exchange-v2013-MBX-install.zip<\/code><\/td><td style=\"vertical-align:top\"> 安装一个具有默认配置的 Exchange 邮箱服务器 (MBX)\n                            角色和一个数据库。在此脚本包运行后，需要重新引导。参见 <a href=\"#_Table_3._RDS-Exchange-v2013-MBX-install\">表 3<\/a>\n                            了解这个脚本包需要的参数。 <\/td><\/tr><tr><td style=\"vertical-align:top\"><code>RDS-Exchange-v2013-CAS-install.zip<\/code><\/td><td style=\"vertical-align:top\"> 安装一个具有默认配置的 Exchange 客户端访问服务器\n                            (CAS) 角色。在此脚本包运行后，需要重新引导。参见 <a href=\"#_Table_4._RDS-Exchange-v2013-CAS-install\">表 4<\/a>\n                            了解这个脚本包需要的参数。 <\/td><\/tr><tr><td style=\"vertical-align:top\"><code>RDS-Exchange-v2013-MULTIROLE-install.zip<\/code><\/td><td style=\"vertical-align:top\"> 安装具有默认配置的 CAS 和 MBX\n                            角色和一个数据库。在此脚本包运行后，需要重新引导。参见 <a href=\"#_Table_5._RDS-Exchange-v2013-MULTIROLE-i\">表 5<\/a>\n                            了解这个脚本包需要的参数。 <\/td><\/tr><tr><td style=\"vertical-align:top\"><code>RDS-Exchange-v2013-CAS-configure.zip<\/code><\/td><td style=\"vertical-align:top\"> 配置客户端访问服务器角色：<br />- 添加接受的域。<br />-\n                            添加或编辑地址策略。<br />- 配置 URL。<br />- 启用/配置 IMAP4 协议。<br />- 启用/配置\n                            POP3 协议。<br />参见 <a href=\"#_Table_6._RDS-Exchange-v2013-CAS-configu\">表 6<\/a>\n                            了解这个脚本包需要的参数。 <\/td><\/tr><tr><td style=\"vertical-align:top\"><code>RDS-Exchange-v2013-MBX-configure.zip<\/code><\/td><td style=\"vertical-align:top\"> 配置邮箱服务器角色：<br />- 添加另一个数据库。<br />-\n                            配置数据库属性。<br />- 创建发送连接器。<br />-配置传输日志。<br />- 启用 IMAP4\n                            后端服务。<br />- 启用 POP3 后端服务。<br />- 创建数据库可用性分组 (Database\n                            Availability Group, DAG) C DAG 的 IP 被设置为 “DHCP”。仅有一个 DAG\n                            网络同时用作 Replication 网络和 MAPI 网络。<br />- 将运行此脚本包的服务器加入 DAG\n                            中。此刻没有创建任何数据库副本（参见下面的脚本包，其中包含此操作）。<br />参见 <a href=\"#_Table_7._RDS-Exchange-v2013-MBX-configu\">表 7<\/a>\n                            了解这个脚本包需要的参数。 <\/td><\/tr><tr><td style=\"vertical-align:top\"><code>RDS-Exchange-v2013-MBX-DBCopy.zip<\/code><\/td><td style=\"vertical-align:top\">\n                            创建了用于另一个邮箱服务器上的本地数据库的副本。邮箱服务器必须是同一个 DAG 的成员。<br />参见 <a href=\"#_Table_8._RDS-Exchange-v2013-MBX-DBCopy\">表 8<\/a>\n                            了解这个脚本包需要的参数。 <\/td><\/tr><\/tbody><\/table><p>创建 Microsoft Exchange\n                虚拟系统模式时，您将需要遵循以下列表中给出的顺序和依赖关系。因此，第一步是添加操作系统镜像。在这个操作系统镜像上： <\/p><ol><li>添加 <code>Windows OSPreparation<\/code> 脚本包，这会将该操作系统加入一个 Active\n                    Directory 中（请参阅 <a href=\"#_Step_2:_Identifying\">第 2 步<\/a> 末尾）。<\/li><li>添加 <code>RDS-Exchange-v2013-PRQ-install<\/code> 脚本包。<\/li><li>添加以下脚本包之一：<code>RDS-Exchange-v2013-CAS-install<\/code>、<code>RDS-Exchange-v2013-MBX-install<\/code>\n                    或 <code>RDS-Exchange-v2013-MULTIROLE-install<\/code>。<\/li><li>如果之前已添加了 <code>RDS-Exchange-v2013-CAS-install<\/code>，那么您可以添加\n                    <code>RDS-Exchange-v2013-CAS-configure<\/code>。<\/li><li>如果之前已添加了 <code>RDS-Exchange-v2013-MBX-install<\/code>，那么您可以添加\n                    <code>RDS-Exchange-v2013-MBX-configure<\/code> 和\n                    <code>RDS-Exchange-v2013-MBX-DBCopy<\/code>。<\/li><li>如果之前已添加了 <code>RDS-Exchange-v2013-MULTIROLE-install<\/code>，那么您可以添加\n                    <code>RDS-Exchange-v2013-MBX-configure<\/code>、<code>RDS-Exchange-v2013-CAS-configure<\/code>\n                    和 <code>RDS-Exchange-v2013-MBX-DBCopy<\/code>。<\/li><\/ol><p>以下是当前在使用上述所有脚本包时支持的拓扑结构。 <\/p><h5 id=\"N10139\">支持的拓扑结构<\/h5><table border=\"0\" cellpadding=\"0\" cellspacing=\"0\" class=\"ibm-data-table\" summary=\"Supported topologies\"><thead xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"><tr><th style=\"text-align:left; vertical-align:top\"><strong> Exchange\n                                Client Access Pattern 1 到 n<\/strong><\/th><th style=\"text-align:left; vertical-align:top\"><strong>Exchange\n                                MailBox Pattern（1 到 16 / DAG）<\/strong><\/th><th style=\"text-align:left; vertical-align:top\"><strong>Exchange\n                                Multirole Pattern（1 到 16 / DAG）<\/strong><\/th><\/tr><\/thead><tbody xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"><tr><td style=\"vertical-align:top\"><img alt=\"Exchange Client Access Pattern 镜像\" src=\"/sunshine_new/images/771066161/images/image-tablea.jpg\" width=\"200\" /><\/td><td style=\"vertical-align:top\"><img alt=\"Exchange MailBox Pattern 镜像\" src=\"/sunshine_new/images/771066161/images/image-tableb.jpg\" width=\"250\" /><\/td><td style=\"vertical-align:top\"><img alt=\"Exchange Multirole Pattern 镜像\" src=\"/sunshine_new/images/771066161/images/image-tablec.jpg\" width=\"250\" /><\/td><\/tr><\/tbody><\/table><p>对于一个 Microsoft Exchange 组织中可以使用的上述每种模式的实例数量，具有以下限制： <\/p><ul class=\"ibm-bullet-list\"><li><em>1<\/em> 到 <em>n<\/em> 个 Client Access Pattern 实例<\/li><li>每个 DAG <em>1<\/em> 到 <em>16<\/em> 个 Mailbox Pattern 实例。如果使用多个\n                    DAG，那么您可以拥有超过 16 个 Mailbox Pattern 实例。<\/li><li>每个 DAG <em>1<\/em> 到 <em>16<\/em> 个 MultiRole Pattern 实例。如果使用多个\n                    DAG，那么您可以拥有超过 16 个 MultiRole Pattern 实例。<\/li><\/ul><p>最终的限制取决于您的 Microsoft Exchange 许可。<\/p><p>在脚本包执行顺序方面，必须遵守以下限制： <\/p><ul class=\"ibm-bullet-list\"><li>不要同时运行 Exchange 角色安装和配置脚本包。在某些情况下，如果角色安装和配置的操作将同时访问相同的 Active\n                    Directory 对象，那么这些操作将会失败。<\/li><li>运行\n                    <code>RDS-Windows-OSPreparation-v1<\/code>、<code>RDS-Exchange-v2013-PRQ-install<\/code>\n                    和任何 Exchange Server\n                    角色安装后，操作系统将会自动重新引导。请等待两分钟（具体依赖于您的环境有多快），然后再次在机器上运行其他脚本包。<\/li><li>创建一个新 Microsoft Exchange 组织时，只有一个脚本包应将 <code>MsExchange_NewOrg<\/code>\n                    参数值设置为 <code>YES<\/code>。该脚本包必须是第一个在 Microsoft Exchange\n                    组织部署中执行角色安装的脚本包。在上面指定的脚本包执行完成之前，不要运行其他 Exchange 脚本包。<\/li><li>在运行 <code>RDS-Exchange-v2013-MBX-configure<\/code> 之前，确保您的 Exchange\n                    组织中有一个 Exchange 客户端访问服务器。这个客户端访问服务器将用作 DAG 的见证服务器 (Witness\n                    Server)。我们建议不要让此服务器具有其他已安装的角色。<\/li><li>在运行 <code>RDS-Exchange-v2013-MBX-configure<\/code> 之前，确保您拥有 Active\n                    Directory 中的 Exchange Trusted System 的适当权限。请参见 <a href=\"#_Table_11._\">表 11<\/a>。<\/li><li>在运行 <code>RDS-Exchange-v2013-MBX-DBCopy<\/code> 脚本包之前，其他所有\n                    <code>RDS-Exchange-v2013-MBX-configure<\/code> 脚本包应该已经完成执行。<\/li><li><code>RDS-Exchange-v2013-MBX-DBCopy<\/code> 脚本包的\n                    <code>MsExchange_DBCopySrvList<\/code>\n                    参数中声明的服务器应该是可用的（目前未参与安装或配置过程）。此外，请记住 Microsoft Exchange v2013 Standard\n                    的每个服务器的最大数据库数量为 5 个。<\/li><\/ul><p>在表 2 到表 8 中，您可以找到每个脚本包在执行之前将获得的参数。 <\/p><h5 id=\"Table_2._RDS-Exchange-v2013-PRQ-install_\">表 2.\n                    RDS-Exchange-v2013-PRQ-install 脚本包参数<\/h5><table border=\"0\" cellpadding=\"0\" cellspacing=\"0\" class=\"ibm-data-table\" summary=\"RDS-Exchange-v2013-PRQ-install script package parameters\"><thead xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"><tr><th style=\"text-align:left; vertical-align:top\"><strong>参数名称<\/strong><\/th><th style=\"text-align:left; vertical-align:top\"><strong>参数描述<\/strong><\/th><th style=\"text-align:left; vertical-align:top\"><strong>示例<\/strong><\/th><\/tr><\/thead><tbody xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"><tr><td style=\"vertical-align:top\"><code>driveLetter<\/code><\/td><td style=\"vertical-align:top\"> 驱动器盘符，将用于映射网络驱动器。这个网络驱动器将包含软件存储库。\n                            <\/td><td style=\"vertical-align:top\"><code>Y<\/code><\/td><\/tr><tr><td style=\"vertical-align:top\"><code>sharePath<\/code><\/td><td style=\"vertical-align:top\"> 具有一种特定于 Microsoft Windows\n                            的共享格式的共享文件夹地址。不要附加路径最后的反斜杠。 <\/td><td style=\"vertical-align:top\"><code>\\\\9.9.9.9\\IBMRepository<\/code><\/td><\/tr><tr><td style=\"vertical-align:top\"><code>shareUser<\/code><\/td><td style=\"vertical-align:top\"> 拥有 <code>sharePath<\/code>\n                            访问权限的用户。该用户不必是管理员。 <\/td><td style=\"vertical-align:top\"><code>ibmuser<\/code><\/td><\/tr><tr><td style=\"vertical-align:top\"><code>shareUserPwd<\/code><\/td><td style=\"vertical-align:top\"><code>shareUser<\/code> 密码。 <\/td><td style=\"vertical-align:top\"><code>Zaq12wsx<\/code><\/td><\/tr><\/tbody><\/table><h5 id=\"_Table_3._RDS-Exchange-v2013-MBX-install\">表 3.\n                    RDS-Exchange-v2013-MBX-install 脚本包参数<\/h5><table border=\"0\" cellpadding=\"0\" cellspacing=\"0\" class=\"ibm-data-table\" summary=\"RDS-Exchange-v2013-MBX-install script package                 parameters\"><thead xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"><tr><th style=\"text-align:left; vertical-align:top\"><strong>参数名称<\/strong><\/th><th style=\"text-align:left; vertical-align:top\"><strong>参数描述<\/strong><\/th><th style=\"text-align:left; vertical-align:top\"><strong>示例<\/strong><\/th><\/tr><\/thead><tbody xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"><tr><td style=\"vertical-align:top\"><code>driveLetter<\/code><\/td><td style=\"vertical-align:top\"> 驱动器盘符，将用于映射网络驱动器。这个网络驱动器将包含软件存储库。\n                            <\/td><td style=\"vertical-align:top\"><code>Y<\/code><\/td><\/tr><tr><td style=\"vertical-align:top\"><code>sharePath<\/code><\/td><td style=\"vertical-align:top\"> 具有一种特定于 Microsoft Windows\n                            的共享格式的共享文件夹地址。不要附加路径最后的反斜杠。 <\/td><td style=\"vertical-align:top\"><code>\\\\9.9.9.9\\IBMRepository<\/code><\/td><\/tr><tr><td style=\"vertical-align:top\"><code>shareUser<\/code><\/td><td style=\"vertical-align:top\"> 拥有 <code>sharePath<\/code>\n                            访问权限的用户。该用户不必是管理员。 <\/td><td style=\"vertical-align:top\"><code>ibmuser<\/code><\/td><\/tr><tr><td style=\"vertical-align:top\"><code>shareUserPwd<\/code><\/td><td style=\"vertical-align:top\"><code>shareUser<\/code> 密码。 <\/td><td style=\"vertical-align:top\"><code>Zaq12wsx<\/code><\/td><\/tr><tr><td style=\"vertical-align:top\"><code>MsExchange_SetupUser<\/code><\/td><td style=\"vertical-align:top\"> 所使用的 Active Directory 的域管理员。\n                            <\/td><td style=\"vertical-align:top\"><code>ibm\\Administrator<\/code><\/td><\/tr><tr><td style=\"vertical-align:top\"><code>MsExchange_SetupUserPwd<\/code><\/td><td style=\"vertical-align:top\"><code>MsExchange_SetupUser<\/code> 密码。 <\/td><td style=\"vertical-align:top\"><code>Zaq12wsx<\/code><\/td><\/tr><tr><td style=\"vertical-align:top\"><code>MsExchange_InstallDir<\/code><\/td><td style=\"vertical-align:top\"> Exchange 安装目录。 <\/td><td style=\"vertical-align:top\"><code>C:\\Exchange<\/code><\/td><\/tr><tr><td style=\"vertical-align:top\"><code>MsExchange_NewOrg<\/code><\/td><td style=\"vertical-align:top\"> 如果设置为 “YES”，则会在所使用的 Active\n                            Directory 中创建一个新组织。<br />如果设置为 “NO”，则会将一个现有组织用于当前的 Exchange 设置。\n                            <\/td><td style=\"vertical-align:top\"><code>YES<\/code><\/td><\/tr><tr><td style=\"vertical-align:top\"><code>MsExchange_OrgName<\/code><\/td><td style=\"vertical-align:top\"> Exchange 组织名称。仅使用字母数字字符，不包含空格。\n                            <\/td><td style=\"vertical-align:top\"><code>IBMMail<\/code><\/td><\/tr><tr><td style=\"vertical-align:top\"><code>MsExchange_ProdKey<\/code><\/td><td style=\"vertical-align:top\"> Exchange 产品密钥。如果没有产品密钥可用，那么此设置将为\n                            “Trial”。 <\/td><td style=\"vertical-align:top\"><code>Trial<\/code><\/td><\/tr><tr><td style=\"vertical-align:top\"><code>MsExchange_DB1Drive<\/code><\/td><td style=\"vertical-align:top\"> Exchange 服务器的第一个数据库 (DB1)\n                            将存储其数据文件的驱动器。 <\/td><td style=\"vertical-align:top\"><code>E:<\/code><\/td><\/tr><tr><td style=\"vertical-align:top\"><code>MsExchange_DB2LogsDrive<\/code><\/td><td style=\"vertical-align:top\"> Exchange 服务器的第一个数据库 (DB1)\n                            将存储其日志文件的驱动器。 <\/td><td style=\"vertical-align:top\"><code>G:<\/code><\/td><\/tr><\/tbody><\/table><h5 id=\"_Table_4._RDS-Exchange-v2013-CAS-install\">表 4.\n                    RDS-Exchange-v2013-CAS-install 脚本包参数<\/h5><table border=\"0\" cellpadding=\"0\" cellspacing=\"0\" class=\"ibm-data-table\" summary=\"RDS-Exchange-v2013-CAS-install script package                 parameters\"><thead xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"><tr><th style=\"text-align:left; vertical-align:top\"><strong>参数名称<\/strong><\/th><th style=\"text-align:left; vertical-align:top\"><strong>参数描述<\/strong><\/th><th style=\"text-align:left; vertical-align:top\"><strong>示例<\/strong><\/th><\/tr><\/thead><tbody xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"><tr><td style=\"vertical-align:top\"><code>driveLetter<\/code><\/td><td style=\"vertical-align:top\"> 驱动器盘符，将用于映射网络驱动器。这个网络驱动器将包含软件存储库。\n                            <\/td><td style=\"vertical-align:top\"><code>Y<\/code><\/td><\/tr><tr><td style=\"vertical-align:top\"><code>sharePath<\/code><\/td><td style=\"vertical-align:top\"> 具有一种特定于 Microsoft Windows\n                            的共享格式的共享文件夹地址。不要附加路径最后的反斜杠。 <\/td><td style=\"vertical-align:top\"><code>\\\\9.9.9.9\\IBMRepository<\/code><\/td><\/tr><tr><td style=\"vertical-align:top\"><code>shareUser<\/code><\/td><td style=\"vertical-align:top\"> 拥有 <code>sharePath<\/code>\n                            访问权限的用户。该用户不必是管理员。 <\/td><td style=\"vertical-align:top\"><code>ibmuser<\/code><\/td><\/tr><tr><td style=\"vertical-align:top\"><code>shareUserPwd<\/code><\/td><td style=\"vertical-align:top\"><code>shareUser<\/code> 密码。 <\/td><td style=\"vertical-align:top\"><code>Zaq12wsx<\/code><\/td><\/tr><tr><td style=\"vertical-align:top\"><code>MsExchange_SetupUser<\/code><\/td><td style=\"vertical-align:top\"> 所使用的 Active Directory 的域管理员。\n                            <\/td><td style=\"vertical-align:top\"><code>ibm\\Administrator<\/code><\/td><\/tr><tr><td style=\"vertical-align:top\"><code>MsExchange_SetupUserPwd<\/code><\/td><td style=\"vertical-align:top\"><code>MsExchange_SetupUser<\/code> 密码。 <\/td><td style=\"vertical-align:top\"><code>Zaq12wsx<\/code><\/td><\/tr><tr><td style=\"vertical-align:top\"><code>MsExchange_InstallDir<\/code><\/td><td style=\"vertical-align:top\"> Exchange 安装目录。 <\/td><td style=\"vertical-align:top\"><code>C:\\Exchange<\/code><\/td><\/tr><tr><td style=\"vertical-align:top\"><code>MsExchange_NewOrg<\/code><\/td><td style=\"vertical-align:top\"> 如果设置为 “YES”，则会在所使用的 Active\n                            Directory 中创建一个新组织。<br />如果设置为 “NO”，则会将一个现有组织用于当前的 Exchange 设置。\n                            <\/td><td style=\"vertical-align:top\"><code>YES<\/code><\/td><\/tr><tr><td style=\"vertical-align:top\"><code>MsExchange_OrgName<\/code><\/td><td style=\"vertical-align:top\"> Exchange 组织名称。仅使用字母数字字符，不含空格。\n                            <\/td><td style=\"vertical-align:top\"><code>IBMMail<\/code><\/td><\/tr><tr><td style=\"vertical-align:top\"><code>MsExchange_ProdKey<\/code><\/td><td style=\"vertical-align:top\"> Exchange 产品密钥。如果没有产品密钥可用，则将此参数设置为\n                            “Trial”。 <\/td><td style=\"vertical-align:top\"><code>Trial<\/code><\/td><\/tr><\/tbody><\/table><h5 id=\"_Table_5._RDS-Exchange-v2013-MULTIROLE-i\">表 5.\n                    RDS-Exchange-v2013-MULTIROLE-install 脚本包参数<\/h5><table border=\"0\" cellpadding=\"0\" cellspacing=\"0\" class=\"ibm-data-table\" summary=\"RDS-Exchange-v2013-MULTIROLE-install script package parameters\"><thead xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"><tr><th style=\"text-align:left; vertical-align:top\"><strong>参数名称<\/strong><\/th><th style=\"text-align:left; vertical-align:top\"><strong>参数描述<\/strong><\/th><th style=\"text-align:left; vertical-align:top\"><strong>示例<\/strong><\/th><\/tr><\/thead><tbody xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"><tr><td style=\"vertical-align:top\"><code>driveLetter<\/code><\/td><td style=\"vertical-align:top\"> 驱动器盘符，将用于映射网络驱动器。这个网络驱动器将包含软件存储库。\n                            <\/td><td style=\"vertical-align:top\"><code>Y<\/code><\/td><\/tr><tr><td style=\"vertical-align:top\"><code>sharePath<\/code><\/td><td style=\"vertical-align:top\"> 具有一种特定于 Microsoft Windows\n                            的共享格式的共享文件夹地址。不要附加路径最后的反斜杠。 <\/td><td style=\"vertical-align:top\"><code>\\\\9.9.9.9\\IBMRepository<\/code><\/td><\/tr><tr><td style=\"vertical-align:top\"><code>shareUser<\/code><\/td><td style=\"vertical-align:top\"> 拥有 <code>sharePath<\/code>\n                            访问权限的用户。该用户不必是管理员。 <\/td><td style=\"vertical-align:top\"><code>ibmuser<\/code><\/td><\/tr><tr><td style=\"vertical-align:top\"><code>shareUserPwd<\/code><\/td><td style=\"vertical-align:top\"><code>shareUser<\/code> 密码。 <\/td><td style=\"vertical-align:top\"><code>Zaq12wsx<\/code><\/td><\/tr><tr><td style=\"vertical-align:top\"><code>MsExchange_SetupUser<\/code><\/td><td style=\"vertical-align:top\"> 所使用的 Active Directory 的域管理员。\n                            <\/td><td style=\"vertical-align:top\"><code>ibm\\Administrator<\/code><\/td><\/tr><tr><td style=\"vertical-align:top\"><code>MsExchange_SetupUserPwd<\/code><\/td><td style=\"vertical-align:top\"><code>MsExchange_SetupUser<\/code> 密码。 <\/td><td style=\"vertical-align:top\"><code>Zaq12wsx<\/code><\/td><\/tr><tr><td style=\"vertical-align:top\"><code>MsExchange_InstallDir<\/code><\/td><td style=\"vertical-align:top\"> Exchange 安装目录。 <\/td><td style=\"vertical-align:top\"><code>C:\\Exchange<\/code><\/td><\/tr><tr><td style=\"vertical-align:top\"><code>MsExchange_NewOrg<\/code><\/td><td style=\"vertical-align:top\"> 如果设置为 “YES”，则会在所使用的 Active\n                            Directory 中创建一个新组织。<br />如果设置为 “NO”，则会将一个现有组织用于当前的 Exchange 设置。\n                            <\/td><td style=\"vertical-align:top\"><code>YES<\/code><\/td><\/tr><tr><td style=\"vertical-align:top\"><code>MsExchange_OrgName<\/code><\/td><td style=\"vertical-align:top\"> Exchange 组织名称。仅使用字母数字字符，不含空格。\n                            <\/td><td style=\"vertical-align:top\"><code>IBMMail<\/code><\/td><\/tr><tr><td style=\"vertical-align:top\"><code>MsExchange_ProdKey<\/code><\/td><td style=\"vertical-align:top\"> Exchange 产品密钥。如果没有产品密钥可用，则将此参数设置为\n                            “Trial”。 <\/td><td style=\"vertical-align:top\"><code>Trial<\/code><\/td><\/tr><tr><td style=\"vertical-align:top\"><code>MsExchange_DB1Drive<\/code><\/td><td style=\"vertical-align:top\"> Exchange 服务器的第一个数据库 (DB1)\n                            将存储其数据文件的驱动器。 <\/td><td style=\"vertical-align:top\"><code>E:<\/code><\/td><\/tr><tr><td style=\"vertical-align:top\"><code>MsExchange_DB2LogsDrive<\/code><\/td><td style=\"vertical-align:top\"> Exchange 服务器的第一个数据库 (DB1)\n                            将存储其日志文件的驱动器。 <\/td><td style=\"vertical-align:top\"><code>G:<\/code><\/td><\/tr><\/tbody><\/table><h5 id=\"_Table_6._RDS-Exchange-v2013-CAS-configu\">表 6.\n                    RDS-Exchange-v2013-CAS-configure 脚本包参数<\/h5><table border=\"0\" cellpadding=\"0\" cellspacing=\"0\" class=\"ibm-data-table\" summary=\"RDS-Exchange-v2013-CAS-configure script package parameters\"><thead xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"><tr><th style=\"text-align:left; vertical-align:top\"><strong>参数名称<\/strong><\/th><th style=\"text-align:left; vertical-align:top\"><strong>参数描述<\/strong><\/th><th style=\"text-align:left; vertical-align:top\"><strong>示例<\/strong><\/th><\/tr><\/thead><tbody xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"><tr><td style=\"vertical-align:top\"><code>MsExchange_SetupUser<\/code><\/td><td style=\"vertical-align:top\"> 所使用的 Active Directory 的域管理员。\n                            <\/td><td style=\"vertical-align:top\"><code>ibm\\Administrator<\/code><\/td><\/tr><tr><td style=\"vertical-align:top\"><code>MsExchange_SetupUserPwd<\/code><\/td><td style=\"vertical-align:top\"><code>MsExchange_SetupUser<\/code> 密码。 <\/td><td style=\"vertical-align:top\"><code>Zaq12wsx<\/code><\/td><\/tr><tr><td style=\"vertical-align:top\"><code>MsExchange_AccDomainList<\/code><\/td><td style=\"vertical-align:top\"> Exchange 接受的域列表（用逗号 “,”\n                            分隔）。可使用通配符。邮箱服务器接受来自此列表定义的域的电子邮件，并能够进一步转发它们。 <\/td><td style=\"vertical-align:top\"><code>*.acme.com<\/code><\/td><\/tr><tr><td style=\"vertical-align:top\"><code>MsExchange_ExtHostName<\/code><\/td><td style=\"vertical-align:top\"> Exchange 外部主机名。这指的是这个服务器在 DNS\n                            服务器中拥有的完全限定的域名条目。 <\/td><td style=\"vertical-align:top\"><code>mail.ibm.com<\/code><\/td><\/tr><tr><td style=\"vertical-align:top\"><code>MsExchange_IMAP4Enable<\/code><\/td><td style=\"vertical-align:top\"> 如果设置为 “TRUE”，则会在将运行该脚本包的服务器上启用\n                            IMAP4 协议。 <\/td><td style=\"vertical-align:top\"><code>TRUE<\/code><\/td><\/tr><tr><td style=\"vertical-align:top\"><code>MsExchange_IMAP4ConnSet<\/code><\/td><td style=\"vertical-align:top\"> CAS 服务器的 IMAP4\n                            外部连接设置。此参数具有以下格式：<br /><code>{external_address}:{port}:SSL<\/code><\/td><td style=\"vertical-align:top\"><code>imap.ibm.com:993:SSL<\/code><\/td><\/tr><tr><td style=\"vertical-align:top\"><code>MsExchange_POP3Enable<\/code><\/td><td style=\"vertical-align:top\"> 如果设置为 “TRUE”，则会在将运行该脚本包的服务器上启用\n                            POP3 协议。 <\/td><td style=\"vertical-align:top\"><code>TRUE<\/code><\/td><\/tr><tr><td style=\"vertical-align:top\"><code>MsExchange_POP3ConnSet<\/code><\/td><td style=\"vertical-align:top\"> CAS 服务器的 POP3\n                            外部连接设置。此参数具有以下格式：<br /><code>{external_address}:{port}:SSL<\/code><\/td><td style=\"vertical-align:top\"><code>imap.ibm.com:995:SSL<\/code><\/td><\/tr><\/tbody><\/table><h5 id=\"_Table_7._RDS-Exchange-v2013-MBX-configu\">表 7.\n                    RDS-Exchange-v2013-MBX-configure 脚本包参数<\/h5><table border=\"0\" cellpadding=\"0\" cellspacing=\"0\" class=\"ibm-data-table\" summary=\"RDS-Exchange-v2013-MBX-configure script package parameters\"><thead xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"><tr><th style=\"text-align:left; vertical-align:top\"><strong>参数名称<\/strong><\/th><th style=\"text-align:left; vertical-align:top\"><strong>参数描述<\/strong><\/th><th style=\"text-align:left; vertical-align:top\"><strong>示例<\/strong><\/th><\/tr><\/thead><tbody xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"><tr><td style=\"vertical-align:top\"><code>MsExchange_SetupUser<\/code><\/td><td style=\"vertical-align:top\"> 所使用的 Active Directory 的域管理员。\n                            <\/td><td style=\"vertical-align:top\"><code>ibm\\Administrator<\/code><\/td><\/tr><tr><td style=\"vertical-align:top\"><code>MsExchange_SetupUserPwd<\/code><\/td><td style=\"vertical-align:top\"><code>MsExchange_SetupUser<\/code> 密码。 <\/td><td style=\"vertical-align:top\"><code>Zaq12wsx<\/code><\/td><\/tr><tr><td style=\"vertical-align:top\"><code>MsExchange_DB2Drive<\/code><\/td><td style=\"vertical-align:top\"> Exchange 服务器的第二个数据库 (DB2)\n                            将存储其数据文件的驱动器。 <\/td><td style=\"vertical-align:top\"><code>F:<\/code><\/td><\/tr><tr><td style=\"vertical-align:top\"><code>MsExchange_DB2LogsDrive<\/code><\/td><td style=\"vertical-align:top\"> Exchange 服务器的第二个数据库 (DB2)\n                            将存储其日志文件的驱动器。 <\/td><td style=\"vertical-align:top\"><code>H:<\/code><\/td><\/tr><tr><td style=\"vertical-align:top\"><code>MsExchange_TransLogsFolder<\/code><\/td><td style=\"vertical-align:top\"> Exchange 传输日志目录。 <\/td><td style=\"vertical-align:top\"><code>J:\\ExchangeLogs<\/code><\/td><\/tr><tr><td style=\"vertical-align:top\"><code>MsExchange_DAGName<\/code><\/td><td style=\"vertical-align:top\"> Exchange 数据库可用性分组名称。如果不希望创建或加入一个\n                            DAG，那么可以对此参数使用值 “NONE”。仅使用字母数字字符，不含空格。 <\/td><td style=\"vertical-align:top\"><code>DAG01<\/code>\n                            或<br /><code>NONE<\/code><\/td><\/tr><tr><td style=\"vertical-align:top\"><code>MsExchange_DAGWitnessSrv<\/code><\/td><td style=\"vertical-align:top\"> DAG 的 Exchange\n                            见证服务器。这是一个安装了客户端访问服务器 (CAS) 角色的 Exchange 服务器 -\n                            我们建议将这个见证服务器用作单个角色服务器。<br />如果希望该设置自动选择您组织的一个 Exchange\n                            CAS，那么可以使用 “Default”。 <\/td><td style=\"vertical-align:top\"><code>CASSrv01<\/code> 或<br /><code>Default<\/code><\/td><\/tr><tr><td style=\"vertical-align:top\"><code>MsExchange_IMAP4BEEnable<\/code><\/td><td style=\"vertical-align:top\"> 如果此参数设置为 “TURE”，则会为邮箱服务器启用 IMAP4\n                            后端服务。 <\/td><td style=\"vertical-align:top\"><code>TRUE<\/code><\/td><\/tr><tr><td style=\"vertical-align:top\"><code>MsExchange_POP3BEEnable<\/code><\/td><td style=\"vertical-align:top\"> 如果此参数设置为 “TURE”，则会为邮箱服务器启用 POP3\n                            后端服务。 <\/td><td style=\"vertical-align:top\"><code>TRUE<\/code><\/td><\/tr><\/tbody><\/table><h5 id=\"_Table_8._RDS-Exchange-v2013-MBX-DBCopy\">表 8.\n                    RDS-Exchange-v2013-MBX-DBCopy 脚本包参数<\/h5><table border=\"0\" cellpadding=\"0\" cellspacing=\"0\" class=\"ibm-data-table\" summary=\"RDS-Exchange-v2013-MBX-DBCopy script package parameters\"><thead xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"><tr><th style=\"text-align:left; vertical-align:top\"><strong>参数名称<\/strong><\/th><th style=\"text-align:left; vertical-align:top\"><strong>参数描述<\/strong><\/th><th style=\"text-align:left; vertical-align:top\"><strong>示例<\/strong><\/th><\/tr><\/thead><tbody xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"><tr><td style=\"vertical-align:top\"><code>MsExchange_SetupUser<\/code><\/td><td style=\"vertical-align:top\"> 所使用的 Active Directory 的域管理员。\n                            <\/td><td style=\"vertical-align:top\"><code>ibm\\Administrator<\/code><\/td><\/tr><tr><td style=\"vertical-align:top\"><code>MsExchange_SetupUserPwd<\/code><\/td><td style=\"vertical-align:top\"><code>MsExchange_SetupUser<\/code> 密码。 <\/td><td style=\"vertical-align:top\"><code>Zaq12wsx<\/code><\/td><\/tr><tr><td style=\"vertical-align:top\"><code>MsExchange_DBCopySrvList<\/code><\/td><td style=\"vertical-align:top\"> 用逗号 “,” 分隔的 Exchange\n                            邮箱服务器主机名列表，您希望在其中创建之前的脚本包创建的数据库（DB1 和\n                            DB2）的副本。<br />这个列表中指定的服务器必须位于相同的 DAG 和 Active Directory\n                            中。<br />此外，这个列表中指定的服务器必须尚未包含指定的邮箱数据库的副本。所有数据库副本必须位于相同的路径上，即使它们托管在不同服务器上。因此，请确保此列表中的服务器具有相同的驱动器和路径。\n                            <\/td><td style=\"vertical-align:top\"><code>ExchangeSrv01,ExchangeSrv02<\/code><\/td><\/tr><\/tbody><\/table><p><strong>备注：<\/strong>用于 Microsoft Exchange 的操作系统需要加入一个 Active\n                Directory。为此，您需要采用某种手动方法，或者可以使用 Windows OSPreparation\n                脚本包。有关如何使用此脚本包和公开的参数的详细信息，请参阅 <a href=\"http://www.ibm.com/developerworks/cn/cloud/library/cl-ps-aim1306-ipl-msscriptpackage/index.html\">Windows OS Preparation Script Package V1 入门<\/a>。 <\/p><h2 id=\"_Step_3:_Acquiring\">第 3\n                步：满足脚本包的先决条件<\/h2><p>本节将介绍运行该脚本包的先决条件，不会涉及操作系统镜像创建过程的详细信息。您将在 <a href=\"http://www.ibm.com/developerworks/aix/library/au-aix-image-construction/index.html\">IBM Construction and Composition Toolkit<\/a> 中找到构建这些镜像的信息。<\/p><p>表 9 给出了 <code>sharePath<\/code> 参数所公开的目录结构（请参见 <a href=\"#Table_2._RDS-Exchange-v2013-PRQ-install_\">表\n                2<\/a>）。此外，它还提供了需要放在此目录结构中的内容的指南。 <\/p><h5 id=\"N10575\">表 9. 软件包<\/h5><table border=\"0\" cellpadding=\"0\" cellspacing=\"0\" class=\"ibm-data-table\" summary=\"Software packages\"><thead xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"><tr><th style=\"text-align:left; vertical-align:top\"><strong>目录<\/strong><\/th><th style=\"text-align:left; vertical-align:top\"><strong>文件<\/strong><\/th><th style=\"text-align:left; vertical-align:top\"><strong>其他备注<\/strong><\/th><\/tr><\/thead><tbody xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"><tr><td style=\"vertical-align:top\"><code>sharePath\\software\\Exchange\\v2013\\base<\/code><\/td><td style=\"vertical-align:top\"><code>Exchange-x64.exe<\/code><\/td><td style=\"vertical-align:top\"> 这是 Microsoft Exchange Cumulative\n                            Update 1 安装包。<br />参见 <a href=\"#Table_2._RDS-Exchange-v2013-PRQ-install_\">表 2<\/a>\n                            获取 <code>sharePath<\/code> 参数详细信息。 <\/td><\/tr><tr><td style=\"vertical-align:top\"><code>sharePath\\software\\Exchange\\v2013\\base<\/code><\/td><td style=\"vertical-align:top\"><code>UcmaRuntimeSetup.exe<\/code><\/td><td style=\"vertical-align:top\"> 这是您可以下载的 <a href=\"http://download.microsoft.com/download/2/C/4/2C47A5C1-A1F3-4843-B9FE-84C0032C61EC/UcmaRuntimeSetup.exe\">Unified Communications Managed API v4.0 Runtime\n                            安装包<\/a>。<br />参见 <a href=\"#Table_2._RDS-Exchange-v2013-PRQ-install_\">表 2<\/a>\n                            获取 <code>sharePath<\/code> 参数详细信息。 <\/td><\/tr><tr><td style=\"vertical-align:top\"><code>sharePath\\software\\Exchange\\v2013\\base<\/code><\/td><td style=\"vertical-align:top\"><code>FilterPack64bit.exe<\/code><\/td><td style=\"vertical-align:top\"> 这是您可以下载的 <a href=\"http://download.microsoft.com/download/0/A/2/0A28BBFA-CBFA-4C03-A739-30CCA5E21659/FilterPack64bit.exe\">Microsoft Office 2010 64bit Filter Packs 安装包<\/a>。 <br />参见\n                                <a href=\"#Table_2._RDS-Exchange-v2013-PRQ-install_\">表\n                                2<\/a> 获取 <code>sharePath<\/code> 参数详细信息。 <\/td><\/tr><tr><td style=\"vertical-align:top\"><code>sharePath\\software\\Exchange\\v2013\\base<\/code><\/td><td style=\"vertical-align:top\"><code>filterpack2010sp1-kb2460041-x64-fullfile-en-us.exe<\/code><\/td><td style=\"vertical-align:top\"> 这是您可以下载的 <a href=\"http://download.microsoft.com/download/A/A/3/AA345161-18B8-45AE-8DC8-DA6387264CB9/filterpack2010sp1-kb2460041-x64-fullfile-en-us.exe\">Microsoft Office 2010 64bit Service Pack 1 Filter Packs\n                                安装包<\/a>。<br />参见 <a href=\"#Table_2._RDS-Exchange-v2013-PRQ-install_\">表 2<\/a>\n                            获取 <code>sharePath<\/code> 参数详细信息。 <\/td><\/tr><tr><td style=\"vertical-align:top\"><code>sharePath\\software\\java<\/code><\/td><td style=\"vertical-align:top\"><code>jre-6u34-windows-x64.exe<\/code><\/td><td style=\"vertical-align:top\"> 这是您可以从 <a href=\"http://www.oracle.com/technetwork/java/javase/downloads/jre6-downloads-1637595.html\">Java SE Runtime Environment 6 下载页面<\/a> 下载的 JRE。\n                        <\/td><\/tr><\/tbody><\/table><p>在开始部署之前，上面的软件应该已经位于指定的位置上。<\/p><p><strong>备注：<\/strong>在运行此资产之前，Unified Communications Manage API 和上表中指定的两个\n                Microsoft Office Filter Packs 应该<em>尚未<\/em> 安装在机器上。<\/p><p>表 10 给出了操作系统磁盘上用于完成 Microsoft Exchange 初始部署所需的空闲空间。根据您的部署范围，您需要咨询 Microsoft\n                公司以获取相关的大小细节。下面的链接提供了一个 <a href=\"http://gallery.technet.microsoft.com/Exchange-2013-Server-Role-f8a61780\">Exchange 2013 Server Role Requirements Calculator<\/a> 作为您规划的起点。 <\/p><h5 id=\"N1060D\">表 10. 需要的空间<\/h5><table border=\"0\" cellpadding=\"0\" cellspacing=\"0\" class=\"ibm-data-table\" summary=\"Space required\"><thead xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"><tr><th style=\"text-align:left;                         vertical-align:top\"><strong>驱动器/位置<\/strong><\/th><th style=\"text-align:left; vertical-align:top\"><strong>需要的最少空闲空间\n                            <\/strong><\/th><th style=\"text-align:left; vertical-align:top\"><strong>其他备注<\/strong><\/th><\/tr><\/thead><tbody xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"><tr><td style=\"vertical-align:top\"><code>C:\\<\/code><\/td><td style=\"vertical-align:top\"> 10 GB <\/td><td style=\"vertical-align:top\"> 这个位置将包含该安装所需的临时位置。 <\/td><\/tr><tr><td style=\"vertical-align:top\"><code>MsExchange_InstallDir<\/code><\/td><td style=\"vertical-align:top\"> 30 GB <\/td><td style=\"vertical-align:top\"> 包含\n                            <code>MsExchange_InstallDir<\/code> 参数中定义的目录的驱动器上应存在的指定的空闲空间量。\n                        <\/td><\/tr><tr><td style=\"vertical-align:top\"><code>MSExchange_TransLogsFolder<\/code><\/td><td style=\"vertical-align:top\"> 1 GB <\/td><td style=\"vertical-align:top\"> 包含\n                            <code>MSExchange_TransLogsFolder<\/code>\n                            参数中定义的目录的驱动器上应存在的指定的空闲空间量。 <\/td><\/tr><tr><td style=\"vertical-align:top\"><code>MsExchange_DB1Drive<\/code><\/td><td style=\"vertical-align:top\"> 1 GB <\/td><td style=\"vertical-align:top\"> 包含\n                            <code>MsExchange_DB1Drive<\/code>\n                            参数中定义的目录的驱动器上应存在的指定的空闲空间量。所需的空间取决于具体的数据库用途（邮箱大小、每个数据库的邮箱数量，等等）。\n                        <\/td><\/tr><tr><td style=\"vertical-align:top\"><code>MsExchange_DB2Drive<\/code><\/td><td style=\"vertical-align:top\"> 1 GB <\/td><td style=\"vertical-align:top\"> 包含\n                            <code>MsExchange_DB2Drive<\/code>\n                            参数中定义的目录的驱动器上应存在的指定的空闲空间量。所需的空间取决于具体的数据库用途（邮箱大小、每个数据库的邮箱数量，等等）。\n                        <\/td><\/tr><tr><td style=\"vertical-align:top\"><code>MsExchange_DB1LogsDrive<\/code><\/td><td style=\"vertical-align:top\"> 2 GB <\/td><td style=\"vertical-align:top\"> 包含\n                            <code>MsExchange_DB1LogsDrive<\/code>\n                            参数中定义的目录的驱动器上应存在的指定的空闲空间量。所需的空间取决于具体的数据库用途（邮箱大小、每个数据库的邮箱数量，等等）。\n                        <\/td><\/tr><tr><td style=\"vertical-align:top\"><code>MsExchange_DB2LogsDrive<\/code><\/td><td style=\"vertical-align:top\"> 2 GB<br /> 依赖于 Exchange 数据库的具体配置。\n                            <\/td><td style=\"vertical-align:top\"> 包含\n                            <code>MsExchange_DB2LogsDrive<\/code>\n                            参数中定义的目录的驱动器上应存在的指定的空闲空间量。所需的空间取决于具体的数据库用途（邮箱大小、每个数据库的邮箱数量，等等）。\n                        <\/td><\/tr><\/tbody><\/table><p>与您将部署这些脚本包的操作系统部分相关的所有空间先决条件，默认情况下必须构建到来宾操作系统镜像中。您<em>不能<\/em>\n                选择在置备虚拟系统模式时修改此镜像。<\/p><p><strong>备注：<\/strong><\/p><ul class=\"ibm-bullet-list\"><li>用于 Microsoft Exchange 的操作系统需要加入一个 Active\n                    Directory。为此，您需要采用某种手动方法，或者可以使用 Windows OSPreparation\n                    脚本包。有关如何使用此脚本包和公开的参数的详细信息，请参阅 <a href=\"http://www.ibm.com/developerworks/cn/cloud/library/cl-ps-aim1306-ipl-msscriptpackage/index.html\">Windows OS Preparation Script Package V1 入门<\/a>。<\/li><li>在运行此文档中列出的脚本包时，不应在该机器上运行其他任何软件安装或 PowerShell 过程。<\/li><li>Exchange 2013（在 Windows 2012 上）有一个交换错误，该错误是在向 DAG\n                    添加服务器时发生的。因此，在您的环境中运行第一个 RDS-Exchange-v2013-MBX-configure 脚本包之前，您必须登录到\n                    AD 服务器，并向 “Exchange Trusted Subsystems” 分组授予 AD\n                        计算机对象及其后代的写入权限。<em>只需对每个 Active Directory\n                    执行此操作一次，即使您部署了多个邮箱。<\/em>要获得相关的指导，请执行表 11 中的步骤。有关此错误的详细描述，请参阅 <a href=\"http://technet.microsoft.com/en-us/library/ff367878(v=exchg.150).aspx\">Microsoft TechNet<\/a>。<\/li><\/ul><h5 id=\"_Table_11._\">表 11. 为 Active Directory 中的\n                    Exchange Trusted System 提供适当的权限<\/h5><table border=\"0\" cellpadding=\"0\" cellspacing=\"0\" class=\"ibm-data-table\" summary=\"Give proper                 permissions to the Exchange Trusted System in the Active                 Directory\"><thead xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"><tr><th style=\"text-align:left; vertical-align:top\"><strong>步骤<\/strong><\/th><th style=\"text-align:left; vertical-align:top\"><strong>描述<\/strong><\/th><\/tr><\/thead><tbody xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"><tr><td style=\"vertical-align:top\"> 1. <\/td><td style=\"vertical-align:top\"> 登录到 Active Directory 服务器。\n                        <\/td><\/tr><tr><td style=\"vertical-align:top\"> 2. <\/td><td style=\"vertical-align:top\"> 单击 <strong>Server Manager<\/strong>\n                            按钮。 <\/td><\/tr><tr><td style=\"vertical-align:top\"> 3. <\/td><td style=\"vertical-align:top\"> 在新打开的窗口中，从 <strong>Tools<\/strong>\n                            菜单运行 <strong>Active Directory Users and Computers<\/strong>。确保\n                                <strong>Advanced Features<\/strong>\n                                视图已被选中，如下图所示。<br /><img alt=\"\" src=\"/sunshine_new/images/771066161/images/image-table11a.jpg\" width=\"350\" /><\/td><\/tr><tr><td style=\"vertical-align:top\"> 4. <\/td><td style=\"vertical-align:top\"> 右键单击 <strong>Computers<\/strong>\n                            并选择 <strong>Properties<\/strong>。在新打开的窗口中，转到\n                                <strong>Security<\/strong> 选项卡并选择 <strong>Exchange Trusted\n                                Subsystem<\/strong>，然后勾选所有写入权限并单击\n                                <strong>Apply<\/strong>。参见下图作为参考。<br /><img alt=\"\" src=\"/sunshine_new/images/771066161/images/image-table11b.jpg\" width=\"250\" /><\/td><\/tr><tr><td style=\"vertical-align:top\"> 5. <\/td><td style=\"vertical-align:top\"> 单击 <strong>Advance\n                            <\/strong>并选择上一步中创建的 <strong>Exchange Trusted\n                                Sybsystem<\/strong> 写入权限行，然后单击\n                                <strong>Edit<\/strong>。参见下图作为参考。<br /><img alt=\"\" src=\"/sunshine_new/images/771066161/images/image-table11c.jpg\" width=\"350\" /><\/td><\/tr><tr><td style=\"vertical-align:top\"> 6. <\/td><td style=\"vertical-align:top\"> 在新打开的窗口中的 “Applies to:” 字段中，选择\n                                <strong>This object and all descendant\n                                objects<\/strong>，如下图所示。<br /><img alt=\"\" src=\"/sunshine_new/images/771066161/images/image-table11d.jpg\" width=\"350\" /><\/td><\/tr><tr><td style=\"vertical-align:top\"> 7. <\/td><td style=\"vertical-align:top\"> 然后单击 <strong>OK<\/strong>。\n                        <\/td><\/tr><\/tbody><\/table><p><strong>备注<\/strong>：在默认情况下，Exchange 在客户端访问服务器和邮箱服务器上都安装了一个自签名 X.509\n                证书，以验证所有网络通信都已加密。您应该手动将客户端访问服务器上的这个自签名证书替换为一个受您的客户端自动信任的证书（有关的更多信息，请参阅 <a href=\"http://technet.microsoft.com/en-us/library/dd351044%28v=exchg.150%29.aspx\">Microsoft Exchange 数字证书和 SSL<\/a>）。 <\/p><h2 id=\"5.Step4:Deployingthescriptpackagewithinavirtualsystempattern|outline\">第 4 步：将脚本包部署到一个虚拟系统模式中<\/h2><p>本节将介绍创建一个虚拟系统模式并将它部署到您的 IBM Workload Deployer 中的步骤。此外，您将了解检查部署状态的详细信息。 <\/p><h3 id=\"N10732\">准备一个用于部署的虚拟系统模式<\/h3><p>脚本包具有一个使用以下命名约定的 zip 压缩文件格式： <\/p><div class=\"codesection\"><pre class=\"displaycode\">RDS_{<em>ProductName<\/em>}_{<em>ProductVersion<\/em>}_{<em>OneWordDescriptionOfPurpose<\/em>}.zip<\/pre><\/div><p>在某些情况下，当（该脚本包安装和配置的）产品安装在多个平台上时，会在名称中指定该平台，以避免混淆。<\/p><p>在 PureApplication System\n                术语中，这被称为一个<em>脚本包<\/em>。该脚本包需要包含在虚拟系统模式中，该模式最终以一个虚拟系统实例的形式进行部署和管理。<\/p><p>要创建和部署一个脚本包，可执行以下步骤： <\/p><ol type=\"1\"><li>登录到您环境的 IBM Workload Deployer 接口。<\/li><li>要添加您收到的脚本包，可单击（上部工具栏中的） <strong>Catalog<\/strong> &gt; <strong>Script\n                        Packages<\/strong>，然后单击菜单栏中的绿色加号图标。输入要创建的脚本包的名称并按下\n                        <strong>OK<\/strong>，如图 1 和图 2 中所示。 <h5 id=\"N1075E\">图 1. 打开脚本包部分<\/h5><img alt=\"打开脚本包部分\" src=\"/sunshine_new/images/771066161/images/image001.jpg\" width=\"580\" /><h5 id=\"N10768\">图 2. 命名脚本包<\/h5><img alt=\"命名脚本包\" src=\"/sunshine_new/images/771066161/images/image002.jpg\" width=\"536\" /><\/li><li>现在单击 <strong>Script package file<\/strong> 字段右侧的灰色的\n                        <strong>Browse<\/strong>，导入为您提供的脚本包压缩文件。从您的本地文件系统选择该压缩文件，然后单击\n                        <strong>Upload<\/strong> 按钮，如图 3 所示。 <h5 id=\"N1077D\">图 3. 导入一个脚本包压缩文件<\/h5><img alt=\"导入一个脚本包压缩文件\" src=\"/sunshine_new/images/771066161/images/image003.jpg\" width=\"580\" /><\/li><li>在使用该脚本包之前，您需要接受许可协议。为此，请参阅图 4 到图 7 中突出显示的区域。 <h5 id=\"N10789\">图 4. 打开许可窗口<\/h5><img alt=\"打开许可窗口\" src=\"/sunshine_new/images/771066161/images/image004.jpg\" width=\"580\" /><h5 id=\"N10793\">图 5. 列出许可内容<\/h5><img alt=\"列出许可内容\" src=\"/sunshine_new/images/771066161/images/image005.jpg\" width=\"580\" /><h5 id=\"N1079D\">图 6. 接受许可<\/h5><img alt=\"接受许可\" src=\"/sunshine_new/images/771066161/images/image006.jpg\" width=\"250\" /><h5 id=\"N107A7\">图 7. 完成许可接受过程<\/h5><img alt=\"完成许可接受过程\" src=\"/sunshine_new/images/771066161/images/image007.jpg\" width=\"250\" /><\/li><li>在导入您的脚本包之后（仍在 Script Package 视图中），就可以选择何时执行这个脚本包（参见 <a href=\"#_Figure_8._Execute\">图 8<\/a>）。<strong>Execute<\/strong>\n                    字段需要设置为表 12 中所示的两个值之一。<\/li><\/ol><h5 id=\"N107BF\">表 12. 脚本包执行设置<\/h5><table border=\"0\" cellpadding=\"0\" cellspacing=\"0\" class=\"ibm-data-table\" summary=\"Script Package Execution settings\"><thead xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"><tr><th style=\"text-align:left; vertical-align:top\"><strong>值<\/strong><\/th><th style=\"text-align:left; vertical-align:top\"><strong>选择时机<\/strong><\/th><\/tr><\/thead><tbody xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"><tr><td style=\"vertical-align:top\"><strong>at virtual system\n                                creation<\/strong><\/td><td style=\"vertical-align:top\">\n                            在将安装这个脚本包的操作系统部分（操作系统镜像）满足 <a href=\"#_Step_2:_Identifying\">第 2\n                                步：确定脚本包参数<\/a> 和 <a href=\"#_Step_3:_Acquiring\">第 3\n                                步：满足脚本包的先决条件<\/a>\n                            中描述的所有先决条件，并且您想要的拓扑结构（例如一个外部数据库）中包含所有外部依赖关系时，选择此选项。 <\/td><\/tr><tr><td style=\"vertical-align:top\"><strong>when I initiate\n                            it<\/strong><\/td><td style=\"vertical-align:top\">\n                            在先决条件未得到满足或外部依赖关系需要首先执行某项操作时，选择此选项。 <\/td><\/tr><\/tbody><\/table><ol start=\"6\"><li>如果您已经在构建虚拟系统模式后选择 <strong>when I initiate it<\/strong>（参见图 8）并单击\n                        <strong>Deploy<\/strong>（参见 <a href=\"#_Figure_13._Deploy\">图\n                    13<\/a>），这会创建您的虚拟主机并安装操作系统。但是，此脚本包的执行会延迟到手动调用此选项之后。图 8 显示了本节中讨论的脚本包选项。 <h5 id=\"_Figure_8._Execute\">图 8.\n                            一个脚本包的执行选项<\/h5><img alt=\"一个脚本包的执行选项\" src=\"/sunshine_new/images/771066161/images/image008.jpg\" width=\"549\" /><\/li><li>对于每个脚本包，您都会看到 <strong>Execute now<\/strong> 按钮，您需要单击它并按照屏幕上的说明来执行脚本包。<a href=\"#_Figure_15._Information\">图 15<\/a> 列出了虚拟系统实例的 Script Package\n                    部分，可以在其中找到 <strong>Execute now<\/strong> 按钮（在参考图中，脚本包尚未执行）。<\/li><li>要创建一个虚拟系统模式，可单击（上部工具栏上的）<strong>Patterns<\/strong> &gt; <strong>Virtual\n                        Systems<\/strong>。然后单击菜单栏上的绿色加号图标，为虚拟系统模式提供一个名称和描述，然后按下\n                        <strong>OK<\/strong>，如图 9 和图 10 所示。 <h5 id=\"fig9\">图 9. 选择一种虚拟系统模式<\/h5><img alt=\"选择一种虚拟系统模式\" src=\"/sunshine_new/images/771066161/images/image009.jpg\" width=\"580\" /><h5 id=\"N10820\">图 10. 创建一种虚拟系统模式<\/h5><img alt=\"创建一种虚拟系统模式\" src=\"/sunshine_new/images/771066161/images/image010.jpg\" width=\"491\" /><\/li><li>要创作或编排新创建的虚拟系统模式，可单击工具栏右上侧的 <strong>Edit<\/strong> 按钮，如图 11 所示。 <h5 id=\"N1082F\">图 11. 您的虚拟系统模式的编辑模式<\/h5><img alt=\"您的虚拟系统模式的编辑模式\" src=\"/sunshine_new/images/771066161/images/image011.jpg\" width=\"580\" /><\/li><li>在新屏幕中，从面板将各个部件拖放到编辑区域的左侧。您需要添加一个 <strong>Windows Server 2008 R2 64\n                        位<\/strong> 镜像和前几步中创建的脚本包。完成这些操作后，单击 <strong>Done\n                    Editing<\/strong>，如图 12 所示。 <h5 id=\"N10841\">图 12. 编辑您的虚拟系统模式<\/h5><img alt=\"编辑您的虚拟系统模式\" src=\"/sunshine_new/images/771066161/images/image012.jpg\" width=\"580\" /><p>您已经创建了一个虚拟系统模式，您可以在环境中将它部署任意次。 <\/p><\/li><li>接下来，部署新的虚拟系统模式。在 IBM Workload Deployer 控制台中，转到\n                        <strong>Patterns<\/strong> &gt; <strong>Virtual\n                    Systems<\/strong>。单击之前创建的系统模式，然后在工具栏右上侧，单击 <strong>Deploy<\/strong>\n                    按钮，如图 13 所示。 <h5 id=\"_Figure_13._Deploy\">图 13.\n                            部署您的虚拟系统模式<\/h5><img alt=\"部署您的虚拟系统模式\" src=\"/sunshine_new/images/771066161/images/image013.jpg\" width=\"580\" /><\/li><li>单击 <strong>Deploy<\/strong> 按钮后，需要使用以下信息： <ol class=\"ibm-alpha-list\" type=\"a\"><li><strong>Virtual System Name<\/strong>：这是虚拟系统模式实例的名称。<\/li><li><strong>Environment<\/strong>：您的 IBM Workload Deployer\n                            管理员应该提供必要的信息。<\/li><li><strong>OS Part parameters<\/strong>：这是您提供需要的操作系统级参数的值的地方。<\/li><li><strong>Script package parameters<\/strong>（可在 OS Part\n                            子页面下找到）：您将在这篇文章中找到有关的详细信息。<\/li><\/ol><\/li><\/ol><p>请注意，惟一的必填字段是带星号 (<strong>*<\/strong>) 的字段和 <strong>Instance\n                Name<\/strong>。<\/p><p>提供字段 <a href=\"#_Step_2:_Identifying\">第 2 步：确定脚本包参数<\/a> 中给出的字段值后，单击\n                    <strong>OK<\/strong> 按钮。<\/p><p>您的虚拟系统模式现在正在部署。在以下第一个或或两个操作都完成时，部署就完成了：<\/p><ul class=\"ibm-bullet-list\"><li>部署的虚拟机的操作系统已安装，虚拟机现在已启动。<\/li><li>您部署的虚拟系统模式中的脚本包已成功执行。<\/li><\/ul><p>上面的后一个操作中的脚本包的执行受到为添加到特定虚拟系统模式的每个脚本包的 “Execute Now” 选项设置的值限制，该值已在本节前面介绍过。 <\/p><h2 id=\"6.Step5:Checkingthestatusofyourdeployment|outline\">第 5 步：检查您的部署的状态<\/h2><ol type=\"1\"><li>要检查您的虚拟系统模式部署的状态，可单击位于上部的蓝色工具栏上的 <strong>Instances<\/strong> &gt;\n                        <strong>Virtual System <\/strong>，如图 14 所示。 <h5 id=\"N108A2\">图 14. 检查虚拟系统模式部署的状态<\/h5><img alt=\"检查虚拟系统模式部署的状态\" src=\"/sunshine_new/images/771066161/images/image014.jpg\" width=\"417\" /><\/li><li>在新打开的窗口中，您将在左侧方框找到您创建的虚拟系统模式。单击它。如果有太多的实例，那么您可以使用搜索过滤器（可在左侧方框顶部找到）并键入一些字符。这是您之前创建的虚拟系统模式实例名称的一部分。<\/li><li>此刻，在页面右侧方框中，将会显示您的部署的详细信息。但是，在此阶段，以下两部分信息最为重要： <ul class=\"ibm-bullet-list\"><li><strong>Current\n                            status<\/strong>：显示当前部署执行的操作。例如，启动虚拟镜像，部署模式，注册虚拟镜像，等等。<\/li><li><strong>Virtual\n                            machines<\/strong>：提供虚拟机的当前状态、它的硬件和网络细节信息，以及部署过程中目前已部署的或可部署的脚本包的状态。网络细节提供了虚拟机的\n                            IP 地址和主机名。图 15 提供了一个示例，包含脚本包部署中最有趣的区域。<\/li><\/ul><p>对于脚本包运行，图 16 描述了这样一种情形，其中脚本包已在虚拟系统部署时执行，而图 15 显示了一个设置为仅 “when I\n                        initiate it（在我启动它时）” 执行的脚本包的示例。这一事实可通过 (none)\n                        属性进行确认，该属性表明脚本包尚未执行。因此，没有这个特定脚本包的日志。 <\/p><h5 id=\"_Figure_15._Information\">图 15. 选择\n                            “when I initiate it” 执行选项时的脚本包状态<\/h5><img alt=\"有关 IT 和脚本包状态的信息\" src=\"/sunshine_new/images/771066161/images/image015.jpg\" width=\"732\" /><h5 id=\"_Figure_16._Information\">图 16. 有关 IT\n                            和脚本包状态的信息<\/h5><img alt=\"有关 IT 和脚本包状态的信息\" src=\"/sunshine_new/images/771066161/images/image016.jpg\" width=\"580\" /><\/li><li>要连接到部署的虚拟机，可使用 Windows 远程桌面或 Linux/Unix ssh 客户端与图 16 中列出的 IP\n                    建立连接。<\/li><li>在图 16 中，显示了每个脚本的日志文件。<code>remote_std_out.log<\/code>\n                    列出了在部署期间已经完成的脚本包，包含错误和正常的脚本包运行的细节。在成功的部署中，您将在末尾看到以下行：\n                        <div class=\"codesection\"><pre class=\"displaycode\">                    SPiN ended: successfully :-)\n===========================End of SPIN LOG =========================\nINFO:Java(TM) 6 Update 34 (64-bit) is installed\nINFO:Uninstalling: Java(TM) 6 Update 34 (64-bit) Version: 6.0.340\nINFO:Successfull uninstall<\/pre><\/div><\/li><\/ol><p>在部署末尾检查 <code>remote_std_out.log<\/code> 文件，可为成功的执行提供最新的保障水平。 <\/p><h2 id=\"7.Conclusion|outline\">结束语<\/h2><p>本文介绍了如何使用一个 IBM Pattern Lab 自动化资产来部署 Microsoft Exchange\n                服务器。文中定义了所使用的拓扑结构，以及这个自动化资产的需求和功能。 <\/p><CMA ID: 971709><Site ID: 10><XSLT stylesheet used to transform this file: dw-document-html-7.0.xsl>\r\n\r\n\r\n<\/div>\r\n<\/div>\r\n","createTime":"2014-05-22 00:00:00","deployTime":"2014-05-22 00:00:00","id":0,"intro":"本指南帮助您开始使用一系列脚本包对 Microsoft Exchange Server v2013 CU1 执行典型的安装，并在 IBM PureApplication System 中定义这种自动化需求。","keyword":"","recommend":false,"source":"http://www.ibm.com/developerworks/cn/cloud/library/cl-ps-aim1311-ipl-msexchange/index.html","title":"在 PureApplication System 中进行脚本包部署的 IBM Pattern Lab\n                快速入门指南: 安装 Microsoft Exchange Server v2013 CU1","typeId":0,"updateTime":"2014-05-22 00:00:00"}
{"author":"","clickNumber":0,"content":"\r\n<div class=\"ibm-columns\">\r\n<div class=\"ibm-col-1-1\">\r\n\r\n<p>去年笔者有幸经历了一个新产品的开发，在开发过程中，我们逐渐迁移到 RTC（Rational Team Concert）进行软件生命周期的管理，在使用 RTC Build Toolkit 构建产品时，阅读了很多资料，花了很长时间，走了很多弯路。后来其他项目组在迁移到 RTC 过程中也存在同样的问题，为了避免大家走同样多的弯路，我觉得有必要将自己的一些经验总结一下，与大家分享。希望本文能成为一个手册，让没有经验的同事和读者也能轻松上手。<\/p><h2 id=\"2.构建系统的基本原理 |outline\">构建系统的基本原理<\/h2><p>有好几个同事就使用 RTC 构建项目的事向我寻求帮助，一上来我就给他们解释构建引擎、构建定义等。讲完之后，他们还是一头雾水，我觉得我一定有什么地方做错了。想来想去，终于发现了这其中的原因：他们都是临危受命，之前没有一点构建项目的经验，对构建系统的基本原理也是一无所知。大概大家都认为程序员是万能的吧，只要跟软件沾边的，什么都会，什么都能学会。当然只要肯花时间看文档，这也不是难事，但是每个人都将宝贵的时间浪费在这上面，实在不值。那我们就一起来看看构建系统是怎么工作的吧！<\/p><p>构建系统的原理很简单，就是用一台构建服务器运行您的构建脚本。<\/p><p>当然事情也没有这么简单，但这是构建系统的核心，其他都是为这一核心服务。让我们从最简单的入手，程序员是如何在他们的机器上运行构建脚本的？以 RTC\n    为例，程序员先要创建工作区，把代码从 RTC 服务器上下载下来，然后在本地运行构建脚本。对于 Java 的项目，大多使用 Ant\n    脚本，脚本里做的事也无非是获取编译代码需要的第三方库、编译代码、单元测试、打包成 jar 等。如果在本地运行一切正常，那现在的工作就是怎么把这些工作放在构建服务器上执行了。但是，没有人二十四小时看着构建服务器。因此，原来人工做的事，必须要使用某种自动化的方式来完成。比如，怎么把代码下载下来？谁来为您运行构建脚本？是否可以为构建指定日程？比如每天构建一次，或者像敏捷开发推荐的那样，提交新的代码就启动新的构建？这些就是构建服务器要做的事。怎么做这些事呢？显然需要一个软件。既然我们使用了 RTC 进行项目和代码的管理，选择 RTC Build Toolkit 就是理所当然的。常言说，A picture is worth a thousand words，我们就用一幅图描述一下 RTC 的构建系统：<\/p><h5 id=\"2.0.1.图 1.RTC 构建系统结构 |outline\">图 1.\n    RTC 构建系统结构<\/h5><img alt=\"RTC 构建系统结构\" src=\"/sunshine_new/images/负1617275218/image003.jpg\" width=\"582\" /><p>从原理上来看，构建服务器就是安装了一个构建引擎，提供了一些服务，来自动化的帮助程序员构建项目。<\/p><h2 id=\"3.准备工作 |outline\">准备工作<\/h2><p>清楚了构建系统的基本原理之后，就该着手开始准备构建项目工作了。<\/p><ol type=\"1\"><li>申请一台构建服务器，并在上面安装 RTC Build Toolkit。<\/li><\/ol><p>第一次接触 RTC 的人，容易将 RTC 服务器和构建服务器混为一谈。它们是单独的服务器，起码从逻辑上是独立的（这里我们以一台 Windows 服务器为例）。<\/p><p>RTC 只发布了一个完整的安装包，安装 RTC Build Toolkit 时，请务必确认选择了正确的组件，如下图所示。另外为了方便管理，建议也在构建服务器上安装 RTC 客户端。<\/p><h5 id=\"3.0.1.图 2.安装 RTCBuildToolkit|outline\">图 2. 安装 RTC\n    Build Toolkit<\/h5><img alt=\"安装 RTC Build Toolkit\" src=\"/sunshine_new/images/负1617275218/image005.jpg\" width=\"582\" /><ol type=\"1\"><li>申请一个新的 RTC 帐号用于构建，并为其申请访问 RTC 项目和代码的权限。\n<p>这里要避免使用开发人员的 RTC 帐号，首先这不安全，其次很麻烦。由于在服务器上构建时会装载代码，导致两边工作空间上的不同步。而且很多公司都对帐号的密码期限有限制，会定期更改密码。申请一个专用的构建帐号，就可以一劳永逸的解决这些问题。<\/p><\/li><li>使用构建帐号创建一个新的工作空间用于构建。\n<p>这个构建空间会在后续创建构建定义时使用，这里要明确的是这里的工作空间指的是 RTC 服务器上的工作空间，当启动构建时，构建引擎会自动从该工作空间上将代码下载到构建服务器，然后调用构建脚本执行构建任务。<\/p><\/li><\/ol><p>完成这些任务后，就可以进行下一步，创建构建引擎了。<\/p><h2 id=\"4.创建构建引擎 |outline\">创建构建引擎<\/h2><p>如果是项目中第一次使用 RTC 构建，那么先得定义一个构建引擎。在 RTC 客户端中，切换到 Jazz Administration 视图，在左侧的栏目里选择 Team Artifacts，打开工程，在 Builds 目录下可以看到一个 Build Engine 文件夹，右键单击，选择创建新的构建定义：<\/p><h5 id=\"4.0.1.图 3.定义构建引擎 |outline\">图 3.\n    定义构建引擎<\/h5><img alt=\"定义构建引擎\" src=\"/sunshine_new/images/负1617275218/image007.jpg\" width=\"368\" /><h5 id=\"4.0.3.图 4.选择项目 |outline\">图 4.\n    选择项目<\/h5><img alt=\"选择项目\" src=\"/sunshine_new/images/负1617275218/image009.jpg\" width=\"508\" /><h5 id=\"4.0.4.图 5.选择构建引擎类型 |outline\">图 5.\n    选择构建引擎类型<\/h5><img alt=\"选择构建引擎类型\" src=\"/sunshine_new/images/负1617275218/image011.jpg\" width=\"508\" /><p>这里有几点需要注意：首先，要选择正确的项目区域，构建引擎是跟项目相关的；其次，填写引擎 ID，这个 ID 作为构建引擎的唯一标志，在创建构建定义时需要，确保到时选择的是正确的 ID。引擎类型选最基本的 Jazz Build Engine。<\/p><h2 id=\"5.定义构建 |outline\">定义构建<\/h2><p>构建引擎定义好之后，我们就可以基于该引擎定义构建了。构建的定义包含以下几大部分：<\/p><ol type=\"1\"><li>基本信息\n<p>这些信息包含构建的 ID、项目区域、对该构建定义的一个描述、以及支持该构建的构建引擎，即上面创建的构建引擎。<\/p><\/li><li>构建日程\n<p>这里可以控制构建的频率，可以选择每天的固定时间、或者按时间间隔进行构建。<\/p><\/li><li>邮件通知\n<p>构建完成后会发送邮件通知相关人员，可以在这个页面配置通知哪些人、可以选择总是发送邮件或者只在构建失败时发送邮件、还可以选择只通知提交代码的人或请求构建的人。<\/p><\/li><li>代码管理\n<p>这是配置的核心之一。这里的配置了构建的代码从哪里装载，前面我们不是拿构建帐号创建了一个专用工作空间吗？我们就选择此空间作为构建空间。还要配置将这些代码下载到构建服务器的哪个目录底下，比如您在构建服务器上创建了一个文件夹：Sample_Build。当开始构建时，构建空间会先从代码流上抓取最新的代码，然后构建引擎负责把构建空间上的代码下载到构建服务器的 Sample_Build 目录。这里有很多有用的选项，常用的有：是否在下载代码前删除文件夹里的内容，一般选择是，保证构建是干净的；是否选择构建时不包括一些组件，有些项目的代码是以组件的形式组织起来的，有一些组件可能对于最终发布的产品并没有意义，比如测试人员的一些测试用例也放在 RTC 的代码库的一个组件里进行管理，但这些测试用例是不会被作为产品的一部分发布出去的，构建时，就可以选择将这些组件排除在外，提高构建的速度；是否在装载前接受最新的代码变化，一般选是，这个选项还有一个好处是可以对构建空间创建一个快照，有了快照，任何时候都可以将代码恢复到快照当时记录的状态，这对于日后建立分支，实现多个分支并行开发是极为有用的；是否只在代码有变更时才启动构建，一般选是，没有代码变更的构建有什么意义？<\/p><\/li><li>Ant 配置\n<p>这是另外一个配置核心，这里要选定 Ant 脚本的路径，这个路径是指代码已经下载到构建服务器的 Sample_Build 目录下了，指的是这个目录下的路径。另外还可以选择执行哪些 Ant 的 target，可以指定多个，以逗号分开。这是一个非常有用的特性，有时候程序员希望在自己的机器上跑一个简单的构建，但在构建服务器上需要跑一个完整的构建，这个时候就可以把程序员希望跑的 target 作为整个脚本的默认 target，哪些额外的 target 就可以在这里指定。后面会介绍该特性在我们项目中的一个应用。<\/p><\/li><li>发布单元测试\n<p>单元测试跑完后，管理层总想看到一个关于单元测试的报告，没问题，RTC 考虑到了经理们的这些爱好，指定好生成的单元测试结果的目录后，系统就会将单元测试作为整个构建报告的一部分发布出来。<\/p><\/li><\/ol><h2 id=\"6.启动构建引擎 |outline\">启动构建引擎<\/h2><p>现在一切配置就绪，让我么发动引擎，开始我们的第一次构建吧！<\/p><p>假设我们把 RTC Build Toolkit 安装在如下目录：<\/p><div class=\"codesection\"><pre class=\"displaycode\">C:\\Program Files (x86)\\IBM\\TeamConcertBuild\\buildsystem\\buildengine\\eclipse<\/pre><\/div><p>为了安全考虑，我们要做的第一件事是为构建帐号生成一个密码文件，密码文件就是对构建帐号的密码进行加密，虽然 RTC 支持直接在命令行里输入明文的密码，但将构建帐号的密码暴露在外总不是一件好事。在命令行里输入：<\/p><div class=\"codesection\"><pre class=\"displaycode\">jbe -vm \"C:\\Program Files\\IBM\\Java60\\bin\\java\" -createPasswordFile buildpass<\/pre><\/div><p>系统会提示输入密码，此时输入构建帐号的密码，会生成一个 buildpass 文件，里面保存着加密后的密码。<\/p><p>然后输入如下命令启动您的构建引擎（根据自己的情况替换掉那些带$符号的变量）：<\/p><div class=\"codesection\"><pre class=\"displaycode\">jbe -vm \"C:\\Program Files\\IBM\\Java60\\bin\\java\" -repository $the_address_of_rtc_server\n \\-userId $build_account -passwordFile $buildpass -engineId \"$engine_id\"<\/pre><\/div><p>如果不出什么意外，构建引擎就启动成功了，您可以在 RTC 客户端手动发起一个构建请求。<\/p><h2 id=\"7.一些经验 |outline\">一些经验<\/h2><p>作者也是从零开始使用 RTC，这个过程中也碰到一些问题，有的解决了，有的没解决。现在将个人觉得一些有用的经验和大家分享，如果您碰巧也遇到过类似的问题，或者需要类似的功能，希望以下的内容对您有用：<\/p><ol type=\"1\"><li>创建 commit-build\n<p>喜欢敏捷开发的人可能有这样的需求，那就是希望每次提交，系统都能自动构建一次，保证他们的代码没有出错。可是 RTC 只提供了按时间点和时间间隔自动启动构建的功能，怎么办？您觉得敏捷开发圈内常用的 CruiseControle 上的 commit-build 是如何做到的？很简单，只不过是把每次构建的时间间隔缩短了。同理，我们创建一个 commit-build，将自动构建的时间间隔调整为 30 分钟左右，这样每隔 30 分钟，构建引擎就会检查代码是否有变更，如果没有，等 30 分钟再检查，如果有，立即触发构建，这样大家就觉得自己的每次提交，都引发了自动构建。<\/p><p>有些项目，完整的构建一次要花很长时间，这并不是开发人员乐于见到的。因此一般可以定义两个构建，一个完整的构建，一个 commit-build 构建，后者可以选择只执行构建脚本上特定的任务，比如仅执行编译和单元测试，这样的一个构建往往只用花很少的时间就可以完成。<\/p><\/li><li>如何让一个组件里的代码变更不触发构建？\n<p>RTC 里的代码是按组件管理的，有时候人们会把测试人员的一些测试用例和自动化脚本也作为一个组件放到整个项目中。我们并不希望测试人员的代码变更触发构建，这时需要编辑用于构建的工作空间，编辑该工作空间的 Flow Targets，让其只包含构建关心的组件。<\/p><\/li><li>如何自动启动构建引擎？\n<p>日常开发中，构建服务器经常会由于一些原因被重启，比如安装系统更新，断电等。每次重启后都要登录上去手动启动构建引擎，长期如此是一件很麻烦的事。更糟的是碰到管理员休假，可能就不只是麻烦的事了，整个项目的进度可能都会受到影响。最好是服务器每次重启后都能自动启动构建引擎。网上有多种方法，我们在项目中使用的方法是，将 RTC 构建做成一项 Windows 服务，具体操作方法，请参考文末的链接。<\/p><\/li><li>如何定制 RTC 构建发出的电子邮件，让其包含构建版本号？\n<p>一般来说，RTC 构建发出的电子邮件内容是不能定制的，但可以通过运行一个 RTC 提供的 Ant 插件，来更新构建的标签，此时可以将构建版本号作为参数传进来。具体脚本如下：<\/p><h5 id=\"N10114\">清单 1. 更新构建标签的 Ant 脚本<\/h5><div class=\"codesection\"><pre class=\"displaycode\">&lt;target name=\"updateLabel\"&gt;\n    &lt;taskdef name=\"buildResultPublisher\" \n     classname=\"com.ibm.team.build.ant.task.BuildResultPublisherTask\" /&gt;\n    &lt;buildResultPublisher label=\"${project.version}.${build.number}-${buildLabel}\"\n\t\t\t\tverbose=\"true\" buildResultUUID=\"${buildResultUUID}\"\nrepositoryAddress=\"${repositoryAddress}\"\\\n    userId=\"${userId}\" passwordFile=\"Path_TO_The_Password_FILE\"/&gt;\n&lt;/target&gt;<\/pre><\/div><\/li><\/ol><h2 id=\"8.结束语 |outline\">结束语<\/h2><p>RTC 的功能非常强大，难能可贵的是它把软件生命周期管理的各个部分集成起来，为开发人员提供一站式服务。可能刚开始使用起来有点困难，但是用熟了就会感觉很顺手。这时在回头看看原来通过各种配置各种产品的管理方式，就会觉得 RTC 是物超所值的。本文总结了作者在使用 RTC 构建项目时的一些经验，希望能对初次使用 RTC 的朋友们有所帮助。<\/p><CMA ID: 971892><Site ID: 10><XSLT stylesheet used to transform this file: dw-document-html-7.0.xsl>\r\n\r\n\r\n<\/div>\r\n<\/div>\r\n","createTime":"2014-05-22 00:00:00","deployTime":"2014-05-22 00:00:00","id":0,"intro":"本文介绍了如何使用 RTC Build Toolkit 搭建项目的构建引擎，并将作者在这个过程中的经验和教训与大家共享。","keyword":"","recommend":false,"source":"http://www.ibm.com/developerworks/cn/rational/1505_wangqf_rtcbuild/index.html","title":"从零开始使用 RTC 构建项目","typeId":0,"updateTime":"2014-05-22 00:00:00"}
{"author":"","clickNumber":0,"content":"\r\n<div class=\"ibm-columns\">\r\n<div class=\"ibm-col-1-1\">\r\n\r\n<p>从某种角度看，自动化测试同样可以看成是一个独立的项目，需要考虑的问题很多，包括但不限于前期调研、需求分析、框架设计、版本管理、自动构建、自动部署、脚本维护以及和产品构建过程集成实现持续集成等。由于篇幅限制，本文仅讨论和脚本开发及使用过程相关的版本管理、自动构建及自动部署等技术问题，至于如何和产品构建过程集成及如何做到利用自动化技术实现持续集成，我们将在另外一篇文章里面讨论。<\/p><p>在敏捷开发项目中，人们对自动化测试提出了更高的要求，面对日益紧迫的交付需求和日渐庞大的自动化开发规模，如何能够快速构建并部署脚本是亟需解决的问题。根据我们对多个项目的观察和实践， 发现大多项目都不同程度的存在下述问题之一：<\/p><ul class=\"ibm-bullet-list\"><li>自动化测试代码纳入版本控制以后，如何在测试环境中方便快捷的获取测试代码并实现自动构建和部署？<\/li><li>Maven 作为时下广受欢迎的构建工具，被广泛应用到多个开发项目，但是在自动化测试项目中却使用不多，尤其对于一些已经运作起来的的项目，如何在不改动原有项目结构的情况下，有效利用 Maven 的构建功能轻松完成自动化测试脚本的编译和运行？<\/li><li>面对日益增加的自动化测试脚本，测试团队如何在不了解自动化测试框架和代码结构的情况下，方便的修改运行参数并提交自动运行任务，等待结果产生？<\/li><\/ul><p>针对上述问题，本文作者结合项目实践经验，从敏捷开发的角度分析并给出解决方案，希望能够起到抛砖引玉的效果。<\/p><p><strong>自动构建及部署工具介绍<\/strong><\/p><p>如果把自动化测试作为一个独立的开发项目看待，我们可以借鉴产品开发的经验，使用相关工具实现我们的持续交付，于是在产品开发项目中备受欢迎的 Rational Team Concert 和 Maven 等工具成为自动化测试项目的新宠，本文就是基于这些主流工具来分析解决上述问题。我们将使用 Rational Team Concert 作为源码管理工具，Maven 作为编译工具，TestNG 实现测试参数的可定制化和易配置性，STAF 进行任务的拼装及 Lotus Automator 作为脚本分发和结果收集的 Web 平台。下面对这几款工具做一下简要介绍：<\/p><ul class=\"ibm-bullet-list\"><li>Rational Team Concert(以下简称 RTC)是 Jazz 家族中的一款重要产品，通过它可以管理测试资产，实现项目构建及进行源代码控制等，成为测试和开发团队的新宠。 自动化测试的代码通过 RTC 进行管理，可以方便的和界面变动产生的工作项关联，便于代码更新及维护。除了方便易用的图形化的客户端，RTC 还提供了命令行控制接口，允许用户灵活地通过脚本进行主要的版本控制操作。<\/li><li>Maven 是 Apache 组织下的一个跨平台的项目构建工具，可以通过集中的配置信息片段完成对项目的管理。Maven 的主要目标就是允许开发人员在短时间内理解开发工作的完整状态， 它定义了一个抽象的生命周期，在不同的生命周期阶段，使用不同的已实现的插件来完成相应的实际工作，这种设计方式既避免了配置文件极大/代码的重复，又极大的实现了功能的复用。<\/li><li>STAF（Software Testing Automation Framework）是开源、跨平台的自动化测试框架，它基于可重用的组件，即一组专门用于构建自动化解决方案的内置服务，来构建自动化测试，它采用点对点的实现机制，所有机器都是对等的，没有客户端和服务器的区分。STAX（STAF Execution Engine）本身是一种特殊的 STAF 外部服务，它也是 STAF 的执行引擎，支持通过 XML 格式调用其他 STAF 服务。<\/li><li>Lotus Automator （以下简称 LA）是一款基于 STAF/STAX 的具有广泛平台支持的自动化测试工具，利用 LA 可以通过 Web 浏览器在远程机器上提交自动化测试任务。<\/li><li>TestNG 是 Test Next Generation 的简称，是根据 JUnit 和 NUnit 思想而构建的一套测试框架。TestNG 引入了一些新的功能使它变得更加强大和容易使用，比如支持注释，灵活的测试配置，参数支持，强大的执行模型等。<\/li><\/ul><h2 id=\"2.解决方案及实现流程 |outline\">解决方案及实现流程<\/h2><p>我们对前面提到的问题进行分析，可以将问题分成两个方面：第一，如何实现脚本的自动更新与编译；第二，如何自动修改测试参数并启动自动化测试脚本。下面我们将对这两个方面逐一进行解决。<\/p><h3 id=\"N1007D\">脚本的自动更新与编译<\/h3><p>图 1 简单再现了某测试团队 LA 管理员更新脚本的工作场景。LA 管理员为了保证 LA 服务器上自动化测试脚本的及时更新，需要经常通过 RTC 客户端连接到 RTC 服务器，手动获取最新代码并完成编译后，打包上传到 LA 服务器上。随着测试需求的增加，在脚本开发阶段和产品趋于稳定之前，每天会有大量的代码更新，LA 管理员每天都要花费大量时间在更新代码这一重复性工作上。<\/p><h5 id=\"N10085\">图 1. 管理员手动更新部署测试代码<\/h5><img alt=\"管理员手动更新部署测试代码\" src=\"/sunshine_new/images/负1371877469/image003.gif\" width=\"576\" /><p>如何减轻 LA 管理员的负担，解决测试工作中的这一瓶颈成为我们首要考虑的问题。 由于我们使用 RTC 进行版本管理，而 RTC 命令行控制接口允许用户通过脚本对源码实现灵活的版本控制，所以 RTC 命令行控制接口成为我们实现灵活自动的源码更新的主要工具。在安装了 RTC 客户端的机器上，您可以在&lt;Team Concert installed dir&gt;\\scmtools\\eclipse 下面找到命令行控制工具 scm 及轻量级命令行工具 lscm。下面仅列出我们需要的命令说明，更多的命令请参考 RTC 帮助文档。<\/p><ol type=\"1\"><li><strong>scm login C 登录指定 Jazz 服务器并保存登录信息<\/strong><\/li><\/ol><p><a href=\"#N10099\" class=\"ibm-popup-link\" onclick=\"ibmweb.overlay.show('N10099',this);return false;\">点击查看代码清单<\/a><\/p><div id=\"N10099\" class=\"dw-sidefile-overlay ibm-common-overlay ibm-overlay-alt-two\"><div class=\"ibm-head\"><p><a href=\"#close\" class=\"ibm-common-overlay-close\">关闭 [x]<\/a><\/p><\/div><div class=\"ibm-body\"><div class=\"ibm-main\"><div class=\"ibm-container ibm-alternate\"><div class=\"ibm-container-body\"><div class=\"codesection\"><pre class=\"displaycode no-auto-overflow\"><strong>语法：<\/strong>scm login [ -r  | --repository-uri ] repository URI [ -u  | --username ] user ID in repository [ -P  |  --password ] password for user ID in repository [ -n  |  --nickname ] nickname for this   combination of user ID and repository\n<strong>示例：<\/strong>scm login -r https://jazzhost:8080/jazz  -n jazznick -u username  -P password\n说明： 在此示例中我们为 repository 创建了昵称 jazznick，此昵称将会在下面的示例中被多次使用。<\/pre><\/div><\/div><\/div><\/div><\/div><div class=\"ibm-footer\"><><\/div><\/div><ol type=\"1\"><li><strong>scm repair C 修复存储库中被损坏或者不同步的 sandbox<\/strong><\/li><\/ol><div class=\"codesection\"><pre class=\"displaycode\"><strong>语法：<\/strong>scm repair [ -r   --repository-uri ] repository URI or nickname { [ -d  |  --dir ] workspace-path }\n<strong>示例：<\/strong>scm repair -r jazznick   -d \"C:\\Users\\IBM_ADMIN\\IBM\\rationalsdp\\workspace\"<\/pre><\/div><ol type=\"1\"><li><strong>scm load C 装载存储库工作空间里的组件到本地工作空间<\/strong><\/li><\/ol><p><a href=\"#N100B5\" class=\"ibm-popup-link\" onclick=\"ibmweb.overlay.show('N100B5',this);return false;\">点击查看代码清单<\/a><\/p><div id=\"N100B5\" class=\"dw-sidefile-overlay ibm-common-overlay ibm-overlay-alt-two\"><div class=\"ibm-head\"><p><a href=\"#close\" class=\"ibm-common-overlay-close\">关闭 [x]<\/a><\/p><\/div><div class=\"ibm-body\"><div class=\"ibm-main\"><div class=\"ibm-container ibm-alternate\"><div class=\"ibm-container-body\"><div class=\"codesection\"><pre class=\"displaycode no-auto-overflow\"><strong>语法<\/strong>：scm load workspace [ -r  --repository-uri ] repository URI or nickname [ -d  | --dir ] workspace-path { [ -q  |  --quiet ] [ -f  |  --force ] }\n<strong>示例：<\/strong>//装载存储库工作空间里的指定组件 testcomponent 到本地工作空间\nscm load  myworkspace  -r  jazznick -d \"C:\\Users\\IBM_ADMIN\\IBM\\rationalsdp\\workspace\" -f  testcomponent<\/pre><\/div><\/div><\/div><\/div><\/div><div class=\"ibm-footer\"><><\/div><\/div><ol type=\"1\"><li><strong>scm accept C接受变更集到存储库工作空间并载入到本地工作空间。<\/strong><\/li><\/ol><p><a href=\"#N100C3\" class=\"ibm-popup-link\" onclick=\"ibmweb.overlay.show('N100C3',this);return false;\">点击查看代码清单<\/a><\/p><div id=\"N100C3\" class=\"dw-sidefile-overlay ibm-common-overlay ibm-overlay-alt-two\"><div class=\"ibm-head\"><p><a href=\"#close\" class=\"ibm-common-overlay-close\">关闭 [x]<\/a><\/p><\/div><div class=\"ibm-body\"><div class=\"ibm-main\"><div class=\"ibm-container ibm-alternate\"><div class=\"ibm-container-body\"><div class=\"codesection\"><pre class=\"displaycode no-auto-overflow\"><strong>语法：<\/strong>scm accept  [ -r  --repository-uri ] repository URI or nickname [ -d  | --dir ]  workspace-path { [ [ -q  |  --quiet ] | [ -v  |  --verbose ] ] [ -s  | --source ] source workspace or stream [ -t  | --target ] target workspace or stream [ -i  | --in-place-markers ] change set ... }\n<strong>示例：<\/strong>scm accept -r formsjazz -d \"C:\\Users\\IBM_ADMIN\\IBM\\rationalsdp\\workspace\" -C testcomponent Coverwrite-uncommitted<\/pre><\/div><\/div><\/div><\/div><\/div><div class=\"ibm-footer\"><><\/div><\/div><ol type=\"1\"><li><strong>scm logout C 退出并删除保存的登录信息。<\/strong><\/li><\/ol><div class=\"codesection\"><pre class=\"displaycode\"><strong>语法：<\/strong>scm logout [ -r  |  --repository-uri ] repository URI or nickname\n<strong>示例：<\/strong>scm logout -r jazznick<\/pre><\/div><p>组合上述命令，我们可以很容易地登录到 Jazz 服务器获取最新的自动化测试代码。以 Windows 平台为例，我们使用 Batch 文件来组合上述命令（这里我们以轻量级命令 lscm 来代替 scm 以获得更好的性能），主要实现代码如清单 1 所示。<\/p><h5 id=\"N100DC\">清单 1. 自动获取 Jazz 服务器端最新代码<\/h5><div class=\"codesection\"><pre class=\"displaycode\">Set workspacesandbox=\"REPLACE_WITH_YOUR_WORKSPACE\"\nSet workspacepath=\"%userprofile%\\workspace\"\n@echo on\necho login to the jazz server with user id and password and update code from RTC\n@echo off\ncall lscm login -r https://jazzserver:port/jazz  -n jazznick -u REPLACE_WITH_YOUR_ACCOUNT\n-P REPLACE_WITH_YOUR_PASSWORD\ncall lscm repair -r jazznick   -d %workspacepath%\ncall lscm load %workspacesandbox% -f -r formsjazz -d %workspacepath% qe.selenium\ncall lscm status -d \"%workspacepath%\"\ncall lscm accept -r jazznick -d %workspacepath% -C qe.selenium --overwrite-uncommitted\ncall scm logout -r jazznick<\/pre><\/div><p>获得最新代码后，我们进行脚本的编译。由于 Maven 能够自动管理 Java 库和项目间的依赖，因此根据 Maven 配置文件模板，通过 dependency 插件显式地声明依赖，就可以完成一个标准 Maven 项目的编译。但是我们的项目是传统的 Java 项目，项目的依赖包都放在特定的 lib 目录下，我们希望在不改变项目结构的情况下使用 Maven 进行快速构建，为了达成这一目的，我们需要借助外部插件 compiler 来完成并在 pom.xml 文件中指定依赖包目录，如清单 2 所示。<\/p><h5 id=\"N100E6\">清单 2. 在 pom.xml 中指定依赖的包目录<\/h5><div class=\"codesection\"><pre class=\"displaycode\">&lt;plugin&gt;\n&lt;artifactId&gt;maven-compiler-plugin&lt;/artifactId&gt;\n&lt;version&gt;2.0.2&lt;/version&gt;\n&lt;configuration&gt;\n&lt;source&gt;1.6&lt;/source&gt;\n&lt;target&gt;1.6&lt;/target&gt;\n&lt;compilerArguments&gt;\n&lt;extdirs&gt;${basedir}/lib&lt;/extdirs&gt;\n&lt;/compilerArguments&gt;\n&lt;/configuration&gt;\n&lt;/plugin&gt;<\/pre><\/div><p>将创建的 pom.xml 放到项目目录下，调用简单的 mvn 命令\"<code>mvn compiler:compile<\/code>\"完成编译。编译完的 jar 包可以在&lt;project_home&gt;/target 下找到。<\/p><p>至此，我们已经完成了代码的更新和编译工作。通过 STAX 把上述脚本拼装起来，通过对不同脚本的调度实现完整流程，把封装的 STAX 文件定制为定时启动或者由其他任务触发实现真正的自动的更新和编译。STAX 文件片段如清单 3 所示。<\/p><h5 id=\"N100F5\">清单 3. 使用 STAX 封装任务<\/h5><p><a href=\"#N100F9\" class=\"ibm-popup-link\" onclick=\"ibmweb.overlay.show('N100F9',this);return false;\">点击查看代码清单<\/a><\/p><div id=\"N100F9\" class=\"dw-sidefile-overlay ibm-common-overlay ibm-overlay-alt-two\"><div class=\"ibm-head\"><p><a href=\"#close\" class=\"ibm-common-overlay-close\">关闭 [x]<\/a><\/p><\/div><div class=\"ibm-body\"><div class=\"ibm-main\"><div class=\"ibm-title\"><h2>清单 3. 使用 STAX 封装任务<\/h2><\/div><div class=\"ibm-container ibm-alternate\"><div class=\"ibm-container-body\"><div class=\"codesection\"><pre class=\"displaycode no-auto-overflow\">&lt;!--Copy download template file from LA server to agent--&gt;\n&lt;call function=\"'cafCopyFile'\"&gt;LAServer,templateFileLocation,downloadscript,target,datadir,downloadscript&lt;/call&gt;\n&lt;!--Download script--&gt;\t\n&lt;call function=\"'cafRunCommand'\"&gt;target,'%s/%s' %(datadir,downloadscript)&lt;/call&gt;          \n&lt;script&gt;(callRC,callResult) = STAXResult&lt;/script&gt;\n&lt;if expr=\"callRC !=0 \"&gt;\n\t&lt;throw exception=\"'eTerminateFunction'\"&gt;callResult&lt;/throw&gt;\n&lt;/if&gt;\n&lt;!--Copy CompileScript.bat &amp;pom.xml to project dir--&gt;\t\n&lt;call function=\"'cafCopyFile'\"&gt;LAServer,templateFileLocation,compilescript,target,workdir,compilescript&lt;/call&gt;\n&lt;call function=\"'cafCopyFile'\"&gt;LAServer,templateFileLocation,pomxml,target,workdir,pomxml&lt;/call&gt;\n&lt;!--Compile scripts--&gt;\n&lt;call function=\"'cafRunCommand'\"&gt;target,'%s/%s' %workdir,compilescript)&lt;/call&gt;<\/pre><\/div><\/div><\/div><\/div><\/div><div class=\"ibm-footer\"><><\/div><\/div><p>通过定时启动，LA 管理员可以从这单一重复的工作中释放出来了。我们图 1 中展示的问题也随之简化为图 2 所示的工作场景。<\/p><h5 id=\"N100FE\">图 2. 代码的自动更新、构建并部署<\/h5><img alt=\"代码的自动更新、构建并部署\" src=\"/sunshine_new/images/负1371877469/image005.gif\" width=\"512\" /><p>我们通过 LA 部署上述 STAX 文件并通过 Web 界面管理和启动 STAF 服务，抑或通过 STAF 命令<code>staf server.cn.ibm.com sem pulse event \"TestEvent\"<\/code><code/>直接启动。<\/p><h3 id=\"N1010F\">脚本运行参数化及自启动<\/h3><p>利用上述流程，我们轻松完成了代码的更新和编译工作，把 LA 管理员从简单重复性的工作中解放出来。随即，我们又遇到另外一个问题：在不了解测试代码的情况下，测试人员如何方便地更新测试参数，比如 Web 应用中的 URL、用户名、密码等；如何调整脚本中测试用例的运行顺序等。针对这个问题，在设计自动化测试框架的时候，我们对多种工具和方案做了调研，比如 Junit、TestNG 及使用属性文件管理测试数据等。最后 TestNG 以其灵活性和参数化的特性胜出。<\/p><p>TestNG 可以利用注释定义测试用例依赖关系并通过配置文件设置参数及定义测试套件。简单来说，要在我们的自动化测试脚本中使用 TestNG，我们只需要做两方面的工作：一方面在代码中加入合适的注释；另一方面生成包含参数列表的的配置文件 testng.xml。限于篇幅，这里我们只讨论 TestNG 如何通过配置文件定义参数及参数是如何被读取到代码中。了解更多关于 TestNG 的注释可以参考其网站。<\/p><p>以下面的 testng.xml 为例，我们定义了脚本运行必需的几个参数。当脚本运行在不同环境中时， 我们只需要改变相应的值就可以。<\/p><h5 id=\"N1011C\">清单 4. TestNG 配置文件<\/h5><div class=\"codesection\"><pre class=\"displaycode\">&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;\n&lt;!DOCTYPE suite SYSTEM \"http://testng.org/testng-1.0.dtd\"&gt;\n&lt;suite thread-count=\"1\" name=\"simplesuite\" parallel=\"false\" &gt;\n  &lt;parameter name=\"browser_url\" value=\"REPLACE_WITH_YOUR_URL\" /&gt;\n  &lt;parameter name=\"browser_name\" value=\"REPLACE_WITH_YOUR_BROWSER\" /&gt;\n  &lt;parameter name=\"defaultuser\" value=\"REPLACE_WITH_YOUR_USER\" /&gt;\n  &lt;parameter name=\"defaultpassword\" value=\"REPLACE_WITH_YOUR_PASSWORD\" /&gt;\n  \n  &lt;test name=\"simpleclass\" preserve-order=\"true\" enabled=\"true\"&gt;\n    \t&lt;classes&gt;\n      \t\t&lt;class name=\"REPLACE_WITH_YOUR_TESTCASE\" /&gt;\n   \t &lt;/classes&gt;\n  &lt;/test&gt;\n&lt;/suite&gt;<\/pre><\/div><p>对于以上参数，代码只需要调用@Parameters 注释就可以很容易的把参数值读进来，由于这些参数是通用信息，在所有测试方法中都可以用到，所以我们把这些信息定义为全局变量，示例代码如清单 5 所示。<\/p><h5 id=\"N10126\">清单 5. 读取 TestNG 参数信息<\/h5><div class=\"codesection\"><pre class=\"displaycode\">@Parameters({\"browser_url\",\"defaultuser\",\"defaultpassword\",\"browser_name\"})\n@BeforeSuite(alwaysRun=true)\npublic void beforeSuite(String url,String user,String password,String browsername) {\n\t\tdefaultURL=url;\n\t\tdefaultUsername=user;\n\t\tdefaultPassword=password;\n\t\tdefaultBrowser = browsername;\n}<\/pre><\/div><p>接下来，我们应该考虑如何根据需要自动更新参数值。上面提到我们使用 LA 作为脚本分发和结果收集的 Web 平台，因此用户可以使用 LA 通过浏览器很方便的修改各项参数，如图 3 所示。<\/p><p><strong>注：<\/strong>对于没有使用 LA\n    的项目，也可以通过其他方式修改参数，比如通过命令行直接对 STAF 命令传参，或者使用属性文件保存不同环境信息以备运行时调用等。<\/p><h5 id=\"N10133\">图 3. 通过 LA 界面输入需要的参数<\/h5><img alt=\"\" src=\"/sunshine_new/images/负1371877469/image007.gif\" width=\"237\" /><p>用户提交修改以后，LA 接收这些参数并调用 STAF 命令更新 TestNG 配置文件，实现代码如清单 6 所示。<\/p><h5 id=\"N1013F\">清单 6. 使用 STAX 更新 TestNG 配置信息<\/h5><p><a href=\"#N10143\" class=\"ibm-popup-link\" onclick=\"ibmweb.overlay.show('N10143',this);return false;\">点击查看代码清单<\/a><\/p><div id=\"N10143\" class=\"dw-sidefile-overlay ibm-common-overlay ibm-overlay-alt-two\"><div class=\"ibm-head\"><p><a href=\"#close\" class=\"ibm-common-overlay-close\">关闭 [x]<\/a><\/p><\/div><div class=\"ibm-body\"><div class=\"ibm-main\"><div class=\"ibm-title\"><h2>清单 6. 使用 STAX 更新 TestNG 配置信息<\/h2><\/div><div class=\"ibm-container ibm-alternate\"><div class=\"ibm-container-body\"><div class=\"codesection\"><pre class=\"displaycode no-auto-overflow\">&lt;call function=\"'cafGetFileContents'\"&gt;target,'%s/test_config/sc_template.xml' %workdir&lt;/call&gt;\n&lt;script&gt;\n\tcallResult = STAXResult\n\tTestNGTemplate = re.sub(r'REPLACE_WITH_YOUR_BROWSER', browser, TestNGTemplate)\n\tTestNGTemplate = re.sub(r'REPLACE_WITH_YOUR_URL', URL, TestNGTemplate)\n\tTestNGTemplate = re.sub(r'REPLACE_WITH_YOUR_USER', username, TestNGTemplate)\n\tTestNGTemplate = re.sub(r'REPLACE_WITH_YOUR_PASSWORD', password, TestNGTemplate)\n&lt;/script&gt;\n&lt;call function=\"'cafWriteTargetFile'\"&gt;target, '%s/test_config/' %workdir, 'sc_template_%s_%s.xml' % (STAXCurrentFunction, LAJobID), TestNGTemplate&lt;/call&gt;<\/pre><\/div><\/div><\/div><\/div><\/div><div class=\"ibm-footer\"><><\/div><\/div><p>这样我们就完成了脚本参数的更新， 解决了脚本运行前的又一个重要问题，接下来我们研究如何一键启动自动化脚本。 由于我们是远程启动，在 TestNG 的几种不同的调用方式中，结合更新过的配置文件，命令行方式成为最适合我们的方案，封装的命令通过 STAF 被发送到目标机器并执行。相关实现代码如清单 7 所示：<\/p><h5 id=\"N10149\">清单 7. 调用 STAF 命令启动 TestNG 脚本<\/h5><p><a href=\"#N1014D\" class=\"ibm-popup-link\" onclick=\"ibmweb.overlay.show('N1014D',this);return false;\">点击查看代码清单<\/a><\/p><div id=\"N1014D\" class=\"dw-sidefile-overlay ibm-common-overlay ibm-overlay-alt-two\"><div class=\"ibm-head\"><p><a href=\"#close\" class=\"ibm-common-overlay-close\">关闭 [x]<\/a><\/p><\/div><div class=\"ibm-body\"><div class=\"ibm-main\"><div class=\"ibm-title\"><h2>清单 7. 调用 STAF 命令启动 TestNG 脚本<\/h2><\/div><div class=\"ibm-container ibm-alternate\"><div class=\"ibm-container-body\"><div class=\"codesection\"><pre class=\"displaycode no-auto-overflow\">&lt;script&gt;\n\tclasspath = '%s/lib/com.ibm.automation.core.jar;%s/lib/selenium-server-standalone.jar;%s/lib/testng-6.4.jar;%s/target/classes' %(workdir, workdir, workdir, workdir)\n\tTestNGRunner = 'java -cp %s org.testng.TestNG \"%s/test_config/sc_template_%s_%s.xml\"' %(classpath, workdir, STAXCurrentFunction, LAJobID)\n&lt;/script&gt;   \n\n……………………………………\n&lt;process&gt;\n\t&lt;location&gt;target&lt;/location&gt;\n\t&lt;command&gt;TestNGRunner&lt;/command&gt;\n\t&lt;workdir&gt;workdir&lt;/workdir&gt;\n&lt;/process&gt;<\/pre><\/div><\/div><\/div><\/div><\/div><div class=\"ibm-footer\"><><\/div><\/div><h2 id=\"3.总结 |outline\">总结<\/h2><p>随着持续集成和持续交付的概念深入人心，自动化测试在受到更多关注的同时也承担着巨大的压力。只有改变传统的思路，以持续交付方法及原则出发，重新审视测试流程并做一些适当的调整，自动化测试才能更好的适应敏捷开发项目并发挥更大的作用。本文仅以简单的例子对自动化测试自动构建、部署及运行部分做了介绍，而软件的持续交付概念涵盖的更多的自动化过程，我们将在接下来的另一篇文章里面做更多介绍，也希望这篇文章能够抛砖引玉，引起您更多的思考和创新。<\/p><CMA ID: 971898><Site ID: 10><XSLT stylesheet used to transform this file: dw-document-html-7.0.xsl>\r\n\r\n\r\n<\/div>\r\n<\/div>\r\n","createTime":"2014-05-22 00:00:00","deployTime":"2014-05-22 00:00:00","id":0,"intro":"随着持续交付的软件发布方法的推广，自动化测试越来越受关注，如何提高各个团队的整体协作水平，如何提高整个交付活动的自动化水平，是实现持续交付面临的重大挑战。本文从众多关注点中选取自动化测试这一环节，结合实际项目经验，介绍如何进行自动化测试脚本的自动构建、自动部署及如何参数化运行，实现真正无人值守的全自动化过程。","keyword":"","recommend":false,"source":"http://www.ibm.com/developerworks/cn/rational/1505_zhaohf_stafrtcmaven/index.html","title":"使用 STAF+RTC+Maven 实现无人值守的自动化测试","typeId":0,"updateTime":"2014-05-22 00:00:00"}
{"author":"","clickNumber":0,"content":"\r\n<div class=\"ibm-columns\">\r\n<div class=\"ibm-col-1-1\">\r\n\r\n<h2 id=\"introduction\">简介<\/h2><p>每一天，公司都在生成许多文档、表单和文件，跨组织边界共享这些文档或向外部公开它们。但是，必须仔细检查文档中的敏感数据（比如个人隐私信息）并完全消除它们，然后才能向公众公开文档。IBM\n                InfoSphere Guardium Data Redaction\n                是一个用于安全公开的解决方案。它为企业提供了高效的方法，从其日常业务中生成的大量文档中删除敏感数据（参见图 1）。<\/p><p>编校服务器自动从文档中提取和删除与隐私相关的信息，以指定的格式提供结果。该服务器还为编校管理器和其他自定义应用程序提供了这些编校服务。编校管理器是一个基于\n                Flex 的 Web\n                应用程序，支持您执行交互式编校和审阅批量编校的文档。以前的文章已经介绍了自动编校的工作原理，以及如何使用编校服务器作为业务工作流的一部分来创建自定义应用程序。自第一版以来，InfoSphere\n                Guardium Data Redaction 已更新了多次，添加了许多特性并增强了其他功能，提高了它的适用性。<\/p><p>本文将介绍 IBM InfoSphere Guardium Data Redaction V2.1 和 V2.5\n                中添加或增强的新功能和特性。假设您拥有该产品的基本知识。请参见 <a href=\"#resources\">参考资料<\/a>，获取其他讨论编校的文章的链接。<\/p><h5 id=\"fig n1\">图 1. 使用 IBM InfoSphere Guardium Data\n                    Redaction 执行业务文档数据编校<\/h5><img alt=\"使用 IBM InfoSphere Guardium Data Redaction 执行业务文档数据编校\" src=\"/sunshine_new/images/负2102703252/fig1_redactionsystem.png\" width=\"580\" /><h2 id=\"XMLdocuredact\">XML\n                文档编校<\/h2><p>IBM InfoSphere Guardium Data Redaction V2.5 现在支持使用 XML 作为一种可编校格式。编校客户端 API\n                已得以增强，您可以在自定义应用程序中编校 XML 文档。这对企业客户至关重要，因为 XML\n                文档（数据）是半结构化的，结合了结构化的元素与自由文本。它们很容易供计算机访问，也很容易增强，而且还适合在使用不同系统和应用程序的组织之间交换。本节介绍这个新\n                API 的编程技巧以及如何配置编校服务器。<\/p><p>要使用 XML 编校功能，必须准备一个 XML 信息规范 (XIS) 文件。XIS（它本身是一个 XML 文档）定义了如何编校 XML 文档。清单 1\n                给出了一个 XIS 示例。XIS 文件中使用两种类型的元素来指定应如何编校 XML 文档：<code>freeText<\/code> 元素和\n                <code>typedEntity<\/code> 元素。一个 <code>freeText<\/code> 元素可包含一个或多个\n                <code>textPath<\/code> 元素。一个 <code>typedEntity<\/code> 有一个或多个\n                <code>nodePath<\/code> 元素。 <code>textPath<\/code> 和 <code>nodePath<\/code>\n                元素都包含定义目标节点的 XPath 表达式。<\/p><h5 id=\"listing n1\">清单 1. XML 信息规范 (XIS) 示例<\/h5><div class=\"codesection\"><pre class=\"displaycode\">&lt;ns25:xmlInfoSpec xmlns:ns25=\"http://ibm.com/igdrxml25\"&gt;\n    &lt;ns25:freeText&gt;\n        &lt;ns25:textPath&gt;//patientRecord/nurseNotes/text()&lt;/ns25:textPath&gt;\n    &lt;/ns25:freeText&gt;\t\n    &lt;ns25:typedEntity semanticCategoryId=\"6\"&gt;\n        &lt;ns25:nodePath&gt;//patientRecord/ssn&lt;/ns25:nodePath&gt;\n    &lt;/ns25:typedEntity&gt;\n&lt;/ns25:xmlInfoSpec&gt;<\/pre><\/div><p>如果一个目标节点是使用 <code>freeText<\/code> 元素指定的，那么编校服务器会将该节点的内容当作自由文本来评估。服务器使用强大的\n                AQL 语言查找要编校的词语，该语言包含在 IBM 的 System T\n                中，使用高级技术来提取信息。服务器然后替换包含预定义的字符串（标签）的词汇，表示信息的语义类别。在此示例中，评估了目标 XML 文件中的\n                <code>nurseNotes<\/code> 元素，编校了所有隐私信息。<\/p><p>如果某个目标节点是使用 <code>typedEntity<\/code> 元素指定的，那么该节点的所有内容都会被识别为属于\n                <code>sematicCategoryId<\/code> 参数所指定的语义类别的一个表达式。例如，如果某个节点在\n                <code>typedEntity<\/code> 元素中被指定为社会安全号码\n                (<code>semanticCategoryId=6<\/code>)，那么该节点的内容将被视为 SSN。如果禁止向文档接收者显示\n                SSN，那么编校服务器会将该节点的主体替换为合适的标签（在本例中使用 “[SSN]”）。<\/p><p>XML 编校不可能使用自动批处理或 Redaction Manager\n                来完成，以这种方式处理的文件无法在安全的查看器中显示。但是，具有批量编校功能的客户端应用程序可使用 API\n                来创建。我们提供了一个示例应用程序来演示如何调用这些功能。该示例应用程序也可用作创建您自己的应用程序的起点。<\/p><p>可使用编校客户端 API，在服务器上从一个自定义应用程序调用 XML 编校功能。在该 API 中已经添加了\n                <code>RedactionToolkitClient<\/code> 类的 6 个方法（参见表 1）和一些相关的类来执行 XML 文档编校。前 4\n                个方法的用法与使用 <code>redactDocumentByRules()<\/code> 或\n                <code>redactRepositoryDocumentForRole()<\/code> 等 API\n                调用的普通文档的相应方法几乎相同。惟一的区别在于，新方法需要 XIS 信息。可通过两种方式将 XIS 信息传递给这些方法：可在一个字符串值中传递\n                XIS 文件的正文，或者将 XIS 文件名称作为一个 <code>RedactionAttributes<\/code> 类对象传递。<\/p><h5 id=\"table n1\">表 1. 增强的 XML 文档编校方法<\/h5><table border=\"0\" cellpadding=\"0\" cellspacing=\"0\" class=\"ibm-data-table\" summary=\"Enhanced methods for XML document redaction\"><thead xmlns:dw=\"http://www.ibm.com/developerWorks/\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"><tr><th scope=\"col\">方法<\/th><th scope=\"col\">操作<\/th><\/tr><\/thead><tbody xmlns:dw=\"http://www.ibm.com/developerWorks/\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"><tr><td><code>redactXmlByRules()<\/code><\/td><td>依据指定的规则编校一个 XML 文档<\/td><\/tr><tr><td><code>redactXmlForRole()<\/code><\/td><td>针对指定的接收者角色编校一个 XML 文档<\/td><\/tr><tr><td><code>redactRepositoryXmlByRules()<\/code><\/td><td>依据指定的规则编校存储库中的一个 XML 文档<\/td><\/tr><tr><td><code>redactRepositoryXmlByRules()<\/code><\/td><td>依据指定的接收者角色的权限编校存储库中的一个 XML 文档<\/td><\/tr><tr><td><code>redactRepositoryXmlsByRules()<\/code><\/td><td>依据指定的规则编校存储库中的 XML 文档<\/td><\/tr><tr><td><code>redactRepositoryXmlsForRole()<\/code><\/td><td>依据指定的接收者角色的权限编校存储库中的 XML 文档<\/td><\/tr><\/tbody><\/table><p> 清单 2 给出了一个使用 <code>redactXmlForRole()<\/code>\n                方法的示例。这个程序向服务器请求在一个客户端机器上编校某个文档。输入文档已加载到 <code>inputDocBytes<\/code>\n                变量中（但清单中省略了加载步骤）。XIS 信息是从一个名为 <em>sampleXmlInfoSpec.xis<\/em> 的文件加载的，并作为\n                <code>redactXmlForRole()<\/code> 方法的第 3 个参数传递。<\/p><h5 id=\"listing n2\">清单 2. 使用 redactXmlForRole() 方法的示例程序（摘录）<\/h5><div class=\"codesection\"><pre class=\"displaycode\">// Set Redaction Attributes\n//     Set output format\nRedactionAttributes redactionAttributes = new RedactionAttributes(\"application/xml\");\n// prepare Document class object\n//     load input document data \nbyte[] inputDocBytes; // binary document data \n...\n//     Set input format and language  \nDocumentAttributes documentAttributes = new DocumentAttributes(\"InputDocument.xml\", \"appli\ncation/xml\", null);\ndocumentAttributes.addAttribute(DocumentAttributes.LANGUAGE, new AttributeValue(\"en\"));\n//     Set input document data, attributes and status \nDocument document = new Document(inputDocBytes, documentAttributes, DOCUMENT_STATE.NOT_RED\nACTED);\n// load xis\nString xisContentFile = \"sampleXmlInfoSpec.xis\";\nString xisContents = FileUtils.readTextFile(xisContentFile, \"UTF-8\");\n// prepare role ID\nint ROLE_RESTRICTED = 1000; // \"RESTRICTED\" role in the sample policy model\n// redact a document\nDocument redactedDocument = client.redactXmlForRole(redactionAttributes, document, xisCont\nents, ROLE_RESTRICTED);<\/pre><\/div><p> 清单 3 是要编校的示例 XML 输入。清单 4 是输入文档的已编校的示例输出。这个编校过程由 <a href=\"#listing n2\">清单 2<\/a> 的程序使用 <a href=\"#listing n1\">清单 1<\/a> 的 XIS\n                来执行。一些词汇（人员名称、时间和日期）和 <code>ssn<\/code> 元素已编校。<\/p><h5 id=\"listing n3\">清单 3. 要编校的 XML 文档示例（输入）<\/h5><div class=\"codesection\"><pre class=\"displaycode\">&lt;medicalData&gt; \n\t&lt;patientRecord&gt;\n\t\t&lt;department&gt;Obstetrics&lt;/department&gt;\n\t\t&lt;ssn&gt;393-55-3113&lt;/ssn&gt;\n\t\t&lt;nurseNotes nurseId=\"KJ8838383\"&gt;Mrs. Mary Jones was admitted at 9:27 AM on\n 1 November 2009.&lt;/nurseNotes&gt; \n\t&lt;/patientRecord&gt; \n\t&lt;patientRecord&gt;\n\t\t&lt;ssn&gt;371-22-3459&lt;/ssn&gt;\n\t\t&lt;department&gt;Surgery&lt;/department&gt;\n\t\t&lt;nurseNotes nurseId=\"FJ82920909\"&gt;The patient, James Smith, arrived at 7:17\n AM on 31 August 2009.&lt;/nurseNotes&gt;\n\t&lt;/patientRecord&gt; \n&lt;/medicalData&gt;<\/pre><\/div><h5 id=\"listing n4\">清单 4. 已编校的 XML 文档示例（输出）<\/h5><div class=\"codesection\"><pre class=\"displaycode\">&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;&lt;medicalData&gt; \n\t&lt;patientRecord&gt;\n\t\t&lt;department&gt;Obstetrics&lt;/department&gt;\n\t\t&lt;ssn&gt;[SSN]&lt;/ssn&gt;\n\t\t&lt;nurseNotes nurseId=\"KJ8838383\"&gt;Mrs. [Person] was admitted at [Time] on [D\nate].&lt;/nurseNotes&gt; \n\t&lt;/patientRecord&gt; \n\t&lt;patientRecord&gt;\n\t\t&lt;ssn&gt;[SSN]&lt;/ssn&gt;\n\t\t&lt;department&gt;Surgery&lt;/department&gt;\n\t\t&lt;nurseNotes nurseId=\"FJ82920909\"&gt;The patient, [Person], arrived at [Time] \non [Date].&lt;/nurseNotes&gt;\n\t&lt;/patientRecord&gt; \n&lt;/medicalData&gt;<\/pre><\/div><p>使用了 <code>redactRepositoryXmlsByRules()<\/code> 和\n                <code>redactRepositoryXmlsForRole()<\/code> 方法有效地同时编校一个存储库中的许多文档。支持的存储库包括\n                Filenet P8 V4.5.1、V5.0 和 V5.1，以及 IBM Content Manager\n                V8。如果存储库的一个编校处理器配置了多线程选项，那么文档会并行地编校，有可能实现更快的吞吐量。清单 5 展示了如何使用\n                <code>redactRepositoryXmlsForRole()<\/code> 方法。这个示例程序在 “on-demand” 存储库中搜索输入\n                XML 文件。不同于 <a href=\"#listing n2\">清单 2<\/a> 中的程序，XIS\n                信息是通过引用文件名称从存储库中的一个 XIS 文件加载的，该文件名称被传递给编校方法（使用\n                <code>RedactionAttributes<\/code> 类对象）。在这种情况下，该方法的第 3 个参数应为\n                null。在最后一个阶段，通过调用 <code>redactRepositoryXmlsForRole()<\/code> 方法来编校 XML\n                文件。<\/p><h5 id=\"listing n5\">清单 5. 已编校的 XML 文档示例（输出）<\/h5><div class=\"codesection\"><pre class=\"displaycode\">// Set Redaction Attributes\n// Set output format and xis information\nRedactionAttributes redactionAttributes = new RedactionAttributes(\"application/xml\"); \nredactionAttributes.addAttribute(RedactionAttributes.REDACT_WITH_INFO_SPEC_IN_REPOSITORY, \nnew AttributeValue(\"sampleXmlInfoSpec.xis\"));\n// Set DocumentReference class objects\n// Search and set information of documents\nDocumentReference[] docRefs = client.queryDocumentRepository(new DocumentRepositorySearchC\nriteria(\"on-demand\", DocumentRepositorySearchCriteria.SEARCH_WITHIN.NOT_REDACTED));\n// prepare role ID\nint role = 1000; // \"RESTRICTED\" role in the sample policy model\n// redact the documents \nDocumentReference[] redactedDocRefs = client.redactRepositoryXmlsForRole(redactionAttribut\nes, docRefs, null, role);<\/pre><\/div><h2 id=\"secureviewer\">安全查看器<\/h2><p>在典型的编校场景中，文档由编校服务器在第一步中按批次处理。在需要时，管理员可使用编校管理器 GUI 来查看结果（图\n                2）。编校的文档可分发给读者。例如，一个已编校的 PDF\n                文件可通过电子邮件发送给授权的读者。但是，在发送文档之后，文档的控制权就会丢失，接收者可将文档转发给未授权的人。<\/p><p>新的安全查看器 GUI 支持须知 (need-to-know) 查看形式。使用此\n                GUI，用户可查看他们的角色或更低角色有权限查看的已编校文档。用户可以打开和阅读文档，但 GUI\n                不会复制文本或直接将文档保存在本地存储中。因此，如果用户的凭据过期，文档会立即无法访问。<\/p><p>该查看器还支持文本搜索，甚至对 TIFF 等原始图形文档也可以执行此操作。<\/p><h5 id=\"fig n2\">图 2. 包含 Redaction Manager 和 Secure Viewer\n                    GUI 的文档数据编校工作流<\/h5><img alt=\"包含 Redaction Manager 和 Secure Viewer GUI 的文档数据编校工作流\" src=\"/sunshine_new/images/负2102703252/fig2_redactionworkflow.png\" width=\"580\" /><p>除了一般输出文档格式（比如 PDF、MS-word、纯文本和 tiff 图像）之外，编校服务器还支持安全文档查看器格式\n                (.sdvf)。这是一种用于安全查看器的特殊的内部格式。对于 .sdvf 输出，可使用增强的 “安全检索和填入” 功能。<\/p><p>在某些情况下，甚至仍然需要对拥有完整权限的信息类型进行额外防范。可通过编校系统配置来编校信息，但仍然支持使用安全查看器进行须知查看。<\/p><p>编校策略的配置是在服务器上的 XmlPolicyModel.xml 文件中定义的。清单 6 显示了这个配置文件的一个例子。permission\n                元素定义了要为哪些用户角色编校哪些语义类别。<\/p><h5 id=\"listing n6\">清单 6. 编校条件定义示例 (XmlPolicyModel.xml)<\/h5><div class=\"codesection\"><pre class=\"displaycode\">...\n&lt;ns21:permission userRoleId=\"1001\" semanticCategoryId=\"3\"&gt;\n\t&lt;ns21:redact/&gt;\n&lt;/ns21:permission&gt;\n...\n&lt;ns21:permission userRoleId=\"1001\" semanticCategoryId=\"10\"&gt;\n\t&lt;ns21:reveal/&gt;\n&lt;/ns21:permission&gt;\n...<\/pre><\/div><p>如果定义了一个 <code>redact<\/code> 元素，则会为指定的用户角色安全地、无条件地删除指定类别中的信息。如果定义了一个\n                <code>reveal<\/code>\n                元素，则会安全地删除信息，但在授权用户请求查看它时，可从服务器上的原始文档安全地检索并显示。请求用户可能需要有选择地指定显示的业务用途。<\/p><p>例如，在示例配置中，组织名称 (<code>semanticCategoryId=3<\/code>)\n                已被删除并被替换为标签：“[Organization]”，而人员名称 (<code>SemanticCategoryId=10<\/code>)\n                也已被替换，但可由授权的 “General” 用户角色揭露\n                (<code>userRoleId=1001<\/code>)。要揭露一个已编校的词汇，用户可单击该标签选择它，然后单击 “Reveal\n                selected entity”\n                图标。然后，用户可能被要求提供业务用途（或必须提供业务用途，具体情况取决于配置），从一个被配置到组合框中的选项中进行选择，或者使用自由文本。然后，从服务器安全地检索已编校的文本并显示（图\n                3）。显示已编校信息的请求由编校服务器记录，以便审计人员可在以后审核这些记录。<\/p><h5 id=\"fig n3\">图 3. 使用须知查看功能安全地检索和显示已编校的信息<\/h5><img alt=\"使用须知查看功能安全地检索和显示已编校的信息\" src=\"/sunshine_new/images/负2102703252/fig3_secureviewer.png\" width=\"580\" /><p>基于角色的编校和基于角色的须知查看特性的优势是，管理员无需为每个角色准备每个文档的不同版本。如果为具有最低访问级别的角色生成一个文档，那么所有接收者都可以浏览它，具有需要较高访问级别的角色的读者仍可以显示与他们的角色相关的信息。<\/p><h2 id=\"stamp\">用于 Bates 编号的时间戳<\/h2><p>时间戳功能已得到了扩展。除了固定字符串之外，编校的日期和时间也可使用用户首选的格式插入到时间戳的文字中。自动递增的 Bates\n                序列号（常常在电子查询等法律文档管理场景中指定）也被支持用于时间戳中。在批量处理文档时，此功能很有用。清单 7 和图 4\n                显示了时间戳功能的一个用例。此外，可指定要包含在时间戳中的文档属性（比如文件名称或内容类型）。每个时间戳还有一个全局惟一标识符\n                (GUID)。<\/p><h5 id=\"listing n7\">清单 7. 时间戳标签定义的示例<\/h5><div class=\"codesection\"><pre class=\"displaycode\">&lt;redactionStamp enabled=\"true\"&gt;\n\t&lt;label&gt;\n\t\t&lt;text&gt;REDACTED for external readers: &lt;/text&gt;\n\t\t&lt;date format=\"yyyy/MMM/dd HH:mm:ss\"/&gt;\n\t\t&lt;text&gt; Serial #: &lt;/text&gt;\n\t\t&lt;batesNumber startNumber=\"1\"/&gt;\n\t&lt;/label&gt;\n\t&lt;position&gt;UpperLeft&lt;/position&gt;\n&lt;/redactionStamp&gt;<\/pre><\/div><h5 id=\"fig n4\">图 4. 时间戳输出示例<\/h5><img alt=\"时间戳输出示例\" src=\"/sunshine_new/images/负2102703252/fig4_stampsample.jpg\" width=\"580\" /><h2 id=\"N10182\">使用一个后处理器插件向文档添加水印<\/h2><p>一个添加到编校服务器中的后处理器插件可在编校的文档上执行自定义的处理。该产品包含一个图形水印的一个示例配置文件。本节介绍向文档添加水印的配置步骤。<\/p><h3 id=\"N10189\">准备<\/h3><p>如果已编校的文件要输出为 PDF 文件，可添加一个水印，无论输出格式是什么。对于此过程，应从网站 (http://itextpdf.com/) 获取\n                iText PDF 库并添加到编校服务器上的\n                &lt;IBM_REDACTION_HOME&gt;\\server\\plugins\\redaction-postprocessor-watermark\\lib\n                目录中。&lt;IBM_REDACTION_HOME&gt; 是在安装过程中指定的程序文件目录。<\/p><p>必须将嵌入到文档中的水印图像创建为一个透明的 png 文件。图像的背景指定为透明，前景图像（实际的水印）指定为部分透明。<\/p><h3 id=\"N10191\">启用该插件<\/h3><p>文件 &lt;IBM_REDACTION_DATA&gt;\\server\\conf\\pdfWatermark.xml\n                应使用一个文本编辑器打开，以添加清单 8 所示的定义。&lt;IBM_REDACTION_DATA&gt;\n                是包含配置文件、日志文件和示例的数据文件目录。它的位置由安装程序定义，取决于用来安装产品的操作系统。该 xml\n                文件指定了后处理器的名称、一个全局标记、水印图像文件、水印图像文件的位置和要接收水印的目标页面。在清单 8 中，WatermarkImg.png\n                是水印图像文件的文件名。<\/p><h5 id=\"listing n8\">清单 8. 一个水印插件配置的示例 (pdfWatermark.xml)<\/h5><div class=\"codesection\"><pre class=\"displaycode\">&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;\n&lt;postprocessor name=\"PdfRedactedWatermark\"&gt;\n \t&lt;enableGlobally&gt;false&lt;/enableGlobally&gt;\n\t&lt;watermarkFile&gt;\n\t/server/conf/WatermarkImg.png\n\t&lt;/watermarkFile&gt;\n\t&lt;lowerLeft&gt;\n\t\t&lt;x&gt;0&lt;/x&gt;\n\t\t&lt;y&gt;0&lt;/y&gt; \n\t&lt;/lowerLeft&gt;\n\t&lt;pages&gt;1&lt;/pages&gt;\n&lt;/postprocessor&gt;<\/pre><\/div><p>使用文本编辑器打开配置文件 &lt;IBM_REDACTION_DATA&gt;\\server\\conf\\plugins.xml\n                并删除注释标记，以启用清单 9 中所示的定义。这会导致编校服务器在启动时加载 pdfWatermark.xml 配置文件。<\/p><h5 id=\"listing n9\">清单 9. 在 plugins.xml 中注册水印插件<\/h5><div class=\"codesection\"><pre class=\"displaycode\">&lt;plugin&gt;\n    &lt;pluginClass&gt;com.ibm.nex.redaction.postprocessors.PdfWatermarker&lt;/pluginClass&gt;\n    &lt;configFile&gt;pdfWatermark.xml&lt;/configFile&gt;\n&lt;/plugin&gt;<\/pre><\/div><p>如果 global 标记被设置为 <code>true<\/code>，那么水印会被应用到编校服务器的任何特性所处理的所有文档上。如果 global\n                标记被设置为 <code>false<\/code>，则必须在每个存储库处理器的配置文件中指定将应用水印的后处理器名称。清单 10\n                中所示的定义必须添加到配置文件中。（例如，作为\n                &lt;IBM_REDACTION_DATA&gt;\\server\\conf\\batchFileSystemProcessor.xml\n                文件。）<\/p><h5 id=\"listing n10\">清单 10. 存储库处理器配置文件中的水印插件的后处理器规范<\/h5><div class=\"codesection\"><pre class=\"displaycode\">&lt;postprocessors&gt;\n&lt;postprocessor&gt;PdfRedactedWatermark&lt;/postprocessor&gt; \n&lt;/postprocessors&gt;<\/pre><\/div><p>必须重新启动编校服务器，才能启用新设置。水印被添加到每个已编校的 PDF 文档中（图 5）。<\/p><h5 id=\"fig n5\">图 5. 包含水印的已编校文档输出的示例<\/h5><img alt=\"包含水印的已编校文档输出的示例\" src=\"/sunshine_new/images/负2102703252/fig5_watermarksample.jpg\" width=\"456\" /><h2 id=\"conclusion\">结束语<\/h2><p>XML 文档中的敏感数据可使用 IBM InfoSphere Guardium Data Redaction 删除，以确保信息安全。IBM\n                InfoSphere Guardium Data Redaction 可集成到您的 ECM\n                系统中，以便对您企业中的文档资源执行大规模编校。此外，编校系统可使用该产品的一些增强特性，比如安全查看器、时间戳扩展或水印插件。<\/p><h2 id=\"acknowledgements\">致谢<\/h2><p>感谢 InfoSphere Guardium Data Redaction 开发团队的 Joshua Fox 和 Michael Pelts\n                对本文的审阅以及提供的宝贵建议。<\/p><CMA ID: 971917><Site ID: 10><XSLT stylesheet used to transform this file: dw-document-html-7.0.xsl>\r\n\r\n\r\n<\/div>\r\n<\/div>\r\n","createTime":"2014-05-22 00:00:00","deployTime":"2014-05-22 00:00:00","id":0,"intro":"IBM InfoSphere Guardium Data Redaction 从企业跨部门的文档或与公众共享的文档中删除敏感数据。该产品支持各种文档格式。本文将介绍 InfoSphere Guardium Data Redaction 的一些特性，以及开始执行 XML 文档编校 (redaction) 的配置和编程技巧。","keyword":"","recommend":false,"source":"http://www.ibm.com/developerworks/cn/data/library/techarticle/dm-1307redaction/index.html","title":"通过高级编校实现更好的文档工作流","typeId":0,"updateTime":"2014-05-22 00:00:00"}
{"author":"","clickNumber":0,"content":"\r\n<div class=\"ibm-columns\">\r\n<div class=\"ibm-col-1-1\">\r\n\r\n<h2 id=\"1.前言 |outline\">前言<\/h2><p>文字是网页中很重要的组成部分。为文字选择一个合适的字体，能够更好的展现一个网站的个性，表达所要传递的信息，同时吸引用户来产生兴趣。<\/p><p>说到字体，我们首先会想到 CSS 里面的 font，例如：<\/p><div class=\"codesection\"><pre class=\"displaycode\">&lt;html&gt;\n&lt;head&gt;\n    &lt;style&gt;\n        p { font-family: Arial, Helvetica, sans-serif; }\n    &lt;/style&gt;\n&lt;/head&gt;\n&lt;body&gt;\n    &lt;p&gt;some text&lt;/p&gt;\n&lt;/body&gt;\n&lt;/html&gt;<\/pre><\/div><p>在这段 HTML 代码中为&lt;p&gt;标签定义了字体，当浏览器解析&lt;p&gt;some text&lt;/p&gt;标签时，首先会在系统中查找 Arial 这个字体，如果找不到，就找 Helvetica 字体，如果还是找不到，就会查找浏览器默认的 sans-serif(非衬线)字体，最后把文字渲染出来。<\/p><h2 id=\"2.什么是安全字体 |outline\">什么是安全字体<\/h2><p>安全字体这个概念，也许很多人都不是很熟悉，我们先举个例子：<\/p><div class=\"codesection\"><pre class=\"displaycode\">font-family: Arial, Helvetica, sans-serif;<\/pre><\/div><p>这个对字体（font-family）的定义就是一个安全字体。每种操作系统都有自己默认安装的字体，浏览器只能正常显示操作系统中安装了的字体。而不同的操作系统默认安装的字体不完全相同，有的甚至名称都不一样，在这种情况下，我们必须定义安全字体，使字体在所有的浏览器中都能够正常显示。<\/p><p>在上面这个 font-family 的定义中，我们选择 Arial 作为首选字体（注：Arial 字体是最常用的 sans serif 字体，也是 Windows 的默认字体，当字体很小是不容易阅读），但是，苹果系统中没有这个字体，所以我们选择 Helvetica（和 Arial 很相似）作为第二备选字体，最后我们选择 sans-serif 作为第三备选字体，如果在一个既没有 Arial 也没有 Helvetica 的系统里，那么浏览器会使用默认的 sans-serif 字体来渲染文字。这样，我们很大程度上保证了使用不同操作系统的访问者都能看到相同（至少是类似）的页面文字。<\/p><p>除了 Arial，常见的安全字体还有：<\/p><ul class=\"ibm-bullet-list\"><li>Verdana 字体，它是微软公司的核心字体之一，专门为屏幕显示而开发的。它的应用广泛，宽度大而易于阅读，是显示器中最清晰的字体。CSS 写法：font-family: Verdana, Geneva, sans-serif;\n<\/li><li>Times New Roman 字体，它是最常用的 serif 字体，是浏览器默认的字体。小号字的易读性也很差。CSS 写法：font-family: 'Times New Roman', Times, serif;\n<\/li><\/ul><p>有兴趣的读者可以通过这个链接来查阅常用的安全字体。<a href=\"http://www.w3schools.com/cssref/css_websafe_fonts.asp\">http://www.w3schools.com/cssref/css_websafe_fonts.asp<\/a><\/p><p>在网页开发中，应该尽量使用安全字体，也就是高度通用的字体，这样，访问者才能流畅的阅读网页的所有内容。<\/p><p>但是，网页设计师一定不会满足于使用这些安全字体，如何才能使用漂亮的字体，并能在普通用户的浏览器中被正确的渲染出来？答案是：使用@font-face 方案。<\/p><h2 id=\"3.@font-face 标签简介 |outline\">@font-face 标签简介<\/h2><p>@font-face 被列为了 CSS3 的一项新特性，其实它并不是什么新鲜技术，它最早出现在 CSS2 的规范定义中，但是在 CSS2.1 中又被删除，现在被正式列入 CSS3。目前主流的浏览器（IE 4+/Firefox 3.5+/Chrome 1+/Safari 3.1+/Opera 10+）都能够支持这个属性，所以不用担心会有浏览器兼容性问题。<\/p><p>@font-face 允许您在网页中使用电脑中没有安装的字体，完全摆脱安全字体的限制。只需将字体包安装在服务器上，当用户加载网页时，字体包会自动下载到用户机器上，保证字体能够正确渲染。<\/p><p>随着@font-face 的不断流行，产生了许多新的字体格式图标集，称为网络字体。Google Fonts API 就是基于@font-face 的特性开发的一套优秀的网络字体库。<\/p><p>网络字体的优点有很多：<\/p><ol type=\"1\"><li>使用的是真正的文本，而不是图片，放大和缩小都不会影响渲染效果，用户体验好；<\/li><li>可以被搜索引擎辨认；<\/li><li>不像图片每次需要重新生成，添加删除更方便。<\/li><\/ol><h2 id=\"4.如何使用 GoogleFontsAPI|outline\">如何使用 Google Fonts API<\/h2><p>Google Fonts 提供了超过 600 种的高质量的字体，所有的浏览器都兼容，无需引入 JavaScript，简单易用，更重要的是，免费。（虽然，暂时不支持中文字体，因为中文字体库实在是太大了）。<\/p><p>现在来看下，如何在网页中使用 Google Fonts。<\/p><h3 id=\"N10094\">挑选字体<\/h3><p>登录<a href=\"http://www.google.com/fonts/\">Google Fonts （谷歌字体官方网站）<\/a>。（图 1）<\/p><h5 id=\"N100A0\">图 1.Google Fonts 主页<\/h5><img alt=\"Google Fonts 主页\" src=\"/sunshine_new/images/负9437881/image003.jpg\" width=\"550\" /><p>在主页中，您可以直接浏览所有的字体，可以按单个词语来查看，或者按句子段落来查看整体效果，还可以调整字体大小。如果您对字体分类比较熟悉，就可以使用左边的搜索条件对字体作筛选。找到您喜欢的字体之后，点击\"Add to Collection\"按钮，然后在网页下方的\"Collection\"中即可找到您添加的所有字体。<\/p><h3 id=\"N100AD\">使用选中的字体来测试您的文字<\/h3><p>在上一页面（图 1）的\"Collection\"中，点击\"review\"。在预览页面中（图 2），输入您的测试文字，来查看效果。另外在\"review\"页面上，您还可以调整其它的与字体相关的样式，比如字体大小，间隔，变换，等等。在图 2 中，我们选择测试的是\"Condiment\"字体<\/p><h5 id=\"N100B5\">图 2.Google Fonts 预览页面<\/h5><img alt=\"Google Fonts 预览页面\" src=\"/sunshine_new/images/负9437881/image005.jpg\" width=\"410\" /><h3 id=\"N100C0\">在您的网页中添加字体链接。<\/h3><p>如果确认使用该字体， 在网页下方的\"Collection\"中，点击\"Use\"按钮，在接下来的页面中，您将看到详细的说明，包括字体链接和如何将字体添加到您的网页中。<\/p><p>有三种方式来添加字体链接： <\/p><ul class=\"ibm-bullet-list\"><li>Standard 方式：\n<div class=\"codesection\"><pre class=\"displaycode\">&lt;link rel='stylesheet' type='text/css'\nhref='http://fonts.googleapis.com/css?family=Condiment'&gt;<\/pre><\/div><\/li><li>@import 方式：\n<div class=\"codesection\"><pre class=\"displaycode\">@import url(http://fonts.googleapis.com/css?family=Condiment);<\/pre><\/div><\/li><li>JavaScript 方式：\n<p>（通过添加动态脚本并执行来导入字体，代码省略）<\/p><\/li><\/ul><p>下一步定义在那个标签上使用该字体，例如：在&lt;class=\"myheader\"&gt;标签上使用，<\/p><p>.myheader {font-family: 'Condiment', cursive;}<\/p><p>大功告成，您现在可以打开您的网页欣赏一下了(图 3)。<\/p><h5 id=\"N100E2\">图 3.测试页面效果<\/h5><img alt=\"测试页面效果\" src=\"/sunshine_new/images/负9437881/image007.jpg\" width=\"576\" /><h5 id=\"N100EF\">清单 1.测试页面代码<\/h5><div class=\"codesection\"><pre class=\"displaycode\">&lt;html&gt;\n          &lt;head&gt;\n                     &lt;link rel=\"stylesheet\" type=\"text/css\"           \n                               href='http://fonts.googleapis.com/css?family=Condiment'&gt;\n                    &lt;style&gt;\n                             .myheader {\n                                        font-family: Condiment, cursive;\n                                        font-size: 48px;\n                                        text-align: center;\n                               }\n                    &lt;/style&gt;\n          &lt;/head&gt;\n          &lt;body&gt;\n                     &lt;div class=\"myheader\"&gt; Test my own text !&lt;/div&gt;\n          &lt;/body&gt;\n&lt;/html&gt;<\/pre><\/div><h3 id=\"N100F4\">优化字体包加载<\/h3><p>如果您不是大范围的在网页中使用 Google 字体，只是在标题或 logo 里使用，那么可以在 url 里添加 text 参数，来限制加载的字体包的大小，最高能缩减 90%左右的大小，以此来节约下载流量。例如：http://fonts.googleapis.com/css?family= Condiment'&amp;text=Hello<\/p><p>这样，您只会下载 h，e，l，o 这四个字母的字体，大大缩小了字体包的大小。<\/p><h3 id=\"N100FD\">下载字体包<\/h3><p>您还可以把字体包下载并安装到本地，这样您就可以在本地使用这些字体，比如在 Notepad，Microsoft Office 里。<\/p><p>方法为：在图 3 中，点击下载按钮<img alt=\"\" src=\"/sunshine_new/images/负9437881/image009.jpg\" width=\"29\" />， 选择\"Download the font families in your Collection as a zip file\"<\/p><h3 id=\"N1010E\">高级应用 API<\/h3><p>Google Fonts 还开放了一些接口（称为 Developer API），用于获取字体库的信息数据。<\/p><p>比如实时获取字体库实际可用的字体及其相关信息：<\/p><p><a href=\"https://www.googleapis.com/webfonts/v1/webfonts?key=YOUR-API-KEY\"><code>https://www.googleapis.com/webfonts/v1/webfonts?key=<\/code><\/a><a href=\"https://www.googleapis.com/webfonts/v1/webfonts?key=YOUR-API-KEY\"><code><em>YOUR-API-KEY<\/em><\/code><\/a><\/p><p>这个请求的返回结果是一个 JSON 类型的数据，包括了每种字体的名称，样式种类（比如 regular，italic），版本，修改时间，包含的样式包的请求地址，等等。<\/p><p>请注意，在 URL 里面有一个 key，这个 key 是和您的 web 应用工程相联系的，只有注册过的 web 应用才能成功调用 Developer API。我们必须要在 Google Cloud Console 注册之后，才能获取这个 key。<\/p><p>关于这个 Developer API， 可以参阅这个<a href=\"https://developers.google.com/fonts/docs/developer_api\">链接<\/a>。<\/p><h2 id=\"7.结束语 |outline\">结束语<\/h2><p>Google Fonts 很强大，但是也碰到一些加载的问题，最好还是字体声明的时候，在最后添加一个安全字体，来保证万无一失。另外的一个建议是，在网页中要适量的使用花样的字体，让整个页面保持干净简洁。<\/p><CMA ID: 971886><Site ID: 10><XSLT stylesheet used to transform this file: dw-document-html-7.0.xsl>\r\n\r\n\r\n<\/div>\r\n<\/div>\r\n","createTime":"2014-05-22 00:00:00","deployTime":"2014-05-22 00:00:00","id":0,"intro":"在线字体提供丰富多样的字体样式，能使页面更美观，更具吸引力。Google Fonts 就是一个开源的在线字体库，使用起来简单快速。","keyword":"","recommend":false,"source":"http://www.ibm.com/developerworks/cn/web/1505_zhangyan_googlefont/index.html","title":"使用 Google Fonts 为网页添加美观字体","typeId":0,"updateTime":"2014-05-22 00:00:00"}
{"author":"","clickNumber":0,"content":"\r\n<div class=\"ibm-columns\">\r\n<div class=\"ibm-col-1-1\">\r\n\r\n<h2 id=\"introduction\">简介<\/h2><p>此文章系列的 <a href=\"http://www.ibm.com/developerworks/data/library/techarticle/dm-1306mongodb/index.html\" onmouseover=\"linkQueryAppend(this)\">第 1 部分<\/a> 介绍了 MongoDB 和 InfoSphere Guardium，提供了有关 InfoSphere Guardium 如何帮助您在更多应用程序中利用 MongoDB 让您感到更安全（因为它能够完全监视和审计数据活动）的一些背景信息。您了解了该解决方案的架构以及使用其原生功能保障 MongoDB 安全的一些建议，还了解了 InfoSphere Guardium 所带来的优势。<\/p><p>本文是此文章系列的第二篇文章，将详细介绍以下两个主题：<\/p><ul class=\"ibm-bullet-list\"><li>在 MongoDB 节点上配置 S-TAP <\/li><li>为各种典型的用例创建安全策略<\/li><\/ul><p>第 3 部分将介绍其他一些功能，比如阻止用户、如何编写报告和访问审计数据，以及如何自动化合规性审计。<\/p><h2 id=\"installconfig\">安装和配置<\/h2><p>这一节将介绍设置和运行以及开始将 MongoDB 中的活动记录到 InfoSphere Guardium 收集器中所需的步骤。<\/p><ol><li> 在 MongoDB 节点上安装 S-TAP 代理。<\/li><li>使用正确的 MongoDB 端口配置 S-TAP 检查引擎。<\/li><li>验证您是否正在查看 MongoDB 流量。<\/li><\/ol><h3 id=\"N100AF\">开始之前<\/h3><p>本文假定您安装了 InfoSphere Guardium 收集器并在网络上进行了配置。针对 MongoDB 的 InfoSphere Guardium 活动监视要求使用 V9 GPU 50 或更高版本。如果您是 InfoSphere Guardium 客户并有资格升级到 V9.0，那么您可以先从 Passport Advantage 下载 Guardium，然后再安装 GPU（您可以从 Fix Central 获取它）。<\/p><p> 支持的 MongoDB 版本为 2.0、2.2 和 2.4。从数据安全的角度讲，建议您升级到 MongoDB 2.4 或更高版本，因为这些版本可提供简介中所述的安全增强功能。（Kerberos 要求使用企业版。）<\/p><p>记录以下信息，您需要使用这些信息来完成该解决方案的安装和配置：<\/p><ul class=\"ibm-bullet-list\"><li>InfoSphere Guardium 收集器的 IP 地址和用于连接它的 端口 (16016)<\/li><li>分片服务器上 mongod 所使用的端口（默认值为 27018）和 IP 地址<\/li><li>路由服务器 (mongo) 使用的端口（默认值为 27017）和 IP 地址<\/li><\/ul><h3 id=\"installstap\">在 MongoDB 节点上安装 S-TAP 代理\n                <\/h3><p> 如图 1 所示，我们建议在 mongod 分片服务器和路由服务器上安装 S-TAP，以便监视在 mongod 分片服务器上可能发生的任何管理员活动。<\/p><h5 id=\"fig1\">图 1. S-TAP 被配置为侦听 MongoDB 端口<\/h5><img alt=\"mongo 上的 S-TAP 侦听 27017，在 mongod（分片）上侦听 27018。\" src=\"/sunshine_new/images/967770037/mongodbstaps.png\" width=\"345\" /><p>S-TAP 是特定于操作系统的，因此您需要为每个相应的节点安装 Linux&#174; S-TAP。可以采用两种不同的方法来完成此操作：<\/p><ul class=\"ibm-bullet-list\"><li> 使用 Guardium Installation Manager (GIM)。借助 GIM，您实际上是在安装 GIM 代理和 S-TAP。通过使用 GIM，可以从 Web 控制器控制所有 S-TAP 升级和未来安装，无需再次访问服务器。由于管理和更新非常简单，所以大多数企业都会使用 GIM。有关 GIM 的详细信息，请参阅 InfoSphere Guardium 信息中心。有关的链接，请参阅 <a href=\"#resources\">参考资料<\/a>。\n                    <\/li><li>使用您从 Fix Central 下载的 S-TAP shell 安装程序。可以采用非交互式完成该操作，这样您就可以使用同一个命令在很多节点上安装。<\/li><\/ul><p> 该过程的详细信息不在本文的讨论范围之内，但是您可以参阅 InfoSphere Guardium 信息中心，获得有关的详细信息。<\/p><p>如果您的 S-TAP 被正确配置为连接到 InfoSphere Guardium 收集器，那么管理控制台中的系统视图将显示为绿色，如图 2 所示。<\/p><h5 id=\"fig2\">图 2. 显示 S-TAP 与收集器正在通信的系统视图<\/h5><img alt=\"显示 3 个显示为绿色的 mongo staps 屏幕\" src=\"/sunshine_new/images/967770037/statusmonitor.jpg\" width=\"580\" /><h3 id=\"inspection\">配置检查引擎<\/h3><p>接下来，您需要为每个 S-TAP 配置检查引擎。检查引擎提供了您定义 S-TAP 使用哪个协议进行监视 (MongoDB) 以及要监视哪些端口的方式。默认情况下，如 <a href=\"#fig1\">图 1<\/a> 所示，用于 mongo 的端口为 27017，而用于 mongod（分片）的端口为 27018。您的端口可能有所不同。<\/p><p>要配置检查引擎，请以管理员身份登录 InfoSphere Guardium，并导航到 Administration Console。从左侧的菜单窗格中，选择 <strong>Local Tap s&gt; S-TAP Control<\/strong>。找到 Mongos 服务器的 S-TAP，单击 <strong>Modify<\/strong>，然后选择 <strong>Add Inspection engine<\/strong> 下列菜单。<\/p><p>输入所需的端口信息。您的 mongos 检查引擎配置应如图 3 所示。<\/p><h5 id=\"fig3\">图 3. Mongos（查询路由器服务器）检查引擎配置<\/h5><img alt=\"显示端口范围 27017 到 27017 的 IE 配置屏幕\" src=\"/sunshine_new/images/967770037/mongosie.jpg\" width=\"392\" /><p>在分片服务器上，配置看起来会稍有不同。因为您可能知道，大多数 “正常” 活动都是通过 mongos 进行路由，然后路由到分片服务器上的 mongods。如果您监视了分片服务器上的所有流量，那么 Guardium 收集器会从 mongos 以及该命令路由到的所有分片服务器收到同一个消息。为了避免这种 “双重计算”，同时仍然能够监视通过 mongos 的所有流量，可将分片服务器上的 STAP 配置为排除所有 mongos 流量。<\/p><h5 id=\"fig4\">图 4. Mongod（分片）检查引擎配置<\/h5><img alt=\"显示端口范围 27018 到 27018 的 IE 配置屏幕。排除 clientIP 具有 mongos 的 IP 地址\" src=\"/sunshine_new/images/967770037/mongodie.jpg\" width=\"389\" /><h3 id=\"api\">使用 API 配置检查引擎<\/h3><p>如果您有很多节点，那么您可能会希望使用 Guardium API 向指定的 S-TAP 中添加检查引擎。只能从该 S-TAP 的活动 Guardium 主机修改 S-TAP 配置，并且只能在 S-TAP 处于联机状态（在系统概述中显示绿色）时修改 S-TAP 配置。<\/p><p><strong>对于 mongos：<\/strong><\/p><div class=\"codesection\"><pre class=\"displaycode\">grdapi create_stap_inspection_engine client=0.0.0.0/0.0.0.0 protocol=MongoDB \nktapDbPort=27017 portMax=27017 portMin=27017 \nstapHost=&lt;ip of Mongos server where associated STAP is installed&gt;<\/pre><\/div><p><strong>对于 mongod：<\/strong><\/p><div class=\"codesection\"><pre class=\"displaycode\">grdapi create_stap_inspection_engine protocol=MongoDB \nktapDbPort=27018 portMax=27018 portMin=27018  \nstapHost=&lt;ip of mongod server where STAP is installed&gt; \nclient=0.0.0.0/0.0.0.0 excludeClient=&lt;ip of Mongos&gt;<\/pre><\/div><h3 id=\"validate\">验证是否正在捕获流量<\/h3><p>有几种方法判断是否正在向 Guardium 收集器发送流量。有经验的 Guardium 用户可以确保安装了将捕获所有流量并查看报告的策略。<\/p><ul class=\"ibm-bullet-list\"><li>如果以用户身份登录，那么在 View 选项卡上，您会看到一个名为 <strong>Number of db per type<\/strong> 的条形图。您可以双击该报告下钻获取数据，以便查看是否有活动。\n<h5 id=\"fig6\">图 5. 报告下钻<\/h5><img alt=\"双击 Mongodb 数据库类型以显示客户端 IP 的报告，然后双击该报告以到达 fullsql\" src=\"/sunshine_new/images/967770037/reportdrilldown.jpg\" width=\"580\" /><\/li><li>如果您正在进行 Guardium 9.0.0.50 的全新安装，或者升级并安装了新的默认策略（名为 Default-Ignore Data Activity for Unknown Connections），那么您不会看到详细的活动。但是，您需要进入 Connection Profile List 报告，该报告将只显示任何未知连接的高级会话信息，其中包括来自 MongoDB 的那些连接的会话信息，此时这些连接应该全都是未知连接。作为一个用户，您可以在 DB Activities 下的 View 选项卡上找到该报告，如图 6 所示。\n<h5 id=\"fig7\">图 6. Connection Profile List<\/h5><img alt=\"View &gt;DB Activities&gt;Connection profile list\" src=\"/sunshine_new/images/967770037/view-clp.jpg\" width=\"338\" /><p>作为一名管理员，您会在 Daily Monitor 选项卡上找到该报告。<\/p><\/li><\/ul><p>该报告如图 7 所示。它包含数据库用户名、客户端 IP 以及整个连接信息 “元组”，它标识了连接信息，比如客户端 IP、源应用程序、数据库用户名、服务器 IP 以及服务名称。<\/p><h5 id=\"fig7.5\">图 7. Connection Profile List<\/h5><img alt=\"查看上述列表主要内容的说明\" src=\"/sunshine_new/images/967770037/connectionprofilelist.jpg\" width=\"580\" /><p>如果您确定自己的策略配置正确，但仍然没看到流量，那么请确保您拥有报告的正确日期和时间范围。如果这也没有问题，那么可能是因为在您的 S-TAP 或检查引擎中包含一些不正确的配置，比如不正确的端口号。<\/p><h2 id=\"creategroups\">创建要在策略和报告中使用的组<\/h2><p>我们进行的一项重要的规划练习是创建组，创建组可以大大提高效率。例如，您可以创建管理员（特权用户）用户组、敏感数据对象组、特定命令（比如分配用户和全新的命令）组和其他任何事项。对于本文，我们将介绍一些监视用例，以及如何创建策略规则以处理那些用例。几乎所有这些规则都要求使用组。表 1 是我们将要创建的规则的摘要以及每个规则中要使用的组。<\/p><h5 id=\"table1\">表 1. 用于创建我们的样例策略规则的规则和组<\/h5><table border=\"0\" cellpadding=\"0\" cellspacing=\"0\" class=\"ibm-data-table\" summary=\"3 column table, all columns left-aligned\"><thead xmlns:dw=\"http://www.ibm.com/developerWorks/\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"><tr><th scope=\"col\">规则顺序<\/th><th scope=\"col\">规则说明<\/th><th scope=\"col\">在规则中使用的组<\/th><\/tr><\/thead><tbody xmlns:dw=\"http://www.ibm.com/developerWorks/\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"><tr><td>1<\/td><td>3 分钟之内每个数据库每个用户登录失败的次数过多就会发出警告<\/td><td>不需要。请参阅 <a href=\"#logfail\">在身份验证失败次数过多时发出实时警告<\/a>。<\/td><\/tr><tr><td>2<\/td><td>忽略功能用户 ID 的详细活动<\/td><td>在策略规则编辑器中对 ClientIP/Src App./DB User/Server IP/Svc.Name 字段使用 “元组” 组构建器。有关的详细信息，请参阅 <a href=\"#ignore\">忽略功能用户的活动<\/a>。<\/td><\/tr><tr><td>3<\/td><td>SkipMongoDB 内部命令<\/td><td>MongoDBSkipCommands（预先填充的组，您可以根据观察到的流量按需添加更多的组。）有关的详细信息，请参阅 <a href=\"#noise\">过滤干扰命令<\/a>。<\/td><\/tr><tr><td>4<\/td><td> 记录管理员用户活动的所有详细信息<\/td><td> 管理员用户 - 创建您自己的管理员用户组，或者修改现有的管理员用户组。在本文中，我们创建了自己的管理员用户组。请参阅 <a href=\"#detail\">特权用户的详细监视<\/a>。<\/td><\/tr><tr><td>5<\/td><td>在特权用户访问敏感数据时发出警告。<\/td><td> 管理员用户 <br /> MongoDB 敏感对象 C  创建您自己的 MongoDB 敏感对象<br /><br /><strong>可选：<\/strong>添加您希望发出警告的一组特定命令。我们创建了一个名为 MongoDB WatchCommands 的命令。请参阅 <a href=\"#sensitivealert\">在特权用户访问敏感数据时发出实时警告<\/a>。<\/td><\/tr><tr><td>6<\/td><td>对 MongoDB Access Control 命令发出警告<\/td><td>不需要使用组。记录对 system.users 集合的访问。请参阅 <a href=\"#alertdcl\">对 Data Control 命令发出实时警告<\/a>。<\/td><\/tr><tr><td>7<\/td><td>记录集合更改是否违反策略<\/td><td>MongoDB Change Commands - 创建您自己的 MongoDB 更改命令<br /><br /><strong>可选：<\/strong>添加生产中一组对象或即将生产的一组对象（集合），对于这些对象来说，集合中的更改或丢弃集合可能会影响应用程序。请参阅 <a href=\"#schemachange\">记录可能会影响应用程序的集合策略违反情况<\/a>。<\/td><\/tr><tr><td>8<\/td><td>敏感文档读取次数过多<\/td><td>MongoDB Sensitive Objects C 创建您自己的 MongoDB 敏感对象<br />请参阅 <a href=\"#recordsaffected\">实时警告：对敏感数据的读取访问超过阈值<\/a>。<\/td><\/tr><\/tbody><\/table><p>在此文章系列的第 3 部分中，我们将会介绍另一个高级功能，您可以使用策略规则及时阻止访问。该功能需要一个许可证才能进行高级活动监视。<\/p><p>要创建一个组，请访问 Group Builder。如果您以管理员的身份进行登录，请单击 <strong>Tools<\/strong> 选项卡，并从左侧菜单窗格中选择 <strong>Config &amp; Control <\/strong> &gt; <strong>Group Builder<\/strong>。在 <a href=\"#ignore\">我们的策略规则示例之一<\/a> 中将会描述 Group Builder 界面的详细信息。<\/p><h2 id=\"secpolicy\">配置安全策略<\/h2><p>基于规则的安全策略是 InfoSphere Guardium 工作原理的核心。正是通过这些规则，您可以指定 InfoSphere Guardium 要记录哪些流量、在哪些条件下会发出警告以及要阻止哪些连接。<\/p><p>9.0.0.50 的全新 InfoSphere Guardium 安装将会包含一个忽略所有流量的默认策略。该默认策略可帮助保护您的网络，防止在激活 S-TAP 和开始监视数据库时出现过载。<\/p><p>我们无法在本文中介绍所有各式各样的策略规则类型及其行为。我们选择了一些常用的监视用例，并介绍了如何为这些用例配置策略规则。我们将在本文的下一小节中介绍这些用例。<\/p><p>现在，让我们创建一个新的策略，您可以使用该策略开始添加规则。<\/p><ol><li>单击 <strong>Tools<\/strong> 选项卡，并从左侧的菜单窗格中选择 <strong>Config &amp; Control <\/strong> &gt; <strong>Policy Builder<\/strong>。<\/li><li>从 Policy Finder 中单击 <strong>New<\/strong>。\n            \n            \n<h5 id=\"fig8\">图 8. 创建新策略<\/h5><img alt=\"单击 new 按钮\" src=\"/sunshine_new/images/967770037/newpolicy.jpg\" width=\"500\" /><\/li><li> 提供相关说明，然后单击 <strong>Apply<\/strong>。\n            \n            \n<h5 id=\"fig9\">图 9. 为该策略提供一个说明 <\/h5><img alt=\"单击 applybutton\" src=\"/sunshine_new/images/967770037/policydefapply.jpg\" width=\"471\" /><p><strong>可选<\/strong>：单击 <strong>Roles<\/strong> 以提示哪些角色可以使用这个新策略。例如，如果您选择管理员，那么具有管理员角色的任何人都可以在系统中使用该策略。<\/p><\/li><li>单击 <strong>Back<\/strong>。<\/li><\/ol><p>现在，您可以通过添加所需的规则来编辑该策略。我们将在下一小节中介绍一些典型的规则。仅当您准备好验证某个新规则或一组规则的行为时，才应安装这个新策略。<\/p><h2 id=\"usecase\">监视用例<\/h2><p>在这一小节中，我们将会介绍涉及其他用例的一些额外的策略规则，这些用例可能适用于您的组织机构，也可能不适用，但这些用例会让您了解一些启动方法。<\/p><p>如果以前从未使用过 InfoSphere Guardium，那么您需要了解的一个重要概念就是策略可以包含任意数量的规则。每个规则都有说明、条件（根据这些条件评估受监视的活动）以及在触发规则时将要启动的操作。<\/p><p>有三种类型的规则：<\/p><ul class=\"ibm-bullet-list\"><li><strong>Access<\/strong>：用于数据库客户端和服务器之间的交互。<\/li><li><strong>Exception<\/strong>：用于数据库服务器向客户端返回的任何异常。请注意，如果您对 MongoDB 连接使用 write concern =0 或 -1（不安全），那么您将无法记录和报告任何插入、更新或移除（删除）返回的错误条件。<\/li><li><strong>Extrusion<\/strong>：应用于返回的数据集。这是一个高级功能，在本文中我们不打算讨论这个问题。<\/li><\/ul><h3 id=\"logfail\">在身份验证失败次数过多时发出实时警告<\/h3><p>防范可能通过算法生成密码的黑客的常见要求是：在某个会话中尝试失败的数量超过您定义的某个阈值时发出警告，比如在 3 分钟内尝试次数超过 5 次。<\/p><p>对于本规则，将会定义一个异常规则。<\/p><ol><li>从 Policy Finder 中选择您的新策略并单击 <strong>Edit Rules<\/strong>。\n<h5 id=\"fig10\">图 10. 编辑新策略的规则<\/h5><img alt=\"单击 Edit Rules 按钮\" src=\"/sunshine_new/images/967770037/editrules.jpg\" width=\"580\" /><\/li><li>在 Policy Rules 页面的底部，单击 <strong>Add Exception Rule<\/strong>。<\/li><li>填写策略条件，以便从 Excpt. Type 字段的下拉菜单中指定 LOGIN_FAILED。包含最小计数（在本例中为 5）并重置间隔（在本例中为 3 分钟）。\n<h5 id=\"fig11\">图 11. 指定引发登录失败规则的条件<\/h5><img alt=\"参见上面的文本描述。\" src=\"/sunshine_new/images/967770037/loginfailurerule.jpg\" width=\"580\" /><\/li><li> 在页面底部，单击 <strong>Add Action<\/strong>，然后从下拉菜单中选择 <strong>ALERT ONCE PER SESSION<\/strong>。该操作将在某人在 3 分钟内身份验证失败超过 5 次而无法成功实现身份验证时为每个会话生成一个警告。\n<h5 id=\"fig12\">图 12. 选择一个会话一次警告<\/h5><img alt=\"参见上面的文本描述。\" src=\"/sunshine_new/images/967770037/actionalertoncepersession.jpg\" width=\"468\" /><\/li><li> 选择通知类型。在我们的示例中，我们选择了 SYSLOG 和默认的消息模板。单击 <strong>Add<\/strong>，然后单击 <strong>Apply<\/strong>。\n<h5 id=\"fig13\">图 13. 选择通知类型<\/h5><img alt=\"参见上面的文本描述。\" src=\"/sunshine_new/images/967770037/alertreceiver.jpg\" width=\"576\" /><\/li><\/ol><p><strong>警告示例：<\/strong>图 14 显示当您以管理员身份登录时 Incident Management 选项卡上的警告示例。<\/p><h5 id=\"fig14\">图 14. 关于登录失败次数的警告（部分输出）<\/h5><img alt=\"警告包含警告的名称以及生成警告的客户端和服务器 IP。\" src=\"/sunshine_new/images/967770037/failed_logins_partial.jpg\" width=\"580\" /><h3 id=\"ignore\">忽略功能用户或连接的活动<\/h3><p>一些组织机构拥有定期授权作业，执行一些类似于批量更新或加载的工作，这些工作需要在夜间或指定的批处理窗口中进行。这些应用程序通常是经过精挑细选的，并且在功能用户 ID 下运行。为了避免 InfoSphere Guardium 收集器中满都是与审计无关的活动，一些组织机构将使用一个名为 “Ignore S-TAP session” 的访问规则操作。<\/p><p> 请注意，系统仍然会记录会话开始和结束信息（即，时间戳、客户端 IP、服务器 IP、用户名等等）。该规则只表示会忽略详细的命令活动。<\/p><div class=\"dw-sidebar ibm-inset\"><h2 id=\"N102BA\">安排策略<\/h2><p>InfoSphere Guardium 支持您可以安排策略安装，这意味着您在夜间可以拥有与白天不同的一组规则。您可以将该规则添加到该策略的另一个副本中，以便在您知道正在进行某个维护作业时自动安排夜间要安装的内容。<\/p><\/div><p><strong>建议：<\/strong>您可以创建一组功能用户并忽略这些用户的活动，但是，如果您想降低丢失可疑活动的可能性，那么可以使用 <em>connection information<\/em> 来指定规则。例如，您可能想忽略来自客户端 IP 1.22.222.222 的功能用户的活动，但是，如果该用户 ID 正在通过其他任何 IP 访问该系统，那么您可能会希望记录该活动。<\/p><p> 因此，我们将创建一个名为 “Functional MongoDB User Connections” 的组，并在我们的策略规则中使用该组。我们将会介绍填充该组的手动方法，以及通过使用 <a href=\"#hint\">Connection Profile List 报告<\/a> 的自动填充组的方法。<\/p><p>确切地说，该策略中访问规则字段的名称为 Client IP/SrcApp/DBUser/Server IP/Svc.Name。该特殊字段有多个组件，这些组件在 Guardium 中称为 “元组”。<\/p><p>您可以使用通配符替代该连接信息的任何部分。下面我们介绍一下通配符的工作原理。<\/p><ol><li>从 Policy Finder 中选择您的新策略，然后单击 <strong>Edit Rules<\/strong>。<\/li><li>在 Policy Rules 页面的底部，单击 <strong>Add Access Rule<\/strong>。\n<h5 id=\"fig15\">图 15. 添加访问规则<\/h5><img alt=\"单击 Access Access rule 按钮以显示规则构建器屏幕。\" src=\"/sunshine_new/images/967770037/addaccessrule.jpg\" width=\"400\" /><\/li><li>为您的新规则提供一个名称，然后单击该元组字段 (Client IP/SrcApp/DB User/Server IP/Svc.Name) 的组构建器图标，如图 16 所示。\n<h5 id=\"fig16\">图 16. 单击该策略规则的连接元组字段的组构建器<\/h5><img alt=\"单击您要为其创建组的 t 字段右侧的组构建器图标。\" src=\"/sunshine_new/images/967770037/clickongroupbuildericon.jpg\" width=\"492\" /><\/li><li> 为元组的每个组件填充属性。您可以使用通配符指示任何内容都有资格进行此操作。在本例中，我们让功能用户 ID 遵循一个命名惯例，因此我们会使用该惯例。此外，我们还知道这些用户 ID 所进行的工作始终来自某个特定的客户端 IP，因此我们还将添加该内容。\n<h5 id=\"fig17\">图 17. 添加一个元组作为组成员\n                            <\/h5><img alt=\"属性 1 是一个 ip，属性 2 是 %，属性 3 是 FUNC%，属性 4 是 %，而属性 5 是 %。\" src=\"/sunshine_new/images/967770037/addtuplegroup.jpg\" width=\"580\" /><\/li><li>当您填充完一个成员的属性后，请单击 <strong>Add<\/strong>。该组应如图 18 所示。\n<h5 id=\"fig18\">图 18. 元组已添加到该组中<\/h5><img alt=\"9.70.144.253+%+%FUNC%+%+%t .\" src=\"/sunshine_new/images/967770037/addtuplegroup_2.jpg\" width=\"393\" /><\/li><li>添加完成员后，请单击 <strong>Back<\/strong>。<\/li><li>从策略规则的元组字段中选择该组。<\/li><li> 单击 <strong>Add Action<\/strong> 并从下拉菜单中选择 <strong>IGNORE S-TAP SESSION<\/strong>。单击 <strong>Apply<\/strong>。该规则现在应如图 19 所示。\n<h5 id=\"fig19\">图 19. 忽略功能用户（受信任用户）连接的 S-TAP 会话<\/h5><img alt=\"该策略规则拥有 MongoDB Functional Users 连接组的 IGNORE S-TAP SESSION 操作。\" src=\"/sunshine_new/images/967770037/functionaluserpolicy.jpg\" width=\"580\" /><strong>注意：<\/strong>我们取消选中了 <strong>Cont. to next rule<\/strong>。这是因为该会话没有理由进入下一个规则，因为我们已经选择忽略该用户和连接的所有活动。<\/li><li>单击 <strong>Save<\/strong>。<\/li><\/ol><h3 id=\"hint\">提示：让填充 Functional User Connections 组的过程自动进行<\/h3><p>如果您的 MongoDB 流量已经受到监视，那么您可以使用内置的 Connection Profile List 报告自动化该过程。如果您以管理员身份进行登录，那么请转到 Daily Monitor 选项卡，并单击左侧菜单窗格中的 <strong>Connection Profiling List<\/strong>。<\/p><p> 您会看到类似于图 20 的一个报告。<\/p><h5 id=\"fig20\">图 20. Connection Profile List 示例<\/h5><img alt=\"该图显示了报告的一部分，并显示了该元组列，在实时活动中已经填充了一些连接。\" src=\"/sunshine_new/images/967770037/connectionprofileblowup.jpg\" width=\"580\" /><p>在该报告的底部，单击 <strong>Invoke 图标<\/strong> (<img alt=\"icon\" src=\"/sunshine_new/images/967770037/invokeicon.jpg\" width=\"37\" />)，以调用 API create_member_to_group_by_desc。在弹出窗口中，将描述字段更改为您要向其中添加此连接的组的名称，然后单击 <strong>Invoke now<\/strong>，如图 21 所示。<\/p><h5 id=\"fig21\">图 21. Connection Profile List 示例<\/h5><img alt=\"描述字段被更改为 MongoDB Functional User 连接。\" src=\"/sunshine_new/images/967770037/addmembertogroup.jpg\" width=\"464\" /><h3 id=\"noise\">过滤干扰命令<\/h3><p>该规则将过滤掉 MongoDB 在内部发出的一些干扰命令，比如健康检查和服务器之间的通信。它使用了一个内置的组，名为 MongoDB Skip Commands。<\/p><ol><li>从 Policy Finder 中选择您的策略并单击 <strong>Edit Rules<\/strong>。<\/li><li>在 Policy Rules 页面的底部，单击 <strong>Add Access Rule<\/strong>。<\/li><li>在标签为 <strong>Command<\/strong> 的策略规则的部分中，从组下拉菜单中选择 MongoDB Skip Commands 组，如图 22 所示。\n<h5 id=\"fig22\">图 22. 从 Group 下拉菜单中选择 MongoDB Skip Commands<\/h5><img alt=\"参见文本描述。\" src=\"/sunshine_new/images/967770037/skipcommandgroup.jpg\" width=\"580\" /><\/li><li>取消选中 Cont. to next rule 框（如果已选中）。因为没有任何进一步操作（这可能发生在该组中的任何命令上），因此该操作节省了处理时间。<\/li><li>在策略规则的底部，选择 <strong>SKIP LOGGING<\/strong> 作为您的操作并单击 <strong>Apply<\/strong>。<\/li><li>保存您的规则。<\/li><\/ol><h3 id=\"detail\">特权用户的详细监视<\/h3><p>在 2.4 中，MongoDB 支持很多新角色，根据它们的作用域，可以将它们大致分为服务器范围的角色和数据库范围的角色。在这两种情况下，都有侧重于用户管理、群集管理和应用程序访问的角色。<\/p><p>由于这些角色中的一些角色基本上等同于超级用户，因此需要确保谨慎分发和监视这些角色，这一点非常重要。<\/p><p>一些组织机构要求详细监视管理用户（特权用户）的任何活动。为此要进行的策略规则操作是 LOG FULL DETAILS。无论在何时，只要使用 LOG FULL DETAILS，就会捕获每个操作的确切时间戳以及全部详细信息。确保您正确设定了您的内部 InfoSphere Guardium 存储库的大小以及设备上的缓冲区大小，以处理该工作负荷，在您的特权用户读取或写入很多文档时尤其如此。<\/p><p><strong>先决条件：<\/strong>创建如上所述的一个 MongoDB 管理员用户组（其中包括您认为是 “特权用户” 的任何人）。<\/p><p>访问您的 MongoDB 策略，然后单击 <strong>Add Access Rule<\/strong>。<\/p><p>向图 23 所示的规则的 DB User 字段中添加一个描述并添加您的管理员用户组。<\/p><h5 id=\"fig23\">图 23. 侧重于 DB User 条件的策略规则摘要<\/h5><img alt=\"DB User 字段拥有一个指定为条件的 MongoDBAdmins 组\" src=\"/sunshine_new/images/967770037/mongodbadminsrule.jpg\" width=\"580\" /><p>由于我们将在一些管理员用户活动上添加一个警告作为下一个规则，因此务必确保选中了 <strong>Cont.to next rule<\/strong> 复选框并选中了操作 <strong>LOG FULL DETAILS<\/strong>，如图 24 所示。<\/p><h5 id=\"fig23a\">图 24. “Continue to next” 规则可确保 Guardium 会在引发该规则的时候处理下一个规则<\/h5><img alt=\"显示 Cont. next rules 按钮被选中并且选择了 log full details 操作，apply 和 save 突出显示\" src=\"/sunshine_new/images/967770037/logfulldetailsaction.jpg\" width=\"580\" /><p>如果您要测试策略规则，您必须安装该规则。转到 <strong>Tools<\/strong> &gt; <strong>Policy Builder<\/strong> &gt; <strong>Install and override<\/strong>。<\/p><h3 id=\"sensitivealert\">在特权用户访问敏感数据时发出实时警告<\/h3><p><strong>敏感字段<\/strong><\/p><p>在 MongoDB 中，您还可以在字段级别对活动发出警告。例如，如果您知道您的文档集合只是用敏感数据（如驱动程序的许可证号）零星地进行了填充，并且您不希望对该集合中的文档的其他所有访问发出警告，那么您可能希望执行该操作。请注意，如果某个字段嵌入到该文档的多个深层级别，那么将记录该字段的圆点表示路径（dot notation path）。<\/p><div class=\"codesection\"><pre class=\"displaycode\">db.CreditCard.insert({\n    \"Name\" : \"Sundari Voruganti\",\n    \"code\" : \"WM2001_0\",\n    \"product\" : \"Gold Card\",\n    \"profile\" : [\n        {\"CCN\" : \"11999002\"},\n        {\"log\" : [\"new\", \"customer\", \"for\", \"now\"]}\n    ],\n    \"otherinfo\" : \"Contact Bob Saget\"\n});<\/pre><\/div><p>在上面的示例中，Guardium 将存储 CreditCard 的一个对象和下列<em>字段<\/em>：Name、code、product、profile.CCN、profile.log 和 otherinfo。<\/p><p>您可以设置一个警告，该警告包含 %CCN%（用于信用卡字段）和 %DLN%（用于驱动程序的许可证字段），您还可以设置一个访问这些字段的警告。<\/p><p>警告是获取有关可疑或不合规则的活动的近乎实时的警告的一个好方法。警告被写入到 UI 的 Incident Management 选项卡（与其他策略违反情况相同），但也可以通过电子邮件将其发送或写入到 Syslog。如果写入到 Syslog，那么您可以将警告转发到安全智能和事件管理系统（比如 IBM QRadar 或 HP Arcsight），以便您的安全团队可以进行相应处理和调查。<\/p><p><strong>先决条件<\/strong>：该策略规则依赖于两个组的存在情况，我们将这两个组分别命名为 “MongoDBAdmins” 和 “MongoDB Sensitive objects”。如果想限制对某个命令的警告，那么您还可以添加一个包含特定命令（比如 find 和 CopyCollection）的组。我们将创建和使用这个可选的组，我们称其为 “MongoDB WatchCommands”。它包含我们想要观察的多个命令，比如 find、update、insert、delete、cloneCollection 和 mapreduce。<\/p><h5 id=\"fig24\">图 25. 敏感对象组。对于 MongoDB 来说，集合就是对象<\/h5><img alt=\"组包含 %credit% 和 %customer%。\" src=\"/sunshine_new/images/967770037/sensitiveobjectsgroup.jpg\" width=\"399\" /><h5 id=\"fig25\">图 26. 一组特定的命令， 我们想要监视何时用于敏感数据<\/h5><img alt=\"组包含 cloneCollection、find、insert、delete、mapreduce 和 insert。\" src=\"/sunshine_new/images/967770037/watchcommandsgroup.jpg\" width=\"339\" /><p>要创建您的策略规则，请从 Policy Finder 中选择您的策略，单击 <strong>Edit Rules<\/strong>，然后单击 <strong>Add Access Rule<\/strong>。<\/p><p>我们的策略规则如图 27 所示。<\/p><h5 id=\"fig26\">图 27. 该策略会在特权用户使用特定命令访问敏感数据时发出警告<\/h5><img alt=\"敏感对象组针对对象条件显示，而观察命令是针对命令条件显示，mongodbadmins 针对 db 用户，操作是一个会话警告一次。\" src=\"/sunshine_new/images/967770037/adminalert.jpg\" width=\"580\" /><p>要测试新规则，请确保重新安装了该策略。<\/p><p>图 28 显示了警告的外观。<\/p><h5 id=\"fig27\">图 28. 在特权用户使用一个不允许的命令访问敏感数据时触发警告（警告摘要）<\/h5><img alt=\"该警告显示了导致触发警告的特定命令。\" src=\"/sunshine_new/images/967770037/sensitivealert_excerpt.jpg\" width=\"580\" /><h3 id=\"alertdcl\">对 Data Control 命令发出实时警告<\/h3><p>一个常见的要求是监视为用户提供访问权限以及特权的任何命令。在 MongoDB 中，管理员可以创建和添加用户，在 MongoDB 2.4 中，还可以为用户提供其他角色。有关 MongoDB 安全和角色的详细信息的链接，请参阅 <a href=\"#resources\">参考资料<\/a>。<\/p><p> 凭据和用户权限信息都存储在集合 system.users 中。<\/p><p>因此，例如，假定某个人按照以下方式创建了新用户：<code>db.addUser({user:\"sundari\",pwd:\"guardium\",roles:[\"readWrite\"]})<\/code>。<\/p><p>如图 29 中的报告所示，InfoSphere Guardium 会将该活动记录为对集合 system.users 的 insert 操作。该活动将包含两个对象：新用户的名称和 system.users 集合。<\/p><h5 id=\"fig28\">图 29. 显示对 system.users 集合的访问的审计报告的摘要<\/h5><img alt=\"示例报告显示了插入用户 sundari 以及授予该用户的角色。\" src=\"/sunshine_new/images/967770037/systemusers.jpg\" width=\"580\" /><p>对于我们的策略规则，我们可能希望可以轻松地查看 system.users 集合上的任何活动。为此，您可以向记录对 system.users 集合的访问的策略中添加一个新的访问规则。图 30 显示了我们的策略规则，在该规则中，我们只是添加了对象 system.users 以及 Log Only 操作，并将我们的策略规则添加到了 UI 的 Incident Management 选项卡中。<\/p><h5 id=\"fig29\">图 30. 用于记录对 system.users 的更改的策略规则，因此可以在事件管理选项卡上看到它们<\/h5><img alt=\"参见文本。\" src=\"/sunshine_new/images/967770037/accesscontrolpolicy_markup.jpg\" width=\"580\" /><p>图 31 显示了一个事件的部分输出。<\/p><h5 id=\"fig30\">图 31. 管理员添加了 Sundari 用户，该用户显示在 Guardium UI 的事件管理选项卡上<\/h5><img alt=\"显示了添加 Sundari 的管理员\" src=\"/sunshine_new/images/967770037/adduser_inc.jpg\" width=\"580\" /><p><strong>注意：<\/strong>记录到事件管理的好处就是可以获得实时的事件记录。但是，如果这是需要定期审计的活动，那么您可能希望创建该活动的报告并将其发给审计人员。<\/p><h3 id=\"schemachange\">记录可能会影响应用程序的集合更改的策略违反情况<\/h3><p>一些组织机构的管理员和应用程序所有者可能希望记录数据库中可能会影响应用程序逻辑或性能的更改，比如丢弃或重命名某个集合，或者丢弃某个索引或数据库。您可以创建一个组，该组包含您要跟踪的命令。请注意，帮助程序方法可能会采用不同的方式在线路上流动。您要跟踪的命令包括：<\/p><ul class=\"ibm-bullet-list\"><li><code>deleteIndexes<\/code><\/li><li><code>drop<\/code>（捕获丢弃的集合）<\/li><li><code>dropDatabase<\/code><\/li><li><code>renameCollection<\/code><\/li><\/ul><p>如果您想避免对可能会导致许多丢弃和重命名操作的测试或 QA 活动触发该规则，那么您可能还需要添加一组 “冻结” 对象。<\/p><h5 id=\"fig31\">图 32. 我们要记录的命令组<\/h5><img alt=\"参见上述文本中的命令列表\" src=\"/sunshine_new/images/967770037/changecommandsgroup.jpg\" width=\"366\" /><p> 随后，您可以添加一个包含该组的访问策略规则，并选择一个在触发该规则时要采取的操作。在我们的示例中，我记录了策略违反情况，但不生成警告。<\/p><h5 id=\"fig32\">图 33. 在 Incident Management 选项卡上发生的更改命令的摘要<\/h5><img alt=\"摘要显示 sundari 重命名了一个集合并丢弃了一个集合\" src=\"/sunshine_new/images/967770037/changealert_excerpt.jpg\" width=\"580\" /><h3 id=\"recordsaffected\">实时警告：对敏感数据的读取访问超过阈值<\/h3><p>很多组织机构都禁止其员工（以及黑客）检索过多的潜在敏感数据，如果出现这种情况，则会发出警告，以便他们可以快速地调查和确定是否发生了严重的违规行为。<\/p><p>执行该操作的一个方法是根据 “受影响的记录” 在 MongoDB 策略的访问规则中创建一个阈值。<\/p><p><strong>先决条件：<\/strong><\/p><ol><li>创建一组您要对其发出警告的敏感数据对象。<\/li><li>确保您的系统配置针对所有检查引擎启用了 <strong>Inspect Returned Data<\/strong> 和 <strong>Log Records Affected<\/strong>。为此，请转到 Administration Console 选项卡，然后选择 <strong>Configuration<\/strong> &gt; <strong> Inspection Engines<\/strong> 并选中相应的复选框，如图 34 所示。<\/li><\/ol><h5 id=\"fig33\">图 34. 将 Guardium 配置为报告读取的文档数量<\/h5><img alt=\"在检查引擎配置中，选中两个字段。\" src=\"/sunshine_new/images/967770037/inspectionenginesreturneddata.jpg\" width=\"580\" /><p>图 35 显示了我们创建的策略规则，即在任何数据库用户对敏感数据对象的读取记录的数量超过 200 时发出警告。请确保在 DB User 字段中放置了一个句点，以计算受每个数据库用户影响的记录，而不是所有数据库用户的记录。<\/p><h5 id=\"fig34\">图 35. 过度发现警告规则（excessive finds alert rule）的定义<\/h5><img alt=\"该组由 MongoDB 敏感对象组成。DB User 是一个句点。受记录影响的阈值为 200。操作是一个会话警告一次。\" src=\"/sunshine_new/images/967770037/recordsaffectedrule.jpg\" width=\"580\" /><p><strong>注意：<\/strong>该规则将在特定用户在该会话中该组的所有集合累计访问超过 200 个文档时发出警告。如果您想为每个集合设置特定的限制，那么应该对每个集合使用不同的规则。<\/p><p>图 36 中的警告显示一个不明身份的用户从信用卡集合中下载了超过 200 个文档。<\/p><h5 id=\"fig35\">图 36. 多度发现警告<\/h5><img alt=\"用户是 NO_AUTH。\" src=\"/sunshine_new/images/967770037/excessivefinds_alert.jpg\" width=\"580\" /><h2 id=\"summary\">结束语<\/h2><p>在此文章系列（包含 3 个部分）的第 2 部分中，我们介绍了有关如何配置解决方案的详细信息，其中包括如何为查询路由器和分片配置特定的检查引擎。我们提供了关于如何验证 S-TAP 是否正在捕获 MongoDB 流量以及是否将其发送至收集器的一些建议。最后，我们还提供了一些样例策略规则，您可以根据您组织机构中的安全和法规要求在您自己的环境中使用这些策略规则。<\/p><p>在第 3 部分中，我们将介绍一个高级功能（阻止），还将介绍报告、审计浏览，以及如何自动化审计报告的注销和审计。<\/p><CMA ID: 972084><Site ID: 10><XSLT stylesheet used to transform this file: dw-document-html-7.0.xsl>\r\n\r\n\r\n<\/div>\r\n<\/div>\r\n","createTime":"2014-05-22 00:00:00","deployTime":"2014-05-22 00:00:00","id":0,"intro":"此文章系列将介绍如何使用 IBM InfoSphere Guardium 监视和保护 MongoDB 数据，其中包括解决方案的配置、样例监视用例和其他功能（比如使用一个审计流程快速搜索审计数据并构建一个合规的工作流程）。第 2 部分将会介绍如何将 InfoSphere Guardium 配置为收集 MongoDB 流量，还将介绍如何为各种典型的数据保护用例创建安全策略规则（比如在失败登录的次数过多时发出警报、监视特权用户，并在其他人未经授权访问敏感数据时发出警报）。许多组织机构都是刚开始使用 MongoDB，现在是时候在环境中建立安全机制来节省时间、防止违规和避免违规了。","keyword":"","recommend":false,"source":"http://www.ibm.com/developerworks/cn/data/library/techarticle/dm-1306mongodb2/index.html","title":"MongoDB 的 InfoSphere Guardium 数据安全和保护，第 2 部分: 配置和策略","typeId":0,"updateTime":"2014-05-22 00:00:00"}
{"author":"","clickNumber":0,"content":"\r\n<div class=\"ibm-columns\">\r\n<div class=\"ibm-col-1-1\">\r\n\r\n<h2 id=\"overview\">简介<\/h2><p>此文章系列的第 1 部分介绍了 MongoDB 和 InfoSphere Guardium。提供了有关 InfoSphere Guardium 如何帮助您在更多应用程序中利用 MongoDB 让您感到更安全（因为它能够完全监视和审计数据活动）的一些背景信息。您了解了该解决方案的架构以及使用其原生功能确保 MongoDB 安全的一些建议，还了解了 InfoSphere Guardium 所带来的优势。<\/p><p>此系列的第 2 部分深入介绍了配置解决方案的详细信息，并解释了如何为各种用例创建安全策略规则。<\/p><p>此系列的最后一篇文章将向您介绍可以使用 InfoSphere Guardium 进行的更多操作，其中包括：<\/p><ul class=\"ibm-bullet-list\"><li>搜索和浏览审计数据。<\/li><li>创建报告，并将审计流程配置为路由报告以便进行审查。\n                    <\/li><li>阻止可疑用户。只有 Advanced Activity Monitor 才有这个特殊的功能。<\/li><\/ul><h2 id=\"auditresults\">查看审计结果：搜索和报告<\/h2><p>这一节将介绍用于审计数据的几个不同选项：<\/p><ol><li>即时搜索（此版本中的新功能）<\/li><li>活动报告<\/li><\/ol><h3 id=\"N10092\">搜索和浏览<\/h3><p>快速搜索工具（位于 Guardium UI 的顶部横幅中），启用该工具时，可提供针对数据库活动、错误和违规的快速搜索和浏览功能。该功能使用了搜索索引，每隔 1-2 分钟运行一次。您可以使用常用的搜索技术，其中包括分面搜索（faceted search）和文本搜索，或者二者的集合使用，以便快速对审计数据进行即时调查。<\/p><p>搜索包含以下事项：<\/p><ul class=\"ibm-bullet-list\"><li>数据库活动各个方面的统计信息（时间、地点、人物、事件）直方图。单击这些方面中的任何一个方面可以缩小您的搜索范围。\n                    <\/li><li>自由文本搜索将会搜索所有带索引的审计数据。例如，您可以输入字符串 “john”，然后搜索所有带索引的数据来查找 john，无论它出现在 DB User、OS User、Client 和 Error 中，还是出现在消息详细信息中。<\/li><\/ul><p>在默认情况下，搜索和浏览功能都处于禁用状态。要启用该功能，可以以 CLI 用户的身份运行以下 <code>grdapi<\/code>：\n                <code>grdapi\n                    enable_quick_search<\/code>。<\/p><p>要访问该功能，请输入一个搜索词或单击 InfoSphere Guardium UI 顶部横幅中的手电筒，如图 1 所示。<\/p><h5 id=\"fig1\">图 1. 访问审计数据的搜索和浏览<\/h5><img alt=\"在红色框中突出显示的手电筒图标\" src=\"/sunshine_new/images/1309584920/flashlight.jpg\" width=\"580\" /><p>使用左侧的方面来选择要添加到筛选器的值。例如，如果您想要查看是否有任何人最近丢弃了某个对象，那么您可以选择自己的时间范围，然后选择 <strong>MongoDB<\/strong> 作为 DB Type，并选择 <strong>drop<\/strong> 作为动词。<\/p><h5 id=\"fig2\">图 2. 使用直方图（方面）浏览审计数据<\/h5><img alt=\"使用直方图（方面）浏览审计数据\" src=\"/sunshine_new/images/1309584920/quicksearch1.jpg\" width=\"580\" /><p> 该操作将会缩小结果的范围，并包含详细信息，包括丢弃的对象、时间和发布该命令的 db 用户。由于空间限制，图 3 中无法显示所有内容。<\/p><h5 id=\"fig3\">图 3. 经过筛选的搜索结果<\/h5><img alt=\"经过筛选的搜索结果\" src=\"/sunshine_new/images/1309584920/quicksearch2.jpg\" width=\"580\" /><h3 id=\"reports\">创建报告<\/h3><p> InfoSphere Guardium 包含很多内置的报告定义和一个丰富的报告构建功能。一些报告会自动填充数据；而对于另一些报告，您必须修改运行时间参数（比如指定正确的日期范围）才能填充该报告。<\/p><p> 如果您看到自己喜欢的报告，还可以克隆用于生成该报告的查询，并对其进行调整，使之满足您的要求。例如，我们假定您喜欢名为 “Admin Users Login” 的报告。如果您以管理员身份登录，那么您会在 Daily Monitor 选项卡上找到该报告。如果单击该报告，您可能会看到消息 <em>No data found<\/em>，如图 4 所示。出现该消息的常见原因是日期范围可能未包含该活动发生的时间范围，或者未满足查询条件的其他某些方面。<\/p><h5 id=\"fig4\">图 4. 一个找不到查询结果的内置报告<\/h5><img alt=\"一个找不到查询结果的内置报告\" src=\"/sunshine_new/images/1309584920/adminuserloginnodata.jpg\" width=\"580\" /><p>单击该报告下面的黄色铅笔图标，您可以看到用于创建该报告的基本查询，如图 5 所示。上半部分包含报告中的列，下半部分包含条件。您可以看到该报告的一个条件是 Admin Users 组的一个运行时参数。<\/p><h5 id=\"fig5\">图 5. 用于生成该报告的查询<\/h5><img alt=\"显示报告列和报告条件的查询构建器\" src=\"/sunshine_new/images/1309584920/adminusersloginquery.jpg\" width=\"580\" /><p> 要查看 Admin Users 组中都有谁，可以转到 Group Builder 工具。假定您以管理员用户身份登录，请导航到 <strong>Tools<\/strong> 选项卡中的 Group Builder。<\/p><h5 id=\"fig6\">图 6. Group Builder 菜单<\/h5><img alt=\"该图显示了 Tools 选项卡和突出显示的 Group Builder 菜单项\" src=\"/sunshine_new/images/1309584920/GroupBuildermenu.jpg\" width=\"383\" /><p> 在打开 Group Filter 后，单击 <strong>Next<\/strong>。从现有组的列表中，选择 <strong>Admin Users<\/strong> 并单击 <strong>Modify<\/strong>。<\/p><p> 如果您的 MongoDB 管理员用户不在列表中，那么可以添加他们，如图 7 所示。<\/p><h5 id=\"fig7\">图 7. 向组中添加新的管理员用户<\/h5><img alt=\"该图显示了如何将 sundari 添加为管理员成员\" src=\"/sunshine_new/images/1309584920/adminusersaddmember.jpg\" width=\"580\" /><p> 如果该报告仍然没有显示任何数据，那么您可以自定义该报告，以更改数据范围。要执行该操作，请单击该报告右上角的 <strong>Customize<\/strong> 图标（蓝色铅笔），如图 8 所示。\n                <\/p><h5 id=\"fig8\">图 8. 通过单击报告组件右上角的蓝色铅笔图标来自定义报告<\/h5><img alt=\"图标题中的文本为描述性文本\" src=\"/sunshine_new/images/1309584920/adminuserscustomize.jpg\" width=\"580\" /><p>然后，您可以更改日期范围（如图 9 所示）以包含一个包括之前整个一周（NOW -1 week）的时间范围，我们知道这个时间已经包含该活动。<\/p><h5 id=\"fig9\">图 9. 扩展报告的日期范围<\/h5><img alt=\"日期被更改为 NOW-1 WEEK 以包含更多数据\" src=\"/sunshine_new/images/1309584920/adminuserscustomize2.jpg\" width=\"580\" /><p>现在，该报告显示了一些数据，如图 10 所示。<\/p><h5 id=\"fig10\">图 10. 报告现在显示了一些数据<\/h5><img alt=\"报告显示了 SUNDARI 登录的活动\" src=\"/sunshine_new/images/1309584920/adminusersloginreport.jpg\" width=\"580\" /><p> 我们仅仅触及了报告自定义和报告创建的一些表面知识。不过，在 <a href=\"#resources\">参考资料<\/a> 中，有一个连接到 InfoSphere Guardium 信息中心 “操作方法” 主题的链接，该链接可以帮助您开始执行这些操作。\n                <\/p><h3 id=\"datamart\">使用数据集市提高预定义的报告性能<\/h3><p>您可以使用自己的或 Guardium 预定义的查询和报告来创建一个数据集市，该数据集市可用来大大提高常用报告的性能。数据集市是一个指定的表，它基于您所需的报告结构。您为了实现汇总数据的目的而定义数据集市的数据粒度（比如分钟、小时、天或周）并计划定期运行该操作。由于结构是预先定义的，所以它不再需要进行运行时联接（join）或其他资源密集型数据库活动。<\/p><p>在需要与常规报告（您可能需要在 Guardium Aggregators 上对大量数据进行处理）一起使用时，数据集市可能特别有效。由于数据集市反映了报告的结构，所以不需要进行复杂的多表联接，从而会大大提高这些报告的性能。<\/p><p>任何报告都可以通过单击报告底部的 Data Mart Builder 链接转换成数据集市，如图 11 所示。<\/p><h5 id=\"fig11\">图 11. 进入 Data Mart Builder 的图标<\/h5><img alt=\"在报告右下角突出显示了该图标位置（底部工具栏）的报告\" src=\"/sunshine_new/images/1309584920/datamartbuildericon.jpg\" width=\"580\" /><p>在 Data Mart Builder 中，您可以指定希望运行查询的频率，以及您将其保存为使用该定义创建的默认报告的时间。系统会根据您选择的粒度和制定的计划不断填充数据。\n                <\/p><h5 id=\"fig12\">图 12. 数据集市配置<\/h5><img alt=\"数据集市配置字段包含数据集市名称、描述、表的提取结果、表名称、时间粒度等。单击 Add to Pane 可向 UI 中添加相应的报告。\" src=\"/sunshine_new/images/1309584920/datamartconfig.jpg\" width=\"580\" /><h2 id=\"workflow\">创建审计数据的报告并将其添加到工作流以便审查<\/h2><p>运行报告并获得批准并不只是某个人的有趣想法。这个过程自动化程度越高，您担心它的时间就越少，所需的合规性管理人员或审计员的审计跟踪能力就越高。借助 Guardium，您可以使用一个审计流程来计划要运行的报告，并将此报告自动发送给审查人员。系统将跟踪谁进行了审查或注销。所有必要操作都可以通过 Web 界面安全执行，其中包括审查结果、提供批准、注释和改进某个操作。<\/p><h5 id=\"fig13\">图 13. 审计流程可以自动路由审查和注销<\/h5><img alt=\"箭头显示审计流程从 DBA 流经 Information Security 直到 Auditor/Manager\" src=\"/sunshine_new/images/1309584920/auditvsrole.png\" width=\"475\" /><p>虽然我们不能详细介绍如何创建一个审计流程，但我们会向您介绍其中一些要点。在这个示例中，我们希望创建一个审计流程，该流程将我们的 Privileges 报告的一个副本发送给相应的人员，以便对它们进行审查。<\/p><p>图 14 显示了我们的报告的外观。<\/p><h5 id=\"fig14\">图 14. 我们创建的名为 MongoDB Privilege Report 的报告<\/h5><img alt=\"包含 system.users 上活动的报告\" src=\"/sunshine_new/images/1309584920/mongodbprivilegereport.jpg\" width=\"580\" /><p>要将其添加到审计流程，请转到 Audit Process Builder（如果您以管理员身份登录，则从 Tools 开始）并创建一个新的流程。系统会询问您是否创建接收者，即将接收审计流程结果的人员（或角色）。然后您就可以将该报告添加为该审计流程中的任务，其中包括您希望报告查询涉及的时间范围（例如，从之前的一天 (NOW -1 DAY) 一直到现在 (NOW)）。一个审计流程可以包含多个任务，而任务又可以包含一组报告或其他活动。<\/p><h5 id=\"fig15\">图 15. 审计流程构建器<\/h5><img alt=\"该图突出显示了构建器的某些区域，比如计划、接收者和屏幕中的 Audit Tasks 部分，在这个位置，您可以添加 mongodb 特权报告审查任务\" src=\"/sunshine_new/images/1309584920/auditprocessbuilder.jpg\" width=\"580\" /><p>您可以制定计划，让任务定期运行，比如每天午夜运行。这样，管理员或 DBA 在第二天早上就会从他们的电子邮件中收到该报告。他们的批准（如果需要）和注释将作为该流程的审计跟踪数据的一部分进行保留。<\/p><p>图 16 给出了发送的电子邮件的一个示例，其中包含该报告的 PDF。<\/p><h5 id=\"fig16\">图 16. 审计流程中的电子邮件示例<\/h5><img alt=\"电子邮件提供了您的评论：MongoDB 审计流程上的用户和特权\" src=\"/sunshine_new/images/1309584920/auditprocessemail.jpg\" width=\"505\" /><h2 id=\"blocking\">阻止访问（通过高级活动监视功能）<\/h2><p>在某些情况下，可能需要阻止用户访问特殊数据。一个典型的用例是阻止管理员访问敏感数据，或者在系统中发现未知用户时阻止该用户。高级活动监视许可证中提供了这项功能，该功能可以在以下情况帮助保护您的数据：<\/p><ul class=\"ibm-bullet-list\"><li>使用外包 DBA 时，需要限制其访问敏感数据<\/li><li>涉及现有或即将出现的内部或外部违规时\n                    <\/li><\/ul><p>该功能依赖于 S-GATE，它是 S-TAP 的一个扩展，可通过修改 guardtap.ini 文件中的一些参数来激活此功能。S-GATE 参数是被称为 “防火墙” 参数。由于使用 S-GATE 可能会导致一些延迟，因此我们建议您在初始化文件中启用 S-GATE，但是，仅当使用名为 S-GATE ATTACH 的策略操作满足某些特定条件时，才能打开该文件。清单 1 提供了您在 guardtap.ini 文件中修改防火墙参数的一个示例。<\/p><div class=\"codesection\"><pre class=\"displaycode\">firewall_installed=1    <strong>&lt;This enables the S-GATE capability to be used<\/strong>\nfirewall_fail_close=0\nfirewall_default_state=0  <strong>&lt;S-GATE off by default but can be turned on using a policy  rule<\/strong>\nfirewall_timeout=10<\/pre><\/div><p>假定已经激活了 S-GATE ATTACH 规则，该流程的工作原理如下（有关步骤的说明，请参阅 <a href=\"#fig17\">图 17<\/a>）：<\/p><ol><li>当某个未经授权的用户连接到 MongoDB 并输入一个命令时，S-GATE 会识别出这个特殊的会话就是必须观察的那个会话。\n                    <\/li><li>该命令由 S-GATE 持有。<\/li><li>将命令与策略进行比较，以查看是否有违反策略的情况，比如是否访问了某个特殊的敏感对象或对象组。\n                    <\/li><li>如果违反了策略规则并且您的策略操作是 S-GATE TERMINATE，那么 S-GATE 会终止该会话，并不允许继续将该命令用于 Mongo 服务器。如果允许使用该命令，则会允许该语句进入服务器。<\/li><\/ol><h5 id=\"fig17\">图 17. 阻止过程概述<\/h5><img alt=\"阻止过程概述\" src=\"/sunshine_new/images/1309584920/blocking.jpg\" width=\"453\" /><p>可以使用许多不同的组合来设置满足您的需要的阻止情况。最重要的事情是确保您不会对普通的业务应用程序应用该功能，因为这会导致延迟针对策略检查所有传入的命令。\n                <\/p><p>对于我们的策略，我们将阻止不在 “授权的用户组” 中的人访问任何敏感数据对象。例如，该组可能包含授权的应用程序的特定 ID。表 1 是我们将要创建的规则的摘要，以及在每个规则中使用的组。<\/p><h5 id=\"table1\">表 1. 用于创建我们的示例策略规则的规则和组<\/h5><table border=\"0\" cellpadding=\"0\" cellspacing=\"0\" class=\"ibm-data-table\" summary=\"2 column table, both columns left-aligned\"><thead xmlns:dw=\"http://www.ibm.com/developerWorks/\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"><tr><th scope=\"col\">规则描述<\/th><th scope=\"col\">规则中使用的组<\/th><\/tr><\/thead><tbody xmlns:dw=\"http://www.ibm.com/developerWorks/\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"><tr><td>观察未经授权的用户（对不在这些对象的授权用户组中的用户进行的任何活动启用 S-GATE。）<\/td><td>授权用户（修改内置组）<\/td><\/tr><tr><td>阻止未经授权的用户（访问敏感数据）<\/td><td>授权用户（修改内置组）<br /> MongoDB 敏感对象（之前在此系列文章的第 2 部分创建的对象）<\/td><\/tr><\/tbody><\/table><p>现在，我们将介绍在正确的环境下激活阻止所需的规则。\n                <\/p><p>首先，如图 18 所示，指定 S-GATE 附加条件，在该条件中<em>未<\/em>授权的用户将激活 S-GATE。请注意，该操作对性能有影响，因此您只能在有限的环境下激活 S-GATE Attach 操作。不建议对应用程序流量使用该操作。<\/p><h5 id=\"fig18\">图 18. 设置开始观察数据活动的条件<\/h5><img alt=\"条件是 ”NOT authorized users“，操作为 ”S-GATE Attach“\" src=\"/sunshine_new/images/1309584920/sgateattachrule.jpg\" width=\"580\" /><p>接下来，如果这些用户中的任何用户访问敏感数据，则会继续前进并终止该连接。<\/p><h5 id=\"fig19\">图 19. 设置终止用户连接的条件<\/h5><img alt=\"向条件中添加了 “mongodb sensitive objects” 组，操作为 “S-GATE Terminate”\" src=\"/sunshine_new/images/1309584920/sgateterminaterule.jpg\" width=\"580\" /><p>请注意，在阻止某个会话时，系统会将这种情况写成一种策略违反情况，您还可以在 Incident Management 选项卡上看到这种情况。如果您的规则包含要警告的操作，那么还可以将这种情况写入 SYSLOG，以便能够将其转发到某个 SIEM 系统，让安全人员进行跟踪调查。还有一个在指定时间内隔离用户以便进行安全调查的选项。<\/p><h2 id=\"summary\">结束语<\/h2><p>此文章系列详细介绍了 InfoSphere Guardium 对 MongoDB 的支持，但此处介绍的功能也适用于各种数据库系统，这些数据库包括代表过去、现在和将来数据库技术的各式各样的数据处理系统。数据库和数据处理技术迅速发展，以便满足新的应用程序和用例的需求。MongoDB 是 “NoSQL” 技术的领先提供商之一，很多需要新技术来处理新数据处理问题的组织机构都打算结合使用 MongoDB 与传统的关系型数据库。因此，拥有一个可以跨关系型技术和 NoSQL 技术使用的数据安全和监视解决方案非常重要。<\/p><p>InfoSphere Guardium 的构建基础\n是，可以跨各种数据库（包括其他 NoSQL 系统，比如 Cassandra 和 CouchDB、关系型、主框架数据（包括 DB2、IMS 和 VSAM），或者基于 Hadoop 的系统，比如 InfoSphere BigInsights、Cloudera、Greenplum Hadoop 和 Hortonworks Data Platform）采用它，并快速提供数据监视功能。<\/p><p>在此文章系列中，我们展示了 IBM 和 10gen 共同开发和验证 MongoDB 的 InfoSphere Guardium 功能的工作结果。总之，这些产品可以提供一个 NoSQL 选项，该选项提供了组织机构通常所需的安全和审计功能，使得公司遵从各种隐私和金融法规。<\/p><CMA ID: 972086><Site ID: 10><XSLT stylesheet used to transform this file: dw-document-html-7.0.xsl>\r\n\r\n\r\n<\/div>\r\n<\/div>\r\n","createTime":"2014-05-22 00:00:00","deployTime":"2014-05-22 00:00:00","id":0,"intro":"此文章系列将介绍如何使用 IBM InfoSphere Guardium 监视和保护 MongoDB 数据，其中包括解决方案的配置、样例监视用例和其他功能（比如使用一个审计流程快速搜索审计数据并构建一个合规的工作流程）。第 3 部分将介绍 InfoSphere Guardium 中用于搜索和报告审计数据的功能、如何创建审计流程，以及如何阻止用户的功能（只有 Advanced Monitor 提供了此功能）。很多组织机构都只是刚开始使用 MongoDB，现在是时候在环境中建立安全机制来节省时间、防止违规和避免违规了。","keyword":"","recommend":false,"source":"http://www.ibm.com/developerworks/cn/data/library/techarticle/dm-1306mongodb3/index.html","title":"MongoDB 的 InfoSphere Guardium 数据安全和保护，第 3 部分: 报告、自动执行和阻止","typeId":0,"updateTime":"2014-05-22 00:00:00"}
{"author":"","clickNumber":0,"content":"\r\n<div class=\"ibm-columns\">\r\n<div class=\"ibm-col-1-1\">\r\n\r\n<h2 id=\"overview\">简介<\/h2><p>本文的作者们来自 IBM、10gen、MongoDB 公司，他们将协作验证 InfoSphere Guardium 是否适用于 MongoDB。这是一个很不错的练习，因为我们已经对彼此的产品和用例非常了解。我们真的想编写一些内容，帮助熟悉关系型数据库和 InfoSphere Guardium 的人了解一些组织机构对某些类型的应用程序使用 MongoDB 的原因。从 InfoSphere Guardium 的角度看，我们的基础架构已经得到了扩展，涉及 MongoDB 中的不同消息协议，但是管理员和信息安全人员将会遵循相同的步骤对 MongoDB 进行审计和报告等。<\/p><p>我们还希望至少为 MongoDB 用户提供对 InfoSphere Guardium 中的一些功能的了解，帮助他们的组织机构实现审计和合规性目标、防止数据泄漏，并且帮助揭示有风险的活动，比如服务器端 JavaScript 的使用。<\/p><div class=\"dw-sidebar ibm-inset\"><h2 id=\"sidebar1\">InfoSphere Guardium 中的新功能<\/h2><p>尽管本文的侧重点是 MongoDB 支持，但是 InfoSphere Guardium 9.0 GPU 50 包含其他许多功能，其中包括：<\/p><ul class=\"ibm-bullet-list\"><li>将数据活动监视扩展到新内容以及扩展大数据和 NoSQL 平台，其中包括 MongoDB、Greenplum HD 和 Greenplum DB 和 Hortonworks 数据平台<\/li><li>增强报告功能以便加快企业级报告，以及使用新的联合查询功能来提高联合环境中审计流程的性能<\/li><li>缩短了发现时间，对数据库活动、异常以及策略违反情况进行快速分面搜索<\/li><li>通过更多内置的最佳实践查看器（报告）检测更多可疑的活动<\/li><li>在 64 位架构上支持 Guardium 设备，以便提高可伸缩性（计划在提供修补程序后，采用完整的安装映像的方式提供）<\/li><li>将所有代理（S-TAP、Guardium Installation Manager 以及 Discovery）整合成一个安装程序，以简化部署、缩短启动和运行的时间<\/li><li>利用报告的 3 次点击 API 分配来简化自动化操作和维护<\/li><li>在您的移动设备上随身携带 Guardium，以管理您的待办事项列表并照看整体的安全健康<\/li><\/ul><\/div><p>完成目标令人兴奋，但需要更多的空间（与一篇文章相比）。因此，为了让某些主题的涉及面更广泛，并为其他主题提供分步说明，我们创建了一个文章系列（包含 3 篇文章）：<\/p><ul class=\"ibm-bullet-list\"><li>此系列文章的第 1 部分将介绍 MongoDB 和 InfoSphere Guardium，简要介绍 MongoDB 的安全最佳实践，并介绍联合解决方案的优势。本文还将介绍架构，并介绍如何让数据流入 InfoSphere Guardium 以及如何在 InfoSphere Guardium 设备中处理数据的步骤。<\/li><li>第 2 部分涉及为 MongoDB 配置 InfoSphere Guardium 监视代理的具体细节。本文还将介绍如何使用安全策略完成一些常见的用例，包括监视特权用户访问、更改和重复失败的登录。<\/li><li>第 3 部分将介绍使得 InfoSphere Guardium 成为企业普遍使用的数据安全和合规性解决方案的某些功能，其中包括阻止、查看、报告审计数据，以及创建自动化某个合规工作流程的审计流程。<\/li><\/ul><h3 id=\"N10096\">MongoDB 简介<\/h3><p>端点设备中数据的扩散、不断增长的用户量、不断增长的新计算模型（如云、社交业务）和大数据带来了数据访问和分析的需求（可以处理数量惊人的数据）。快速增长型 NoSQL 数据库的价值是能够更快速地处理应对这些趋势所需的大量数据，同时还能够通过动态架构提供更大的灵活性。例如，动态架构使得组织机构能够快速响应规则的变化。<\/p><p> MongoDB 会为您特别提供这些优势，同时还提供常规可操作数据存储所需的丰富查询功能。MongoDB 通过一个文档模型提供更高的开发人员效率和灵活性；还可以将它用于关系型或典型 NoSQL 数据库，或者与新的数据库一起使用。<\/p><p> 图 1 显示了更高级别的 MongoDB 架构图，还介绍了对于理解非常重要的一些重要概念（如果您负责配置针对 MongoDB 的 InfoSphere Guardium）。（该图代表一个分片环境。MongoDB 也可以独立运行。）MongoDB 使用自动分片来获得水平可伸缩性，使用副本集来获得高可用性。客户端连接到 MongoDB 进程（分片环境中的 mongos），如果启用了安全性，那么可以选择对它们自身进行身份验证，在数据库中执行文档的插入、查询和更新。mongos 会将查询路由到相应的分片 (mongod)，以实现特殊命令。<\/p><h5 id=\"fig1\">图 1. MongoDB 架构提供一个可伸缩的环境<\/h5><img alt=\"客户端连接到一个 mongos（查询路由器）并分裂出配置为副本集的分片。\" src=\"/sunshine_new/images/822227530/mongooverview2.png\" width=\"258\" /><p>由于 MongoDB 使用了文档数据模型，所以它是被称为文档数据库的某种类型的 NoSQL 数据库。使用 JSON (JavaScript Object Notation) 采用分层方式建立文档模型，因此它们只包含名称-值对。这些值可以是单独的类型值、数组或文档本身（以及这些内容的组合），以匹配您在您的应用程序中拥有的任何对象。该模型可以提供快速查询，因为数据可以彼此靠近存储在文档中，而不是分布在多个表中并需要一个联接。清单 1 显示了 JSON 文档的一个示例。<\/p><h5 id=\"listing1\">清单 1. JSON 文档示例<\/h5><div class=\"codesection\"><pre class=\"displaycode\">{\n\"_id\" : 1,\n\"name\" : { \"first\" : \"John\", \"last\" : \"Backus\" },\n\"contribs\" : [ \"Fortran\", \"ALGOL\", \"Backus-Naur Form\", \"FP\" ],\n\"awards\" : [\n           {\n             \"award\" : \"W.W. McDowell Award\",\n             \"year\" : 1967,\n             \"by\" : \"IEEE Computer Society\"\n           },\n           { \"award\" : \"Draper Prize\",\n             \"year\" : 1993,\n             \"by\" : \"National Academy of Engineering\"\n           }\n]\n}<\/pre><\/div><p>本文档结构允许您使用在应用程序中建立对象模型的方式将数据存储在 MongoDB 中，因此它提供了充分的上市时间和极大的灵活性优势。（尤其在拥有动态的未预定义的架构时）。<\/p><p>在幕后，出于效率的考虑，文档采用二进制 JSON 格式 (BSON) 存储，但您永远无需处理 JSON 文档之外的任何内容。<\/p><p>表 1 将关系型概念和 MongoDB 概念进行了比较。<\/p><h5 id=\"table1\">表 1. 将关系型概念映射到 MongoDB<\/h5><table border=\"0\" cellpadding=\"0\" cellspacing=\"0\" class=\"ibm-data-table\" summary=\"3-columned table, all columns left-aligned\"><thead xmlns:dw=\"http://www.ibm.com/developerWorks/\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"><tr><th scope=\"col\">关系型概念<\/th><th scope=\"col\">MongoDB 概念<\/th><th scope=\"col\">备注<\/th><\/tr><\/thead><tbody xmlns:dw=\"http://www.ibm.com/developerWorks/\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"><tr><td>数据库/架构<\/td><td>数据库<\/td><td>其他内容的容器<\/td><\/tr><tr><td>表<\/td><td>集合<\/td><td/><\/tr><tr><td>行<\/td><td>文档<\/td><td/><\/tr><tr><td>列<\/td><td>字段<\/td><td>字段是在文档级别上定义的，不是在集合级别上定义的。换句话说，该字段没有预定义的架构，而关系型数据库有预定义的架构。<\/td><\/tr><tr><td>索引<\/td><td>索引<\/td><td/><\/tr><\/tbody><\/table><p>Mongo 的其他功能旨在让您使用这个文档结构以及您喜欢的编程语言，无需花费大量时间管理数据库。高可用性、性能以及自动分片（分区）是采用某种应用程序无需担心的方式构建的，因此应用程序开发团队可以快速集中精力满足业务需求。<\/p><h2 id=\"recommendations\">MongoDB 的安全建议<\/h2><p>越来越多的企业开始了解 MongoDB 能够满足特定的应用程序需求，所以他们可能面临着满足安全性和合规性的要求，他们的组织机构中的更多已建立的数据库必须也能够满足这些要求。<\/p><p>MongoDB 拥有一系列出色的安全最佳实践，在他们的维基页面中已对此进行了概括。（您可以在<a href=\"#resources\">参考资料<\/a>中找到这些链接。）此外，为了解决一些基本的安全痛点，MongoDB 在其版本 2.4 中改进了以下安全措施：<\/p><ul class=\"ibm-bullet-list\"><li>对要求采用这种方法的企业进行 Kerberos 身份验证（仅适用于企业版），以便能够将此方法集成到他们的标准安全系统中<\/li><li>基于角色的访问控制系统，可进行更细粒度的控制<\/li><li>增强了客户端的 SSL 支持要求<\/li><\/ul><p><strong>重要提示<\/strong>：目前，InfoSphere Guardium 无法监视 SSL 用于客户端访问时的活动。<\/p><p>现在，让我们看一看网络配置、身份验证、角色使用方面的一些最佳实践，防止出现 JavaScript 注入攻击。<\/p><h3 id=\"netconfig\">网络配置<\/h3><p>为了降低 MongoDB 的安全风险，建议在受信任的环境中运行 MongoDB 及其所有组件，并且配合相应的防火墙控制、MongoDB 组件之间紧密绑定以及特定的 IP 端口。运行分片群集时，查询流量通常会通过一个单独的进程（称为 mongos）进行路由，当然，我们建议您监视所有经过 mongos 的活动。<\/p><p>如图 2 所示，特权用户或其他人有可能会直接进入分片中的 mongod 实例。因此，我们建议您不仅要使用防火墙尽可能地锁定对分片的访问，而且还要在分片上进行 InfoSphere Guardium 监视，以捕获该活动。由于您会在此系列文章的第 2 部分中掌握该内容，因此您可以在分片上将 Guardium 配置为忽略来自 mongos 的活动，因为该活动将被 InfoSphere Guardium 捕获。这样您就能够发回在分片上发生的任何其他活动。<\/p><p>实际上有很多设置监视的选项，但从效率角度来讲，这是一个比较合理的选项，同时还能为管理员提供必要的监视功能。<\/p><h5 id=\"fig2\">图 2. 一个推荐的配置<\/h5><img alt=\"使用防火墙防止客户端访问 mongod 分片，并防止路由通过 mongos。对于使用客户端或本地连接的特权用户，Guardium 将监视该活动。\" src=\"/sunshine_new/images/822227530/recommendedconfig.png\" width=\"578\" /><p>此外，有一个安全最佳实践，那就是使用非默认的端口运行。为了便于理解，我们使用了默认的端口配置（27017 作为 mongos，27018 作为分片服务器），但 InfoSphere Guardium 在使用非默认端口时也工作状况良好。<\/p><h3 id=\"authenticate\">身份验证<\/h3><p>一个明确的建议是在启用身份验证的情况下运行 MongoDB。（默认情况下，不启用身份验证。）从监视和审计的角度看，身份验证对于让 InfoSphere Guardium 能够选取数据库用户名也非常重要。如果您没有启用身份验证，那么您会在报告的 DB USER name 字段中看到字符串 “NO_AUTH”。（InfoSphere Guardium 在会话中间将会启动监视，在没有选取 DB 用户的情况下，您有可能看不到 NO_AUTH。）<\/p><p>从 MongoDB 角度看，2.4 版本之前的身份验证仅限使用在 Mongo 中托管的用户名和密码的基本身份验证，未集成到企业用户管理系统中。在执行身份验证之后，还有少量角色拥有只读或完全访问权限。在 2.4 企业版中，还添加了额外的功能，其中包括支持 Kerberos。<\/p><h3 id=\"roles\">角色以及基于角色的访问<\/h3><p>在 2.4 版本中，MongoDB 支持很多新角色，按照它们的作用域，大致可以将它们划分为服务器范围的角色和数据库范围的角色。在这种情况下，都有侧重于用户管理、群集管理和应用程序访问的角色。<\/p><div class=\"dw-sidebar ibm-inset\"><h2 id=\"N10134\">为什么在报告中显示 SQL 标题？<\/h2><p>默认的报告标题不使用 SQL 术语。因为 InfoSphere Guardium 由不同的组成部分组成，因此许多不同的数据库将会在企业中使用相同的策略和报告。但是，如果您拥有特定的 MongoDB 报告并且不希望在报告标题中包含 SQL，那么您可以自定义自己喜欢的报告标题。<\/p><\/div><p>由于这些角色中的一些角色基本上等同于超级用户，所以确保谨慎分发和监视这些角色很重要。<\/p><p>请注意，在使用 InfoSphere Guardium 时，您可以监视和审计对环境或任何逻辑数据库的 system.users 集合的更改，因此，您可以确保只颁发了适当的授权。图 3 显示了一个样例报告，在该报告中，您可以看到数据库用户 Indrani 向 Kathy 和 Sundari 授予了读/写角色，这相当于在 MongoDB 中的 system.users 集合上执行插入操作。<\/p><h5 id=\"fig3\">图 3. 显示授予的角色的审计报告示例（将文档插入到 system.users 中）<\/h5><img alt=\"对象名称为 sundari 和 system.users，动词是 insert。\" src=\"/sunshine_new/images/822227530/systemusersexample.jpg\" width=\"578\" /><h3 id=\"javascript\">防止 JavaScript 注入攻击<\/h3><p>传统的 SQL 注入类型的攻击对 MongoDB 来说不是大问题，因为它使用了 BSON（二进制 JSON）而不是字符串。但是，仍有一些情况需要注意，其中包括使用以下操作，这些使您能够直接在服务器上运行任意 JavaScript 表达式：<\/p><ul class=\"ibm-bullet-list\"><li>$where<\/li><li>db.eval()<\/li><li>mapReduce<\/li><li>group<\/li><\/ul><p>降低风险的方法有很多（包括关闭所有服务器端脚本），但首先您需要能够确定使用上述这些操作的位置。在使用 InfoSphere Guardium 时，会记录这些操作中的 JavaScript 并将其报告为对象。这一点的意义是您可以设置在访问这些内容时要发生的改变或策略违反情况。这在测试环境中可能非常有用，可用于发现和确定对这些危险的使用，并在部署到生产环境之前进行必要的代码审查。图 4 中的样例报告（参见 <a href=\"sidefile2.html\">大图<\/a>）显示 <code>$eval<\/code> 正被报告为一个 JavaScript 对象。您还还可以查看全部命令文本，以便了解它们在上下文中的使用。如果这是您以后要监视的一些内容，那么您可以创建一个定期报告，该报告会告诉您再次使用这些操作中的某一个操作的时间。<\/p><h5 id=\"fig4\">图 4. 某些操作的 JavaScript（如 db.eval）以对象的形式记录在 InfoSphere Guardium 中 <\/h5><img alt=\"显示在报告中采用 JavaScript 对象记录的 dbeval 示例。\" src=\"/sunshine_new/images/822227530/evalcombined.jpg\" width=\"580\" /><h2 id=\"Benefits\">对 MongoDB 使用 InfoSphere Guardium 的优势<\/h2><p>对于对真正的数据库审计感兴趣的任何组织机构以及可能需要满足法规要求（如支付卡行业 (PCI) 或萨班斯法案 (SOX) 要求）的组织机构来说，InfoSphere Guardium 都是对原生 MongoDB 功能的一个重要的有益补充。MongoDB 中的原生安全和身份验证功能与在其他数据库中一样，确实不足以满足世界上各种法规和合规性要求。这些要求中的大多数都要求提供更强有力的可问责性（accountability），因为它们能够记录和验证谁在什么时候对数据库事务执行了哪些操作。<\/p><p> InfoSphere Guardium 被部署在世界各地的大型和小型组织机构中，旨在解决各种数据库的数据保护问题和合规性问题。该解决方案非常灵活、功能非常强大且非常有效。MongoDB 用户可能希望看到的优势如下：<\/p><ul class=\"ibm-bullet-list\"><li>InfoSphere Guardium 记录非常详细和细化的信息，如图 5（参见 <a href=\"sidefile1.html\">大图<\/a>）中所示的样例报告所示，该样例包含客户端和服务器 IP、源程序、数据库用户（如果启用了授权）以及所有命令消息（当它流经电线时）的详细信息。在下面的示例中，Kerberos 被用作身份验证机制。\n                    <p>请注意，部分消息被解析和存储为一个 Verb（有时称为 Command）和 Object，这意味着这些实体是可以用于指定策略规则的项，如此系列的第 2 部分所示。例如，您可以指定一个规则，只要发出一个 find，就会触发该规则，或者任何人只要触碰敏感数据对象组中的一个对象，就会触发该规则。<\/p><h5 id=\"fig5\">图 5. 审计报告的示例<\/h5><img alt=\"显示 mycollection 上的删除、查找、插入以及显示动词和对象的报告示例。\" src=\"/sunshine_new/images/822227530/auditreportmarkup.jpg\" width=\"580\" /><\/li><li>您可以审计数据库异常条件，比如失败的身份验证次数，这可能表示存在暴力攻击。此系列的第 2 部分将会介绍如何配置此项。<\/li><li>您可以有选择地记录对读取活动有影响的文档的数量，用这种方法对次数异常高的下载发出警报。此系列的第 2 部分将介绍这方面的一个示例。<\/li><li>您可以阻止本地用户访问，以防止出现管理员读取敏感内容的情况。您会在此系列的第 3 部分看到有关此内容的一个示例。<\/li><li>您可以为各种条件指定实时警报，并在此系列的第 2 部分了解到如何配置这些内容。组织机构有责任尽其所能地避免泄漏尴尬数据或已损坏的数据。证明合规性是您的责任的一部分，而且在发生违规时，您能够在几分钟或几小时（而不是几天或几周）内快速检测和反应，这可能意味着巨大损失和轻微不便之间的差别。实时警报以及在违反阈值时发出警报会帮助您在几秒钟或几分钟（而不是几天、几周甚至更长时间）之内检测到可疑行为。\n                <p>可以使用电子邮件或通过 SNMP 将那些警报发送到另一个监视系统。还可以与 IBM QRadar 和 HP ArcSight 消息类型进行内置集成，自动将警报条件从 syslog 转发给这些系统。<\/p><\/li><li>必须将审计信息存储一定的时间，有时候甚至要存储几年。设计 InfoSphere Guardium 时需要考虑到这些需求的类型，并因为这种原因而提供安全存档功能。<\/li><li>最后，证明合规性可能非常耗时，甚至任务繁重，因为这些通常需要在一定程度上定期复查和注销。InfoSphere Guardium 不仅仅允许您创建满足审计要求所需的报告，而且还允许您拥有一个可靠的工作流功能，该功能可集成到您的业务流程中，并将所有注销和评论作为审计跟踪的一部分进行保存。<\/li><\/ul><h2 id=\"Architecture\">解决方案的架构<\/h2><p>借助其不会带来干扰的架构（参见图 6），InfoSphere Guardium 提供了无需在 MongoDB 群集上更改配置的数据活动的完全可见性。<\/p><h5 id=\"fig6\">图 6. 高级架构<\/h5><img alt=\"mongo 客户端连接到 mongos，而 mongos 连接到分片。每台服务器（mongos 和分片）上都安装了 stap。stap 将流量转发给收集器。在收集器中，您可以生成实时警报或报告。\" src=\"/sunshine_new/images/822227530/highlevelarch.png\" width=\"569\" /><p>对于熟悉 InfoSphere Guardium 的人，可以在 MongoDB 服务器上安装 S-TAP（轻量级软件代理）。S-TAP 是一个轻量级的代理，它位于操作系统中。当 Mongo 服务器收到客户端的数据请求时，S-TAP 会复制网络数据包，并将它发送到硬化的、防篡改的硬件或软件设备（称为收集器），以便解析和分析它们，并将它们记录在 InfoSphere Guardium 存储库中。<\/p><p> InfoSphere Guardium 系统的真正智慧体现在收集器上。因为就是在这里，消息被分成众多组成部分，并记录到收集器上的内部存储库中，同时采取了所有必要的操作，如生成实时警报、记录活动或阻止特定的本地用户。通过将大量活动（解析和记录）卸载到硬化的收集器上，最大程度地减少了对 Mongo 应用程序的性能影响（在很多情况下不超过 2-4%），而且您可以有效地制定职责分离。<\/p><p>InfoSphere Guardium 基于角色的 Web 控制台对警报、报告定义、合规性工作流以及设置（如存档计划）进行集中管理，无需 MongoDB 管理员的参与，这提供了审计员所需的职责分离，并且简化了合规性活动。<\/p><h3 id=\"N101AD\">消息从客户端流到 Guardium 收集器的高级示例<\/h3><p>对于不熟悉 InfoSphere Guardium 的人，对数据流经系统有一个基本了解可以帮助您有效地理解和使用系统的其他部分，比如策略配置、报告和警报。<\/p><h5 id=\"fig7\">图 7. MongoDB 命令如何流到 InfoSphere Guardium 收集器<\/h5><img alt=\"请参阅详细的文本说明。此样例命令是 Joe 发布的 test.creditcard.insert 语句。\" src=\"/sunshine_new/images/822227530/parsingoverview.png\" width=\"572\" /><p>在我们描述该流程时可参阅图 7：<\/p><ol><li>（未在图中显示。）当用户或应用程序登录到 MongoDB 时，就会启动一个新会话。InfoSphere Guardium 会始终记录会话的开始和结束，如果策略要求的话，还会记录在该会话中发生的活动。（在此系列的第 2 部分中，您会了解如何将安全策略配置为忽略在受信任连接的开始和结束之间发生的任何事情。）<\/li><li> 用户或应用程序输入了一个 MongoDB 命令。<p><strong>备注：<\/strong>MongoDB 客户端可能会对实际输入的内容进行某些转换（语法糖等）。InfoSphere Guardium 仅收集在电路上实际流过的内容。在本示例中，用户 Joe 输入了以下命令：\n                        <\/p><h5 id=\"listing2\">清单 2. 此示例中显示的 MongoDB 命令<\/h5><div class=\"codesection\"><pre class=\"displaycode\">test.CreditCard.insert({\n    \"Name\" : \"Sundari\",\n     \"profile\" : [\n        {\"CCN\" : \"11999002\"},\n        {\"log\" : [\"new\", \"customer\"]}\n    ],\n    });<\/pre><\/div><\/li><li>BSON 消息流入 Mongo 服务器（如果是分片服务器，则为 mongos 服务器；如果是本地服务器，则为 mongod 服务器）并且在网络数据包中包含额外的信息（如数据库用户的名称、客户端 IP、服务器 IP 和时间戳）。<\/li><li>位于 mongo 服务器上的 S-TAP 会拦截并复制该消息。该消息通过 TCP/IP 流入正在端口 16016 上侦听的收集器。<\/li><li>在收集器上，分析引擎（有时称为 “嗅探器（sniffer）”）认识到这是一个 MongoDB 消息并对其进行相应地解析。在我们的示例语句中，该信息被记录到以下实体。<ul class=\"ibm-bullet-list\"><li><strong>客户端/服务器实体<\/strong>：Joe 以 DB 用户的身份进行登录<\/li><li><strong>命令实体<\/strong>：INSERT<\/li><li><strong>对象实体<\/strong>：CreditCard<\/li><li><strong>字段实体<\/strong>：Name<\/li><li><strong>字段实体<\/strong>：profile.CCN<\/li><li><strong>字段实体<\/strong>：profile.log<\/li><\/ul> 这对收集器上实际发生的事项进行了极大的简化，目的只是为了让您能够对此有一个基本了解。<\/li><\/ol><h2 id=\"code-hd\">结束语<\/h2><p>本文是由三篇文章组成的文章系列的第一篇文章，我们在文本中介绍了联合解决方案的基础，包括对 MongoDB 和 InfoSphere Guardium 的概述，还介绍了 InfoSphere Guardium 如何与 MongoDB 一起，在有关数据保护和合规性的方面提供巨大价值。此外，InfoSphere Guardium 还提供了一个强大而又灵活的基础架构，用于自动化审计和合规性任务，尽可能地减轻 IT 工作人员的负担。<\/p><p>在第 2 部分中，我们将介绍为 MongoDB 配置 S-TAP 的具体细节，还将介绍如何使用安全策略完成一些常见的用例，包括监视管理员访问、警报以及反复失败的登录。<\/p><CMA ID: 972185><Site ID: 10><XSLT stylesheet used to transform this file: dw-document-html-7.0.xsl>\r\n\r\n\r\n<\/div>\r\n<\/div>\r\n","createTime":"2014-05-22 00:00:00","deployTime":"2014-05-22 00:00:00","id":0,"intro":"此文章系列将会介绍如何使用 IBM InfoSphere Guardium 监视和保护 MongoDB 数据。第 1 部分将会概述解决方案、架构以及对 MongoDB 使用 InfoSphere Guardium 的优势。快速增长型的 NoSQL 数据库（如 MongoDB）的价值是能够处理高速、高容量的数据，同时能够借助动态架构提供更大的灵活性。很多组织机构都只是刚开始使用 MongoD，现在是在环境中建立安全机制以节省时间、防止违规和避免违规的时候了。此文章系列将会介绍解决方案的配置、样例监视用例和其他功能（比如使用一个审计流程快速搜索审计数据并构建一个合规的工作流程）。","keyword":"","recommend":false,"source":"http://www.ibm.com/developerworks/cn/data/library/techarticle/dm-1306mongodb/index.html","title":"MongoDB 的 InfoSphere Guardium 数据安全和保护，第 1 部分: 解决方案概述和数据安全建议","typeId":0,"updateTime":"2014-05-22 00:00:00"}
{"author":"","clickNumber":0,"content":"\r\n<div class=\"ibm-columns\">\r\n<div class=\"ibm-col-1-1\">\r\n\r\n<h2 id=\"major1\">引言<\/h2><p>IBM WebSphere Commerce 是 IBM 公司提供的一个电子商务解决方案，迄今已有十多年的历史，最新版本是 7.0。WebSphere Commerce 中内置了多种业务模型和商务流程，在对产品只需要进行一次安装、部署之后，客户就可以快速的向其消费者或者分销商等提供丰富的 B2C 和 B2B 业务，并支持包括在线销售、电话销售等多种销售渠道，而且通过其提供的开发工具（WebSphere Commerce Development Environment），客户能方便的开发、部署符合其自身需求的特定业务逻辑或者将其现有功能集成到 WebSphere Commerce 中，详细信息请参考 <a href=\"http://publib.boulder.ibm.com/infocenter/wchelp/v7r0m0/index.jsp\">WebSphere Commerce 的信息中心<\/a>。<\/p><p>在本文中，我们将介绍 IBM? WebSphere Commerce V7 预览功能在 Feature Pack6 改进和应用，以及如何实现在多平台 Web 浏览器直接通过预览 URL 来显示我们在管理中心 CMC 中所做的更改。另外。本文也介绍了如何来解决 URL 预览的权限安全问题。<\/p><h2 id=\"major2\">WebSphere Commerce 预览功能介绍<\/h2><p>在 FEP6 之前，预览功能的实现分为三个部分<\/p><ul class=\"ibm-bullet-list\"><li>Preview Setup Command: 这就是所谓的企业用户工具（如 CMC）与管理员通过指定预览选项来更新管理员的业务环境（特别是预览上下文和内容方面）。<\/li><li>Preview Servlet：用来处理商店的预览页面请求。对于一个新的预览会话来说，预览 Servlet 将创建预览用户活动 ( 一个通用的用户活动 )，并在转发请求到商店请求的 Servlet 之前，复制从管理员的业务上下文的预览选项来预览用户的业务环境。<\/li><li>Preview-sensitive Business Logic：根据在预览用户的业务环境中设置预览选项的行为。<\/li><\/ul><p>这种实现方式有如下限制：<\/p><ul class=\"ibm-bullet-list\"><li>它只能支持 Web 容器内的组件<\/li><li>商店预览请求必须在预览设置命令被调用的浏览器会话中进行，所以只能在当前浏览器下运行是一个很大的限制。<\/li><\/ul><h3 id=\"minor2.1\">FEP6 的改进<\/h3><p>在 FEP6 中，引入了如下的功能<\/p><ul class=\"ibm-bullet-list\"><li>BOD 和 REST 服务预览\n\n\t\t\t\n<p>增加预览功能到 Webservice 和 REST 服务框架 , 使用户还可以预览在除 Web 组件之外的其他服务上的内容 , 例如本地移动应用和 Portlets。<\/p><\/li><li>商店预览链接\n\t\t\t\n<p>让用户能够根据预先的配置在不同的浏览器和设备上进行查看或者与其他业务用户共享的预览选项生成商店预览链接保存预览页（启用预览的存储页面）<\/p><p>这样改进的优势如下：<\/p><ul class=\"ibm-bullet-list\"><li>易用性 \n\t\t\t\t    \n<ul class=\"ibm-bullet-list\"><li>它可以非常方便的为一个服务消费者增加预览支持，可以在运行时启用或者禁用预览功能。<\/li><li>商店预览链接将通过预先设置的预览项直接指向目标商店预览页面，不需要任何的额外配置。<\/li><li>任何一个业务用户都可以通过密码进行访问预览链接，即使没有账户。<\/li><\/ul><\/li><li>功能完整性 \n\t\t\t\t    \n<ul class=\"ibm-bullet-list\"><li>将支持以前版本支持的预览服务，包括时间，工作区，目录。<\/li><li>服务的消费者可以用公众号，访客或者注册用户通过启用预览提交服务申请。<\/li><\/ul><\/li><li>安全性 \n\t\t\t\t      \n<ul class=\"ibm-bullet-list\"><li>只有管理员可以开启预览服务给服务消费者，或者生成商店预览的链接。<\/li><li>服务消费者只能被允许通过开启预览功能的 HTTPS 中发起 REST 服务请求<\/li><li>管理员在生成一个商店预览链接的时候，可以设定密码来限定这个链接的访问。<\/li><li>BOD 和 REST 服务预览功能默认关闭，以阻止非授权访问。<\/li><\/ul><\/li><\/ul><\/li><\/ul><h2 id=\"major3\">功能设计<\/h2><h3 id=\"minor3.1\">预览令牌<\/h3><p>预览令牌基本上是由管理员生成的加密字符串，它封装一系列的预览选项和何处何地可以使用的限制。生成的预览令牌允许任何用户通过令牌来执行预览操作（如在预览模式下发起服务请求或者访问一个商店预览链接），直至令牌过期或者撤销。通过预览令牌，可以将预览的行为从预览功能搭建中分离开来。<\/p><h5 id=\"fig1\">图 1. 预览令牌<\/h5><img alt=\"图 1. 预览令牌\" src=\"/sunshine_new/images/负1205914671/images/image01.jpg\" width=\"581\" /><h3 id=\"minor3.2\">创建预览令牌的命令 / 服务<\/h3><p>创建预览令牌是一个管理的命令和服务，可以将一系列的预览项和使用限制生成预览令牌。它提供了类似于现有的预览运行时的预览设置命令，但预览的选项将被绑定到预览令牌，而不是管理员的业务上下文。<\/p><p>这个命令和服务有如下的参数：<\/p><p>start- 以 yyyy/MM/dd HH:mm:ss 格式表示的预览日期和时间。默认是当前日期和时间。<\/p><p>timeZoneId - 时区 ID，不许是一个有效的 Java 语言的时区 ID，默认是当前服务器的时区 ID。<\/p><p>status- 如果是 true 的话，预览模式是静态的，否则不是。默认是不是静态的。<\/p><p>invstatus:<\/p><ul class=\"ibm-bullet-list\"><li>\n\t\t\t\t\t 0：使用数据库中的级别<\/li><li>\n\t\t\t\t\t 1：设置所有的过滤器结果为 true<\/li><li>\n\t\t\t\t\t -1：设置所有的过滤器结果为 false<\/li><\/ul><div class=\"codesection\"><pre class=\"displaycode\">默认为 0<\/pre><\/div><p>includedMemberGroupIds- 给某客户群的用户提供预览。一个用逗号相隔成员组 ID 的列表<\/p><p>workspaceId- 工作台 ID。可选。<\/p><p>taskGroupId- 任务组 ID。可选。<\/p><p>taskId- 任务 ID。可选。<\/p><p>tokenLife- 预览令牌的生命周期，以分钟为单位。默认 60。<\/p><p>startDate- 以 yyyy/MM/dd HH:mm:ss 格式表示的预览令牌开始的日期和时间。默认是当前日期和时间。<\/p><p>endDate- 以 yyyy/MM/dd HH:mm:ss 格式表示的预览令牌结束的日期和时间。长度应超过令牌生命周期。默认是开始日期加上令牌的周期长<\/p><p>Password- 商店预览链接的密码。可选。<\/p><h5 id=\"listing1\">清单 1. AJAX 预览令牌请求<\/h5><div class=\"codesection\"><pre class=\"displaycode\"> https://wcstestserver.raleigh.ibm.com:8000/webapp/wcs/tools \n /servlet/AjaxPreviewTokenCreate?storeId=10001&amp;start \n =2013%2F01%2F01+00%3A00%3A00&amp;timeZoneId=America%2FNew \n _York&amp;status=true&amp;invstatus \n =0&amp;includedMemberGroupIds=10001%2C10002 \n &amp;workspaceId=10001&amp;taskId=10001&amp;tokenLif \n e=60&amp;password=passw0rd<\/pre><\/div><h5 id=\"listing2\">清单 2. AJAX 预览令牌响应<\/h5><div class=\"codesection\"><pre class=\"displaycode\"> { \n\"previewToken\": \"iuJOiPLnTn0=\"\n }<\/pre><\/div><h5 id=\"listing3\">清单 3. BOD 预览令牌请求<\/h5><div class=\"codesection\"><pre class=\"displaycode\"> &lt;_mbr:ProcessPerson xmlns:_mbr=\"http://www.ibm.com/xmlns/prod \n /commerce/9/member\" xmlns:_wcf=\"http://www.ibm.com/xmlns/prod \n /commerce/9/foundation\" xmlns:oa=\"http://www.openapplications.org \n /oagis/9\" versionID=\"6.0.0.4\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"&gt; \n  &lt;oa:ApplicationArea xsi:type=\"_wcf:ApplicationAreaType\"&gt; \n    &lt;oa:CreationDateTime&gt;&lt;/oa:CreationDateTime&gt; \n    &lt;oa:BODID&gt;&lt;/oa:BODID&gt; \n    &lt;_wcf:BusinessContext intent=\"Authoring\"&gt; \n      &lt;_wcf:ContextData name=\"storeId\"&gt;10001&lt;/_wcf:ContextData&gt; \n    &lt;/_wcf:BusinessContext&gt; \n  &lt;/oa:ApplicationArea&gt; \n  &lt;_mbr:DataArea&gt; \n    &lt;oa:Process&gt; \n      &lt;oa:ActionCriteria&gt; \n        &lt;oa:ActionExpression actionCode=\"CreatePreviewToken\"\n         expressionLanguage=\"_wcf:XPath\"/&gt; \n      &lt;/oa:ActionCriteria&gt; \n    &lt;/oa:Process&gt; \n    &lt;_mbr:Person&gt; \n      &lt;_mbr:Credential&gt; \n         &lt;_wcf:UserData&gt; \n            &lt;_wcf:UserDataField name=\"start\"&gt;2013/01/01 00:00:00&lt;/_wcf:UserDataField&gt; \n            &lt;_wcf:UserDataField name=\"timeZoneId\"&gt;America/New_York&lt;/_wcf:UserDataField&gt; \n            &lt;_wcf:UserDataField name=\"status\"&gt;true&lt;/_wcf:UserDataField&gt; \n            &lt;_wcf:UserDataField name=\"invstatus\"&gt;0&lt;/_wcf:UserDataField&gt; \n            &lt;_wcf:UserDataField name=\"includedMemberGroupIds\"&gt;10001,10002&lt;/_wcf:UserDataField&gt; \n            &lt;_wcf:UserDataField name=\"workspaceId\"&gt;10001&lt;/_wcf:UserDataField&gt; \n            &lt;_wcf:UserDataField name=\"taskGroupId\"&gt;10001&lt;/_wcf:UserDataField&gt; \n            &lt;_wcf:UserDataField name=\"taskId\"&gt;10001&lt;/_wcf:UserDataField&gt; \n            &lt;_wcf:UserDataField name=\"tokenLife\"&gt;60&lt;/_wcf:UserDataField&gt; \n            &lt;_wcf:UserDataField name=\"password\"&gt;passw0rd&lt;/_wcf:UserDataField&gt; \n &lt;/_wcf:UserData&gt; \n       &lt;/_mbr:Credential&gt; \n      &lt;_mbr:PersonalProfile/&gt; \n      &lt;_mbr:ContactInfo&gt; \n        &lt;_wcf:ContactInfoIdentifier&gt; \n          &lt;_wcf:ExternalIdentifier/&gt; \n        &lt;/_wcf:ContactInfoIdentifier&gt; \n        &lt;_wcf:Address/&gt; \n      &lt;/_mbr:ContactInfo&gt; \n    &lt;/_mbr:Person&gt; \n  &lt;/_mbr:DataArea&gt; \n &lt;/_mbr:ProcessPerson&gt;<\/pre><\/div><h5 id=\"listing4\">清单 4. BOD 预览令牌响应<\/h5><div class=\"codesection\"><pre class=\"displaycode\"> &lt;_mbr:AcknowledgePerson xmlns:Oagis9 \n =\"http://www.openapplications.org/oagis/9\" \n xmlns:_mbr=\"http://www.ibm.com/xmlns/prod/commerce/9/member\" \n xmlns:_wcf=\"http://www.ibm.com/xmlns/prod/commerce/9/foundation\"\n  xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"&gt; \n  &lt;Oagis9:ApplicationArea xsi:type=\"_wcf:ApplicationAreaType\"&gt; \n    &lt;Oagis9:CreationDateTime&gt;&lt;/Oagis9:CreationDateTime&gt; \n    &lt;Oagis9:BODID&gt;&lt;/Oagis9:BODID&gt; \n  &lt;/Oagis9:ApplicationArea&gt; \n  &lt;_mbr:DataArea&gt; \n    &lt;Oagis9:Acknowledge&gt; \n      &lt;Oagis9:OriginalApplicationArea&gt; \n        &lt;Oagis9:CreationDateTime&gt;&lt;/Oagis9:CreationDateTime&gt; \n        &lt;Oagis9:BODID&gt;&lt;/Oagis9:BODID&gt; \n      &lt;/Oagis9:OriginalApplicationArea&gt; \n    &lt;/Oagis9:Acknowledge&gt; \n    &lt;_mbr:Person&gt; \n      &lt;_mbr:Credential&gt; \n        &lt;_wcf:UserData&gt; \n          &lt;_wcf:UserDataField name=\"previewToken\"&gt;iuJOiPLnTn0=&lt;/_wcf:UserDataField&gt; \n        &lt;/_wcf:UserData&gt; \n      &lt;/_mbr:Credential&gt; \n    &lt;/_mbr:Person&gt; \n  &lt;/_mbr:DataArea&gt; \n &lt;/_mbr:AcknowledgePerson&gt;<\/pre><\/div><h5 id=\"listing5\">清单 5. REST 预览令牌请求<\/h5><div class=\"codesection\"><pre class=\"displaycode\"> Post /wcs/resources/store/10001/previewToken HTTPS/1.1 \n Host: wcstestserver.raleigh.ibm.com \n Content-Type: application/json \n { \n \"start\": \"2013/01/01 20:30:00\", \n \"timeZoneId\": \"America/New_York\", \n \"status\": \"true\", \n \"invstatus\": \"0\", \n \"includedMemberGroupIds\": \"10001,10002\", \n \"workspaceId\": \"10001\", \n \"taskGroupId\": \"10001\", \n \"taskId\": \"10001\", \n \"tokenLife\": \"60\", \n \"password\": \"passw0rd\"\n }<\/pre><\/div><h5 id=\"listing6\">清单 6. REST 预览令牌响应<\/h5><div class=\"codesection\"><pre class=\"displaycode\"> HTTPS/1.1 201 Created \n Content-Type: application/json \n { \n \"previewToken\": \"iuJOiPLnTn0=\"\n }<\/pre><\/div><h3 id=\"minor3.3\">BOD 服务预览<\/h3><p>为了支持 BOD 服务预览，Webservice 框架需要在 BOD 的业务上下文元素中去支持预览令牌（previewToken）。当 Webservice 框架调用 BCS 发出请求后，ClassicCommerceContextServiceImpl 将会解密并且验证预览令牌，验证成功后，系统会根据预览选项临时更新用户的业务上下文。它允许已存在的预览业务正常工作，而不需要做任何变化。<\/p><h5 id=\"fig2\">图 2.BOD 服务预览<\/h5><img alt=\"图 2.BOD 服务预览\" src=\"/sunshine_new/images/负1205914671/images/image02.jpg\" width=\"581\" /><h3 id=\"minor3.4\">REST 服务预览<\/h3><p>类似于 Webservice 框架，REST 服务架构也需要在 HTTP header 区域 WCPreview Token 来接受预览令牌。在最初的请求中，CommerceTokenRequestHandler 将会验证预览令牌是否通过 HTTPS 发出的，并且 BusinessContextRequestHandler 将拷贝它到 BOD 的业务上下文，以方便于可以被 webservice 架构访问。<\/p><h5 id=\"fig3\">图 3.REST 服务预览<\/h5><img alt=\"图 3.REST 服务预览\" src=\"/sunshine_new/images/负1205914671/images/image03.jpg\" width=\"581\" /><h3 id=\"minor3.5\">商店预览链接<\/h3><p>商店的预览链接基本上是管理员使用业务用户工具或者指令、服务生成的 URL，可以通过预设的预览项直接指向商店预览页面。当预览的链接生成之后，它将会允许任何用户凭借管理员分配的正确的密码访问预览页，直至预览链接过期或者撤销。这么设计的目的是为了可以在业务用户工具之外工作，并且无需任何设置，所以他可以在不同的浏览器和设备上被查看和与其他用户共享。<\/p><p>CMC 将可以通过将预览令牌作为参数追加到普通的预览页面的 URL 来生成一个商店预览链接<\/p><div class=\"codesection\"><pre class=\"displaycode\">https://wcstestserver.raleigh.ibm.com:8006/webapp/wcs/preview\n/servlet/en/aurora?previewToken=iuJOiPLnTn0%3D<\/pre><\/div><p>为了支持商店预览链接，需要向预览 servlet 中加入一个新的预览请求 plugin(PreviewTokenPreviewRequestPluginImpl)。它将会解码并且验证预览令牌，如果通过，将会更新用户的业务上下文。<\/p><h5 id=\"fig4\">图 4. 商店预览链接<\/h5><img alt=\"图 4. 商店预览链接\" src=\"/sunshine_new/images/负1205914671/images/image04.jpg\" width=\"582\" /><h3 id=\"minor3.6\">实例演示<\/h3><p>通过 CMC 生成商店预览链接例子：一个管理员可以登录 CMC 的商店预览功能模块，然后生成一个预览的链接到目前正在预览的页面。<\/p><h5 id=\"fig5\">图 5.Setting for generated URL<\/h5><img alt=\"图 5.Setting for generated URL\" src=\"/sunshine_new/images/负1205914671/images/image05.jpg\" width=\"582\" /><p>点击 Generate URL<\/p><h5 id=\"fig6\">图 6.Generate URL<\/h5><img alt=\"图 6.Generate URL\" src=\"/sunshine_new/images/负1205914671/images/image06.jpg\" width=\"582\" /><p>如果管理员在生成预览链接的时候设置了预览密码，那么当这个链接被第一次访问（或者密码输入不对）时，将会跳转到 StorePreivewLinkView。它将会让预览用户输入密码。然后将会验证密码，如果成功，将会更新业务上下文。在更新之后，如果再有后来的请求，将不会再次要求输入密码。<\/p><h5 id=\"fig7\">图 7.Setting for password<\/h5><img alt=\"图 7.Setting for password\" src=\"/sunshine_new/images/负1205914671/images/image07.jpg\" width=\"581\" /><h5 id=\"fig8\">图 8.Preview mode<\/h5><img alt=\"图 8.Preview mode\" src=\"/sunshine_new/images/负1205914671/images/image08.jpg\" width=\"582\" /><h2 id=\"major4\">总结<\/h2><p>至此为止，介绍了 FEP6 中预览功能的新特性。 希望读者通过本文能对 WebSphere Commerce V7 的预览功能有个更加深入的了解。<\/p><CMA ID: 972108><Site ID: 10><XSLT stylesheet used to transform this file: dw-document-html-7.0.xsl>\r\n\r\n\r\n<\/div>\r\n<\/div>\r\n","createTime":"2014-05-22 00:00:00","deployTime":"2014-05-22 00:00:00","id":0,"intro":"在本文中，我们将介绍 WebSphere Commerce V7 预览功能在 Feature Pack 6 中的改进和应用，以及如何实现在多平台 Web 浏览器直接通过预览 URL 来显示我们在管理中心 CMC 中所做的更改。另外。本文也介绍了如何来解决 URL 预览的权限安全问题。","keyword":"","recommend":false,"source":"http://www.ibm.com/developerworks/cn/websphere/library/techarticles/1405_liuc_preview/1405_liuc_preview.html","title":"WebSphere Commerce V7 预览功能介绍以及在 Feature Pack 6 改进和应用","typeId":0,"updateTime":"2014-05-22 00:00:00"}
{"author":"","clickNumber":0,"content":"\r\n<div class=\"ibm-columns\">\r\n<div class=\"ibm-col-1-1\">\r\n\r\n<p><em>Codename: BlueMix 是一款 beta\n                    级产品，随着我们不断让其功能更加完善和更易于使用，它也将不断改进。我们会竭尽全力保持本文最新，但并不总是完全跟得上现状。感谢大家的理解！<\/em><\/p><p>作为一家无线服务供应商公司的客户分析小组中的数据科学家，我们想利用客户数据来预测客户流失情况。对于电信行业来说，客户保留是一个重大挑战，在该行业中，客户年度流失率高达\n                40%。如果我们可以预测哪些客户存在流动的风险，那么我们的公司就可以在客户将业务转向别处之前采取相应的措施来留住客户。即使是很少的客户流失，也会对我们的企业底线产生重要的影响。<\/p><p>我们决定构建一个可以随时间的推移而增强的快速 Web 应用程序。我们的应用程序使用了分类算法代码，该算法是我们使用开源机器学习工具 Weka 通过\n                Java&#8482; 语言开发的。在 BlueMix 中，我们可以部署自己的 Java 应用程序，并利用 BLU Acceleration 分析数据库服务的优势对我们的客户数据进行分析。BLU Acceleration\n                提供了简单性和性能，如果我们决定扩大规模或增强应用程序来执行其他类型的数据分析，那么还可以提供企业级的应用程序。最后，我们选择使用 Twitter\n                Bootstrap 作为 Web 开发框架，因为它提供了移动先行 Web\n                界面的灵活性，而且可以轻松适应那些用来执行我们的分析的混合设备和浏览器。<\/p><p>了解如何才能在 BlueMix\n                中构建一个类似的应用程序。我们假设您拥有适用于您的应用程序的必要代码，我们还提供了一些应用程序代码和数据，使用它们作为样例，帮助您开始了解如何操作。<\/p><ul class=\"ibm-bullet-list\"><li><a href=\"http://bludemo.ng.bluemix.net/\">运行代码<\/a><\/li><li><a href=\"https://hub.jazz.net/project/kschawla/bludemo/overview\">获取\n                        JazzHub 中的代码<\/a><\/li><\/ul><h2 id=\"Whatyouwillneedtobuildasimilarapp|outline\">构建类似应用程序的前提条件<\/h2><ul class=\"ibm-bullet-list\"><li>熟悉 Java 应用程序开发<\/li><li>熟悉现代的前端框架，例如 <a href=\"http://getbootstrap.com/2.3.2/\">Twitter\n                        Bootstrap<\/a><\/li><li>对统计分析工具有一定的了解，例如 <a href=\"http://www.cs.waikato.ac.nz/ml/weka/\">Weka<\/a> 或\n                    R<\/li><\/ul><h2 id=\"Step1:CreatetheapplicationinBlueMix|outline\">第 1 步. 在 Codename: BlueMix 中创建应用程序<\/h2><p>访问 <a href=\"http://ace.ng.bluemix.net\">Codename: BlueMix<\/a> 并登录。<\/p><h5 id=\"N1008D\">图 1. <\/h5><img alt=\"BlueMix 登录屏幕的屏幕截图\" src=\"/sunshine_new/images/462027141/image001.jpg\" width=\"800\" height=\"313\" /><p><a href=\"#N1008F\" class=\"ibm-popup-link\" onclick=\"ibmweb.overlay.show('N1008F',this);return false;\">点击查看大图<\/a><\/p><div id=\"N1008F\" class=\"dw-sidefile-overlay ibm-common-overlay ibm-overlay-alt-two\"><div class=\"ibm-head\"><p><a href=\"#close\" class=\"ibm-common-overlay-close\">关闭 [x]<\/a><\/p><\/div><div class=\"ibm-body\"><div class=\"ibm-main\"><div class=\"ibm-title\"><h2>图 1. <\/h2><\/div><div class=\"ibm-container ibm-alternate\"><div class=\"ibm-container-body\"><img alt=\"BlueMix 登录屏幕的屏幕截图\" src=\"/sunshine_new/images/462027141/image001.jpg\" width=\"1000\" /><\/div><\/div><\/div><\/div><div class=\"ibm-footer\"><><\/div><\/div><p>在仪表板页面上，单击 <strong>Add an application<\/strong>。<\/p><p>在本例中，您将创建一个 Java 应用程序。在 Runtimes 下，选择 <strong>.java liberty<\/strong>\n                (Liberty for Java)。<\/p><p>在弹出窗口中，单击 <strong>CREATE APP<\/strong>。<\/p><p>在下一个弹出窗口中，填写应用程序名称和主机，然后单击 <strong>CREATE<\/strong>。<\/p><h5 id=\"N100A9\">图 2. <\/h5><img alt=\"\" src=\"/sunshine_new/images/462027141/image002.jpg\" width=\"800\" height=\"337\" /><p><a href=\"#N100AB\" class=\"ibm-popup-link\" onclick=\"ibmweb.overlay.show('N100AB',this);return false;\">点击查看大图<\/a><\/p><div id=\"N100AB\" class=\"dw-sidefile-overlay ibm-common-overlay ibm-overlay-alt-two\"><div class=\"ibm-head\"><p><a href=\"#close\" class=\"ibm-common-overlay-close\">关闭 [x]<\/a><\/p><\/div><div class=\"ibm-body\"><div class=\"ibm-main\"><div class=\"ibm-title\"><h2>图 2. <\/h2><\/div><div class=\"ibm-container ibm-alternate\"><div class=\"ibm-container-body\"><img alt=\"\" src=\"/sunshine_new/images/462027141/image002.jpg\" width=\"1000\" /><\/div><\/div><\/div><\/div><div class=\"ibm-footer\"><><\/div><\/div><p>Codename: BlueMix 在您的工作区中创建应用程序并启动 Java\n                运行时。您可通过仪表板上显示的确认信息来获知成功启动应用程序的时间。<\/p><h5 id=\"N100B3\">图 3. <\/h5><img alt=\"\" src=\"/sunshine_new/images/462027141/image003.jpg\" width=\"800\" height=\"418\" /><p><a href=\"#N100B5\" class=\"ibm-popup-link\" onclick=\"ibmweb.overlay.show('N100B5',this);return false;\">点击查看大图<\/a><\/p><div id=\"N100B5\" class=\"dw-sidefile-overlay ibm-common-overlay ibm-overlay-alt-two\"><div class=\"ibm-head\"><p><a href=\"#close\" class=\"ibm-common-overlay-close\">关闭 [x]<\/a><\/p><\/div><div class=\"ibm-body\"><div class=\"ibm-main\"><div class=\"ibm-title\"><h2>图 3. <\/h2><\/div><div class=\"ibm-container ibm-alternate\"><div class=\"ibm-container-body\"><img alt=\"\" src=\"/sunshine_new/images/462027141/image003.jpg\" width=\"1000\" /><\/div><\/div><\/div><\/div><div class=\"ibm-footer\"><><\/div><\/div><h2 id=\"Step2:CreatetheBLUAccelerationservice|outline\">第 2 步. 创建 BLU Acceleration 服务<\/h2><p>从仪表板中选择您创建的应用程序，转到它的概述页面。<\/p><p>单击该页面的 Services 部分中的 <strong>Add new service<\/strong>。<\/p><h5 id=\"N100C7\">图 4. <\/h5><img alt=\"\" src=\"/sunshine_new/images/462027141/image004.jpg\" width=\"800\" height=\"417\" /><p><a href=\"#N100C9\" class=\"ibm-popup-link\" onclick=\"ibmweb.overlay.show('N100C9',this);return false;\">点击查看大图<\/a><\/p><div id=\"N100C9\" class=\"dw-sidefile-overlay ibm-common-overlay ibm-overlay-alt-two\"><div class=\"ibm-head\"><p><a href=\"#close\" class=\"ibm-common-overlay-close\">关闭 [x]<\/a><\/p><\/div><div class=\"ibm-body\"><div class=\"ibm-main\"><div class=\"ibm-title\"><h2>图 4. <\/h2><\/div><div class=\"ibm-container ibm-alternate\"><div class=\"ibm-container-body\"><img alt=\"\" src=\"/sunshine_new/images/462027141/image004.jpg\" width=\"1000\" /><\/div><\/div><\/div><\/div><div class=\"ibm-footer\"><><\/div><\/div><p>选择 <strong>BLU Acceleration<\/strong> 作为要添加的服务。<\/p><p>弹出的窗口将显示有关 BLU Acceleration 服务的更多信息。在后续弹出窗口中依次单击 <strong>ADD TO\n                    APPLICATION<\/strong> 和 <strong>CREATE<\/strong>。<\/p><h5 id=\"N100DC\">图 5. <\/h5><img alt=\"\" src=\"/sunshine_new/images/462027141/image005.jpg\" width=\"800\" height=\"331\" /><p><a href=\"#N100DE\" class=\"ibm-popup-link\" onclick=\"ibmweb.overlay.show('N100DE',this);return false;\">点击查看大图<\/a><\/p><div id=\"N100DE\" class=\"dw-sidefile-overlay ibm-common-overlay ibm-overlay-alt-two\"><div class=\"ibm-head\"><p><a href=\"#close\" class=\"ibm-common-overlay-close\">关闭 [x]<\/a><\/p><\/div><div class=\"ibm-body\"><div class=\"ibm-main\"><div class=\"ibm-title\"><h2>图 5. <\/h2><\/div><div class=\"ibm-container ibm-alternate\"><div class=\"ibm-container-body\"><img alt=\"\" src=\"/sunshine_new/images/462027141/image005.jpg\" width=\"1000\" /><\/div><\/div><\/div><\/div><div class=\"ibm-footer\"><><\/div><\/div><h2 id=\"Step3:ExploretheBLUAccelerationservice(optional)|outline\">第 3 步. 查看 BLU Acceleration 服务（可选）<\/h2><p>BLU Acceleration 服务在其 Web 控制台中提供了一些数据分析工具，包括加载和查询数据、使用 R 或 Excel&#174;\n                来分析数据，使用 Cognos\n                来报告数据，以及向您提供常见行业特定用例的行业模型。这个令人印象深刻的可用工具集值得您去探索，以便为将来的项目做准备。<\/p><p>在应用程序概述页面中，选择 <strong>BLUAcceleration<\/strong> 服务。<\/p><h5 id=\"N100F2\">图 6. <\/h5><img alt=\"\" src=\"/sunshine_new/images/462027141/image006.jpg\" width=\"800\" height=\"462\" /><p><a href=\"#N100F4\" class=\"ibm-popup-link\" onclick=\"ibmweb.overlay.show('N100F4',this);return false;\">点击查看大图<\/a><\/p><div id=\"N100F4\" class=\"dw-sidefile-overlay ibm-common-overlay ibm-overlay-alt-two\"><div class=\"ibm-head\"><p><a href=\"#close\" class=\"ibm-common-overlay-close\">关闭 [x]<\/a><\/p><\/div><div class=\"ibm-body\"><div class=\"ibm-main\"><div class=\"ibm-title\"><h2>图 6. <\/h2><\/div><div class=\"ibm-container ibm-alternate\"><div class=\"ibm-container-body\"><img alt=\"\" src=\"/sunshine_new/images/462027141/image006.jpg\" width=\"1000\" /><\/div><\/div><\/div><\/div><div class=\"ibm-footer\"><><\/div><\/div><p>在接下来的页面上，单击 <strong>Launch the console<\/strong>。<\/p><p>这会打开一个新窗口，其中包含 BLU Data Warehouse Web 控制台。您可以在这个控制台中做许多事情，包括将数据文件上传到数据库，以及用\n                R 分析数据。<\/p><h5 id=\"N10101\">图 7. <\/h5><img alt=\"\" src=\"/sunshine_new/images/462027141/image007.jpg\" width=\"800\" height=\"393\" /><p><a href=\"#N10103\" class=\"ibm-popup-link\" onclick=\"ibmweb.overlay.show('N10103',this);return false;\">点击查看大图<\/a><\/p><div id=\"N10103\" class=\"dw-sidefile-overlay ibm-common-overlay ibm-overlay-alt-two\"><div class=\"ibm-head\"><p><a href=\"#close\" class=\"ibm-common-overlay-close\">关闭 [x]<\/a><\/p><\/div><div class=\"ibm-body\"><div class=\"ibm-main\"><div class=\"ibm-title\"><h2>图 7. <\/h2><\/div><div class=\"ibm-container ibm-alternate\"><div class=\"ibm-container-body\"><img alt=\"\" src=\"/sunshine_new/images/462027141/image007.jpg\" width=\"1000\" /><\/div><\/div><\/div><\/div><div class=\"ibm-footer\"><><\/div><\/div><h2 id=\"Step4.UploadyourdatatoBLUAcceleration(optional)|outline\">第 4 步. 将数据上传到 BLU Acceleration（可选）<\/h2><p>我们的样例数据集已经位于 BLU Acceleration 数据仓库中。但是，您也可以使用自己的数据。要想将数据上传到 BLU\n                Acceleration：<\/p><ol><li>在 BLU Acceleration Web 控制台中，单击 <strong>Manage<\/strong> 选项卡，然后选择\n                        <strong>Load Data<\/strong>。<\/li><li>我们将加载来自 CSV 文件的数据。选择 <strong>Local File System<\/strong>\n                    作为数据来源，并浏览包含您的数据的文件。<\/li><li>您需要为该数据创建一张新表。单击 <strong>+<\/strong>。<\/li><li>再次通过浏览寻找要加载的 CSV 文件。BLU Acceleration 会生成一个 SQL 语句，根据 CSV\n                    文件的内容来创建表。对于我们的分析，除了分类列之外，我们需要加倍增加所有的列。请根据提示修改列类型。<\/li><li>单击 <strong>Run DDL<\/strong> 来运行语句；您会收到查询成功运行的通知。单击\n                    <strong>OK<\/strong>。然后单击 <strong>Cancel<\/strong>。<\/li><li>选择刚刚创建的表。<\/li><li>选择默认选项 <strong>Append new data into the table<\/strong>，然后单击\n                        <strong>Load Now<\/strong>。系统会加载数据。<\/li><\/ol><h2 id=\"Step5.DownloadtheCode|outline\">第 5 步.\n                下载代码<\/h2><p>如果尚未下载代码，请 <a href=\"https://hub.jazz.net/project/kschawla/bludemo/overview\">获取 JazzHub 中的代码<\/a>。<\/p><p>选择 <strong>EDIT CODE<\/strong>。登录后，您会看到要下载的代码。<\/p><p>单击 <strong>File &gt; Export &gt; Zip<\/strong> 将代码下载到您的计算机。<\/p><h2 id=\"Step6.Understandthecode|outline\">第 6 步.\n                了解代码<\/h2><p>样例应用程序包含以下组件：<\/p><ul class=\"ibm-bullet-list\"><li>FileLocationContextListener 在服务器上创建了用于文件上传的文件夹。<\/li><li>如果用户选择使用数据库来上传针对模型的培训数据集，那么可以使用输入的详细信息将数据上传到 Instances 对象，使用这些数据作为\n                    TrainingSet。然后，可以使用这个 TrainingSet 来创建 NaiveBayes\n                    模型。或者，使用默认的数据库表来创建模型。<\/li><li>用户可以上传一个 CSV 文件，用它作为一个 Testing 集。该文件被上传到先前在服务器上创建的文件夹中。<\/li><li>Weka 将 Attribute-Relation File Format (ARFF)\n                    文件作为一种基本的文件格式进行处理，该文件包含所需的属性和数据集。CSV2ARFF.java 是一个单独的实用程序，它可以将 CSV\n                    文件转换成存储在服务器上的相同文件夹中的 ARFF 文件。<\/li><li>然后，将 ARFF 文件加载到 Instances 对象中，使用该文件作为一个 TestingSet。<\/li><li>对于 TestingSet 中的所有实例，可以使用 NaiveBayes 模型将输出分类为 <em>Churn<\/em> 或 <em>Not\n                        Churn<\/em> 类。<\/li><li>然后，在用户界面上显示相应的输出。<\/li><\/ul><h2 id=\"Step7.Generatea.warfile|outline\">第 7 步.\n                生成 WAR 文件<\/h2><p>要想将代码推送到 BlueMix 中，需要生成一个 WAR 文件。利用 Eclipse 可以轻松完成这一操作。为了防止您无法生成 WAR\n                文件，这里已经包含了该文件。<\/p><p>选择 <strong>File &gt; Import<\/strong>。在对话窗口中，选择 <strong>Existing Projects\n                    into Workspace<\/strong>，然后选择 <strong>Next<\/strong>。<\/p><p>在接下来的对话窗口中，浏览从 JazzHub 下载的文件。<\/p><h5 id=\"N10181\">图 8. <\/h5><img alt=\"\" src=\"/sunshine_new/images/462027141/image008.jpg\" width=\"650\" /><p>保留所有的默认值即可。然后选择 <strong>Finish<\/strong>。现在，您已经将项目添加到了您的 Eclipse Client。<\/p><p>要想将项目导出为一个 WAR 文件，请右键单击 Project Explorer 中的项目。然后选择 <strong>Export &gt; War\n                    File<\/strong>。将 WAR 文件单独保存到一个目录中。<\/p><h5 id=\"N10193\">图 9. <\/h5><img alt=\"\" src=\"/sunshine_new/images/462027141/image009.jpg\" width=\"610\" /><h2 id=\"Step8.Deploytheapplication|outline\">第 8\n                步. 部署应用程序<\/h2><p>打开一个终端并转到 WAR 文件的目录。最好是将 WAR 文件放入它自己的目录中。<\/p><p>运行 cf <code>push<\/code> 命令。提供应用程序名称、所需的内存、实例，以及到达 WAR 文件的路径。对于这个应用程序，我们提供\n                512 MB 的内存和一个实例：<code>cf push bludemo -m 512m -p\nBLUDemo.war <\/code>。<\/p><p>当上传应用程序时，出现的详细信息会指示正在发生的事情。大约一分钟半以后，应用程序就可以正常运行了。<\/p><p>如果想要更改应用程序，可重复此流程。生成新的 WAR 文件后，运行相同的命令将它推送到 BlueMix。<\/p><h2 id=\"Alternativesteps:DeploytheapplicationfromJazzHub|outline\">备选步骤：从 JazzHub 部署应用程序<\/h2><p>不需要遵循前面的大部分步骤，您就可以创建服务并通过 JazzHub 部署应用程序。<\/p><p>在自己的工作区中拥有代码之后（第 5 步），修改名称为 manifest.yml 的文件。<\/p><p>将 <em>name<\/em> 和 <em>host<\/em> 修改为应用程序的名称和主机。这些值应该是相同的。文件会自动被保存。<\/p><p>单击 <strong>Deploy<\/strong>，然后 JazzHub 会尝试着根据 manifest.yml\n                文件来部署应用程序。在进行部署的时候，JazzHub 会请求您提供凭证。完成第 4 步来上传培训数据。然后，演示应用程序将会开始运行。<\/p><h2 id=\"N101C3\">结束语<\/h2><p>现在，您已经了解了 BLU Acceleration 如何在 Codename: BlueMix\n                上以服务的形式提供了数据仓库和分析，以及开发人员如何使用云中提供的非常快的 IBM BLU\n                技术来开发和部署重型应用程序。这就是云中更快速、更简单的数据挖掘方式。<\/p><h5 id=\"N101CA\">致谢<\/h5><p>非常感谢 Alexandria Burkleaux 对本文的评论。<\/p><CMA ID: 971779><Site ID: 10><XSLT stylesheet used to transform this file: dw-document-html-7.0.xsl>\r\n\r\n\r\n<\/div>\r\n<\/div>\r\n","createTime":"2014-05-20 00:00:00","deployTime":"2014-05-20 00:00:00","id":0,"intro":"BLU Acceleration 在 Codename: BlueMix 上以服务的形式提供了数据仓库和分析。开发人员可以使用云中提供的非常快的 IBM BLU 技术来开发和部署重型应用程序。本文将了解如何使用 Weka 统计分析工具和 IBM BLU 纵列数据库来开发一个数据挖掘应用程序。","keyword":"","recommend":false,"source":"http://www.ibm.com/developerworks/cn/data/library/bd-dataminingblu-app/index.html","title":"使用 Java、Weka 和 BLU Acceleration 服务构建数据挖掘应用程序","typeId":0,"updateTime":"2014-05-20 00:00:00"}
{"author":"","clickNumber":0,"content":"\r\n<div class=\"ibm-columns\">\r\n<div class=\"ibm-col-1-1\">\r\n\r\n<div class=\"dw-sidebar ibm-inset\"><h2 id=\"N10046\">常见术语<\/h2><ul class=\"ibm-bullet-list\"><li><strong>JSON<\/strong>：一个为传送结构化数据而设计的基于文本的开放标准。JSON \n是在 Web 应用程序和\n                        Web 服务器之间传输数据的常用格式。<\/li><li><strong>JSON 有效负载<\/strong>：针对 REST API 的 <code>POST<\/code> 或\n                        <code>PUT<\/code> 请求的格式化 JSON 主体。<\/li><li><strong>JSON 模式<\/strong>：介绍应用于 JSON 有效负载的验证和转化规则。<\/li><\/ul><\/div><p>本文提出了一种解决方案，该解决方案处理云服务与其用户需要进行 JavaScript Object \nNotation (JSON)\n                有效负载验证和转换时出现的问题。我们将这种基础架构称为 JVAX（JSON Verification and\n                Conversion/Transformation，JSON 验证和转换），它使用了一个可配置的 JSON 模式来实现验\n证和转换。<\/p><p>带有 JSON 有效负载的云应用程序的开发周期通常涉及连续的升级和集成。每个用例的添加或修\n改都有可能需要更改应用程序的 JSON\n                验证和转换逻辑。这使得应用程序越来越脆弱，容易出错，并且难以维护。<\/p><p>一般来说，提供 Representational State Transfer (REST) API 的云服务会执行大量 JSON\n                有效负载验证和转换工作。JVAX 基础架构被设计用于独立验证和转换云服务的 JSON 工作负载\n，因此，JVAX\n                系统减少了请求-验证流程的工作量，该流程通常是服务提供商必须完成的。与此同时，JVAX\n                还有助于使得使用应用程序变得更可靠，并且应用程序更易于维护。<\/p><p>JVAX 使用一个复杂的机制来描述有效负载规则。在介绍 JVAX 结构之前，我们先来查看一个示例\n。<\/p><h2 id=\"N10065\">JVAX 模式定义<\/h2><p>清单 1 展示了一个简单 JSON 有效负载：一个 <code>Person<\/code> 对象。<\/p><h5 id=\"listing1\">清单 1. <code>Person<\/code> 对象的样例输入数据<\/h5><div class=\"codesection\"><pre class=\"displaycode\">\"Person\": {\n  \"FirstName\" : \"Krishna\",\n  \"LastName\" : \"Yadav\"\n  \"Age\" : 25,\n  \"PhoneNumber\" : \"91-012-3456789\"\n}<\/pre><\/div><p>清单 2 展示了清单 1 的 <code>Person<\/code> 对象的一个基本 JSON 模式示例：<\/p><h5 id=\"listing2\">清单 2. <code>Person<\/code> 对象的 JVAX\n                    模式定义<\/h5><div class=\"codesection\"><pre class=\"displaycode\">{\n  \"Person\" : {\n    \"<strong>type<\/strong>\" : \"object\",\n    \"<strong>properties<\/strong>\" : {\n      \"FirstName\" : {\n        \"<strong>type<\/strong>\" : \"string\",\n        \"<strong>category<\/strong>\" : \"MANDATORY\"\n      },\n      \"LastName\" : {\n        \"<strong>type<\/strong>\" : \"string\",\n        \"<strong>category<\/strong>\" : \"MANDATORY\"\n      },\n      \"Age\" : {\n        \"<strong>type<\/strong>\" : \"number\",\n        \"<strong>category<\/strong>\" : \"MANDATORY\"\n      },\n      \"PhoneNumber\" : {\n        \"<strong>type<\/strong>\" : \"string\",\n        \"<strong>category<\/strong>\" : \"OPTIONAL\"\n      }\n    }\n  }}<\/pre><\/div><p>清单 2 中的 JSON 模式描述了 <code>Person<\/code> 对象的各种各样的数据类型。表 1 列出了 \nJVAX 支持的类型：<\/p><h5 id=\"table1\">表 1. 支持的 JVAX 字段类型<\/h5><table border=\"0\" cellpadding=\"0\" cellspacing=\"0\" class=\"ibm-data-table\" summary=\"Three column  table showing the supported JVAX field types.\"><thead xmlns:dw=\"http://www.ibm.com/developerWorks/\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"><tr><th scope=\"col\">支持的类型<\/th><th scope=\"col\">输入值<\/th><th scope=\"col\">示例<\/th><\/tr><\/thead><tbody xmlns:dw=\"http://www.ibm.com/developerWorks/\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"><tr><td><code>string<\/code><\/td><td><code>java.lang.String<\/code> 支持的双引号字符串值。<\/td><td><div class=\"codesection\"><pre class=\"displaycode\">\"<strong>type<\/strong>\" : \"string\"<\/pre><\/div><\/td><\/tr><tr><td><code>boolean<\/code><\/td><td><code>true<\/code> 或\n                            <code>false<\/code><\/td><td><div class=\"codesection\"><pre class=\"displaycode\">\"type\" : \n\"boolean\"<\/pre><\/div><\/td><\/tr><tr><td><code>object<\/code><\/td><td>一个有序的键/值对集合。 <br /><code>properties<\/code> 指示符保存了这些键/值对的描述。<\/td><td><div class=\"codesection\"><pre class=\"displaycode\">\"type\" : \"object\",\n\"<strong>properties<\/strong>\" : {\n// description of the collection\n}<\/pre><\/div><\/td><\/tr><tr><td><code>array<\/code><\/td><td>一个有序的值序列（该值可以是基本类型或其他对\n象类型）。<br /> 假设这些元素具有相同类型。<br /><code>items<\/code>\n                                指示符保存了该阵列的描述。<\/td><td><div class=\"codesection\"><pre class=\"displaycode\">\"<strong>type<\/strong>\" \n\n:\"array\",\"<strong>items<\/strong>\" : {\n// description of array elements\n}<\/pre><\/div><\/td><\/tr><tr><td><code>number<\/code><\/td><td><code>java.lang.number<\/code>\n                                支持的数值<\/td><td><div class=\"codesection\"><pre class=\"displaycode\">\"<strong>type<\/strong>\" : \n\"number\"<\/pre><\/div><\/td><\/tr><\/tbody><\/table><p>在有效负载中，每个字段都需要一个值。对于每个字段来说，该模式应用了一个\n                <code>category<\/code>。这些类别使用内部规则（在应用程序代码的业务逻辑中实现）确定了 \nJVAX\n                如何处理字段值。这些规则支持一种重写这些值的方法，这对于防止调用方设置无效值来说非常\n重要。表 1 展示了 JAVX 类别及其相关处理规则：<\/p><h5 id=\"table2\">表 2. JVAX 类别及其相关处理规则<\/h5><table border=\"0\" cellpadding=\"0\" cellspacing=\"0\" class=\"ibm-data-table\" summary=\"Three column simple table showing jvax categories\"><thead xmlns:dw=\"http://www.ibm.com/developerWorks/\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"><tr><th scope=\"col\">类别<\/th><th scope=\"col\">描述（针对 API 用户）<\/th><th scope=\"col\">内部处理规则（yes = 输入中提供）（no = 输入中不提供）<\/th><\/tr><\/thead><tbody xmlns:dw=\"http://www.ibm.com/developerWorks/\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"><tr><td><code>MANDATORY<\/code><\/td><td>API 请求必须提供该值。<\/td><td><ul class=\"ibm-bullet-list\"><li>如果是 yes，则使用该值。<\/li><li>如果是 no，则会出现错误。<\/li><\/ul><\/td><\/tr><tr><td><code>OPTIONAL<\/code><\/td><td>API\n                            请求可有选择地提供该值，如果没有提供任何值，则使用默认值。<\/td><td><ul class=\"ibm-bullet-list\"><li>如果是 yes，则使用该值。<\/li><li>如果是 no，而且在该模式中提供了一个默认值，则使用该默认值。<\/li><li>如果是 no，而且该模式中没有提供默认值，则不执行任何操作。<\/li><\/ul><\/td><\/tr><tr><td><code>RESERVED<\/code><\/td><td>该字段仅供内部专用。所有 API\n                            输入值都将被忽略，并使用该模式中的内部默认值进行替换。<\/td><td><ul class=\"ibm-bullet-list\"><li>如果是 yes，则使用默认值覆盖。<\/li><li>如果是 no，则创键一个默认值并填充。<\/li><\/ul> （这两种情况下都不会出现错误。）<\/td><\/tr><tr><td><code>SUPPRESSED<\/code><\/td><td>如果提供值，则忽略该值。<\/td><td><ul class=\"ibm-bullet-list\"><li>如果是 yes，则删除该值。<\/li><li>如果是 no，则不执行任何操作。<\/li><\/ul><\/td><\/tr><\/tbody><\/table><p>该模式也支持使用枚举类型、规则表达式和自定义验证机制。因为模式可参考共享对象定义，\nJVAX 可提升代码重用率。<\/p><h2 id=\"N1015E\">JVAX 设计<\/h2><p>JVAX 设计中的关键概念是，在服务供应商处理这些请求之前，通过一个 JVAX 系统传递这些请求\n。图 1 展示了一个 JVAX\n                组件以及如何关联它们的概述：<\/p><h5 id=\"figure1\">图 1. JVAX 概述<\/h5><img alt=\"JVAX 组件以及如何关联它们的概述\" src=\"/sunshine_new/images/1917640390/figure1.png\" width=\"426\" /><p>图 1 中反映的基本步骤包括：<\/p><ol><li>在 JVAX 系统上，服务提供商定义了一个充当 API 有效负载模板的 JSON 模式。<\/li><li>用户使用该 API 将 JSON 有效负载发送给 JVAX 系统。<\/li><li>JVAX 根据该模式验证和转换输入有效负载。<\/li><li>出现错误时，JVAX 代表供应商来响应用户。 <\/li><li>验证成功时，JVAX 将请求重定向到该服务供应商。 <\/li><\/ol><h2 id=\"N1017D\">设计 JSON 模式<\/h2><p>定义 JSON 模式的步骤包括：<\/p><ol><li>服务供应商定义了 API 和相关的有效负载字段。<\/li><li>服务供应商定义了反映 API 有效负载字段的模式。<\/li><li>服务供应商使用以下规则定义了字段类型： <ul class=\"ibm-bullet-list\"><li>如果 API 需要一个字段，那么服务供应商会则将它标记为 \n<code>MANDATORY<\/code>。<\/li><li>如果不需要一个字段，则将它标记为 <code>OPTIONAL<\/code>。<\/li><li>总是有一组特定值的字段被标记为 <code>RESERVED<\/code>。<\/li><li>如果某个字段的值不能传递给 API，则将该字段标记为 <code>SUPPRESSED<\/code>\n。<\/li><\/ul><\/li><\/ol><p>图 2 显示了 JSON 模式设计所涉及的所有步骤：<\/p><h5 id=\"figure2\">图 2. 设计一个 JSON 模式的步骤<\/h5><img alt=\"图 2 中的步骤包括：1. 创建一个 JSON 有效负载模式。2. 检查 API 调用和 JSON 有效负载。3. 识别字段类别（比如必需的、有选择、的保留或禁止的）。4. 识别字段数值类型和自定义验证。5. 确定针对未识别的 JSON 结构的策略\" src=\"/sunshine_new/images/1917640390/figure2.png\" width=\"190\" /><h2 id=\"onboarding\">JVAX 加载流程<\/h2><p>图 3 展示了一个 JVAX 系统的启用流程：<\/p><h5 id=\"figure3\">图 3. JVAX 加载流程<\/h5><img alt=\"JVAX 系统加载流程的图像\" src=\"/sunshine_new/images/1917640390/figure3.png\" width=\"403\" /><p>在图 3 中展示的流程中：<\/p><ol><li>JVAX 系统读取服务用户提供的 JSON 有效负载。<\/li><li>JVAX 读取服务供应商为特定 API 提供的 JSON 模式。<\/li><li>JVAX 尝试验证 JSON 模式。如果遇到错误，则返回一个错误条件并停止。<\/li><li>如果模式是无效的，那么 JVAX 将会根据已定义的 JSON 模式来验证 JSON 有效负载。如果\n有效负载与 JSON\n                    模式的签名不符，则会返回一个错误条件并停止。<\/li><li>如果有效负载验证过程中没有出现错误，那么 JVAX 将会（有选择地）根据 API 需要转化\n输入 JSON 有效负载。<\/li><li>服务供应商基础框架将会调用该 API，并使用它来向服务用户发送响应。<\/li><\/ol><h2 id=\"N101CC\">配置选项<\/h2><p>对于整体 JVAX 系统，既可以进行单机配置，也可以进行嵌入式配置。在单机配置中，JVAX\n                从云服务中单独安装，作为一个单独的流程运行。在嵌入式配置中，JVAX 嵌入在现有应用程序\n中，因此可共享同一个进程空间。嵌入式配置使得 JVAX\n                易于部署和配置；还避免了不必要的硬件配置成本。<\/p><h2 id=\"N101D3\">JVAX 的优势<\/h2><p>JVAX 解决方案的优势包括：<\/p><ul class=\"ibm-bullet-list\"><li>易于配置：基于规则的 JVAX 方法使得利用可能时常变化的业务规则变得很容易。<\/li><li>可插拔性和可扩展性：基于规则的 JVAX\n                    方法可嵌入在实际服务或其他任何现有服务代理中。或者在有效负载被拦截或者审查时，作\n为独立的代理进行添加。<\/li><li>易于维护：只需改变配置，无需重新部署服务。<\/li><li>高效性：请求不能到达 API，除非这些请求是有效的。因此，这将为服务供应商减少不必要\n的处理开销。<\/li><li>版本控制支持：尽管系统内部界面可能会被服务供应商改变 ，但 JVAX 提供一种较为简单\n的方法来维护外部界面兼容性。<\/li><li>文档支持：模式信息可直接转化成 API 文档。<\/li><\/ul><h2 id=\"N101E7\">结束语<\/h2><p>JSON 被广泛用于客户端应用和 Web 服务器之间的数据传送，在云时代，进行 JSON\n                验证和转换变得日益重要。对于服务提供商和服务用户来说，JAVX 系统可能是一个布尔值，其可配置性可帮助服务供应商减少处理各种 JSON\n                格式的工作负载时所涉及的维护工作。服务用户很容易看到来自 JVAX 系统的响应，并相应地修改其 JSON 有效负载。<\/p><CMA ID: 971612><Site ID: 10><XSLT stylesheet used to transform this file: dw-document-html-7.0.xsl>\r\n\r\n\r\n<\/div>\r\n<\/div>\r\n","createTime":"2014-05-19 00:00:00","deployTime":"2014-05-19 00:00:00","id":0,"intro":"本文提出了一种解决方案架构，该架构利用 JavaScript Object Notation (JSON) 验证和转化实现了云用户和云服务器供应商获益。","keyword":"","recommend":false,"source":"http://www.ibm.com/developerworks/cn/cloud/library/cl-json-verification/index.html","title":"动态验证和转换基于云的应用程序的 JSON 有效负载","typeId":0,"updateTime":"2014-05-19 00:00:00"}
{"author":"","clickNumber":0,"content":"\r\n<div class=\"ibm-columns\">\r\n<div class=\"ibm-col-1-1\">\r\n\r\n<div class=\"dw-sidebar ibm-inset\"><h2 id=\"N1004A\">关于本系列<\/h2><p>Java&#8482; 传承的是平台，而不是语言。有超过 200 种语言可以在 JVM 上运行，它们之中不可避免地会有一种语言最终取代\n                    Java 语言，成为编写 JVM 程序的最佳方式。本系列将探讨三种下一代 JVM 语言：Groovy、Scala 和\n                    Clojure，比较并对比新的功能和范例，让 Java 开发人员对自己近期的未来发展有大体的认识。<\/p><\/div><p>\n                所有编程语言都在增加函数特性，因为运行时已变得强大到足够适应性能或内存开销。函数式编程的许多收益之一是，您可将麻烦或容易出错的任务卸载到运行时。另一个收益是将函数特性简洁地组合到您代码中的能力。 <\/p><p> 在本期文章中，我将探讨 Java 下一代语言中的内存化。然后，通过利用 Clojure\n                示例，我将展示通过利用函数特性之间的协调作用，如何实现常见问题的一般解决方案。 <\/p><h2 id=\"N10056\">内存化<\/h2><p><em>内存化<\/em> 这个词是 Donald\n                Michie（一位英国人工智能研究人员）发明的，用于表示重复的值的函数级缓存。如今，内存化在函数式编程语言中很常见，它要么被用作一个内置特性，要么被用作一个相对容易实现的特性。 <\/p><p>\n                内存化在以下场景中很有帮助。假设您必须反复调用一个注重性能的函数。一个常见解决方案是构建内部缓存。每次计算某个参数集的值时，您都会将该值放入缓存中，作为参数值的线索。在未来，如果该函数使用以前的参数调用，那么它将会从缓存返回值，而不是重新计算它。函数缓存是一种经典的计算机科学权衡：它使用更多内存（我们常常拥有丰富的内存）来不断实现更高的性能。 <\/p><p> 函数必须是<em>纯粹的<\/em>，缓存技术才能发挥其作用。<em>纯函数<\/em>\n                是没有副作用的函数：它没有引用任何其他易变的类字段，没有设置除返回值以外的任何值，而且仅依赖于参数作为输入。<code>java.lang.Math<\/code>\n                类中的所有方法都是纯函数的良好示例。显然，只有在函数可靠地为一组给定的参数返回相同值时，您才能成功地重用缓存的结果。 <\/p><h3 id=\"N1006C\">Groovy 中的内存化<\/h3><div class=\"dw-sidebar ibm-inset\"><h2 id=\"N10072\">有关内存化的更多信息<\/h2><p> 我在 <a href=\"https://www.ibm.com/developerworks/cn/views/global/libraryview.jsp?sort_by=&amp;show_abstract=true&amp;show_all=&amp;search_flag=&amp;contentarea_by=Java+technology&amp;search_by=函数式思维&amp;topic_by=-1&amp;type_by=所有类别&amp;ibm-search=搜索\"><em>函数式思维<\/em><\/a>\n    系列的 “<a href=\"http://www.ibm.com/developerworks/cn/java/j-ft9/index.html\">Groovy 中的函数特性，第 3 部分<\/a>” 一期中描述了 Groovy 中的内存化机制。这篇文章还展示了所有 3 种\n                    Java 下一代语言的更详细的内存化语法。 <\/p><\/div><p> 内存化在 Groovy 中很简单，Groovy 在 <code>Closure<\/code> 类上包含一系列\n                <code>memoize()<\/code>\n                函数。例如，假设您有一个昂贵的哈希算法，以至于您需要缓存结果来提高效率。为此，您可以使用闭包块语法来定义方法，在返回时调用\n                <code>memoize()<\/code> 函数，如清单 1 所示。我并不是暗示清单 1 中使用的 <a href=\"http://en.wikipedia.org/wiki/ROT13\">ROT13 算法<\/a>（即<a href=\"http://en.wikipedia.org/wiki/Caesar_cipher\">凯撒密码<\/a>\n                的一个版本）的性能面临挑战，只是假设缓存在这个示例中很重要。 <\/p><h5 id=\"listing1\">清单 1. Groovy\n                    中的内存化<\/h5><div class=\"codesection\"><pre class=\"displaycode\">class NameHash {\n  def static hash = {name -&gt;\n    name.collect{rot13(it)}.join()\n  }.memoize()\n\n  public static char rot13(s) {\n    char c = s\n    switch (c) {\n      case 'A'..'M':\n      case 'a'..'m': return c + 13\n\n      case 'N'..'Z':\n      case 'n'..'z': return c - 13\n      default: return c\n    }\n  }\n}\n\nclass NameHashTest extends GroovyTestCase {\n  void testHash() {\n    assertEquals(\"ubzre\", NameHash.hash.call(\"homer\"))  }\n}<\/pre><\/div><p> 正常情况下，Groovy 函数定义看起来像清单 1 中的\n                <code>rot13()<\/code>，方法主体位于参数列表之后。<code>hash()<\/code>\n                函数定义使用了稍微不同的语法，将代码块分配给 <code>hash<\/code> 变量。该定义的最后一部分是对\n                <code>memoize()<\/code> 的调用，它自动为重复的值创建一个内部缓存，与该参数建立联系。 <\/p><p><code>memoize()<\/code> 方法实际上是一个方法系列，为您提供了对缓存特征的一定控制，如表 1 所示。 <\/p><h5 id=\"groovy_memo\">表 1. Groovy 的 <code>memoize()<\/code>\n                    系列<\/h5><table border=\"0\" cellpadding=\"0\" cellspacing=\"0\" class=\"ibm-data-table\" summary=\"\"><thead xmlns:dw=\"http://www.ibm.com/developerWorks/\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"><tr><th scope=\"col\">方法<\/th><th scope=\"col\">用途<\/th><\/tr><\/thead><tbody xmlns:dw=\"http://www.ibm.com/developerWorks/\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"><tr><td><code>memoize()<\/code><\/td><td>返回闭包的一个包含缓存的实例<\/td><\/tr><tr><td><code>memoizeAtMost()<\/code><\/td><td>为缓存元素的数量设置一个上限<\/td><\/tr><tr><td><code>memoizeAtLeast(int protectedCacheSize)<\/code><\/td><td>为缓存元素的数量设置一个下限，保护一定数量的元素免遭垃圾收集<\/td><\/tr><tr><td><code>memoizeBetween(int protectedCacheSize, int maxCacheSize)<\/code><\/td><td>为缓存元素的数量设置一个下限和上限<\/td><\/tr><\/tbody><\/table><p> 表 1 中的方法为您提供了对缓存特征粗粒度的控制，这不是直接调优缓存特征的细粒度方式。内存化应是一种通用机制，您可以用它来轻松优化常见的缓存情形。 <\/p><h3 id=\"N100DC\">Clojure 中的内存化<\/h3><p> 内置于 Clojure 中的内存化。您可以使用 <code>(memoize )<\/code> 函数内存化任何函数。例如，如果您已经拥有一个\n                <code>(hash \"homer\")<\/code> 函数，那么您可以通过\n                <code>(memoize (hash \"homer\"))<\/code> 针对一个缓存版本而对其进行内存化。清单 2 在\n                Clojure 中实现了 <a href=\"#listing1\">清单 1<\/a> 中的名称哈希示例。 <\/p><h5 id=\"listing2\">清单 2. Clojure\n                    内存化<\/h5><div class=\"codesection\"><pre class=\"displaycode\">(defn name-hash [name]\n  (apply str (map #(rot13 %) (split name #\"\\d\"))))\n\n(def name-hash-m (memoize name-hash))\n\n(testing \"name hash\"\n  (is (= \"ubzre\" (name-hash \"homer\"))))\n\n(testing \"memoized name hash\"\n  (is (= \"ubzre\" (name-hash-m \"homer\")))))<\/pre><\/div><p> 请注意，在 <a href=\"#listing1\">清单 1<\/a> 中，调用内存化的函数需要调用 <code>call()<\/code> 方法。在\n                Clojure 版本中，内存化的方法调用在表面上完全相同，但增加了对方法用户不可见的间接性和缓存。 <\/p><h3 id=\"N10100\">Scala 中的内存化<\/h3><p> Scala 没有直接实现内存化，但有一个名为 <code>getOrElseUpdate()<\/code>\n                的集合方法来处理实现它的大部分工作，如清单 3 所示。 <\/p><h5 id=\"listing3\">清单 3. Scala\n                内存化<\/h5><div class=\"codesection\"><pre class=\"displaycode\">def memoize[A, B](f: A =&gt; B) = new (A =&gt; B) {\n    val cache = scala.collection.mutable.Map[A, B]()\n    def apply(x: A): B = cache.getOrElseUpdate(x, f(x))\n  }\n\ndef nameHash = memoize(hash)<\/pre><\/div><p> 清单 3 中的 <code>getOrElseUpdate()<\/code>\n                函数是建立缓存的完美的运算符。它检索匹配的值，或者在没有匹配值时创建一个新条目。 <\/p><h2 id=\"N10116\">组合函数特性<\/h2><div class=\"dw-sidebar ibm-inset\"><h2 id=\"N1011C\">通过复合 (composition) 来组合<\/h2><p><em>复合<\/em> 在软件开发中有许多含义。<em>函数复合<\/em> 指组合函数来获得复合结果的能力。在数学术语中，如果您有一个\n                    <code>f(x)<\/code> 函数和一个 <code>g(x)<\/code> 函数，那么您应能够执行\n                    <code>f(g(x))<\/code>。在软件术语中，如果您有一个将字符串转换为大写的 <code>a()<\/code>\n                    函数和一个删除过量空格的 <code>b()<\/code> 函数，那么复合函数将执行这两项任务。 <\/p><\/div><p> 在上一节和前几期 <em>Java 下一代<\/em> 文章中，我介绍了函数式编程的许多细节，尤其是与 Java\n                下一代语言相关的细节。但是，函数式编程的真正强大之处在于各种特性与解决方案的执行方式的组合。<\/p><p>\n                面向对象的程序员倾向于不断创建新数据结构和附带的运算。毕竟，构建新类和在它们之间传递的消息是主要的语言模式。但是构建如此多的定制结构，会使在最低层级上构建可重用代码变得很困难。函数式编程语言引用一些核心代码结构并构建优化的机制来理解它们。 <\/p><p> 以下是一个示例。清单 4 给出了来自 <a href=\"http://commons.apache.org/proper/commons-lang/\">Apache\n                    Commons<\/a> 框架的 <code>indexOfAny()<\/code> 方法，该框架为 Java 编程提供了大量帮助器。 <\/p><h5 id=\"listing4\">清单 4. 来自 Apache Commons 的\n                    <code>indexOfAny()<\/code><\/h5><div class=\"codesection\"><pre class=\"displaycode\">// From Apache Commons Lang, http://commons.apache.org/lang/\npublic static int indexOfAny(String str, char[] searchChars) {\n    if (isEmpty(str) || ArrayUtils.isEmpty(searchChars)) { \n        return INDEX_NOT_FOUND;\n    }\n    int csLen = str.length();\n    int csLast = csLen - 1;\n    int searchLen = searchChars.length;\n    int searchLast = searchLen - 1;\n    for (int i = 0; i &lt; csLen; i++) {\n        char ch = str.charAt(i);\n        for (int j = 0; j &lt; searchLen; j++) { \n            if (searchChars[j] == ch) {\n                if (i &lt; csLast &amp;&amp; j &lt; searchLast &amp;&amp; CharUtils.isHighSurrogate(ch)) {\n                    if (searchChars[j + 1] == str.charAt(i + 1)) {\n                        return i;\n                    }\n                 } else {\n                     return i;\n                 }\n\n             }\n         }\n     }\n     return INDEX_NOT_FOUND;\n}<\/pre><\/div><p> 清单 4 中 1/3 的代码负责边缘检查和实现嵌套迭代所需的变量的初始化。我将逐步将此代码转换为\n                Clojure。作为第一步，我将删除边角情形，如清单 5 所示。 <\/p><h5 id=\"listing5\">清单 5.\n                删除边角情形<\/h5><div class=\"codesection\"><pre class=\"displaycode\">public static int indexOfAny(String str, char[] searchChars) {\n    when(searchChars) {\n        int csLen = str.length();\n        int csLast = csLen - 1;\n        int searchLen = searchChars.length;\n        int searchLast = searchLen - 1;\n        for (int i = 0; i &lt; csLen; i++) {\n            char ch = str.charAt(i);\n            for (int j = 0; j &lt; searchLen; j++) {\n                if (searchChars[j] == ch) {\n                    if (i &lt; csLast &amp;&amp; j &lt; searchLast &amp;&amp; CharUtils.isHighSurrogate(ch)) {\n                        if (searchChars[j + 1] == str.charAt(i + 1)) {\n                            return i;\n                        }\n\t\t    } else {\n\t\t        return i;\n\t\t    }\n\t\t}\n            }\n        }\n        return INDEX_NOT_FOUND;\n    }\n}<\/pre><\/div><p> Clojure 会智能地处理 <code>null<\/code> 和 <code>empty<\/code> 情形，拥有\n                <code>(when ...)<\/code> 等智能函数，该函数仅在字符存在时返回 <code>true<\/code>。Clojure\n                具有动态（且强）类型，消除了在使用前声明变量类型的需求。因此，我可以删除类型声明，获得清单 6 中所示的代码。 <\/p><h5 id=\"listing6\">清单 6.\n                删除类型声明<\/h5><div class=\"codesection\"><pre class=\"displaycode\">indexOfAny(str, searchChars) {\n    when(searchChars) {\n        csLen = str.length();\n    csLast = csLen - 1;\n    searchLen = searchChars.length;\n    searchLast = searchLen - 1;\n    for (i = 0; i &lt; csLen; i++) {\n          ch = str.charAt(i);\n        for (j = 0; j &lt; searchLen; j++) {\n          if (searchChars[j] == ch) {      \n          if (i &lt; csLast &amp;&amp; j &lt; searchLast &amp;&amp; CharUtils.isHighSurrogate(ch)) {\n            if (searchChars[j + 1] == str.charAt(i + 1)) {\n            return i;\n          }\n          } else {\n            return i;\n          }\n        }\n        }\n    }\n    return INDEX_NOT_FOUND;\n    }\n}<\/pre><\/div><p><code>for<\/code> 循环\n                （命令式语言的主要元素）允许依次访问每个元素。函数式语言倾向于更多地依靠集合方法，这些方法已理解（或避免）了边角情形，所以我可删除\n                <code>isHighSurrogate()<\/code>（它检查字符编码）等方法和索引指针的操作。此转换的结果如清单 7 所示。 <\/p><h5 id=\"listing7\">清单 7. 一个用于替换最里面的\n                    <code>for<\/code> 的 <code>when<\/code>\n                子句<\/h5><div class=\"codesection\"><pre class=\"displaycode\">// when clause for innermost for\nindexOfAny(str, searchChars) {\n    when(searchChars) {\n        csLen = str.length();                    \n        for (i = 0; i &lt; csLen; i++) {            \n            ch = str.charAt(i);\n            when (searchChars(ch)) i;\n        }\n    }\n}<\/pre><\/div><p> 在清单 7 中，我将代码折叠到一个方法中，该方法会检查受欢迎的字符是否存在，在找到这些字符时，它会返回其索引。尽管我既未使用 Java 也未使用\n                Clojure，而是提供了一段陌生的伪代码，但这个 <code>when<\/code> 方法并不总是存在。但 Clojure 中还有\n                <code>(when )<\/code> 方法，此代码会慢慢变成该方法。 <\/p><p> 接下来，我将最顶层的 <code>for<\/code> 循环替换为一种更加简洁的代码，使用\n                    <code>for <\/code><em>comprehension：<\/em> 一个结合了集合的访问和过滤（等）的宏。演变后的代码如清单\n                8 所示。 <\/p><h5 id=\"listing8\">清单 8. 添加一个\n                    comprehension<\/h5><div class=\"codesection\"><pre class=\"displaycode\">// add comprehension\nindexOfAny(str, searchChars) {\n    when(searchChars) {\n        for ([i, ch] in indexed(str)) {    \n            when (searchChars(ch)) i;\n        }\n    }\n}<\/pre><\/div><p> 要理解清单 8 中的 <code>for <\/code> comprehension，首先您必须理解一些部件。Clojure 中的\n                <code>(indexed ...)<\/code> 函数接受一个 <code>Sequence<\/code>\n                并返回一个包含编号的元素的序列。例如，如果我调用 <code>(indexed '(a b c))<\/code>，返回值为\n                <code>([0 a] [1 b] [2 c])<\/code>。（单个撇号告诉\n                Clojure，我想要一个字符的文字序列，但并不希望执行一个包含两个参数的 <code>(a )<\/code>。）<code>for<\/code>\n                comprehension 在我的搜索字符上创建这个序列，然后应用内部的 <code>when<\/code> 来查找匹配字符的索引。 <\/p><p> 此转换的最后一步是将代码转换为合适的 Clojure 语法，还原真实函数和语法的外观，如清单 9 所示。 <\/p><h5 id=\"listing9\">清单 9. Clojure\n                    化的代码<\/h5><div class=\"codesection\"><pre class=\"displaycode\">// Clojure-ify\n(defn index-filter [pred coll]           \n  (when pred                     \n    (for [[index element] (indexed coll) :when (pred element)] index)))<\/pre><\/div><p> 在清单 9 中的最终的 Clojure 版本中，我将语法转换为合适的 Clojure\n                并添加一次升级：此函数的调用方现在可传递任何判定函数（一个返回布尔值结果的函数），而不只是检查一个空字符串。Clojure\n                    的一个目标是实现创建可读的代码的能力（在您理解圆括号之后），而且这个函数证实了这种能力：<em>对于带索引的集合，在您的判定与元素匹配时，将会返回索引<\/em>。<\/p><p>Clojure 的另一个目标是使用最少量的字符来表达清楚目的；在这方面，Java 与 Clojure 相差甚远。表 2 比较了 <a href=\"#listing4\">清单 4<\/a> 中的 “移动部件” 和 <a href=\"#listing9\">清单 9<\/a>\n                中的相应部件。<\/p><h5 id=\"N101D2\">表 2.比较 “移动部件”<\/h5><table border=\"0\" cellpadding=\"0\" cellspacing=\"0\" class=\"ibm-data-table\" summary=\"\"><thead xmlns:dw=\"http://www.ibm.com/developerWorks/\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"><tr><th scope=\"col\"/><th scope=\"col\">要求<\/th><th scope=\"col\">函数<\/th><\/tr><\/thead><tbody xmlns:dw=\"http://www.ibm.com/developerWorks/\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"><tr><td>函数<\/td><td>1<\/td><td>1<\/td><\/tr><tr><td>类<\/td><td>1<\/td><td>0<\/td><\/tr><tr><td>内部退出点<\/td><td>2<\/td><td>0<\/td><\/tr><tr><td>变量<\/td><td>3<\/td><td>0<\/td><\/tr><tr><td>分支<\/td><td>4<\/td><td>0<\/td><\/tr><tr><td>布尔运算符<\/td><td>1<\/td><td>0<\/td><\/tr><tr><td>函数调用<\/td><td>6<\/td><td>3<\/td><\/tr><tr><td><strong>总计<\/strong><\/td><td><strong>18<\/strong><\/td><td><strong>4<\/strong><\/td><\/tr><\/tbody><\/table><p> 复杂性上的差异一目了然。尽管 Clojure 代码更简单，但它也更加通用。这里，我对一个硬币翻转序列建立了索引，建模为 Clojure\n                <code>:h<\/code>（头）和 <code>:t<\/code>（尾）关键字： <\/p><div class=\"codesection\"><pre class=\"displaycode\">(index-filter #{:h} [:t :t :h :t :h :t :t :t :h :h]) \n-&gt; (2 4 8 9)<\/pre><\/div><p> 请注意，返回值是所有匹配的索引位置的序列，而不只是第一个。Clojure 中的列表操作尽可能是 <a href=\"#lazy\">惰性的<\/a>，包括这一个操作。如果我仅想要第一个值，那么我可以通过 <code>(take 1 )<\/code>\n                从结果中获得该值，或者我可以全部打印它们，就像我在这里所做的那样。 <\/p><p> 我的 <code>(index-filter )<\/code> 函数是通用的，所以我可在数字上使用它。例如，我可确定其斐波纳契值超过 1,000\n                的第一个数字： <\/p><div class=\"dw-sidebar ibm-inset\"><h2 id=\"lazy\">惰性<\/h2><p><em>惰性 <\/em>&#8212; 尽可能延迟表达式计算 &#8212;\n                    是函数式语言在不需要或只需很少开发人员成本的情况下添加功能的另一个优秀示例。请参阅 “<a href=\"http://www.ibm.com/developerworks/cn/java/j-ft18/index.html\">函数式思维：探索\n                        Java 中的惰性计算<\/a>” 和 “<a href=\"http://www.ibm.com/developerworks/cn/java/j-ft19/index.html\">函数式思维：深入剖析惰性计算<\/a>”，了解 Java 下一代语言中的惰性讨论和示例。 <\/p><\/div><div class=\"codesection\"><pre class=\"displaycode\">(first \n  (index-filter #(&gt; % 1000) (fibo)))\n-&gt; 17<\/pre><\/div><p><code>(fibo)<\/code> 函数返回一个没有限制但惰性的斐波纳契数字序列；<code>(index-filter )<\/code>\n                找到第一个超过 1,000 的值。（事实证明，18 的斐波纳契值为 1,597。）函数结构、动态类型、惰性和简洁语法相结合，得到的是更强大的功能。 <\/p><h2 id=\"N10252\">结束语<\/h2><p> 函数式编程结构在零散使用时可带来优势，在结合使用它们时会带来更多的优势。所有 Java\n                下一代语言在一定程度上都是函数式的，支持增加这种开发风格的使用。 <\/p><p> 在本期文章中，我讨论了函数式编程如何消除移动部件（让编程更少出错），以及结合使用函数特性的优势。在下一期文章中，我将开始更深入地演示此概念，讨论\n                Java 下一代语言如何让 JVM 上的并发性变得更轻松。 <\/p><CMA ID: 970949><Site ID: 10><XSLT stylesheet used to transform this file: dw-document-html-7.0.xsl>\r\n\r\n\r\n<\/div>\r\n<\/div>\r\n","createTime":"2014-05-19 00:00:00","deployTime":"2014-05-19 00:00:00","id":0,"intro":"Scala 和 Clojure 都是函数式语言，而 Groovy 通过库包含了许多函数特性。这一期的 Java 下一代文章将探讨如何在 Java 下一代语言中实现内存化，以及如何使用函数组合特性来实现简洁性。","keyword":"","recommend":false,"source":"http://www.ibm.com/developerworks/cn/java/j-jn12/index.html","title":"Java\n            下一代: 内存化和函数式协同","typeId":0,"updateTime":"2014-05-19 00:00:00"}
{"author":"","clickNumber":0,"content":"\r\n<div class=\"ibm-columns\">\r\n<div class=\"ibm-col-1-1\">\r\n\r\n<h2 id=\"major1\">基于 WebSphere Commerce 框架发布全球化商店流程<\/h2><p>WebSphere Commerce 商店发布是个自动的过程。了解它的发布具体流程有助于高效快速解决全球化商店发布中遇到的问题。本文中的所有案例是基于 WebSphere Commerce 7.0 Feature Pack 7.0  (FEP7) 中的 Aurora 商店。WebSphere Commerce 全球化商店发布流程如图 1 所示，主要分 3 个步骤。先解压缩商店存档文件，然后更新商店参数，最后一步向数据库发布数据。最后一步是商店发布中最重要的一步，接下来我们详细介绍发布数据过程中的主要任务。<\/p><h5 id=\"fig1\">图 1. 发布全球化商店流程<\/h5><img alt=\"图 1. 发布全球化商店流程\" src=\"/sunshine_new/images/负925935895/images/image01.jpg\" width=\"582\" /><p>第三步发布数据过程中，WebSphere Commerce 每个商店归档文件中都一个叫作 ibm-wc-load.xml 的文件，该文件定义了商店数据发布时要依次完成的任务。下面是 Aurora 商店的 ibm-wc-load.xml 的片段示例：<\/p><div class=\"codesection\"><pre class=\"displaycode\">      &lt;task name=\"dataload\"&gt; \n        &lt;param name=\"infile\" value=\"${asset:master}\" /&gt; \n        &lt;param name=\"storePublish\" value=\"true\" /&gt; \n      &lt;/task&gt; \n      &lt;task name=\"reconcileStoreLanguages\"&gt; \n        &lt;param name=\"storeIdentifier\" value=\"${asset:foreignKeys#STORE_IDENTIFIER}\" /&gt; \n        &lt;param name=\"organizationDN\" \n        value=\"ou=${asset:foreignKeys#STORE_IDENTIFIER_LOWERCASE}, \n        ${asset:foreignKeys#ORGANIZATION_DN}\" /&gt; \n      &lt;/task&gt;<\/pre><\/div><p>典型的数据发布过程一般包含如下任务：<\/p><p>将商店数据装入数据库<\/p><p>这一步是商店发布过程中至关重要的一步。每个商店存档中都包含一个 store-data-assets.xml 的文件，文件包含要进行数据导入的文件。 在发布中，所有在 store-data-assets.xml 文件中的所有 XML 文件被合并成一个大文件，然后大文件中的标识被解析。解析完的文件就能进行数据装入了。WebSphere Commerce 的数据装入（Data Load）工具可以将 XML 导入到数据库中。如果在数据发布是出现错误，用户可以查看 Data Load 的日志文件。<\/p><p>对于全球化商店，store-data-assets.xml 包含了所有语言的 XML 文件，解析和数据装入过程中，所有语言的 XML 文件都会被写到数据库中。下面是支持多语言的 store-data-assests.xml 的一个示例片段：<\/p><div class=\"codesection\"><pre class=\"displaycode\"> &amp;en_US_store.xml; \n &amp;en_US_fulfillment.xml; \n &amp;en_US_businesspolicy.xml; \n &amp;en_US_catalog.xml; \n &amp;en_US_accesscontrol.xml; \n &amp;en_US_seocatalog.xml; \n\n &amp;ja_JP_store.xml; \n &amp;ja_JP_fulfillment.xml; \n &amp;ja_JP_businesspolicy.xml; \n &amp;ja_JP_catalog.xml; \n &amp;ja_JP_accesscontrol.xml; \n &amp;ja_JP_seocatalog.xml; \n &amp;zh_TW_store.xml; \n &amp;zh_TW_fulfillment.xml; \n &amp;zh_TW_businesspolicy.xml; \n &amp;zh_TW_catalog.xml; \n &amp;zh_TW_accesscontrol.xml; \n &amp;zh_TW_seocatalog.xml;<\/pre><\/div><ul class=\"ibm-bullet-list\"><li>协调商店语言 <br />全球化商店可以切换不同的语言支持，但只有 WAS 实例创建时所启动的语言才能得到支持。所以改任务会检查并确保商店中只启动了 WAS 实例支持的语言。<\/li><li>更新注册表组件<\/li><li>发布业务账户和合同<\/li><li>配置支付<\/li><li>创建商店参数文件<\/li><\/ul><h2 id=\"major2\">Step by Step 发布商店<\/h2><p>用户可以使用 WebSphere Commerce 的发布向导发布商店。在发布之前用户需要有站点管理员权限，而且 WebSphere Commerce server 要在运行状态。对于全球化商店，用户需要确保在 WAS 实例创建时启动了所需语言。 具体步骤如下：<\/p><ol type=\"1\"><li>打开管理控制台 <strong>https://&lt;host&gt;:8002/adminconsole<\/strong><\/li><li>选择菜单商店归档文件 --&gt; 发布<\/li><li>选择商店，点击“下一步”<\/li><li>修改参数，点击“下一步”\n\t\t\t \n<h5 id=\"fig2\">图 2. 商店发布<\/h5><img alt=\"图 2. 商店发布\" src=\"/sunshine_new/images/负925935895/images/image02.jpg\" width=\"582\" /><\/li><li>点击“完成”<\/li><\/ol><h2 id=\"major3\">常见商店发布故障排查<\/h2><p>在商店发布过程中，尤其在测试和开发阶段，用户可能会遇到一些异常和错误。如何高效快速解决这类问题呢？下面我们给出商店发布中的几个问题及解决方案。<\/p><h3 id=\"minor3.1\">无效 DOCTYPE 标记引起的数据加载异常及解决方法<\/h3><p><strong>问题：<\/strong>解析 store-data-assets.xml 出错，内容中有不允许的 DOCTYPE。<\/p><p><strong>日志：<\/strong><\/p><p>An exception was caught: com.ibm.commerce.foundation.dataload.exception.DataLoadApplicationException: 解析 XML 文件时发生错误：C:\\Documents and Settings\\wcadmin\\Local Settings\\Temp\\1\\WCS3585075380422555559\\SARS\\Stores.war\\WEB-INF\\stores\\Aurora\\data\\store-data-assets.xml。所传回的错误是：热葜胁蝗菰S DOCTYPE。<\/p><p>Application message:<\/p><p>资料读取器 com.ibm.commerce.foundation.dataload.datareader.XmlReader 读取资料时，发生}。<\/p><p>资料中的位置如下：-1<\/p><p>资料如下：null<\/p><p>Exception message:<\/p><p>解析 XML 文件时发生错误：C:\\Documents and Settings\\wcadmin\\Local Settings\\Temp\\1\\WCS3585075380422555559\\SARS\\Stores.war\\WEB-INF\\stores\\Aurora\\data\\store-data-assets.xml。所传回的错误是：热葜胁蝗菰S DOCTYPE。<\/p><p>Stack trace:<\/p><p>com.ibm.commerce.foundation.dataload.exception.DataLoadApplicationException: 解析 XML 文件时发生错误：C:\\Documents and Settings\\wcadmin\\Local Settings\\Temp\\1\\WCS3585075380422555559\\SARS\\Stores.war\\WEB-INF\\stores\\Aurora\\data\\store-data-assets.xml。所传回的错误是：热葜胁蝗菰S DOCTYPE。<\/p><p><strong>解决方案：<\/strong>store-data-assets.xml 里面包含了多个 XML 文件，用户需要去删除 XML 文件中的 DOCTYPE，重新发布商店。<\/p><h3 id=\"minor3.2\">商店发布时遇到 Dataload exception 及解决方案<\/h3><p><strong>问题：<\/strong>商店发布遇到 DataLoad 异常， 商店发布失败。<\/p><div class=\"codesection\"><pre class=\"displaycode\"> Publish failed to publish the data assets.  \n An error occured while executing the task com.ibm.commerce.tools \n .devtools.publish.tasks.DataLoadTaskCmdImpl. Refer to the following \n  message for details and suggested action: Publishing the store \n   archive Errors occurred when parsing the XML file: C:\\Documents \n    and Settings\\wcadmin\\Local Settings\\Temp\\1\\WCS5816305021739160452 \n    \\SARS\\Stores.war\\WEB-INF\\stores\\MadisonsCatalog\\data\\.. \n    \\store-catalog-assets.xml. The error returned was: A SQL \n     exception was caught. The error was: [jcc][1091][10404][4.12.55] \n     Invalid data conversion: Parameter instance \n      @attribute_value_id_GirlsTops_5 is invalid for the requested \n       conversion. ERRORCODE=-4461, SQLSTATE=42815. failed with the \n       following details {1}<\/pre><\/div><p><strong>日志：<\/strong>这类问题是商店发布中常见的问题。用户只查看商店发布的日志不能够找到错误根源。这种情况下，我们要去看看 DataLoad 日志。下面是日志文件的一个例子。<\/p><p>C:\\Users\\wcadmin\\AppData\\Local\\Temp\\WCS4235666365570164756\\SARS\\Stores.war\\WEB-INF\\stores\\Aurora\\data\\DataLoad_ERROR_2013.09.29_22.57.43.665.log<\/p><div class=\"codesection\"><pre class=\"displaycode\"> An exception was caught: com.ibm.commerce.foundation.dataload. \n exception.DataLoadSQLException: A SQL exception was caught. \n The error was: [jcc][1091][10404][4.12.55] Invalid data conversion: \n  Parameter instance @attribute_value_id_GirlsTops_5 is invalid \n   for the requested conversion. ERRORCODE=-4461, SQLSTATE=42815. \n Application message: \n An error occurred while transforming the data object into physical \n  objects.  Data Object: ATTRVALDESC \n VALUSAGE=1 \n STRINGVALUE=Manches longues \n SEQUENCE=1 \n VALUE=Manches longues \n LANGUAGE_ID=-2 \n ATTR_ID=7000000000000000015 \n OPTCOUNTER=0 \n ATTRVAL_ID=@attribute_value_id_GirlsTops_5 \n ,Operation mode:  ., Physical objects: \n ================================================== \n Transformed Physical objects: \n ================================================== \n ATTRVALDESC \n VALUSAGE=1 \n STRINGVALUE=Manches longues \n SEQUENCE=1 \n VALUE=Manches longues \n LANGUAGE_ID=-2 \n ATTR_ID=7000000000000000015 \n OPTCOUNTER=0 \n ATTRVAL_ID=@<strong>attribute_value_id_GirlsTops_5<\/strong>\n ,Operation mode:  . \n ==================================================<\/pre><\/div><p><strong>解决方案：<\/strong>在 DataLoad 日志文件中，用户可以找到出错时正在处理的 Data 对象。上例中，LANGUAGE_ID=-2， 说明处理的语言是法语。TTRVAL_ID=@attribute_value_id_GirlsTops_5，说明在处理产品属性 attribute_value_id_GirlsTops_5 时出错。这时可以去比较法语商店产品文件和英文商店产品文件，如果产品属性 ID 跟英文不一致，会导致如上错误。这种情况下，我们可以通过修改产品文件去修复该错误。<\/p><h3 id=\"minor3.3\">加载 SEO 异常及解决方法<\/h3><p><strong>问题：<\/strong>商店发布过程中，加载 csv 文件发生错误。<\/p><p><strong>日志：<\/strong><\/p><div class=\"codesection\"><pre class=\"displaycode\"> SeopageDesc_zh_CN_ERROR_2013.11.04_00.43.13.424 \n ---------------------------------------------------------------------------------- \n Error report for load item: SeopageDesc_zh_CN. \n ---------------------------------------------------------------------------------- \n &lt;/message&gt; \n &lt;/record&gt; \n &lt;record&gt; \n    &lt;date&gt;2013-11-04T12:43:13&lt;/date&gt; \n    &lt;millis&gt;1383554593439&lt;/millis&gt; \n    &lt;sequence&gt;2342&lt;/sequence&gt; \n    &lt;level&gt;FINE&lt;/level&gt; \n    &lt;class&gt;com.ibm.commerce.foundation.dataload.report.error.LoadItemErrorReport&lt;/class&gt; \n    &lt;method&gt;addReportDetails&lt;/method&gt; \n    &lt;thread&gt;109&lt;/thread&gt; \n    &lt;message&gt; \n\n An exception was caught: com.ibm.commerce.foundation.dataload. \n exception.DataLoadSystemException: Reading the input file failed. \n Make sure the file has a right character encoding. \n The error was: Input length = 1. This error happened when \n reading file C:\\Users\\wcadmin\\AppData\\Local\\Temp\\WCS341976631804557721 \n \\SARS\\Stores.war\\WEB-INF\\stores\\Aurora\\data\\zh_CN\\seopagedesc.csv \n at line number 1. The actually invalid characters may be within next \n  a few lines. \n Application message: \n An error occurred during data loader execution: Reading the input \n file failed. Make sure the file has a right character encoding. \n The error was: Input length = 1. This error happened when reading \n  file C:\\Users\\wcadmin\\AppData\\Local\\Temp\\WCS341976631804557721\\SARS \n \\Stores.war\\WEB-INF\\stores\\Aurora\\data\\zh_CN\\seopagedesc.csv \n at line number 1. The actually invalid characters may be within next a few lines. \n Exception message: \n Reading the input file failed. Make sure the file has a right character \n  encoding. The error was: Input length = 1. This error happened when \n  reading file C:\\Users\\wcadmin\\AppData\\Local\\Temp\\WCS341976631804557721\\SARS \n  \\Stores.war\\WEB-INF\\stores\\Aurora\\data\\zh_CN\\seopagedesc.csv \n   at line number 1. The actually invalid characters may be \n   within next a few lines. \n Stack trace: \n com.ibm.commerce.foundation.dataload.exception.DataLoadSystemException: \n Reading the input file failed. Make sure the file has a right character \n  encoding. The error was: Input length = \n   1. This error happened when reading file \n   C:\\Users\\wcadmin\\AppData\\Local\\Temp\\WCS341976631804557721 \n   \\SARS\\Stores.war\\WEB-INF\\stores\\Aurora\\data\\zh_CN\\seopagedesc.csv \n   at line number 1. The actually invalid characters may be within next a few lines.<\/pre><\/div><p><strong>解决方案：<\/strong>Seo csv 文件的第三列是 URL 关键字。该关键字不能包含空格字符。上述错误就是由 csv 文件该列存在空格字符引起的。用户删除此空格字符就能解决上述问题。<\/p><h2 id=\"major4\">小结<\/h2><p>本文以 WebSphere Commerce 7.0 Feature Pack 7.0 为例，介绍了全球化商店动态发布的流程，以及如何一步一步发布商店。此外，本文举例说明了全球化商店发布中遇到的常见问题，以及解决问题的思路和方法。希望对用户有一定帮助。<\/p><h2 id=\"major5\">参考资源<\/h2><ul class=\"ibm-bullet-list\"><li>\n参考 <a href=\"http://pic.dhe.ibm.com/infocenter/wchelp/v7r0m0/index.jsp\">WebSphere<\/a><a href=\"http://pic.dhe.ibm.com/infocenter/wchelp/v7r0m0/index.jsp\">Commerce InfoCenter<\/a>，了解更多 WebSphere Commerce 产品信息。<\/li><\/ul><CMA ID: 971243><Site ID: 10><XSLT stylesheet used to transform this file: dw-document-html-7.0.xsl>\r\n\r\n\r\n<\/div>\r\n<\/div>\r\n","createTime":"2014-05-15 00:00:00","deployTime":"2014-05-15 00:00:00","id":0,"intro":"顺应经济全球化的发展趋势，越来越多的企业选择将电子商务平台构筑成支持多语言文化具有全球化视野的电子商务平台。WebSphere Commerce 对于快速发布具有全球化功能的网店提供了强有力的支持。本文化繁为简、深入浅出的介绍了如何基于 WebSphere Commerce 框架动态发布带有多语言支持功能的网店， 清晰的介绍了所应用的接口并提供了详细的实施步骤。并重点探讨了在基于 WebSphere Commerce 框架发布全球化商店时遇到一些常见的数据载入错误 , 本文根据实际经验总结了几种常见的错误类型，进行了分析并详细介绍了如果解决该类问题。对于基于 WebSphere Commerce 的开发、测试和使用人员具有很好的参考价值。","keyword":"","recommend":false,"source":"http://www.ibm.com/developerworks/cn/websphere/library/techarticles/1405_liujl_commerceshop/1405_liujl_commerceshop.html","title":"WebShpere Commerce 全球化商店发布动态流程及故障排查","typeId":0,"updateTime":"2014-05-15 00:00:00"}
{"author":"","clickNumber":0,"content":"\r\n<div class=\"ibm-columns\">\r\n<div class=\"ibm-col-1-1\">\r\n\r\n<h2 id=\"major1\">背景介绍<\/h2><p>在汽车保险、智能交通、物流管理等行业中，普遍存在着高效任务分派及持续优化的需求。\n                例如对于突发保险理赔事件，可以交给哪个业务人员处理？哪个业务人员距离执行业务地点最近？可以最快到达？对其之前的工作安排有没有影响？怎么能够很好的管理和提高已分派业务的处理效率？怎样能够通过分析业务分布特点及处理效率来提高和优化业务规则？在目前的\n                ECM 产品中业务分派及优化的功能不够突出，我们的方案能够体现业务智能分派及业务规则持续优化两大特色。<\/p><p>基于位置信息的任务自动分派来自 ECM 的一个客户。针对此需求，我们设计了一个更加通用的解决方案，并以汽车保险业务作为演示场景。<\/p><h2 id=\"major2\">汽车保险业务的智能分派与优化应用场景介绍<\/h2><p>该场景是一个常见的汽车保险业务场景，主要包括保险业务的智能分派以及基于业务分布特点和处理效率等多种因素的持续的流程优化。<\/p><p>以下列举演示场景所涵盖的业务需求：<\/p><p>1. 保险业务分析师可以设计保险业务数据和处理流程；<\/p><p>2. 保险客服人员可在该系统中进行保险业务数据录入；<\/p><p>3. 通过设定的分派规则分配给距离事发地位置最近的业务员；（分派规则使用位置信息及其他参考因素进行分派，分派规则可由客户定制和改进。）<\/p><p>4. 业务员手机终端将会收到分派的任务；<\/p><p>5. 业务员处理业务时，系统自动记录业务员处理业务时间及相关数据； <\/p><p>6. 定期分析历史数据，优化业务规则及处理效率。<\/p><h2 id=\"major3\">技术架构<\/h2><h5 id=\"img001\">图 1. 技术架构<\/h5><img alt=\"图 1. 技术架构\" src=\"/sunshine_new/images/负547019899/img001.png\" width=\"600\" /><h3 id=\"major4\">产品介绍<\/h3><p>我们的方案中，充分使用多个 IBM 产品，上图中蓝色背景的组件是已有的 IBM 产品，绿色背景的组件和手机客户端由我们自行开发。<\/p><p>ICM（IBM Case Manager）是一个基于图形的案例管理系统，简称\n                ICM。使用这个系统可以简化案例管理解决方案的设计与构建并对案例进行处理与管理。我们使用 ICM 产品负责保险业务的数据、文档和流程管理。\n                在我们的演示场景中，保险业务的录入、保险业务的分派等等都是由该产品提供服务。<\/p><p>IBM FileNet eForm 产品是一款基于 web\n                的表单管理软件，使用简单，开发时间快捷，并且提供接口快速接入数据库及第三方软件。适合于复杂流程的专业表格显示。目前在 ICM 中已经内嵌了\n                eForm 产品，不需要单独安装。在实际应用中也可以选择使用 IBM Forms 产品。IBM Forms 是基于开放标准的电子表格软件。可与现有\n                IT 系统快速整合数据，并通过易于使用的、基于 Web 的表格将业务流程扩展到您的客户。<\/p><p>IBM ILOG JRules 是先进的业务规则管理系统，能提供编写、部署和管理业务规则等业务功能。我们使用 IBM ILOG JRules\n                产品负责分派中的业务员分派。我们开发的 Rule based task dispatcher 可以获取当前的 task assignment\n                factors (负载、距离远近等)，传给 ILOG\n                JRules，由它通过当前各个业务员的状态及预定义的任务分派因素来指定当前业务应该分派给哪个业务员。<\/p><p>我们的手机客户端应用通过 “Assignment factor update” 和 “Task Push Service” 与后端业务系统交互。<\/p><p>ICM 管理的业务系统存储了丰富的 event log，可以通过 Case Analyzer 进行定制化抽取，并在 IBM Cognos BI\n                中进行历史业务分析。<\/p><p>由于篇幅有限，我们共分 4 篇文章系统讲述整个系统的实现过程。另外 3 篇分别会介绍：“系列二 - Android 手机客户端应用开发及演示示例”、“系列三\n                - 如何利用 JRules 完成自定义业务智能分派模块”、“系列四 - FileNet Case Analyzer 与 Cognos BI\n                的集成及业务分析优化示例”。<\/p><h2 id=\"major5\">构建汽车保险业务解决方案<\/h2><p>首先我们需要使用 ICM 来定义一个基本的汽车保险业务解决方案。<\/p><h3 id=\"N1008D\">定义案例属性<\/h3><p>根据项目需求，首先使用 ICM Case Builder 来定义保险业务解决方案。登陆 Case Builder 后，\n                创建汽车保险业务解决方案。根据业务需求来定义案例属性及属性的数据类型，比如图 2 中的 AccidentDescription\n                表示事故描述、AccidentID 表示保险 ID 号、AccidentTime 表示事故发生时间、AccidentType\n                表示事故发生类型、AssignedEmpName 表示处理事故的保险业务员名字、CaseStatus 表示案子的状态以及客户相关信息属性、客户 ID\n                号码、客户名字、客户位置等。<\/p><h5 id=\"img002\">图 2. 定义案例属性<\/h5><img alt=\"图 2. 定义案例属性\" src=\"/sunshine_new/images/负547019899/img002.png\" width=\"582\" /><h3 id=\"N1009E\">定义角色及工作流<\/h3><p>接下来定义在这个解决方案中的角色“业务员\n                EMP”。在这个解决方案中只涉及一个系统节点和一个业务员角色。客户在打电话报案时，客服人员会登陆到系统中，填写事故相关的信息，然后案子会通过系统节点配置的\n                JRules 自动分派给某一个业务员。所以具体定义的工作流程如下。图中定义了一个系统节点，该系统节点给 JRules 做自动分派使用，具体\n                JRules 的设置在第三篇文章中介绍。进行自动分派以后，会将工作流分派给某一个业务员。<\/p><h5 id=\"img003\">图 3. 定义工作流<\/h5><img alt=\"图 3. 定义工作流\" src=\"/sunshine_new/images/负547019899/img003.png\" width=\"581\" /><h3 id=\"major9\">定义表单<\/h3><p>在 ICM 中案例属性可以通过智能表单 eForms 或 IBM Form 来展示，在这里我们用 eForms 表单来查询用户信息和展示案例数据，因为\n                eForms 在实现数据库查询方面更简单更便捷。首先我们需要在 eForms 的设计工具 eForms Designer\n                里面先设计需要用到的表单。因为表单是为了展示案例里面的所有数据，必须将表单中的字段名称与案例中的属性名称定义一致，这样表单中填入的数据才能够保存到案例中。定义好的表单如下所示。<\/p><h5 id=\"img004\">图 4. 定义表单<\/h5><img alt=\"图 4. 定义表单\" src=\"/sunshine_new/images/负547019899/img004.png\" width=\"581\" /><p>在智能表单中，我们定义了搜索功能，可以通过客户的 ID\n                号码搜索后台数据库，然后将客户其他信息如名字、电话、保险号、保险开始结束日期等等返回到表单字段中。另外保险单号码，通过自动增一功能来实现，这样可以保证保险单号码的唯一性。<\/p><h3 id=\"major10\">配置表单应用<\/h3><p>定义好表单后，我们需要在 ICM Administration Client 中运行表单相关任务 Deploy the Forms\n                Application，然后表单才能正常工作。<\/p><h5 id=\"img005\">图 5. CMAC 中 Form 任务<\/h5><img alt=\"图 5. CMAC 中 Form 任务\" src=\"/sunshine_new/images/负547019899/img005.png\" width=\"581\" /><p>因为我们使用的是 eForms，所以在 IBM Forms rendering application 中选择 None。然后选项 Webform\n                Server Translator URL 可以忽略。但是必须要选中重启 Websphere Application\n                Server。运行完这个任务，就可以在 ICM 中配置使用 eForms 表单了。<\/p><p>在本例中，当客户遇险时会打电话给客服人员。客服人员会登陆 ICM Case\n                Client，并创建一个案例，在案例中需要显示一个表单，这样我们来配置添加案例页面。首先需要将表单添加到 WorkplaceXT 中，然后得到表单的\n                Version Series ID。然后登陆到 Case Client 中，打开管理空间，然后打开汽车保险解决方案中的 Add Case Form\n                页面。选中操作下面的 Case Manager 页面设置，在页面注册中选择页面类型为 “添加案例” 页面。然后编辑表单 widget，填入表单的\n                Version Series ID。这样 Case Client 端就配置好了。<\/p><p>在 Case Builder 中，重新编辑解决方案，编辑案例类型，在 “添加案例” 页面的缺省布局中选择 Add Case\n                Form。这样在添加案例的时候就会打开 Add Case Form 页面。并展示表单在表单 widget 中。<\/p><h3 id=\"major11\">地图应用<\/h3><p>根据项目需求，需要知道汽车事故发生的具体地址并以此来计算业务人员距离事故发生地点的距离。我们使用百度提供的 Javascript 地图 API\n                提供地图的服务。地图样式如下所示：<\/p><h5 id=\"img006\">图 6. 地图应用<\/h5><img alt=\"图 6. 地图应用\" src=\"/sunshine_new/images/负547019899/img006.png\" width=\"582\" /><p>图中，不动的红色图标表示事故现场，而跳跃的红色图标实时同步所有业务员的具体位置。这样我们就能大概知道离事故现场最近的业务员。在设计 Add Case\n                Form 页面时，加入 Web Site widget，并配置打开的网络地址为：http://9.115.199.150:9080/ICMMCRest/resources/LocationRetrieve，从而实现了地图的功能。\n                这个是后台提供的地图服务，我们会在下面的章节做详细的介绍。<\/p><h2 id=\"major12\">实例展示<\/h2><p>客服添加一个案例后，在 Add Case Form 页面填写用户编号 C001，客户的其他信息会通过后台数据库查询并返回到 Form\n                表单中。客户相关信息：客户 ID 号码、客户名字、电话、保险号码、保险开始结束时间可以自动填写到 Form 表单对应的字段中。客服可以通过右方的地图\n                API 解析出事故发生地点的坐标然后填写到表单中，业务员距离事故现场的距离是 JRules\n                进行自动任务分派的重要参数之一。然后继续填写事故相关信息，比如事故发生时间、事故简单描述等等。<\/p><h5 id=\"img007\">图 7. 实例图片<\/h5><img alt=\"图 7. 实例图片\" src=\"/sunshine_new/images/负547019899/img007.png\" width=\"581\" /><p>所有数据填写完毕之后，点击添加，这样一个保险案例就产生了。刚刚定义的工作流会自动启动，接下来它会到系统节点，通过 JRules\n                来判断应该发给哪个业务员。业务员手机终端会收到分派的任务，立刻赶往事故发生地点进行处理。<\/p><h2 id=\"major13\">总结<\/h2><p>在本文中主要介绍了汽车保险业务的智能分派与优化背景和应用场景，基本解决方案的搭建。JRules、手机终端应用开发及历史数据分析更新等将在之后的系列文章中介绍。<\/p><CMA ID: 971267><Site ID: 10><XSLT stylesheet used to transform this file: dw-document-html-7.0.xsl>\r\n\r\n\r\n<\/div>\r\n<\/div>\r\n","createTime":"2014-05-15 00:00:00","deployTime":"2014-05-15 00:00:00","id":0,"intro":"本文将介绍汽车保险业务的智能分派与优化的背景和应用场景，以及如何构建汽车保险业务解决方案，客户电子表单的设计及客户端地图小插件的集成与应用。","keyword":"","recommend":false,"source":"http://www.ibm.com/developerworks/cn/data/library/techarticle/dm-1405-ecm-insurance1/index.html","title":"使用 ECM 产品解决汽车保险业务的智能分派与优化系列: 第一部分：应用场景及解决方案的构建","typeId":0,"updateTime":"2014-05-15 00:00:00"}
{"author":"","clickNumber":0,"content":"\r\n<div class=\"ibm-columns\">\r\n<div class=\"ibm-col-1-1\">\r\n\r\n<h3 id=\"0.1.Introduction|outline\">简介<\/h3><p>云计算承诺并通常交付诸如可扩展虚拟化的企业解决方案、弹性基础架构、健壮服务及成熟平台的能力。基于云的架构看似能提供无限的可能，但它同时也展现了许多挑战与风险。云计算的范畴包括从基于云的开发工具到弹性基础架构，使得开发人员使用全尺寸的测试环境成为可能，而且既廉价又易于构建和基于需要进行分解。第一步是要理解为何云计算最适合用在应用生命周期管理（Application Lifecycle Management，ALM）中。<\/p><h3 id=\"0.2.Cloud-basedcomputingandtheALM|outline\">云计算与 ALM<\/h3><p>云计算最适合在应用生命周期的上下文中进行理解。技术专业人员经常在开发生命周期的每一个阶段使用基于云的工具，来管理工作流以及 ALM 所需要的所有任务。基于云的 ALM 工具通常包括源代码管理、工作流自动化（包括缺陷及任务追踪）、知识管理，以及基于社区的论坛。基于云的工具可以在整个 ALM 中使用。许多组织通过维护他们自己拥有的私有云来更好地利用云。虚拟化环境使得持续交付和健壮测试环境成为可能。云计算的真正优势是它在低成本交付企业架构和可随着需求的增加而扩展架构这两方面的能力。使用云技术的公司可以更加专注于运维支出（operating expenditures，OPEX）而不是资本支出（capital expenditures，CAPEX）。因此，业务可以保持在初始的低开销，并根据资源和系统使用的情况支付费用。但云也有其自身所特有的一些风险和潜在的陷阱。<\/p><h3 id=\"0.3.Thedarksideofcloud-basedcomputing|outline\">云计算不好的一面<\/h3><p>云计算自身带有一些问题，诸如从技术复杂性到必须依赖于并不会与本组织所关切的优先级和紧迫性相一致的第三方等等。例如，虽然您将您客户信息的隐私和安全性放在第一位，但一些运营商并无法实现足够的安全措施，甚至并未将风险作为一个重要的方面来进行考虑。许多零售商发现，数据丢失会有损组织的信誉并有可能对业务产生负面影响。客户并不关心第三方才是数据决口的最终根源。许多服务提供商声明他们只处理 IT 循规和监管方面的事情，而不对客户方面的事情负责。就相关的法规和审计要求来说，这种声明或许并无依据。云计算就是存在这样的缺点，但好消息是 DevOps 可以帮助有效地降低这一类的风险，甚至为可能发生的问题提供后备计划。首先您需要理解您所使用的云能力。<\/p><h3 id=\"0.4.Whichcloud?|outline\">哪种云？<\/h3><p>云计算是一个非常宽泛的主题，涵盖属于组织自己所拥有基础架构中的私有云到租用云提供商提供的服务：<\/p><ul class=\"ibm-bullet-list\"><li>软件即服务（Software as a Service，SaaS）：把软件作为一种订购或基于所需来提供。服务提供商管理底层基础架构，包括操作系统和应用程序本身。<\/li><li>平台即服务（Platform as a Service，PaaS）：平台由服务提供商维护，用户无需关心底层的基础架构，包括操作系统和存储。<\/li><li>基础架构即服务（Infrastructure as a Service，IaaS）：基础架构，包括广泛使用的虚拟私有主机（Virtual Private Server，VPS），由服务提供商管理，用户自行维护操作系统、存储，以及在硬件和网络层之上的基础架构。<\/li><\/ul><p>由于云已经扩张到数据库、存储和文档服务，现在越来越经常将这些服务称为 XaaS 来表示几乎任何类型的资源都可以被虚拟化。由于所有这些灵活性，云对于每一个问题来说都是一个理想的解决方案。但真相是云计算也可能会极度失调。<\/p><h3 id=\"0.5.Dysfunctionalcloud-basedcomputing|outline\">失调的云计算<\/h3><p>当人们开始使用云资源之后，他们都会惊讶于他们所遇到的挑战。虽然 IasS 通常要求您拥有知识丰富的系统管理员，PaaS 及SaaS 模型则将更多的系统管理员负担交给服务提供商。人们会很快发现 PaaS 及 SaaS 云计算并不意味着他们的系统完全不需要管理员。当发生问题时，通过服务提供商的帮助支持中心（help desk）来解决问题将会非常挑战。通常解决办法就是需要您为修复问题所需的额外功能付费。人们通常都会觉得自己被服务提供商束缚，除非他们自己拥有自动化的过程来重新配给他们的服务器，并无缝重建他们的应用基础架构。DevOps 提供原则和规程来定位此类问题，并在问题发生时进行处理。<\/p><h3 id=\"0.6.DevOpsbestpracticesthatareessentialforthecloud|outline\">对于云来说最核心的 DevOps 最佳实践<\/h3><p>DevOps 原则和实践提供了基础能力，使得组织物尽其用云计算并定位及减轻与云计算相关的固有风险成为可能。组织可以可靠地构建他们的基础架构、配置服务器和能在更好的位置部署应用，来处理云所带来的挑战。DevOps 提供了以下核心能力来帮助管理云计算：<\/p><ul class=\"ibm-bullet-list\"><li><a href=\"#0.6.1.Infrastructureascode|outline\">基础架构即代码（Infrastructure as Code）<\/a><\/li><li><a href=\"#0.6.2.Provisioningservers|outline\">配给服务器<\/a><\/li><li><a href=\"#_Release_and_deployment\">自动化应用部署<\/a><\/li><li><a href=\"#_Service_validation_and\">知识分享<\/a><\/li><li><a href=\"#0.6.5.ManagingthefullALM|outline\">管理完整的应用生命周期<\/a><\/li><li><a href=\"#0.6.6.Continuousintegrationanddelivery|outline\">持续集成与部署<\/a><\/li><li><a href=\"#0.6.7.Continuousqualityassuranceandtesting|outline\">持续质量保证与测试<\/a><\/li><\/ul><p>任何软件或系统开发工作都应当从一个关于所构建软件和系统清晰的规格说明开始。如果您能够自动化构建您的基础架构、配给服务器并部署应用，您的组织就能够处理发生的事故或问题，并在需要时无缝变更服务提供商。<\/p><a id=\"0.6.1.Infrastructureascode|outline\"><\/a><p><strong>基础架构即代码<\/strong><\/p><p>DevOps 着重关注于使用自动化、编程化的规程来构建和维护核心基础架构组件的能力。对于 DevOps 来说，基础架构即代码（Infrastructure as Code）包括了配给服务器、构建中间件，以及安装组成系统架构核心组件的应用程序代码等方面的能力。基础架构即代码还包括了比编写安装过程脚本更多的方面，虽然编写脚本也是必要的需求。通过 DevOps，技术主题专家（Subject Matter Experts，SME）能够与最具备资质创建自动化和完全可追溯的可重复过程的运维专家一起协作。基础架构组件包括复杂的应用程序服务器，例如 IBM&#174; WebSphere&#174; Application Server，及健壮的数据库，例如 IBM&#174; DB2&#174;。如果不借助 DevOps 完全自动化，而且被文档记录、可重复、可验证的安装过程，安装这些核心基础架构组件将会是一个复杂的任务。从质量的视角，确保中间件的能力，例如数据库及应用服务器被正确安装，将帮助确保测试环境能与生产环境相一致。当这些环境相一致时，将会减少在生产环境中发现在测试阶段并没有显现的缺陷的风险。基础架构即代码一个最重要的方面就是编程化配给服务器的能力。<\/p><a id=\"0.6.2.Provisioningservers|outline\"><\/a><p><strong>配给服务器<\/strong><\/p><p>为了在云中构建服务器，可以从操作系统一个已知的基线开始。许多云提供商提供一个应用程序编程接口（Application Programming Interface，API）来帮助系统管理员自动化配给服务器的规程。这些规程包括使用诸如包安装器等工具安装关键组件的脚本，这样通常可以支持使用加密哈希值（cryptographic hash）来验证正确的包是否被包括核被安装好。安全标准，例如 <a href=\"http://www.cisecurity.org/\">Center for Internet Security<\/a>（CIS）所提供的那些标准，可以被自动化并且帮助确保系统是被尽可能安全地配置的。在服务器、操作系统及中间件都被配给好之后，下一步就是自动化应用程序部署。<\/p><a id=\"_Release_and_deployment\"><\/a><p><strong>自动化应用程序部署<\/strong><\/p><p>应用程序部署通常涉及可观的复杂性，DevOps 提供了对于创建自动化应用程序部署的能力来说最核心的原则和规程。使用 DevOps 关于持续集成和持续部署的实践来创建完全自动化部署流水线，对于贯穿整个应用程序部署生命周期来说非常重要。成功构建完全自动化部署流水线一个最有效率的途径，就是创建一个认可分享知识和专业技能的价值的组织文化。这种想法是核心的 DevOps 原则之一。<\/p><a id=\"_Service_validation_and\"><\/a><p><strong>知识分享<\/strong><\/p><p>DevOps 着重关注于开发与运维之间的协作。开发人员选择和实现新的技术、新的特性，他们快速定位发生在已有系统中问题。开发人员是比组织内其他人更加了解技术的主题专家。运维团队贡献关于所用技术在运行生产条件下的相关行为的核心专业技能。运维专业人员包括发布及部署团队，他们是创建自动化可重复过程方面的专家。当这两个团队分享信息时，整个组织都可以从这种制度化关于有效运维的核心基础知识中获益。DevOps 团队要比部署和运维团队要大。它需要包括整个组织和服务提供商中的所有利益相关者。这些利益相关者需要认可确保其客户成功的重要性。<\/p><a id=\"0.6.4.1.Knowledgesharingwiththecloud-basedprovider|outline\"><\/a><p><strong>与云提供商一起进行知识分享<\/strong><\/p><p>最佳的云提供商会培育他们的用户通过在线虚拟社区分享知识的文化，这些分享包括描述服务器配给和自动化应用程序部署方面的技术说明。在这样的环境中，DevOps 推崇在被通知用户和由云服务提供商安排的主题专家之间分享知识的概念。这种分享可以通过在线社区来完成，并培育关于优秀沟通与协作的 DevOps 原则。当社区成员及服务提供商在一个云计算环境中一起分享知识时，许多风险得以降低。知识需要在贯穿整个应用生命周期中进行分享。<\/p><a id=\"0.6.5.ManagingthefullALM|outline\"><\/a><p><strong>管理完整的应用生命周期<\/strong><\/p><p>这一工作是由受云计算影响的所有利益相关者一起执行的，例如业务分析师、开发人员、测试人员及运维专业人员。关于沟通和协作的 DevOps 原则对于基于云的开发和基于云的运维来说非常关键，但在云中管理应用生命周期也会带来一些独特的挑战和风险。诸如持续集成和交付方面的技术可以帮助建立自动化的应用程序部署流水线。<\/p><a id=\"0.6.6.Continuousintegrationanddelivery|outline\"><\/a><p><strong>持续集成与交付<\/strong><\/p><p>持续集成与持续交付是通常与 DevOps 最佳实践联系在一起的最有效的两个技术。基于云的开发可以从经常集成变更和自动化部署中获益良多，而且代码可以使用被良好定义和完全自动化的部署流水线交付到一个经常使用的基础上。<\/p><p>了解持续集成与交付：<\/p><a id=\"_Use_automated_systems\"><\/a><ul class=\"ibm-bullet-list\"><li><a href=\"http://www-01.ibm.com/software/tivoli/products/prov-mgr/\">IBM Tivoli&#8482; Provisioning Manager<\/a> 支持一个动态的基础架构。它自动化了对物理服务器、虚拟服务器、软件、存储和网络的管理。<\/li><li><a href=\"http://www-01.ibm.com/software/tivoli/products/prov-mgr-os-deploy/\">IBM Tivoli Provisioning Manager for OS Deployment<\/a> 自动化了操作系统的远程部署。<\/li><li><a href=\"http://www.urbancode.com/html/products/deploy/\">IBM UrbanCode Deploy&#8482;<\/a> 提供了一个自动化的部署框架，可以减少部署错误和改善效率、正确率和可追溯性。<\/li><\/ul><a id=\"0.6.7.Continuousqualityassuranceandtesting|outline\"><\/a><p><strong>持续质量保证与测试<\/strong><\/p><p>持续质量保证（Quality Assurance，QA）与测试需要包括所有利益相关者在全生命周期中进行努力。云展现了一些针对 QA 以及测试方面的挑战，但它同时也提供了一些优秀的能力。通过 DevOps 关于自动化配给和持续部署方面的最佳实践，开发人员、QA 专业人员和其他利益相关者可以在一个以前并未曾有的低成本，而且与生产环境相似的测试环境中进行测试。在云中，环境验证是最为重要的，尤其当它是由服务提供商所控制时。但即便是私有云，配给虚拟服务器也经常会显现一些特别的挑战。系统专业人员了解一个虚拟机并不能完全准确具备一台物理服务器的行为。这些风险需要被理解和避免。DevOps 关于配给测试环境的能力使用云资源来交付新的能力，如果您已经具备使用自动化规程配给和维护这些环境的 DevOps 最佳实践，可使得生产力和质量两个方面都得到了增强。<\/p><p>了解测试：<\/p><ul class=\"ibm-bullet-list\"><li><a href=\"http://www.ibm.com/developerworks/cn/rational/products/qualitymanager/\">IBM&#174; Rational&#174; Quality Manager<\/a>，一个基于 web 的集中化测试管理环境，为跟踪和度量报告提供了一个协作化的解决方案。<\/li><li>IBM&#174; Rational Integration Tester 是 <a href=\"http://www.ibm.com/developerworks/cn/rational/products/testworkbench/\">IBM&#174; Rational&#174; Test Workbench<\/a> 的一部分，组合了对高度复杂应用的功能测试、性能测试、回归测试、加载测试和集成测试等自动化测试功能。<\/li><\/ul><h3 id=\"0.7.UseDevOpstoaddresschallengesinthecloud|outline\">使用 DevOps 来定位云中的挑战<\/h3><p>DevOps 原则和实践增强了所有利益相关者之间的协作，包括开发、运维、质量保证、测试、信息安全，以及服务提供商内部的技术支持结构。在这种情况下，DevOps 协作同样包括来自服务提供商的技术支持工作人员，以及客户同行参与的社区支持群组。例如，一个优秀的云服务提供商会为客户编写可以让其他客户收益的技术说明付酬劳，也会为对协作文化有贡献的过程付酬金。DevOps 还提供强有力的工具和过程，来让组织得以根据需要尽可能经常地配给服务器和部署代码。当服务提供商无法满足其服务水平协议（Service Level Agreements，SLA）并提供预期服务时，您可以无缝转移到其他的云服务提供商。开发工具可以快速获得和根据所需扩展，无论工具是托管在服务提供商的云或企业自己拥有的私有云上。为了实现虚拟化的真正价值，应用 DevOps 原则和实践来帮助领航云计算的挑战。<\/p><h3 id=\"0.8.Securityinthecloud|outline\">云计算的安全<\/h3><p>尽管存在可能的风险，如果使用得当的话云计算同样可以安全和可靠。DevOps 最佳实践，使得理解和监控运行时环境成为可能。您可以侦测非授权的变更，无论变更是因为人为错误或出于恶意目的。更重要的是，如果需要的话您可以通过重新构建您的系统来处理事故。在系统被入侵或当其他 IT 设施在诸如洪水或地震等灾难之后需要恢复时，这一能力非常关键。<\/p><p>组织需要明白的是，在云服务中航行并不容易。一个关于有效沟通、协作和过程改进的文化非常关键。<\/p><h3 id=\"0.9.Conclusion|outline\">结论<\/h3><p>DevOps 提供了一组强有力的原则和实践，来帮助定位云计算所固有的一些挑战。使用这些最佳实践来实现云计算完全的威力和能力。<\/p><CMA ID: 971304><Site ID: 10><XSLT stylesheet used to transform this file: dw-document-html-7.0.xsl>\r\n\r\n\r\n<\/div>\r\n<\/div>\r\n","createTime":"2014-05-15 00:00:00","deployTime":"2014-05-15 00:00:00","id":0,"intro":"为了实现基于云的软件开发和基于云的运维的真正价值，应用 DevOps 实践来帮助减少与云计算相关的陷阱和风险。了解如何使用 DevOps 最佳实践来确保您的组织能够同时使用基于云的开发工具和过程，并成功实现可扩展的基于云的运维。","keyword":"","recommend":false,"source":"http://www.ibm.com/developerworks/cn/rational/d-cloud-devops/index.html","title":"DevOps 最佳实践: 第 5 部分 云中的 DevOps","typeId":0,"updateTime":"2014-05-15 00:00:00"}
{"author":"","clickNumber":0,"content":"\r\n<div class=\"ibm-columns\">\r\n<div class=\"ibm-col-1-1\">\r\n\r\n<p><em><strong>备注<\/strong>：Codename: BlueMix 是一款 <strong>beta 级<\/strong>产品，随着我们不断让其功能更加完善和更易于使用，它也将不断改进。我们会竭尽全力保持本文最新，但并不总是完全跟得上现状。感谢大家的理解！！<\/em><\/p><h3 id=\"1.3.Settingthescene|outline\">设置场景<\/h3><p>MeterPal 是一个虚构的、由 Kickstarter 资助的创业公司，它提供了一种移动的、社会化的新的计时停车方法。Phil 和 5 位大学同学共同创立了 MeterPal。他们与 JKE Banking 达成协议，帮助 JKE Banking 处理其微支付交易。作为回报，他们参与了虚构的 Money that Matters 慈善计划。在有人支付停车计时费用时，他们可将该费用舍入为最接近的美元数，并提供给预先选择的慈善机构。<\/p><p>Innovationville 的市长希望部署他们的智慧计时停车解决方案。<\/p><p>Phil 和他的团队受到鼓舞，快速将他们的解决方案投入市场并不断获得新的用户。他们选择采用一种敏捷开发流程，其中 Phil 是产品负责人，Sarah 是项目研发管理经理。在过去，该团队主要使用白板，通过便笺来采集项目信息。他们从未找到机会采用、安装和配置一个敏捷的协作式工具来支持其开发。<\/p><p>在 Innovate（IBM&#174; 在奥兰多的举行的技术峰会）期间，项目研发管理经理 Sarah 了解到了 <a href=\"https://hub.jazz.net/help/faq\">DevOps Services<\/a> (JazzHub)。她参加了一个开放的 DevOps Services 实验活动，该工具的简便性给她留下了深刻印象。<\/p><p><em>采用 DevOps Services 的团队可将精力集中在真正重要的事务上：产品开发和交付。<\/em><\/p><p>Sarah 知道产品负责人 Phil 有点担忧新应用程序的采用，因为 MeterPal 项目的发布日期离现在只有 12 周。Phil 希望在早期冲刺阶段实现尽可能多的商业价值。因此，Sarah 展示了 DevOps Services 特性如何为协作式开发提供支持。DevOps Services 帮助该团队：<\/p><ul class=\"ibm-bullet-list\"><li>继续使用 scrum 敏捷实践，因为 DevOps Services 包含一个 scrum 模板，可帮助团队执行敏捷开发<\/li><li>能够灵活地与 Uma 合作，这是开发团队中有时在家里工作的一名成员。云中的一个工具使得 Uma 能够与团队协作，甚至在她未在办公室的时候也能与团队协作。<\/li><li>她能迅速而又高效地工作，因为可以从 Web 浏览器访问基于 Web 的 DevOps Services，无需在本地安装软件。<\/li><\/ul><p>返回到办公室后，Sarah 说服团队为他们的项目试用 DevOps Services，团队使用 DevOps Services 启动了 MeterPal 项目。<\/p><p class=\"ibm-button-link-alternate\"><a href=\"https://hub.jazz.net/project/phil5/MeterPal?&#10;utm_source=developerWorks&amp;utm_medium=article&amp;utm_content=jazzhub-&#10;project&amp;utm_campaign=dwchina\">分析 MeterPal 项目<\/a><\/p><h3 id=\"1.4.UseJazzHubtodevelopandBlueMixtodeploy|outline\">使用 DevOps Services 进行开发，使用 Codename:BlueMix 进行部署<\/h3><p>在项目 MeterPal 的第一次冲刺开始时，Sarah 要求 scrum 团队转到 <a href=\"https://hub.jazz.net/\">DevOps Services<\/a> 并进行注册。他们在不到 3 分钟的时间内完成了任务，因为注册表仅需要一个有效的电子邮件地址、一个用户 ID、一个密码和一些基本信息。<\/p><p>Sarah 访问 DevOps Services，使用她的帐户进行登录，并准备好创建一个项目。如图 1 所示，她键入项目名称 (MeterPal)，将它设为公开可见（公开项目在 DevOps Services 上是免费的），然后选择 scrum 流程，转到 <a class=\"ibm-tooltip\" title=\"Codename: BlueMix is IBM's open platform for developing and                     hosting applications. Built on the Cloud Foundry open source technology, BlueMix is a Platform as a Service (PaaS) offering that aims to simplify the normally tedious tasks associated with managing the infrastructure necessary to develop and host applications at Internet scale.\">Codename:BlueMix<\/a> 来部署他们的应用程序。Sarah 还选择了 Jazz&#8482; 源代码控制选项，因为团队决定将他们的源代码存储在 <a href=\"https://hub.jazz.net/learn\">DevOps Services<\/a> 云上。\n                <\/p><h5 id=\"fig1\">图 1. 在 DevOps Services 上创建一个公开的 scrum 项目<\/h5><img alt=\"添加 scrum 特性，将它部署到 BlueMix\" src=\"/sunshine_new/images/负1267720265/image001.jpg\" width=\"517\" /><p>几秒之后，就在云上完成了MeterPal 项目的创建。Sarah 邀请其他团队成员立即加入该项目。他们收到了 DevOps Services 发送的一个电子邮件通知，要求注册或以团队成员身份登录到 MeterPal 项目。<\/p><p>很快，Sarah 在 DevOps Services 上创建了 MeterPal 项目。该团队能够通过 Web 浏览器访问一个简单而又强大的云环境，他们可以执行：<\/p><ul class=\"ibm-bullet-list\"><li>敏捷项目规划<\/li><li>阶段、案例和任务跟踪<\/li><li>源代码控制<\/li><li>在云中的部署<\/li><\/ul><p class=\"dw-article-ps-see-blk\"><span class=\"dw-article-ps-see-head\">阅读：<\/span><a class=\"dw-article-ps-see\" href=\"https://hub.jazz.net/tutorials/jazzweb\">开发应用程序并部署到 BlueMix<\/a><\/p><p class=\"dw-article-ps-see-blk\"><span class=\"dw-article-ps-see-head\">阅读：<\/span><a class=\"dw-article-ps-see\" href=\"https://www.ibmdw.net/bluemix/\">访问 BlueMix 开发人员社区<\/a><\/p><p class=\"dw-article-ps-see-blk\"><span class=\"dw-article-ps-see-head\">观看：<\/span><a class=\"dw-article-ps-see\" href=\"http://www.youtube.com/user/JazzHub\">观看 DevOps Services (JazzHub) 视频<\/a><\/p><h3 id=\"1.5.ConfigureaJazzHubproject|outline\">配置一个 DevOps Services\n    项目<\/h3><p>现在 Sarah 希望在 DevOps Services 上配置 MeterPal 项目。她添加了相关的描述和很酷的图像。Sarah\n        创建了一个与项目目标一致的时间表（发布计划在 12 周内进行）。然后 Sarah 输入了一个项目开始日期，以及冲刺的数量和时长，如图 2\n        所示。不同的冲刺是使用相应的开始和结束日期自动创建的。<\/p><h5 id=\"fig2\">图 2. 在 DevOps Services 上创建冲刺<\/h5><img alt=\"每个冲刺的开始时间和结束时间\" src=\"/sunshine_new/images/负1267720265/image002.jpg\" width=\"483\" /><p>然后，Sarah 为第一次迭代创建一个冲刺订单（sprint backlog），她称之为 Sprint 1，如图 3 所示。<\/p><p><strong>备注：<\/strong>DevOps Services 自动创建了一个产品订单。<\/p><h5 id=\"N100C9\">图 3. DevOps Services 上的敏捷项目计划<\/h5><img alt=\"Plans 选项卡上的 Sprint 1 订单\" src=\"/sunshine_new/images/负1267720265/image003.jpg\" width=\"575\" /><p>Sarah 在大约 5 分钟以前才开始使用 DevOps Services。在这个阶段，无需执行任何进一步配置。云中的 MeterPal 项目已经可供团队使用，他们可以利用该项目为他们的敏捷、协作式工作提供支持。<\/p><p class=\"dw-article-ps-see-blk\"><span class=\"dw-article-ps-see-head\">阅读：<\/span><a class=\"dw-article-ps-see\" href=\"https://hub.jazz.net/explore\">DevOps Services (JazzHub) 项目<\/a><\/p><h3 id=\"1.6.In-contextcollaborationonthecloud|outline\">云上的上下文中协作<\/h3><p>借助 DevOps Services 上配置的 MeterPal 项目，产品负责人 Phil 可向产品订单添加新的阶段和案例。团队可执行典型的 scrum 活动，比如订单排序和细化、冲刺规划，或者将案例分解为任务。DevOps Services 还有助于将源代码与计划连接起来。借助这种可跟踪行，很容易了解每个案例的实现过程。MeterPal 项目的主页包含一个项目描述、一些文件和成员。<\/p><h5 id=\"fig4\">图 4. MeterPal 项目的主页<\/h5><img alt=\"该页面包含描述、文件和成员\" src=\"/sunshine_new/images/负1267720265/image004.jpg\" width=\"575\" /><p>开发人员 Darryl 从冲刺订单中获取一个任务。他的目标是为 MeterPal 网站创建一个新页面。<\/p><p>Darryl 在 DevOps Services 上打开 Code 选项卡。从他的 Web 浏览器，他创建一个新 HTML 文件，如图 5 所示。DevOps Services 在线编辑器支持 JavaScript、HTML、CSS 或 Java&#8482; 编程语言的开发和语法突出显示功能。Darryl 还可以创建一个使用 Web 编辑器的样式表，但他决定从另一个项目导入一个现有的文件。<\/p><h5 id=\"fig5\">图 5. DevOps Services 上的源代码编辑器<\/h5><img alt=\"MeterPal.html 的内容\" src=\"/sunshine_new/images/负1267720265/image005.jpg\" width=\"575\" /><p>开发人员可在他们的 Web 浏览器中进行工作。如果愿意的话，他们还可以选择从 Eclipse&#174; 或 IBM&#174; Visual Studio IDE 进行开发。DevOps Services 上开发的应用程序可推送到云中的 IBM BlueMix 运行时上并进行测试。<\/p><p>当 Uma 在家里工作时，她的工作效率并不受影响，因为她可以远程访问云上的项目。她可以从她的 Web 浏览器与团队合作处理案例和任务。Uma 甚至可从移动设备访问项目信息，当有人在工作项目中提到她时，她会获得电子邮件通知。<\/p><p>最初，产品负责人 Phil 很不情愿对 MeterPal 项目采用新工具。他的担忧是，团队成员需要花费太多的时间来学习 DevOps Services，而不是将精力集中在案例实现上。但 Phil 现在认为，在团队采用 DevOps Services 后，他们的生产力并未受影响。而且由于可以从 Web 访问订单，Phil 能够更高效地与利益相关者进行协作，甚至与远距离的利益相关者进行协作。<\/p><p>DevOps Services 支持在云上执行上下文中的协作，帮助 MeterPal 团队构建更好的产品。产品信息是集中存储的，而且可以从实时仪表板访问。人们可开始讨论阶段、案例或任务。他们可执行评审和访问实现代码。对于 MeterPal 团队，DevOps Services 环境缩短了产品上市准备时间。<\/p><h3 id=\"1.7.Summary|outline\">结束语<\/h3><p>MeterPal 的其他团队经常联系项目研发管理经理 Sarah。每个人都听到了 MeterPal 项目对 DevOps Services 的成功使用。没有漫长的学习曲线，没有痛苦的安装和配置。借助 MeterPal 简单的 Web 界面，DevOps Services 支持团队可执行任务跟踪、敏捷规划、源代码控制和部署。团队成员可将精力集中在真正重要的事务上：产品开发和交付。其他许多团队也有意向在他们的计划中采用 DevOps Services。<\/p><CMA ID: 971310><Site ID: 10><XSLT stylesheet used to transform this file: dw-document-html-7.0.xsl>\r\n\r\n\r\n<\/div>\r\n<\/div>\r\n","createTime":"2014-05-15 00:00:00","deployTime":"2014-05-15 00:00:00","id":0,"intro":"本文将介绍如何使用 DevOps Services (JazzHub) 与其他人协作，在云中计划、跟踪、开发和部署软件。本文使用了一个示例应用程序，帮助您了解如何在 DevOps Services 上进行开发并在 IBM Codename:BlueMix 上进行部署。","keyword":"","recommend":false,"source":"http://www.ibm.com/developerworks/cn/rational/d-bluemix-devops-services-project/index.html","title":"使用 DevOps Services 在云中开发应用程序","typeId":0,"updateTime":"2014-05-15 00:00:00"}
{"author":"","clickNumber":0,"content":"\r\n<div class=\"ibm-columns\">\r\n<div class=\"ibm-col-1-1\">\r\n\r\n<p><em><strong>备注：<\/strong>Codename:BlueMix 是一款 <strong>beta\n                    级<\/strong>产品，随着我们不断让功能更加完善和更易于使用，它也将不断改进。我们将竭尽全力保持本文最新，但它并不总是完全跟上现状。感谢大家的理解！<\/em><\/p><p>有效的、创新性的应用程序甚至都有可能被破坏或在市场上遭遇失败，因为它们无法满足性能、响应时间和总体可靠性等\n                NFRs。在传统上，架构师通过修改基础架构的形状和大小来响应\n                NFRs。并发用户数量通过将用户会话分区到多个并行运行的系统上来处理；响应时间可通过消除性能瓶颈（常常在数据库和存储使用上）来改善；服务需求通过添加能够快速执行大容量事件记录的新服务来满足；等等。但在云环境中，架构师管理\n                NFRs 的方法方面的选择更加有限。<\/p><p>云基础架构即服务 (IaaS) 平台使得基础架构的修改更经济、更轻松（这解释了 IaaS\n                环境在快速变化、快速扩展的工作负载中流行的原因），而且架构师的选择也相应地减少了。云平台即服务 (PaaS)\n                环境在此范例上更进一步，从用户角度讲消除了水平扩展、组件放置、日志记录和系统管理。这些操作都会发生，但作为 IT\n                架构师，您无法控制（或几乎无法控制）它们。<\/p><p>但是，架构师对 NFR\n                的管理不会在云环境中消失。相反，它们转移到了应用程序的内部机制中，转变为了一些应用程序设计模式。这些模式的实现可确保云应用程序是云操作环境\n                (CloudOE) 中的 “良民”，它们不会连接 CloudOE 机制并与 CloudOE 的工作方式保持一致。本文将介绍它们在 PaaS\n                环境中解决的 NFRs 模式和类型，还会介绍 IBM Codename: BlueMix，这是一个开放标准 PaaS\n                CloudOE，您可以在其中让设计模式生效。<\/p><h2 id=\"N1005D\">NFRs 和应力案例<\/h2><p>功能性需求和非功能性需求在概念上不同。二者都表示定义的系统的利益相关者或影响者的<em>动机<\/em>。随着 IT\n                技术和角色的演变，软件系统会继续增加利益相关者的数量和他们的请求的复杂性。除了系统的用户之外，利益相关者和它们各自的需求包括：<\/p><ul class=\"ibm-bullet-list\"><li>开发人员：代码的结构和清晰度<\/li><li>维护人员：记录和调试工具<\/li><li>测试人员：跟踪和提供的其他问题判定工具<\/li><li>提供商：应用程序使用培训的简单性<\/li><li>运营商：提供的信息水平<\/li><li>运营经理：解决方案的可伸缩性<\/li><li>配置管理专家：支持的中间件包装和级别<\/li><li>数据库管理员数据库资源使用和优化<\/li><li>服务经理：监视操作所需的技能和工作 <\/li><li>网络和系统管理专家：支持的工具<\/li><li>企业架构师：与公司标准架构的合规性<\/li><li>安全官员：实现的安全类型<\/li><li>采购人员：解决方案的可伸缩性和适应性<\/li><li>评估人员：审核工具<\/li><li>支持人员：用户操作的复杂性： <\/li><li>沟通人员：界面的清晰性 <\/li><\/ul><p>这种情况考虑了具有困难的功能性需求和严苛的 NFRs 的复杂系统，这些 NFRs\n                包括非常高的可用性、快速的性能和挑战性的安全需求等。云计算还增加了对极高的灵活性和地理分散性的需求 &#8212; 随时随地都可用。<\/p><p>IT\n                架构师如何确保系统的架构能够令人满意地包含了所有这些需求？这里的危机在于，需求的解决是相互隔离的，没有考虑到一种需求的解决可能对其他需求带来什么样的影响。<\/p><p>要从整体上考虑需求，可将它们构想为相对的 “力（force）”，如图 1 所示。IT 解决方案可能以最优方式解决这些力。<\/p><h5 id=\"fig1\">图 1. 需求是相对力<\/h5><img alt=\"需求是相对力\" src=\"/sunshine_new/images/68916333/figure1.png\" width=\"407\" /><p>在图 1 中，这些力量包括：<\/p><ul class=\"ibm-bullet-list\"><li>功能性需求<\/li><li>我们在 IT 系统上施加的质量需求和约束 (NFRs)： \n<ul class=\"ibm-bullet-list\"><li>运行时质量<\/li><li>非运行时质量<\/li><li>业务约束<\/li><li>技术约束<\/li><\/ul><\/li><\/ul><p>特别重要的是可能在任何给定时刻一起运行的相对力的组合。此外，一些同时作用的力也会<em>相互加强<\/em>。也就是说，它们的影响会增加系统的特定部件上的应力。举例而言，大量并发用户与发生错误后较短的恢复时间相结合，可能在系统发生故障后给用户识别子系统带来压力，从而导致产生大量操作和实际阻止操作运行。类似地，严格的响应时间和具有有限资源的数据库相结合，可能带来无法处理的请求组合，除非应用程序是专为处理它而设计的（举例而言，通过使用缓存机制）。就像在土木工程中一样，我们使用词汇<em>应力案例<\/em>\n                来识别这些同时作用、相互加强的力。<\/p><p>云提供商的服务水平协议 (SLA) 是解决方案的需求（约束）之一，可能影响应力案例。例如，如果 IaaS\n                合同指定了一定容量的虚拟网络，托管应用程序的内部吞吐量上的这种潜在约束可能需要特定的机制来实现外部吞吐量目标。<\/p><p>有时，一种应力案例可能使得无法同时满足所有需求。在这些情况下，可能必须设定一组更加受限的需求，以便为用户维护合理的服务水平。我们将这些案例称为<em>降级的操作<\/em>。降级的操作在云应用程序中可能无法避免，所以小心地设计它们并在它们出现时与用户沟通很重要。<\/p><p>降级操作的一个简单、普遍的示例与分片数据库的<em>最终一致性<\/em>\n                    机制由关。这些数据库在云中提供了多个读取实例来确保性能和可靠性，而特定数据元素的写入始终在同一个实例上完成（为了保持写入一致性）。因为复制新数据所花费的时间有限，所以某个数据库实例中的信息可能在读取时不一致；它只是<em>最终<\/em>\n                一致的。使用最终一致的数据的应用程序必须能够支持降级的操作，通过做笑话用户感知到的不一致性（例如，通过显示仍在缓冲区中，还未提交的更新），或者（如果没有活动数据可用）通过在数据库最后更新时提醒用户。<\/p><h4 id=\"N100C0\">一个示例<\/h4><p>为了帮助解释如何处理 CloudOE PaaS 环境中的 NFRs，我们将基于虚构的 AMGRO.cloud\n                公司开发一个示例，这家零售商通过获取佣金的独立兼职销售人员网络来销售其商品。<\/p><p>AMGRO 决定通过提供一个目录来购买应用程序，开始进入在线销售市场。为了加速部署，AMGRO 计划在一个云提供商的 PaaS\n                环境中开发了该应用程序（该提供商将提供 Web\n                UI、安全服务和访问控制），并且链接到在交付服务和支付服务方面的市场领导者的在线服务。新应用程序还必须与现有的 AMGRO 企业资源规划 (ERP)\n                平台相集成，以便用于会计和仓库管理。<\/p><p>AMGRO 的新应用程序的 NFRs 包括：<\/p><ul class=\"ibm-bullet-list\"><li>并发用户数量预计约为 10,000。<\/li><li>所有目录视图预计在常规 ADSL 连接或高速蜂窝网络上只需不到 1 秒即可获得。<\/li><li>AMGRO 的云环境和支付服务预计具有 24x7 的可用性。<\/li><li>AMGRO 和交付服务提供商通过常规的 Internet 连接。<\/li><\/ul><p>对交付服务请求的响应具有 2 小时的承诺 SLA。此外，交付服务的可用性目标在晚上、他们执行系统维护期间有所不同。出于合同原因，此 SLA\n                不应更改。<\/p><p>因为新的 PaaS 应用程序将连接 AMGRO ERP 系统，所以此接口是高度敏感的，必须得到足够的保护。<\/p><p>图 2 演示了 AMGRO 示例。（此图和本文后面的大部分图都采用了 <a href=\"http://www.ibm.com/developerworks/rational/library/nonfunctional-aspects-togaf-archimate/\">TOGAF ArchiMate<\/a> 概念。）<\/p><h5 id=\"fig2\">图 2. AMGRO 示例<\/h5><img alt=\"AMGRO 示例\" src=\"/sunshine_new/images/68916333/figure2.jpg\" width=\"700\" /><p>在 AMGRO 的系统中，以下 NFR 组合一定属于应力案例：<\/p><p><strong>案例 1：亚秒级响应时间，但系统加载了：<\/strong><\/p><ul class=\"ibm-bullet-list\"><li>10,000 个并发用户<\/li><li>亚秒级响应时间<\/li><\/ul><p><strong>案例 2：亚秒级响应时间，但外部系统缓慢或不可靠：<\/strong><\/p><ul class=\"ibm-bullet-list\"><li>亚秒级响应时间<\/li><li>通过常规 Internet 连接交付和支付服务<\/li><\/ul><p><strong>案例 3：应用程序应该是可用的，但外部系统是异步的，或者具有不匹配的 SLA：<\/strong><\/p><ul class=\"ibm-bullet-list\"><li>24x7 可用性<\/li><li>Internet 连接<\/li><li>可用性 SLA 不匹配<\/li><li>离线流程<\/li><\/ul><p><strong>案例 4：混合云：<\/strong><\/p><ul class=\"ibm-bullet-list\"><li>安全的连接<\/li><\/ul><h2 id=\"N1010B\">PaaS 应用程序、NFRs 和架构师的角色<\/h2><p>一个基于云操作环境的 PaaS 解决方案会利用 CloudOE 编程模型来管理 NFRs，为应用程序架构师减轻了一些任务：<\/p><ul class=\"ibm-bullet-list\"><li><strong>在水平范围上管理用户负载<\/strong>：CloudOE\n                    根据工作负载在虚拟机中添加和删除组件实例，从而进行进行相应调整。应用程序架构师不再需要处理可伸缩性，但现在必须理解哪些组件必须同时扩展，以及如何管理通信的组件之间的不同扩展水平。<\/li><li><strong>为关键的路径利用最新的技术<\/strong>：在内部部署的解决方案中，架构师在系统的关键部分（数据库、消息主干网等）中利用了最新的技术。在云计算中，您采用了标准技术并拥有有限数量的基本选择。消除了硬件或软件技术上的不一致，但关键的路径必须通过设计模式来处理。<\/li><li><strong>通过放在同一位置可消除性能瓶颈<\/strong>：将具有高交互程度的工件相邻放置，是一种改善性能的常见做法。您仍然可以对\n                    CloudOE 中的应用程序这么做（假设这种捆绑不会妨碍水平扩展），但您可能无法控制具有多个分布式副本的应用程序和技术服务（例如\n                    MongoDB）的协同定位。 <\/li><li><strong>控制 SLA<\/strong>：在 CloudOE\n                    中，没有应用程序是孤立的。出于增强系统总体可靠性的用途，涉及的组件可以在任何地方。另一方面，（应用程序）本地的云提供商提交的 SLA\n                    可能与不同云平台上的另一个连接的组件提交的 SLA 不同。应用程序架构师无法假设具有统一的\n                    SLA，必须考虑响应丢失或延迟的可能性。<\/li><\/ul><h3 id=\"N10122\">PaaS NFRs 管理模式<\/h3><p>如果绘制 PaaS 的 <a href=\"http://www.ibm.com/developerworks/architecture/library/ar-introocdv1/\">操作上下文图<\/a>，我们可确定 4 种类型的外部角色：<\/p><ul class=\"ibm-bullet-list\"><li><strong>应用程序本身的用户（应用程序服务的使用者）<\/strong>：这些角色同行具有与应用程序的响应时间和可用性相关的需求。此外，由于并发用户数量的不同，典型的云应用程序常常具有无法预测的复杂性。<\/li><li><strong>外部系统<\/strong>：这些是云外部的物理系统，不在应用程序架构师的控制之下。 <\/li><li><strong>事件驱动的服务<\/strong>：一些服务可能实现长期运行的流程或一个异步接口。<\/li><li><strong>内部部署的系统（混合服务）<\/strong>：内部部署系统的云组件和内部组件都在应用程序架构师的控制之下，因此架构师可根据\n                    NFRs 来调节它们。<\/li><\/ul><p>与 4 种 PaaS 角色对应，我们确定了 4 种与 NFR 相关的设计模式：<\/p><ul class=\"ibm-bullet-list\"><li><strong>无状态应用程序<\/strong>模式，管理用户数量的扩展、高可用性和对短响应时间的支持，甚至在系统具有负载时亦可执行此操作。 <\/li><li><strong>异步应用程序<\/strong>模式，在长期运行的服务需要参与应用程序流程时，管理响应时间和持续可用性。 <\/li><li><strong>外部 API<\/strong> 模式，在流程流涉及到外部系统时管理高可用性和扩展。 <\/li><li><strong>安全 VPN<\/strong> 模式，安全地集成内部部署的系统。<\/li><\/ul><p>图 3 演示了 4 种模式和它们与 4 种角色的关系。<\/p><h5 id=\"fig3\">图 3. PaaS 模式<\/h5><img alt=\"PaaS 模式\" src=\"/sunshine_new/images/68916333/figure3.jpg\" width=\"764\" /><h4 id=\"N1015C\">无状态应用程序模式<\/h4><p>无状态应用程序模式的目标是，确保系统可同时扩展，服务大量请求并保持执行路径尽可能短。图 4 演示了无状态应用程序模式。 <\/p><h5 id=\"fig4\">图 4.  无状态应用程序模式 <\/h5><img alt=\"无状态应用程序模式\" src=\"/sunshine_new/images/68916333/figure4.jpg\" width=\"739\" /><p>使用的基本机制是 CloudOE 水平扩展功能。水平扩展功能通过执行环境实例的动态打开和关闭，以及系统级路由器/平衡组件来提供。<\/p><p>要高效地使用动态扩展，应用程序组件必须完全是无状态的。通常在传统的 Web\n                应用程序中，所有来自某个用户的请求都会路由到同一个应用服务器实例，该实例会将会话数据和对话状态保存在内存中。会话 cookie\n                被用作从内存检索会话数据和处理请求的密钥。在云计算中，大多数托管云实现都无法保证，是同一个应用程序实例将为一个会话服务。会话请求必须由面向\n                Internet\n                的路由器路由到不同的应用程序实例。因此，在此模式中，要保持执行实例完全无状态，会在外部使用内存存储，并作为服务在托管云提供的所有实例之间共享。（否则，在一个实例的所有会话关闭之前，不可能进行向下调整。） <\/p><h4 id=\"aa\">异步应用程序模式<\/h4><p>异步应用程序模式用于解决方案的事件驱动部分，一般在同步响应不可能实现也未想到时使用。图 5 演示了该模式。<\/p><h5 id=\"fig5\">图 5.  异步应用程序模式 <\/h5><img alt=\"异步应用程序模式\" src=\"/sunshine_new/images/68916333/figure5.jpg\" width=\"759\" /><p>该模式包含一个无状态异步业务服务（也称为<em>工作应用程序\n                (worker)<\/em>）池，这些服务从一个队列中获取<em>作业<\/em>，执行它们，然后将结果存储在一个（SQL 或\n                NoSQL）数据库中，供其他模式（例如无状态应用程序模式）使用。作业是一个独立的命令和上下文集合，另一种模式可使用它与工作应用程序通信。作业通常由前端应用程序放在队列中。流程的结果存储在数据库中，以便前端应用程序可避免扫描队列或等待队列关联\n                ID。<\/p><p>可同时存在多种工作应用程序类型、多种作业类型和多个队列，每种都有一定的特殊性。因此，使用不同的队列，可使用模式按正确的顺序执行一组活动。首选的数据库是一个最终一致的数据库，它可能拥有本地副本，但它至少对读取操作是一致的。具有单一实例的\n                SQL 数据库仅在 ACID（原子性、一致性、隔离性、耐久性）他特征很重要时使用， 例如，在执行信息传输操作时，比如在执行银行帐户上的借贷操作时。 <\/p><h4 id=\"N1018A\">外部 API 模式<\/h4><p>在您必须将一个外部（CloudOE 外部的）系统（例如，一个基于 IaaS 应用程序）集成到您 PaaS 解决方案中时，外部 API\n                模式很有用。在这种情况下，您可以假设外部系统发布了一个您通常所依赖的 SLA &#8212; 使用 “通常”\n                这个词是因为模式的准确用途是让您的应用程序远离外部应用程序可能拥有任何 “执行故障”。图 6 演示了此模式。 <\/p><h5 id=\"fig6\">图 6. 外部 API 模式 <\/h5><img alt=\"外部 API 模式\" src=\"/sunshine_new/images/68916333/figure6.jpg\" width=\"605\" /><p>该模式可通过在为您的（和其他）应用程序服务的 API 实例时间缓存活动数据来提供支持。以 AMGRO 场景为例，过去 24\n                小时内从外部支付服务收到的支付尝试或确认信息可缓存，以便在 AMGRO.cloud 用户请求最近发生的支付列表时无需访问外部服务。<\/p><p>公共服务 API 通常可帮助客户实现缓存机制，填充标准的 HTTP\n                响应标头：<code>Cache-Control<\/code>、<code>Expires<\/code> 和\n                <code>ETag<\/code>。例如，使用此标头，刷新内容只有在太平洋时间 2014 年 8 月 30 日（星期四）14:56:34\n                之后才会收到：<\/p><div class=\"codesection\"><pre class=\"displaycode\">Cache-Control: public\nExpires: Thu, 30 Aug 2014 14:56:34 GMT<\/pre><\/div><p> 使用此标头，收到的内容会缓存 868 秒，然后才会发出另一个 API 请求：<\/p><div class=\"codesection\"><pre class=\"displaycode\">Cache-Control: max-age=868<\/pre><\/div><h4 id=\"N101B1\">安全 VPN 模式<\/h4><p>安全 VPN 模式（如图 7 中所示）是外部 API 模式的一个变体。安全 VPN\n                    模式旨在满足将云上的组件与内部部署的组件（例如一个现有的<em>记录系统<\/em>，如 “<a href=\"http://www.ibm.com/developerworks/cn/cloud/library/cl-cloudecosystem/\">设计一个 SoE 生态系统来支持富用户体验<\/a>”中所述）的需求，这是混合云应用程序中的典型需求。<\/p><h5 id=\"fig7\">图 7. 安全 VPN 模式 <\/h5><img alt=\"安全 VPN 模式\" src=\"/sunshine_new/images/68916333/figure7.jpg\" width=\"597\" /><p>此模式背后的假设是，您可同时控制两种环境，进而比外部 API 模式更好地控制累积 SLA。<\/p><p>系统的内部部署部分将依赖于传统的架构模式，比如集群，以确保可伸缩性和可用性（裸机和 IaaS\n                解决方案都是如此）。云端惟一值得注意的加载项是活动数据的缓存（用以减少流经高开销 VPN 渠道的通信）。<\/p><p>VPN 渠道是该模式的核心，因为它在应用程序的两部分之间建立了受信任的通信。出于这个原因，除了标准 CloudOE 防火墙之外，PaaS\n                应用程序还使用了一个软件 VPN 功能（由 CloudOE 以服务的形式提供），该功能对应于内部部署端的一项类似（硬件或软件）功能。<\/p><h4 id=\"N101CE\">ACID 和最终一致性数据库模式<\/h4><p>事实上 CloudOE 同时提供了 SQL ACID 数据库服务和 NoSQL\n                最终一致性数据库服务，严格地讲，这不是一种设计模式。但我们在这里包含了它，因为这种灵活性对 PaaS 架构师很重要。图 8 演示了这种 PaaS\n                特性。 <\/p><h5 id=\"fig8\">图 8. ACID 和最终一致性数据库 <\/h5><img alt=\"ACID 和最终一致性数据库\" src=\"/sunshine_new/images/68916333/figure8.jpg\" width=\"800\" /><p>SQL\n                数据库可保证操作按一种顺序执行，无论有多少用户在使用该服务。这是通过锁定资源来执行的，所以更新冲突不可能发生。一次读取会返回一个字段的最后一个值或倒数第二个值（而且想要的行为通常可由用户自定义）。在缺陷方面，锁定机制限制了活动实例数量（因为多种多对多副本很快会变得无法管理）或需要一个具有单一中央锁定表的数据库\n                &#8212; 整个系统的单点故障。<\/p><p>NoSQL 数据库（比如\n                MongoDB）为本地写入维护着相同的规则，但会将这些写入操作复制到多个分布式副本上。如果一个副本失败，其他副本会接管它的客户端。复制无法立即进行，所以一个副本上的读取操作可能返回到苏第\n                    <em>n+1<\/em>\n                个值。副本最终会保持一致，但我们不知道具体时间。最终一致性是一种强大的扩展机制，适用于易变性较低的数据，因为本地读取比远程读取快得多。例如，来自工作应用程序的结果（通常写入一次且从不更新）是放入最终一致的数据库上的很好的候选数据。相反，一些（或许是大多数）高易变性数据需要\n                SQL 数据库的 ACID 属性。<\/p><h2 id=\"cloudoe\">Codename:BlueMix：一个 PaaS\n                CloudOE<\/h2><div class=\"dw-sidebar ibm-inset\"><h2 id=\"N101EC\">CloudOE 和参与型系统<\/h2><p> 我们在上一篇文章 “<a href=\"http://www.ibm.com/developerworks/cn/cloud/library/cl-cloudecosystem/\">设计一个 SoE 生态系统来支持富用户体验<\/a>” 中，将 CloudOE 的概念介绍为现代<em>参与型系统<\/em>\n                    的支持性技术。 <\/p><\/div><p>CloudOE 的成功的一种度量方式是，它帮助前线开发人员快速编写旨在验证业务想法的敏捷应用程序的能力。我们将通过一个示例大体介绍一下 IBM\n                CloudOE（Codename:BlueMix)，探讨 Codename:BlueMix\n                    的一些简化了<em>响应式<\/em>、<em>可扩展<\/em>、<em>高度可用<\/em>、<em>高度可靠<\/em>\n                    且<em>安全<\/em> 的应用程序的开发的特征。<\/p><p>Codename:BlueMix 构建于开源的 Cloud Foundry PaaS\n                    技术之上，它从该技术集成了一些重要概念，比如<em>应用程序<\/em>、<em>服务<\/em>、<em>组织<\/em>、<em>空间<\/em>\n                    和<em>构件包<\/em>。如果不熟悉这些概念，不要担心。我们将借助（图 9\n                中描绘的）一个以云为中心的典型应用程序的蓝图，帮助您了解这些概念。 <\/p><h5 id=\"fig9\">图 9. 一个 PaaS 应用程序<\/h5><img alt=\"一个 PaaS 应用程序\" src=\"/sunshine_new/images/68916333/figure9.png\" width=\"816\" /><div class=\"dw-sidebar ibm-inset\"><h2 id=\"N10225\">了解 Codename:BlueMix<\/h2><p>要从 Web UI 中了解 Codename:BlueMix，使用您的 IBM ID <a href=\"http://www.bluemix.net\">登录<\/a> 并创建第一个应用程序。<\/p><p>随后，您可能希望评估多个访问 Codename:BlueMix 的接口：<\/p><ul class=\"ibm-bullet-list\"><li>Web UI<\/li><li>Cloud Foundry 命令行，它可直接从 Web UI 下载<\/li><li>一个可从 Eclipse 下载的 Cloud Foundry Eclipse 插件<\/li><\/ul><p>可使用 <a href=\"https://orionhub.org/\">Orion<\/a> 在线编辑代码并将其推送到\n                    Codename:BlueMix。可将代码托管在 <a href=\"https://hub.jazz.net/\">JazzHub<\/a>\n                    上并将其推送到 Codename: BlueMix。<\/p><\/div><p>我们使用词汇<em>以云为中心的应用程序<\/em> 来表示一个为在 CloudOE 中运行而构思和设计的系统。这样一个系统通过可通过 Web 访问的\n                GUI 为用户提供了价值（图 2 中的 Presentation Web\n                应用程序）。它也可向其他系统提供服务，在此情况下，您可能发现使用具象状态传输 (REST)/JavaScript 对象表示法 (JSON)\n                接口来设计另一个 Web 应用程序（图 2 中的 Application services Web 应用程序）会很有用 &#8212;\n                REST/JSON 比 HTML\n                页面更适合系统集成。您希望在系统中提供的第三个元素是一个工作应用程序，它负责以异步方式将前端应用程序与会降低用户体验的后端流程分离。<\/p><p>Presentation 应用程序、Application services 应用程序和工作应用程序都是 Codename:BlueMix\n                应用程序：可通过 HTTP 协议访问且使用受 Codename:BlueMix 支持的任何语言和 Web 开发框架（包括 Java /\n                Liberty、Node.js / Express 和 Ruby / Sinatra）编写的 Web 应用程序。<\/p><p>如果一个工作应用程序（比如图 2 中的应用程序）没有提供 Web 服务，您将没有将 HTTP\n                路由与它关联，所以它无法从网络访问。但是，如果您使用一个工作 API 来查询和控制工作应用程序，在此情况下您不会丢弃\n                Codename:BlueMix 在云中部署工作应用程序时自动配置的 HTTP 路线。<\/p><p>这些应用程序实现了您系统的逻辑。您的开发团队编写代码。您无需担忧运行时（Liberty、Node\n                Express）的部署和配置；Codename:BlueMix 会完成此任务。在设计系统时，您绝不能忘记的惟一一点是，应用程序必须遵循 <a href=\"http://12factor.net/\"><em>12 因素方法<\/em><\/a>，以便它们是<em>无状态的<\/em>。 <\/p><h4 id=\"N10256\">为什么选择无状态？<\/h4><p>无状态性对以云为中心的应用程序不可或缺，因为 Codename:BlueMix\n                具有两种行为：它在应用程序节点（应用程序实例）崩溃时自动重新启动它们。而且它可同时运行同一个应用程序的更多实例，每个实例在自己的容器中运行，将它们放在平衡流量的面向\n                Internet 的路由器背后。这些行为让您的应用程序<em>可靠<\/em>、<em>高度可用<\/em> 且<em>可扩展<\/em>。<\/p><p>如果您的代码没有将任何配置数据或业务数据持久保存在本地，Codename:BlueMix\n                    应用程序非常合适。本地文件系统是短暂性的，它不会将信息保留到应用程序实例重新启动后。那么应将数据持久化到何处？<em>服务<\/em>\n                    和<em>环境<\/em> 都是有魔力的词汇：在每个应用程序实例启动时，Codename: BlueMix\n                    提供的应用程序<em>环境<\/em>中的源配置数据利用了 Codename:BlueMix 托管<em>服务<\/em>\n                来存储业务数据。<\/p><p>服务是应用程序通过网络使用的中间件资源：例如，数据存储（比如 SQL Database (SQLDB) Service 或\n                MongoDB）、消息/队列系统（比如 IBM Elastic MQ (ElasticMQ) 或 RabbitMQ），以及缓存系统（比如 IBM\n                DataCache 或分布式内存）。Codename:BlueMix 会全面管理它提供的服务，所以您无需置备和管理（监视和备份）您的数据存储。而且\n                Codename:BlueMix 提供了工具（命令行、Web UI、IDE 插件）来请求服务实例，还提供了客户端 API\n                来在您应用程序中使用该实例。<\/p><h4 id=\"N10275\">分布式缓存、消息/队列，以及数据服务<\/h4><p>现在您已理解了服务在 CloudOE 中的作用，我们返回看看 <a href=\"#fig9\">图 9<\/a> 中 3\n                个基本服务，您构建以云为中心的应用程序需要这些服务：消息/队列、数据存储和分布式缓存。<\/p><p>您可能需要一个分布式缓存服务来改善 Presentation\n                应用程序的响应时间，缓存来自用户的频繁请求。分布式缓存还拥有卸载应用程序服务和数据服务层的优势。使用分布式缓存服务的 Presentation\n                应用程序的另一个用例是，存储必须在应用程序实例之间共享的 HTTP 用户会话数据。所以，分布式缓存服务可帮助开发人员构建响应式系统。<\/p><p>消息队列服务有助于改善以云为中心的应用程序的<em>性能<\/em>。此服务用在 <a href=\"#aa\">异步应用程序<\/a>\n                模式中，以预防演示和应用程序服务层执行会对用户体验带来负面影响的可能很慢的任务。任何时候在演示或应用程序服务层中执行这种任务，您都要使用消息队列服务来将任务委托给工作应用程序。工作应用程序获取任务并按自己的进度执行它。用户会异步获得操作结果的通知。<\/p><p>通常，任务的星系描述暗示要更新业务数据库。CloudOE 提供了数据服务来实现此用途。<a href=\"#fig9\">图 9<\/a> 显示了一个关系\n                (SQL) 数据服务，但也可使用 CloudOE 所提供的基于文档的或键/值 (NoSQL) 数据服务。<\/p><h2 id=\"N10290\">使用 Codename:BlueMix 中的服务<\/h2><p>使用 Codename:BlueMix 中的服务很简单。您配置一个实例（<em>create<\/em>\n                    操作），将它与需要它的应用程序关联（<em>bind<\/em> 操作），然后开始编码。Codename:BlueMix\n                存储列出可用的服务，每个服务提供了文档和可供您用于开始编码的示例代码。所有服务都可通过 REST API 在网络上访问。API 端点 URL\n                和使用服务的凭据在 <code>VCAP_SERVICES<\/code> 环境变量中提供给绑定的应用程序。<\/p><p>我们以 Codename:BlueMix DataCache 服务为例。IBM 将 IBM WebSphere&#174;\n                DataPower&#174; XC10 Appliance 中的底层技术创建为缓存键/值数据对的 Codename:BlueMix 服务。创建一个\n                DataCache 服务并将它绑定到应用程序后，Codename:BlueMix\n                配置一个网格和一组用于缓存和检索数据的凭据。<code>VCAP_SERVICES<\/code> 定义类似于清单 1。<\/p><h5 id=\"listing1\">清单 1. <code>VCAP_SERVICES<\/code>\n                    定义<\/h5><div class=\"codesection\"><pre class=\"displaycode\">VCAP_SERVICES=\n{\n  \"DataCache-0.1\":[\n    {\n      \"name\":\"DataCache-8acb7\",\n      \"label\":\"DataCache-0.1\",\n      \"tags\":[],\n      \"plan\":\"free\",\n      \"credentials\":{\n        \"catalogEndPoint\":\"75.126.158.85:2809\",\n        \"restResource\":\"http://75.126.158.85/resources/datacaches/S5D22GP5TOisTeszePBbpAWU\",\n        \"restResourceSecure\":\"https://75.126.158.85/resources/datacaches/S5D22GP5TOisTeszePBbpAWU\",\n        \"gridName\":\"S5D22GP5TOisTeszePBbpAWU\",\n        \"username\":\"MKzIkp36RpKBWZP9FmXZHgFJ\",\n        \"password\":\"lyk7FzsNR66pBm7kWlTAvwHP\"\n      }\n    }\n  ]\n}<\/pre><\/div><p>我们假设您在编写一个 Node.js 应用程序。要使用 REST API 缓存一个键/值对，可执行 3 个步骤：<\/p><ol><li>初始化一些帮助器变量：\n                        \n<p><a href=\"#N102B6\" class=\"ibm-popup-link\" onclick=\"ibmweb.overlay.show('N102B6',this);return false;\">点击查看代码清单<\/a><\/p><div id=\"N102B6\" class=\"dw-sidefile-overlay ibm-common-overlay ibm-overlay-alt-two\"><div class=\"ibm-head\"><p><a href=\"#close\" class=\"ibm-common-overlay-close\">关闭 [x]<\/a><\/p><\/div><div class=\"ibm-body\"><div class=\"ibm-main\"><div class=\"ibm-container ibm-alternate\"><div class=\"ibm-container-body\"><div class=\"codesection\"><pre class=\"displaycode no-auto-overflow\">var vcap_services = JSON.parse(process.env.VCAP_SERVICES);\nvar credentials = vcap_services['DataCache-0.1'][0]['credentials'];\nvar auth = 'Basic ' + new Buffer(credentials.username + ':' + credentials.password).toString('base64');\nvar parsedUrl = url.parse(credentials.restResource);<\/pre><\/div><\/div><\/div><\/div><\/div><div class=\"ibm-footer\"><><\/div><\/div><\/li><li>准备用来缓存一个键/值对的 HTTP <code>POST<\/code> 请求，如清单 2 所示。\n                            \n<h5 id=\"listing2\">清单 2. 准备 <code>POST<\/code>\n                            缓存请求<\/h5><div class=\"codesection\"><pre class=\"displaycode\">var post_options = {\n  hostname: parsedUrl.hostname,\n  path: parsedUrl.pathname + '/'+ credentials.gridName + '/' + encodeURIComponent(key),\n  method: 'POST',\n  headers: {\n    'Content-Type': 'application/json',\n    'Authorization': auth }\n};\n\nvar post_req = http.request(post_options, function(res) {\n  // Handle response callback\n\n  res.setEncoding('utf8');\n\n  var msg = ''; // Store text message sent by the server\n\n  res.on('data', function (chunk) {\n    msg += chunk;\n  });\n\n  res.on('end',function() {\n    if ( res.statusCode != 200 ) {\n      console.log('Error while caching key. Status: %d. Message: %s', res.statusCode, msg);\n      // Add error handling code here\n    } else {\n      // OK, key/value cached!\n    }\n  });\n});<\/pre><\/div><\/li><li>写入值并提交请求：\n                        \n<div class=\"codesection\"><pre class=\"displaycode\">post_req.write(JSON.stringify(<em>value<\/em>));\npost_req.end();<\/pre><\/div><\/li><\/ol><h2 id=\"N102CE\">PaaS 应用程序中的层<\/h2><p>在普通的 Web 应用程序中，您可能会找到一个按层组织的应用程序组件分层结构：<\/p><ul class=\"ibm-bullet-list\"><li><strong>演示组件<\/strong>管理与应用程序用户的交互<\/li><li><strong>流程管理器组件<\/strong>管理实现应用程序用例的活动的工作流<\/li><li><strong>应用程序服务组件<\/strong>处理位于应用程序核心的信息实体和服务<\/li><li><strong>技术组件<\/strong>向上方的各层隐藏底层的技术 <\/li><li><strong>中间件组件<\/strong>位于应用程序外部<\/li><\/ul><p>如图 10 所示，此结构的绝大部分仍然对 PaaS 应用程序有效。PaaS 应用程序的 Presentation Web App\n                将传统演示角色和流程管理器角色压缩到单个组件中，以最大限度改善相关设备和用户交互的用户体验<\/p><h5 id=\"fig10\">图 10. PaaS 应用程序中的各层与传统 Web 应用程序对比<\/h5><img alt=\"PaaS 应用程序中的各层与传统 Web 应用程序对比\" src=\"/sunshine_new/images/68916333/figure10.jpg\" width=\"850\" /><p>我们在 <a href=\"#cloudoe\">Codename:BlueMix 中确定的 CloudOE 应用程序服务和工作应用程序组件：PaaS\n                    CloudOE<\/a> 部分可分类为应用程序服务，工作应用程序专门用作异步服务。要满足云应用程序严格的\n                NFRs，可能有必要识别所有可通过异步交互来解决的用例，使用它们识别工作应用程序组件，保持应用程序裸机的执行路径尽可能短。<\/p><p>CloudOE\n                提供的每个中间件服务包含至少一个技术组件。通常，云应用程序使用非严格的分层，就此而言，演示应用程序和应用程序服务都可使用技术组件。<\/p><h2 id=\"N102FD\">结束语<\/h2><p>在传统上，架构师通过调整系统的基础架构和技术架构，解决了新系统上的 NFRs\n                带来的压力条件。云消除了架构师的指向任务，但需要他们确保云应用程序是云操作环境中的 “良民”。本文介绍的模式利用了 CloudOE 的特性，比如\n                IBM Codename:BlueMix。通过使用模式，可将 PaaS 应用程序设计为云中的可靠的、高度可用的、可扩展的 “良民”。<\/p><h5 id=\"N10303\">致谢<\/h5><p>感谢 Pete Cripps 和 Philippe Spaas 抽时间讨论本文中的概念，感谢 Donald Cronin 和 Michael\n                Behrendt 审阅本文。<\/p><CMA ID: 970966><Site ID: 10><XSLT stylesheet used to transform this file: dw-document-html-7.0.xsl>\r\n\r\n\r\n<\/div>\r\n<\/div>\r\n","createTime":"2014-05-15 00:00:00","deployTime":"2014-05-15 00:00:00","id":0,"intro":"了解架构设计模式，以管理特定于平台即服务 (PaaS) 环境的非功能性需求 (NFRs)。了解 Codename:BlueMix（IBM PaaS 云操作环境）的技术特征，看看 Codename:BlueMix 如何为可靠、高度可用且可扩展的应用程序的设计和创建提供支持。","keyword":"","recommend":false,"source":"http://www.ibm.com/developerworks/cn/cloud/library/cl-bluemix-nfr/index.html","title":"管理云应用程序的非功能性需求","typeId":0,"updateTime":"2014-05-15 00:00:00"}
{"author":"","clickNumber":0,"content":"\r\n<div class=\"ibm-columns\">\r\n<div class=\"ibm-col-1-1\">\r\n\r\n<h2 id=\"Introduction\">简介<\/h2><p>    Amazon Web Services (AWS) 是一个远程计算服务的集合，其中包含 Amazon 云计算平台。这些服务中包含两种这样的服务：<\/p><ul class=\"ibm-bullet-list\"><li> Amazon Simple Storage Service (S3) 是一个在线文件存储 Web 服务，通过 Web 服务接口（REST，SOAP）提供存储。<\/li><li> Amazon Relational Database Service (RDS) 是一个可扩展的分布式关系数据库 Web 服务。借助 Amazon RDS，您可以在云中创建和使用自己的数据库实例，并围绕它们构建自己的应用程序。\n          <\/li><\/ul><p>\n            本文介绍了如何利用 IBM InfoSphere Guardium 平台评估数据库安全性和加固位于 Amazon 云中的数据库。您可以学习以下知识：<\/p><div class=\"dw-sidebar ibm-inset\"><p>了解所有 <a href=\"http://www-01.ibm.com/software/data/guardium/\">InfoSphere Guardium\n                产品<\/a>的实时数据安全性。<\/p><\/div><ul class=\"ibm-bullet-list\"><li> 使用 Guardium 和\n                Amazon RDS 来发现 Amazon 云中的数据库实例。<\/li><li> 使用数据源在 Guardium 中访问这些实例。<\/li><li> 在 Amazon 云中的这些数据库实例上运行漏洞评估。<\/li><\/ul><h2 id=\"N1007D\">云计算<\/h2><p> 云计算就是分布在网络如 Internet 上的计算。云就是分布式计算资源和网络的集合。云计算正在变得越来越流行和常见。正如越来越多的工作流和数据正在转移到云内，InfoSphere Guardium 也是如此。云计算所要求的数据安全与保护程度至少与其他任何计算资源和数据存储相同。但考虑到 Internet 的普遍流行，云内的数据安全与保护甚至更为重要。<\/p><p> 很多厂商都提供用于云计算的平台。Amazon 提供流行的商业性云产品。Amazon 的云产品叫做 <a href=\"http://aws.amazon.com/\">Amazon Web Services<\/a> (AWS)，其中包括大量的计算服务，从数据存储到计算能力、数据库、分析功能、应用部署，再到应用本身。 <\/p><h2 id=\"N1008A\">InfoSphere Guardium<\/h2><p> InfoSphere Guardium 是一种企业级信息数据库审计与保护解决方案，帮助企业保护和审计各种关系与非关系数据源中的信息。 <\/p><p>  Guardium 可以保护和监控各种数据源，包括：<\/p><ul class=\"ibm-bullet-list\"><li>大型数据仓库，比如 Netezza、GreenplumDB 和\n                    Teradata。 <\/li><li>Hadoop 发行版，比如 Big Insights、Cloudera 和 HortonWorks。 <\/li><li>非 SQL 数据库，比如 CouchDB、MongoDB 和 Cassandra。 <\/li><li>DB2、IMS 和 VSAM for IBM System z。 <\/li><li>其他各种类型的数据源与协议，比如 Microsoft Sharepoint、CIFS、HTTP 和 FTP。 <\/li><\/ul><p> 当然，也支持所有传统的和流行的关系数据库服务器 (RDBMS)：<\/p><ul class=\"ibm-bullet-list\"><li>Oracle 公司的 Oracle Database 和 MySQL<\/li><li>Microsoft 公司的 SQL Server<\/li><li>开源的 PostgreSQL<\/li><li>Sybase<\/li><li>IBM 公司的数据库产品 DB2 和 Informix<\/li><\/ul><h2 id=\"N100AB\">InfoSphere Guardium 中的数据源<\/h2><p> 在 Guardium 中，<em>数据源<\/em> 代表任意可能的数据来源、特定的数据库、文件或任意其他数据来源。对于很多 Guardium 应用而言，数据源就是数据库实例。InfoSphere Guardium 支持数据安全保护的生命周期，从发现敏感数据到监控与审计，再到评估安全性和强化数据库。每种类型的数据源都支持 InfoSphere Guardium 的一部分功能。创建数据源时，它首先会与一个 Guardium 应用关联在一起，该应用将说明数据源的用途。<\/p><h3 id=\"N100B5\">数据源详解<\/h3><p> InfoSphere Guardium 中定义了一些使用数据源的应用：审计，安全评估，变更审计，分类，自定义域，数据库分析，值监控，重放等。为 Guardium 定义好数据源后，Guardium 就知道为其定义数据源的特定应用如何访问该数据源。<\/p><p> 可以为数据源访问定义各种参数，包括： <\/p><ul class=\"ibm-bullet-list\"><li>用户名<\/li><li>密码<\/li><li>主机<\/li><li>端口<\/li><li>服务名<\/li><li>数据库名<\/li><li>连接属性<\/li><li>文件系统目录<\/li><li>各种数据库特定的细节 <\/li><\/ul><p> 某些情况下，数据库类型实际上根本不是一个名称。数据库类型可能指明一种协议，比如 HTTP 或 FTP，或者甚至一个文件，Guardium 可以连接到所有这些内容并运行 Guardium 安全应用。不同的 Guardium 应用要求的数据库访问类型也不同。通常要为 Guardium 提供使用数据源的应用所需的最低权限，包括某些 Guardium 应用的登录信息。例如，Guardium 的漏洞评估要求对数据库的高级管理权限，因此您需要提供一个拥有这种访问权限的数据库用户名与密码。 \n            <\/p><h3 id=\"N100D2\">云中的数据源<\/h3><p> 除了位置之外，位于指定企业中和位于云内的数据源之间还存在一点差异。所有指定的 Guardium 安全功能可以在位于 Amazon AWS 中的数据仓库上同等工作（所有其他功能也一样）。而且因为所有人都可以访问和使用云，Guardium 可以为使用 Amazon AWS 上数据仓库的所有客户提供量身定做的软件和服务。<\/p><p> Amazon AWS 提供的 Amazon RDS 允许用户快速而轻松地创建和使用几种不同的数据库实例。目前，受支持的数据库类型包括 Oracle、MySQL、Microsoft SQL Server 和\n                PostgreSQL。Guardium 提供在 Amazon RDS 中发现实例的功能，支持您快速而轻松地为每个被发现的数据源定义数据源。借助 Guardium，您可以快速而轻松地配置 Amazon RDS，让 Guardium 的应用能够访问这些数据源。Guardium 让在这些数据源上运行漏洞评估变得十分简单。Guardium 中的这些功能提高了 Amazon RDS 的安全性，称为 Amazon RDS Discovery。 <\/p><h2 id=\"N100DA\">开始使用 RDS\n                Discovery<\/h2><p>您可以在 Guardium GUI 中访问 RDS Discovery。Guardium GUI 可以在 Internet 浏览器中打开。在浏览器中使用 HTTPS 协议访问 Guardium 系统的主机名或 IP 地址，端口为 8443(https://hostname:8443)。使用 Guardium 访问权限管理器提高的 Guardium 访问证书登录 Guardium GUI。如果使用 admin 用户 id 登录，可以单击 <strong>Tools<\/strong> 选项卡导航到 Amazon RDS Discovery 页面，如图 1 中所示。 <\/p><h5 id=\"fig1\">图 1. Amazon RDS Discovery<\/h5><img alt=\"Guardium Amazon RDS 初始屏幕\" src=\"/sunshine_new/images/负257464383/screen.jpg\" width=\"600\" /><p> 一开始该页面会显示两个文本框，您可以在其中输入 Access\n                Key 和 Secret Access Key，还有一块 Amazon 区域。<\/p><p> Guardium 使用的 Amazon SDK 要求用户提供密钥才能访问 Guardium。要获取密钥，请打开您的 AWS Security\n                Credentials Web 页面（登录到 aws.amazon.com 后，将位于右上方的菜单中）。在 Security Credentials 页面上，可以访问密钥，检索以前创建密钥的密钥 id，或者创建新的密钥。密钥用于让像 Guardium 这样的应用在您需要时访问自己的 Amazon AWS 帐号。<\/p><p> Guardium <em>不会<\/em> 将密钥信息保存在它自己的数据存储中，不会将密钥发送到别处，也不会将密钥用于其他任何目的。为了方便起见，在您的登录期间，密钥将被暂时保存在 Guardium 系统中。如果您离开并返回 RDS Discovery 页面，密钥字段将为您自动填写。然而，当您注销时该信息将被作废。 <\/p><p>\n                从 Guardium 服务器到 Amazon AWS 的所有信息均通过一个加密的 HTTPS 连接传输。<\/p><h2 id=\"N100F9\">Amazon 区域<\/h2><p> Amazon 云计算资源分布在全世界不同区域的数据中心设施中。每个数据中心位置称为一个区域，代表着一个独立的地理区域。每个区域包含多个不同的位置，称为 Availability Zones (AZ)。AWS 用户可以将资源（比如实例和数据）放在多个区域中。资源不会跨区域重复，除非您特地这么做。每个区域都是完全独立的，而且它们提供的服务也会有一定程度的差异，但 Amazon RDS 目前在所有区域中都是可用的。您初始化的所有 Amazon RDS 行为都只能运行在一个区域中。 <\/p><p> \n                表 1 中列出了区域的清单，该清单是由查询 Amazon 动态生成的。例如，如果区域表没有出现，可能表示 Guardium 系统无权访问 Internet。要访问 Amazon AWS，必须提供有权通过 Internet 访问 Amazon 云的工具，否则 Guardium 无法访问您的 RDS 实例。<\/p><h5 id=\"N10108\">表 1. Amazon 区域<\/h5><table border=\"0\" cellpadding=\"0\" cellspacing=\"0\" class=\"ibm-data-table\" summary=\"Amazon Regions\"><thead xmlns:dw=\"http://www.ibm.com/developerWorks/\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"><tr><th scope=\"col\">区域<\/th><th scope=\"col\">名称<\/th><th scope=\"col\">运行日期<\/th><\/tr><\/thead><tbody xmlns:dw=\"http://www.ibm.com/developerWorks/\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"><tr><td>US East (Northern Virginia)<\/td><td>us-east-1<\/td><td>2006<\/td><\/tr><tr><td>US West (Northern California)<\/td><td>us-west-1<\/td><td>2009<\/td><\/tr><tr><td>US West (Oregon)<\/td><td>us-west-2<\/td><td>2011<\/td><\/tr><tr><td>AWS GovCloud (US) <\/td><td>us-gov-west-1<\/td><td>2011<\/td><\/tr><tr><td>EU (Ireland)<\/td><td>eu-west-1<\/td><td>2007<\/td><\/tr><tr><td>South America (Sao Paulo, Brazil)<\/td><td>sa-east-1<\/td><td>2011<\/td><\/tr><tr><td>Asia Pacific (Singapore)<\/td><td>ap-southeast-1<\/td><td>2010<\/td><\/tr><tr><td>Asia Pacific (Tokyo)<\/td><td>ap-northeast-1<\/td><td>2011<\/td><\/tr><tr><td>Asia Pacific (Sydney)<\/td><td>ap-southeast-2<\/td><td>2012<\/td><\/tr><tr><td>China (Beijing)<\/td><td/><td>很快投入运行<\/td><\/tr><\/tbody><\/table><p> Guardium 的 RDS Discovery 支持在任意数量的 Amazon 区域内同时发现 RDS 实例。选择目标区域查询 RDS 实例。 <\/p><h2 id=\"N1015E\">发现结果<\/h2><p>在输入密钥 id 和密钥，而且选择一个或多个要查询的区域后，可以单击 <strong>Discover<\/strong> 来检索这些区域中关于 RDS 数据库实例的信息。 <\/p><p>在区域列表下将出现一个显示已发现实例的窗格，如图 2 所示。 <\/p><h5 id=\"fig2\">图 2. 已发现的实例 <\/h5><img alt=\"发现的实例的网格将会出现在区域网格的下方\" src=\"/sunshine_new/images/负257464383/discovered.jpg\" width=\"600\" /><p>\n                为了生成此窗格，Guardium GUI 服务器需要同时联系您选择要查询实例的所有相关区域，如图 3 中所示。 <\/p><h5 id=\"fig3\">图 3. 联系 AWS 区域<\/h5><img alt=\"接触 AWS 区域\" src=\"/sunshine_new/images/负257464383/cloud.png\" width=\"561\" /><p><a href=\"#fig2\">图 2<\/a> 中标记为 Accessible 的列将显示一个绿色的复选标记或红色的 X，表示 Guardium 是否能够连接到实例。如果 RDS 实例是公共的而且状态为 “available”，就认为它是可访问的。可能的状态值包括：<\/p><ul class=\"ibm-bullet-list\"><li>available<\/li><li>creating<\/li><li>backing-up<\/li><li>deleted<\/li><li>deleting<\/li><li>failed<\/li><li>modifying<\/li><li>rebooting<\/li><li>resetting-master-credentials<\/li><\/ul><p> 每个数据库实例的当前状态和是否属于公共显示在已发现实例的 Details 列中，如图 4 中所示。您无法为不能访问的实例创建 Guardium 安全组或数据源，因为这些选择是禁用的。<\/p><p> 每个实例的其他细节也会显示出来，比如数据库名称、主机与端口、发现它的区域，以及它在 Amazon 中是否有相关的虚拟私有云（VPC）。 <\/p><p> \n                可以使用图 4 中的窗格创建 Amazon 安全组和 Guardium 数据源，并对窗格中选中的 RDS 实例运行漏洞评估。在不离开 RDS Discovery 页面的情况下就可以完成上述所有操作。<\/p><h5 id=\"N1019F\">图 4. Discovery 窗格选择<\/h5><img alt=\"接触 AWS 区域\" src=\"/sunshine_new/images/负257464383/buttons.jpg\" width=\"600\" /><p>\n                如 <a href=\"#fig5\">图 5<\/a> 中所示，最后四列显示了与前面为这些数据库实例创建的 Guardium 安全组与 Guardium\n                数据源相关的详细信息。首次查看窗格中的数据库实例时，Security Group and Datasource 列中将显示红色的 Xs。如果任意实例、安全组或数据源在别处被修改，单击页面右上方的  <strong>Refresh<\/strong>\n                按钮将显示最新的数据。其他用户可以通过别的方式同时修改所有这些项，比如访问 Amazon Web Console，在单独浏览器中使用 Guardium GUI，或者使用 Guardium CLI。<\/p><p> 如果已经调整了浏览器窗口的大小，而且希望重新显示窗格以适应浏览器窗口，也可以使用 Refresh 按钮。<\/p><p><a href=\"#fig1\">图 1<\/a> 中 Instances 上方显示的过滤器框是为了提高易用性。在框中输入文本进行过滤，只显示与过滤器文本相匹配的行。\n            <\/p><h2 id=\"N101B8\">错误<\/h2><p> 执行操作时可能出现错误，无论是发现操作还是在一个或多个数据库实例上进行的操作都是如此。如果出现任何错误，<strong>Errors...<\/strong> 按钮将出现在页面的右下方，如图 5 所示。随着您执行的每项操作，<strong>Errors...<\/strong> 按钮将变为可见或不可见，它只在前面的操作产生错误时显示。<\/p><h5 id=\"fig5\">图 5. Errors 按钮<\/h5><img alt=\"Errors 按钮将会显示在右方网格的下方\" src=\"/sunshine_new/images/负257464383/errors.jpg\" width=\"600\" /><p> \n                有些错误可能源自 Amazon AWS 或者产生自 Amazon 自己的代码。这些错误不会被翻译，将以从 Amazon 接收到的本来面目出现。窗口还将显示产生错误的区域。<\/p><p> 例如，当用户错误输入密钥或密钥 id 时，就会出现一个常见的错误。出现这种情况时，如果 Guardium 服务器联系每个区域，每个区域都会拒绝接受 Guardium 的请求。图 6 显示了证书无效时产生的一条示例错误消息。<\/p><h5 id=\"N101D4\">图 6. Invalid credentials error<\/h5><img alt=\"无效证书错误\" src=\"/sunshine_new/images/负257464383/badkey.jpg\" width=\"600\" /><p>表 2 总结了一些常见的错误，并提供了解决问题的技巧。\n            <\/p><h5 id=\"N101E5\">表 2. 找出和解决常见问题<\/h5><table border=\"0\" cellpadding=\"0\" cellspacing=\"0\" class=\"ibm-data-table\" summary=\"Amazon Regions\"><thead xmlns:dw=\"http://www.ibm.com/developerWorks/\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"><tr><th scope=\"col\">问题<\/th><th scope=\"col\">详细信息<\/th><th scope=\"col\">解决方案<\/th><\/tr><\/thead><tbody xmlns:dw=\"http://www.ibm.com/developerWorks/\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"><tr><td>政府区域不可访问<\/td><td>AWS 政府区域无法访问。大多数客户将不能使用政府区域。只选择您在其中有 RDS 实例的区域。出现的错误信息与输入错误密钥或密钥 id 时的错误信息相同。<\/td><td>不要在区域窗格中选择名为\"us-gov-west-1\" 的区域。<\/td><\/tr><tr><td>无效证书<\/td><td>用户输入的密钥或密钥 id 不正确。<\/td><td>重新输入密钥 id 和密钥，尝试使用浏览器中的复制与粘贴功能或 Control-C 与 Control-V 快捷键来复制和粘贴所选择的文本。 <\/td><\/tr><tr><td>无效的时间或日期，签名不是最新<\/td><td> 如果  连接到 AWS 的 Guardium 系统上的日期或时间的误差超过 15 分钟，AWS 将拒绝访问。（这已经考虑了时区和夏令时的因素。）系统上的本地时间必须正确。<\/td><td><a href=\"http://pic.dhe.ibm.com/infocenter/igsec/v1/index.jsp?topic=%2Fcom.ibm.guardium.using.doc%2Ftopics%2Fhow-to-perform-an-initial-installation-and-configuration.html\">在本地正确地设置时区、日期与时间<\/a><\/td><\/tr><\/tbody><\/table><h2 id=\"N1020B\">Amazon 安全组<\/h2><p><a href=\"http://docs.aws.amazon.com/AmazonRDS/latest/UserGuide/Overview.RDSSecurityGroups.html\">安全组<\/a> 允许通过 Internet 访问 Amazon RDS DB 实例。如图 7 中所示，它们就像是简单的防火墙。访问由一系列没有分类的域间路由（CIDR） IP 地址范围进行授权。和所有其他的 Amazon AWS 服务一样，安全组按照区域进行组织。每个区域内可以存在很多安全组，而每个安全组中又存在很多 CIDR IP 地址范围。 <\/p><h5 id=\"N10216\">图 7. 安全组控制访问<\/h5><img alt=\"Security Groups 控制访问\" src=\"/sunshine_new/images/负257464383/sg.png\" width=\"615\" /><p> \n                每个 CIDR IP 范围都描述了一个地址和掩码：ip1.ip2.ip3.ip4/mask。掩码作用于最左边的二进制位。每个数据库都可以与多个安全组进行关联。如果任意一个安全组中的任意一个 CIDR IP 范围授权访问指定的 IP 地址，从该 IP 地址就可以访问数据库。表 3 显示了示例的 CIDR IP 范围。\n            <\/p><h5 id=\"N10227\">表 3. 示例的 CIDR IP 范围<\/h5><table border=\"0\" cellpadding=\"0\" cellspacing=\"0\" class=\"ibm-data-table\" summary=\"Sample CIDR/IP ranges\"><thead xmlns:dw=\"http://www.ibm.com/developerWorks/\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"><tr><th scope=\"col\">CIDR IP<\/th><th scope=\"col\">匹配<\/th><\/tr><\/thead><tbody xmlns:dw=\"http://www.ibm.com/developerWorks/\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"><tr><td>0.0.0.0/0<\/td><td> 0 掩码匹配地址中的 0 二进制位，因此允许从任何地方进行访问<\/td><\/tr><tr><td>192.168.12.0/23<\/td><td> 23 二进制位掩码是 255.255.254.0，因此这代表范围\n                            192.168.12.0 到 192.168.13.255<\/td><\/tr><tr><td>1.2.3.4/32<\/td><td> 32 二进制位掩码匹配地址中的所有二进制位，因此这个 CIDR IP\n                            只匹配一个地址 1.2.3.4<\/td><\/tr><\/tbody><\/table><p> Amazon 安全组与 Guardium 组或 Guardium 组构建器无关。Amazon 安全组只是一种 Amazon 构件，而 Guardium 不会维护它们的任何记录。Guardium provides 提供简单的功能，可以专门为 Guardium 访问创建安全组，也可以为该安全组添加另外的 CIDR IP 范围。然而，如何配置安全组是由每个用户来决定的。增加 Guardium 功能是为了方便，但并非必需的。<\/p><p> 用户可能有一个已经为他们整个组织创建好的组。又或者，他们可能还没有自己的组，需要创建一个组来支持从 Guardium 系统进行访问。用户可以通过提供的按钮或者访问 Amazon AWS Web Console 为 Guardium 创建组。<\/p><p> 无论如何创建和配置安全组，为了让 Guardium 连接到 RDS 实例，必须给 Guardium 系统授权访问附加给该 RDS 实例的至少一个安全组中列出的至少一个 CIDR IP 范围。\n            <\/p><h3 id=\"N10248\">安全组<\/h3><p> 有两种适用于 RDS 实例的安全组： <a href=\"http://docs.aws.amazon.com/AmazonRDS/latest/UserGuide/USER_VPC.html\">VPC<\/a> 或 RDS。某些区域中的 RDS 帐号创建默认 VPC 中的所有 RDS 实例。<\/p><p> VPC 内部的 RDS DB 实例使用 VPC 安全组。不在 VPC 内部的 RDS DB 实例使用 RDS 安全组。当一个 RDS 实例位于 VPC 内部时，AWS 中有一个位置可以定义和管理 VPC 中所有 AWS 计算资源的网络访问规则，包括 DB 实例。使用 <a href=\"https://console.aws.amazon.com/ec2/v2\">EC2 控制台<\/a> 来管理 VPC 安全组。使用 <a href=\"https://console.aws.amazon.com/rds\">RDS 控制台<\/a> 来管理 RDS 安全组。 <\/p><p>RDS 控制台可以告诉您，<a href=\"http://docs.aws.amazon.com/AmazonRDS/latest/UserGuide/USER_VPC.FindDefaultVPC.html\">如果有一个默认的 VPC<\/a>，这意味着使用的是 VPC 安全组而不是 RDS 安全组。<\/p><p> 如图 8 中所示，选中实例时，Security Group 按钮就会启用。单击此按钮会做三件事情：<\/p><ol><li> 创建一个 Guardium 安全组（如果还不存在）。 <\/li><li> 添加 Guardium 系统的 IP 地址（如果还未添加）。<\/li><li> 将所选的数据库实例添加给组（如果还未关联）。\n                <\/li><\/ol><p>  图 8 显示了一个例子。   <\/p><h5 id=\"N1026E\">图 8. 已创建的安全组<\/h5><img alt=\"已创建的安全组\" src=\"/sunshine_new/images/负257464383/sgcreatedui.jpg\" width=\"600\" /><p> 创建组之后，可以在实例窗格的  Guardium Security Group 列中看到组的名称。同一区域中的实例将共享同一个安全组。CIDR IP 地址列表根据安全组的名称命名。和指定的实例一样，Amazon 创建组也需要一些时间。您可能会看到括号中的状态为\"adding\"，这表示安全组还不能使用。最终状态会变为\"active\"。<\/p><p> 如果 Guardium 安全组尚未创建，或者与实例相关联的 IP 地址不在组中，又或者还没有把组添加给实例的安全组列表，Guardium Security Group 列中就会出现一个红色的 X。这不一定意味着实例是不可访问的。可能存在附加给实例的另一个安全组，授权访问包括 Guardium 系统在内的一个 IP 地址范围。可能有一个授权访问 Guardium 系统 IP 地址的安全组，但该安全组是通过一些其他的手段创建的，而且名称也不同。<\/p><p>\n                每个组织的安全组配置都是独一无二的。有些可能是整个组织使用一个安全组。有些可能需要使用 GUI 创建一个提供访问权限的 Guardium 安全组。完全由客户自行选择如何提供 RDS 实例访问。<\/p><p>\n                正如 Amazon 看到的那样，为实例的安全组添加 Guardium 系统的 IP 地址应该授权访问 RDS 实例。有时候，Guardium 系统的网络配置会出现冲突。如果出现这种情况，用户可以手动添加一个 CIDR IP 地址范围给 Guardium 安全组，只要单击 <strong>Add IP Range<\/strong> 按钮即可。<\/p><p>\n                应该存在连接问题，可以使用 CIDR IP 范围 0.0.0.0/0 测试访问，这将授权访问所有 IP 地址，并允许您确定连接问题是与安全组配置还是其他方面有关。然而，不要将这个 CIDR IP 范围用于保存敏感信息的正在使用的数据库。为了提高安全性，您应该尽量减少经过允许的访问。<\/p><p>如果要从指定的 DB 实例移除 Guardium 安全组，或者想从 Guardium 安全组移除 CIDR IP 范围，需要使用 AWS 控制台。\n            <\/p><h2 id=\"N10286\">创建数据源 <\/h2><p> 为了让 Guardium 能够与 RDS 实例一起工作，必须为它创建一个 RDS 实例。在 RDS Discovery 中，为您希望拥有相关联数据源的每个实例输入一个用户名与密码，用于连接到实例。至于用户，您可以选择首次创建 RDS 实例时创建的 master 用户，也可以选择为该数据库实例创建的任意其他用户。此后就能够创建它们的数据源，只要在窗格中选择这些行然后单击 \n                    <strong>Create/Update Datasources<\/strong> 即可。\n            <\/p><p> 操作完成之后，可以在数据源列中看到数据源的名称。数据源将被保存在 Guardium 的数据存储中，而且当未来发现相同的 RDS 实例时将显示在窗格中。如果希望修改实例的用户名或密码，可以重复上述操作。 <\/p><p> 如果针对数据源进行了专门配置，或者希望测试 Guardium 是否能够成功连接到数据源，您可以选择已经创建数据源的一行，然后单击 <strong>Datasource\n                    Definition...<\/strong>。选定之后，就可以看到标准的数据源定义表单，您可以从 Guardium 的 Datasource\n                Definitions 构建器中访问这个表单。如图 9 中所示，所有的数据源详细信息都将显示出来。<\/p><h5 id=\"N10298\">图 9. Datasource Definition<\/h5><img alt=\"数据源定义\" src=\"/sunshine_new/images/负257464383/ds.jpg\" width=\"550\" /><p> 使用数据源定义表单可以修改数据源，比如任意连接属性或描述。然而，大多数属性是不应该修改的，因为它们与 Amazon 上的设置相匹配。数据源的名称源自于实例主机名称、端口和区域，它们联合起来对于每个 RDS 实例是独一无二的。<\/p><p> \n                此页面上的一个有用功能是 <strong>Test Connection<\/strong> 按钮，使用它可以检查在尝试使用数据源之前是否已经能够成功连接。图 10 显示了一个成功的连接。如果无法连接，可能有多种原因。 <\/p><h5 id=\"N102A9\">图 10. 成功的连接<\/h5><img alt=\"成功连接\" src=\"/sunshine_new/images/负257464383/connected.jpg\" width=\"500\" /><p>\n                如果连接超时，原因可能是没有将安全组配置为允许访问 Guardium 系统的 IP 地址。检查安全组的步骤是：<\/p><ul class=\"ibm-bullet-list\"><li> 使用 AWS 控制台检查所有安全组。 <\/li><li>使用系统管理员身份检查 Guardium 系统 IP 地址。 <\/li><li>尝试使用拥有 CIDR IP 范围 0.0.0.0/0 的安全组连接到一个测试 DB 实例，这个范围表示授权访问所有实例。 <\/li><li>尝试使用其他工具连接到 DB 实例。例如，使用 MySQL\n                    客户端连接 MySQL 数据库，或者使用 SQL*Plus 工具连接 Oracle 数据库。使用通用数据库工具如 Razor SQL 连接任意数量的不同数据库类型。 <\/li><\/ul><p> 如果安全组的配置正确，连接失败就可能存在其他原因，比如：<\/p><ul class=\"ibm-bullet-list\"><li>用户 id 或密码不正确。通常，这会弹出一个相关的错误消息框。 <\/li><li>实例当时不可用。在 Guardium 实例窗格或 AWS 控制台中检查实例的状态。如果实例为 backed-up、deleted、modified、rebooted 状态，如果主证书被修改，或者如果实例由于某些原因失效，它就是不可用的。<\/li><\/ul><p> 如果连接测试通过，这就表明运行漏洞评估时可以成功连接到 RDS 数据库实例。\n            <\/p><h3 id=\"N102C6\">其他数据源视图<\/h3><p> Amazon RDS Discovery 创建的数据源用于安全评估应用。它们可以与其他 Guardium 应用共享，具体操作是导航至 Datasource 构建器，然后选择复选框表示想要共享数据源。<\/p><p> 查看已创建的数据源还可以通过其他的传统途径。可以在数据源构建器的 <strong>Tools<\/strong> 选项卡上查看它们，如图 11 中所示。 <\/p><h5 id=\"N102D2\">图 11. 数据源构建器<\/h5><img alt=\"数据源构建器\" src=\"/sunshine_new/images/负257464383/dsbuilder.jpg\" width=\"600\" /><p>也可以在 Daily\n                Monitor 选项卡中的数据源报告中看到数据源，如图 12 中所示。<\/p><h5 id=\"N102DE\">图 12. 数据源报告<\/h5><img alt=\"Datasources Report\" src=\"/sunshine_new/images/负257464383/dsreport.jpg\" width=\"600\" /><h2 id=\"N102E7\">漏洞评估<\/h2><p>\n                Guardium Vulnerability and Threat Management 解决方案是管理所有数据库环境的安全性与合规性的第一步。测试与过程工作流有助于自动识别和解决数据库漏洞，从而完善配置和加强基础架构。 <\/p><p> 借助 Guardium Vulnerability Assessment 应用，组织可以一致和自动地识别与解决数据库漏洞。Guardium 的评估过程能够评估数据库环境的健康程度并提出改进建议，具体手段包括：<\/p><ul class=\"ibm-bullet-list\"><li>基于最佳实践评估系统配置，找出数据源的漏洞或潜在威胁，包括配置与行为风险。 <\/li><li>找出环境中固有的漏洞。 <\/li><li>基于已发现的领域，针对大多数关键风险与漏洞推荐和指定操作计划。以报告与建议的形式为如何满足合规性变化和提升被评估数据库环境的安全性提供指导原则。 <\/li><\/ul><h3 id=\"N102F7\">RDS 实例的漏洞评估<\/h3><p>\n                为实例指定数据源，并且清楚 Guardium 系统有权访问带有安全组的实例之后，就可以在该实例上运行漏洞评估。图 13 概要描述了这个过程。<\/p><h5 id=\"N102FE\">图 13. RDS 实例的漏洞评估<\/h5><img alt=\"Vulnerability Assessment of RDS Instances\" src=\"/sunshine_new/images/负257464383/va.png\" width=\"547\" /><p> 选择一个或多个具有相关联数据源的可访问实例后，<strong>Launch Vulnerability Assessment<\/strong> 按钮就会启用。评估将在大量数据库实例上运行几次安全测试，并创建一份结果报告。单击 <strong>Launch Vulnerability Assessment<\/strong> 按钮，在所选的数据库实例上运行评估，如图 14 中所示。<\/p><h5 id=\"N10310\">图 14. Vulnerability Assessment 对话框<\/h5><img alt=\"Vulnerability Assessment Dialog\" src=\"/sunshine_new/images/负257464383/vadialog.jpg\" width=\"600\" /><p> 可以输入对现有漏洞评估的描述或新的描述，也可以输入评估报告的接收人。但该对话框中的所有字段都是可选的。单击 <strong>OK<\/strong> 按钮运行评估。如果评估成功运行，就会提示另一个对话框。评估运行在一个<em>审计进程<\/em>中，而该进程则运行在 Guardium 系统的后台。审计进程会连续运行它的相关任务，记录结果，并将结果交付给一个或多个用户。 <\/p><p> 如果所描述的漏洞评估不存在，则会创建一个评估。如果创建新的安全评估，创建时将使用所选的 RDS 实例数据源和与多个数据库类型相关的所有可用测试，包括 Oracle、MySQL、SQL Server 或 PostgreSQL。<\/p><p> 如果安全评估已经存在，将把所选的 RDS 实例数据源添加给该评估（如果尚未添加）。如果现有评估没有任何测试，将会添加与数据库类型相关的所有可用测试。否则，测试将保持不变。<\/p><p>\n                除非已经存在，否则将为漏洞评估创建一个审计过程。它的描述与评估相同，只包含一个任务：安全评估。该过程将被立即提交执行，但完成会需要一定的时间。<\/p><p> 评估完成后，结果将被分发给所有接收人。<\/p><h3 id=\"N10329\">审计过程视图<\/h3><p> 运行审计过程后，您可以在 GUI 的 Guardium Job Queue and the Audit Process Log 选项卡中查看状态。在 GUI 的 Guardium Monitor 选项卡中可以查看这些报告。<\/p><p> 也可以从 Audit Process Builder 手动访问这些结果，如图 15 中所示。<\/p><h5 id=\"N10332\">图 15. Audit Process Builder<\/h5><img alt=\"Audit Process Builder\" src=\"/sunshine_new/images/负257464383/auditbuilder.jpg\" width=\"600\" /><p> 审计过程结果包括在数据库实例上运行的各次测试的结果。一幅表格式的图对评估中执行的所有测试进行了总结，这个范围较大的结果区域提供了如下信息：<\/p><ul class=\"ibm-bullet-list\"><li>对被执行测试的详细描述。<\/li><li>目标 RDS 实例的相关信息。<\/li><li>每次测试的通过与失败状态，严重程度信息，以及出现该状态的原因。<\/li><li>关于测试本身与测试来源相关外部参考的信息。<\/li><\/ul><h3 id=\"N10346\">关于漏洞评估的更多信息<\/h3><p>本文仅包含对于漏洞评估的摘要信息。漏洞评估中还包含大量宝贵的安全信息，但这方面的详细说明已经超出了本文的范畴。 <a href=\"#resources\">参考资料<\/a>中提供了更多关于 InfoSphere Guardium 漏洞评估的信息。<\/p><h2 id=\"N10350\">结束语<\/h2><p>\n                越来越多的组织正在迁移到云中，以降低保存数据和维护它们自身信息技术基础架构的成本。迁移到云将会带来新的数据安全挑战。Guardium 已经能很好地适应私有和混合的云环境。Guardium 轻松发现、评估和加固 Amazon RDS 实例的功能可以帮助您保护公共云中的数据。Guardium 的使命是为安全、数据保护与审计提供一致的企业级解决方案，这完全符合云的优点。 <\/p><p>敬请期待本系列文章的第 2 部分，它将讨论 Guardium 如何使用 Amazon S3 进行备份与恢复操作。<\/p><CMA ID: 971288><Site ID: 10><XSLT stylesheet used to transform this file: dw-document-html-7.0.xsl>\r\n\r\n\r\n<\/div>\r\n<\/div>\r\n","createTime":"2014-05-15 00:00:00","deployTime":"2014-05-15 00:00:00","id":0,"intro":"云上关系数据库数量的不断膨胀使得对数据保护与审计的需求变得日益迫切。IBM InfoSphere? Guardium? 提供了诸多强大的功能，例如实时的数据库安全与监控、详细的数据库审计、自动的合规性报告、数据级的访问控制、数据库漏洞管理以及云自动发现中敏感数据等。 借助 Amazon Relational Database Service (RDS)，您可以在云中创建和使用自己的数据库实例，并围绕它们构建自己的应用程序。这个由两部分组成的文章系列探讨了如何使用 Guardium 保护云中的数据库信息。本文描述了如何使用 Guardium 的发现与漏洞评估功能来保护 Amazon RDS 数据库实例。第 2 部分将讲述 Guardium 如何使用 Amazon S3 进行备份与恢复。","keyword":"","recommend":false,"source":"http://www.ibm.com/developerworks/cn/data/library/techarticle/dm-1402igcloud1/index.html","title":"InfoSphere Guardium 与 Amazon 云，第 1 部分: 探索 Amazon RDS 数据库实例和漏洞","typeId":0,"updateTime":"2014-05-15 00:00:00"}
{"author":"","clickNumber":0,"content":"\r\n<div class=\"ibm-columns\">\r\n<div class=\"ibm-col-1-1\">\r\n\r\n<div class=\"dw-sidebar ibm-inset\"><h2 id=\"N1004F\">关于本系列<\/h2><p>由于多核系统普遍存在，并发性编程的应用无疑比以往任何时候都要广泛。但并发性很难正确实现，用户需要借助工具来为他们提供帮助。很多基于 JVM\n                    的语言都属于这类开发工具，Scala 在此领域尤为活跃。此系列文章将介绍一些针对 Java 和 Scala\n                    语言的较新的并发性编程方法。<\/p><\/div><p>处理器速度数十年来一直持续快速发展，并在世纪交替之际走到了终点。从那时起，处理器制造商更多地是通过增加核心来提高芯片性能，而不再通过增加时钟速率来提高芯片性能。多核系统现在成为了从手机到企业服务器等所有设备的标准，而这种趋势可能继续并有所加速。开发人员越来越需要在他们的应用程序代码中支持多个核心，这样才能满足性能需求。<\/p><p>在本系列文章中，您将了解一些针对 Java 和 Scala 语言的并发编程的新方法，包括 Java 如何将 Scala 和其他基于 JVM\n                的语言中已经探索出来的理念结合在一起。第一期文章将介绍一些背景，通过介绍 Java 7 和 Scala 的一些最新技术，帮助了解 JVM\n                上的并发编程的全景。您将了解如何使用 Java <code>ExecutorService<\/code> 和\n                <code>ForkJoinPool<\/code> 类来简化并发编程。还将了解一些将并发编程选项扩展到纯 Java 中的已有功能之外的基本\n                Scala 特性。在此过程中，您会看到不同的方法对并发编程性能有何影响。后续几期文章将会介绍 Java 8\n                中的并发性改进和一些扩展，包括用于执行可扩展的 Java 和 Scala 编程的 <a href=\"http://akka.io/\">Akka<\/a> 工具包。 <\/p><h2 id=\"N10062\">Java 并发性支持<\/h2><p>在 Java 平台诞生之初，并发性支持就是它的一个特性，线程和同步的实现为它提供了超越其他竞争语言的优势。Scala 基于 Java 并在 JVM\n                上运行，能够直接访问所有 Java 运行时（包括所有并发性支持）。所以在分析 Scala 特性之前，我首先会快速回顾一下 Java\n                语言已经提供的功能。<\/p><h4 id=\"N10069\">Java 线程基础<\/h4><p>在 Java 编程过程中创建和使用线程非常容易。它们由 <code>java.lang.Thread<\/code> 类表示，线程要执行的代码为\n                <code>java.lang.Runnable<\/code>\n                实例的形式。如果需要的话，可以在应用程序中创建大量线程，您甚至可以创建数千个线程。在有多个核心时，JVM\n                使用它们来并发执行多个线程；超出核心数量的线程会共享这些核心。<\/p><div class=\"dw-sidebar ibm-inset\"><h2 id=\"N10077\">Java 5：并发性的转折点<\/h2><p>Java 从一开始就包含对线程和同步的支持。但在线程间共享数据的最初规范不够完善，这带来了 Java 5 的 Java 语言更新中的重大变化\n                    (JSR-133)。Java Language Specification for Java 5 更正并规范化了\n                    <code>synchronized<\/code> 和 <code>volatile<\/code>\n                    操作。该规范还规定不变的对象如何使用多线程。（基本上讲，只要在执行构造函数时不允许引用\n                    “转义”，不变的对象始终是线程安全的。）以前，线程间的交互通常需要使用阻塞的 <code>synchronized<\/code>\n                    操作。这些更改支持使用 <code>volatile<\/code> 在线程间执行非阻塞协调。因此，在 Java 5\n                    中添加了新的并发集合类来支持非阻塞操作 &#8212; 这与早期仅支持阻塞的线程安全方法相比是一项重大改进。<\/p><\/div><p>线程操作的协调难以让人理解。只要从程序的角度让所有内容保持一致，Java 编译器和 JVM\n                就不会对您代码中的操作重新排序，这使得问题变得更加复杂。例如：如果两个相加操作使用了不同的变量，编译器或 JVM\n                可以安装与指定的顺序相反的顺序执行这些操作，只要程序不在两个操作都完成之前使用两个变量的总数。这种重新排序操作的灵活性有助于提高 Java\n                性能，但一致性只被允许应用在单个线程中。硬件也有可能带来线程问题。现代系统使用了多种缓存内存级别，一般来讲，不是系统中的所有核心都能同样看到这些缓存。当某个核心修改内存中的一个值时，其他核心可能不会立即看到此更改。<\/p><p>由于这些问题，在一个线程使用另一个线程修改的数据时，您必须显式地控制线程交互方式。Java\n                使用了特殊的操作来提供这种控制，在不同线程看到的数据视图中建立顺序。基本操作是，线程使用 <code>synchronized<\/code>\n                    关键字来访问一个对象。当某个线程在一个对象上保持同步时，该线程将会获得此对象所独有的一个锁的独占访问。如果另一个线程已持有该锁，等待获取该锁的线程必须等待，或者被<em>阻塞<\/em>，直到该锁被释放。当该线程在一个\n                <code>synchronized<\/code> 代码块内恢复执行时，Java 会保证该线程可以 “看到了”\n                以前持有同一个锁的其他线程写入的所有数据，但只是这些线程通过离开自己的 <code>synchronized<\/code>\n                锁来释放该锁之前写入的数据。这种保证既适用于编译器或 JVM 所执行的操作的重新排序，也适用于硬件内存缓存。一个\n                <code>synchronized<\/code> 块的内部是您代码中的一个稳定性孤岛，其中的线程可依次安全地执行、交互和共享信息。<\/p><p>在变量上对 <code>volatile<\/code>\n                关键字的使用，为线程间的安全交互提供了一种稍微较弱的形式。<code>synchronized<\/code>\n                关键字可确保在您获取该锁时可以看到其他线程的存储，而且在您之后，获取该锁的其他线程也会看到您的存储。<code>volatile<\/code>\n                关键字将这一保证分解为两个不同的部分。如果一个线程向 <code>volatile<\/code>\n                变量写入数据，那么首先将会擦除它在这之前写入的数据。如果某个线程读取该变量，那么该线程不仅会看到写入该变量的值，还会看到写入的线程所写入的其他所有值。所以读取一个\n                <code>volatile<\/code> 变量会提供与<em>输入<\/em> 一个 <code>synchronized<\/code>\n                块相同的内存保证，而且写入一个 <code>volatile<\/code> 变量会提供与<em>离开<\/em> 一个\n                <code>synchronized<\/code> 块相同的内存保证。但二者之间有很大的差别：<code>volatile<\/code>\n                变量的读取或写入绝不会受阻塞。<\/p><h4 id=\"N100C0\">抽象 Java 并发性<\/h4><p>同步很有用，而且许多多线程应用程序都是在 Java 中仅使用基本的 <code>synchronized<\/code>\n                    块开发出来的。但协调线程可能很麻烦，尤其是在处理许多线程和许多块的时候。确保线程仅在安全的方式下交互<em>并<\/em>\n                避免潜在的死锁（两个或更多线程等待对方释放锁之后才能继续执行），这很困难。支持并发性而不直接处理线程和锁的抽象，这为开发人员提供了处理常见用例的更好方法。<\/p><p><code>java.util.concurrent<\/code>\n                分层结构包含一些集合变形，它们支持并发访问、针对原子操作的包装器类，以及同步原语。这些类中的许多都是为支持非阻塞访问而设计的，这避免了死锁的问题，而且实现了更高效的线程。这些类使得定义和控制线程之间的交互变得更容易，但他们仍然面临着基本线程模型的一些复杂性。<\/p><p><code>java.util.concurrent<\/code>\n                包中的一对抽象，支持采用一种更加分离的方法来处理并发性：<code>Future&lt;T&gt;<\/code>\n                接口、<code>Executor<\/code> 和 <code>ExecutorService<\/code> 接口。这些相关的接口进而成为了对\n                Java 并发性支持的许多 Scala 和 Akka 扩展的基础，所以更详细地了解这些接口和它们的实现是值得的。<\/p><p><code>Future&lt;T&gt;<\/code> 是一个 <code>T<\/code> 类型的值的持有者，但奇怪的是该值一般在创建\n                <code>Future<\/code> 之后才能使用。正确执行一个同步操作后，才会获得该值。收到 <code>Future<\/code>\n                的线程可调用方法来：<\/p><ul class=\"ibm-bullet-list\"><li>查看该值是否可用<\/li><li>等待该值变为可用<\/li><li>在该值可用时获取它<\/li><li>如果不再需要该值，则取消该操作<\/li><\/ul><p><code>Future<\/code> 的具体实现结构支持处理异步操作的不同方式。<\/p><p><code>Executor<\/code> 是一种围绕某个执行任务的东西的抽象。这个 “东西”\n                最终将是一个线程，但该接口隐藏了该线程处理执行的细节。<code>Executor<\/code>\n                本身的适用性有限，<code>ExecutorService<\/code> 子接口提供了管理终止的扩展方法，并为任务的结果生成了\n                <code>Future<\/code>。<code>Executor<\/code> 的所有标准实现还会实现\n                <code>ExecutorService<\/code>，所以实际上，您可以忽略根接口。<\/p><p>线程是相对重量级的资源，而且与分配并丢弃它们相比，重用它们更有意义。<code>ExecutorService<\/code>\n                简化了线程间的工作共享，还支持自动重用线程，实现了更轻松的编程和更高的性能。<code>ExecutorService<\/code> 的\n                <code>ThreadPoolExecutor<\/code> 实现管理着一个执行任务的线程池。<\/p><h4 id=\"N10116\">应用 Java 并发性<\/h4><p>并发性的实际应用常常涉及到需要与您的主要处理逻辑独立的外部交互的任务（与用户、存储或其他系统的交互）。这类应用很难浓缩为一个简单的示例，所以在演示并发性的时候，人们通常会使用简单的计算密集型任务，比如数学计算或排序。我将使用一个类似的示例。<\/p><p>任务是找到离一个未知的输入最近的已知单词，其中的<em>最近<\/em> 是按照<em>Levenshtein 距离<\/em>\n                来定义的：将输入转换为已知的单词所需的最少的字符增加、删除或更改次数。我使用的代码基于 Wikipedia 上的 <a href=\"http://en.wikipedia.org/wiki/Levenshtein_distance\">Levenshtein\n                    距离<\/a> 文章中的一个示例，该示例计算了每个已知单词的 Levenshtein\n                距离，并返回最佳匹配值（或者如果多个已知的单词拥有相同的距离，那么返回结果是不确定的）。<\/p><p>清单 1 给出了计算 Levenshtein 距离的 Java 代码。该计算生成一个矩阵，将行和列与两个对比的文本的大小进行匹配，在每个维度上加\n                1。为了提高效率，此实现使用了一对大小与目标文本相同的数组来表示矩阵的连续行，将这些数组包装在每个循环中，因为我只需要上一行的值就可以计算下一行。<\/p><h5 id=\"listing1\">清单 1. Java 中的 Levenshtein\n                距离计算<\/h5><div class=\"codesection\"><pre class=\"displaycode\">/**\n * Calculate edit distance from targetText to known word.\n *\n * @param word known word\n * @param v0 int array of length targetText.length() + 1\n * @param v1 int array of length targetText.length() + 1\n * @return distance\n */\nprivate int editDistance(String word, int[] v0, int[] v1) {\n    \n    // initialize v0 (prior row of distances) as edit distance for empty 'word'\n    for (int i = 0; i &lt; v0.length; i++) {\n        v0[i] = i;\n    }\n    \n    // calculate updated v0 (current row distances) from the previous row v0\n    for (int i = 0; i &lt; word.length(); i++) {\n        \n        // first element of v1 = delete (i+1) chars from target to match empty 'word'\n        v1[0] = i + 1;\n        \n        // use formula to fill in the rest of the row\n        for (int j = 0; j &lt; targetText.length(); j++) {\n            int cost = (word.charAt(i) == targetText.charAt(j)) ? 0 : 1;\n            v1[j + 1] = minimum(v1[j] + 1, v0[j + 1] + 1, v0[j] + cost);\n        }\n        \n        // swap v1 (current row) and v0 (previous row) for next iteration\n        int[] hold = v0;\n        v0 = v1;\n        v1 = hold;\n    }\n    \n    // return final value representing best edit distance\n    return v0[targetText.length()];\n}<\/pre><\/div><p>如果有大量已知词汇要与未知的输入进行比较，而且您在一个多核系统上运行，那么您可以使用并发性来加速处理：将已知单词的集合分解为多个块，将每个块作为一个独立任务来处理。通过更改每个块中的单词数量，您可以轻松地更改任务分解的粒度，从而了解它们对总体性能的影响。清单\n                2 给出了分块计算的 Java 代码，摘自 <a href=\"https://github.com/dsosnoski/concur1\">示例代码<\/a> 中的 <code>ThreadPoolDistance<\/code> 类。清单 2 使用一个标准的\n                <code>ExecutorService<\/code>，将线程数量设置为可用的处理器数量。<\/p><h5 id=\"listing2\">清单 2. 在 Java\n                中通过多个线程来执行分块的距离计算<\/h5><div class=\"codesection\"><pre class=\"displaycode\">private final ExecutorService threadPool;\nprivate final String[] knownWords;\nprivate final int blockSize;\n\npublic ThreadPoolDistance(String[] words, int block) {\n    threadPool = Executors.newFixedThreadPool(Runtime.getRuntime().availableProcessors());\n    knownWords = words;\n    blockSize = block;\n}\n\npublic DistancePair bestMatch(String target) {\n    \n    // build a list of tasks for matching to ranges of known words\n    List&lt;DistanceTask&gt; tasks = new ArrayList&lt;DistanceTask&gt;();\n\n    int size = 0;\n    for (int base = 0; base &lt; knownWords.length; base += size) {\n        size = Math.min(blockSize, knownWords.length - base);\n        tasks.add(new DistanceTask(target, base, size));\n    }\n    DistancePair best;\n    try {\n        \n        // pass the list of tasks to the executor, getting back list of futures\n        List&lt;Future&lt;DistancePair&gt;&gt; results = threadPool.invokeAll(tasks);\n        \n        // find the best result, waiting for each future to complete\n        best = DistancePair.WORST_CASE;\n        for (Future&lt;DistancePair&gt; future: results) {\n            DistancePair result = future.get();\n            best = DistancePair.best(best, result);\n        }\n        \n    } catch (InterruptedException e) {\n        throw new RuntimeException(e);\n    } catch (ExecutionException e) {\n        throw new RuntimeException(e);\n    }\n    return best;\n}\n\n/**\n * Shortest distance task implementation using Callable.\n */\npublic class DistanceTask implements Callable&lt;DistancePair&gt;\n{\n    private final String targetText;\n    private final int startOffset;\n    private final int compareCount;\n    \n    public DistanceTask(String target, int offset, int count) {\n        targetText = target;\n        startOffset = offset;\n        compareCount = count;\n    }\n    \n    private int editDistance(String word, int[] v0, int[] v1) {\n        ...\n    }\n\n    /* (non-Javadoc)\n     * @see java.util.concurrent.Callable#call()\n     */\n    @Override\n    public DistancePair call() throws Exception {\n        \n        // directly compare distances for comparison words in range\n        int[] v0 = new int[targetText.length() + 1];\n        int[] v1 = new int[targetText.length() + 1];\n        int bestIndex = -1;\n        int bestDistance = Integer.MAX_VALUE;\n        boolean single = false;\n        for (int i = 0; i &lt; compareCount; i++) {\n            int distance = editDistance(knownWords[i + startOffset], v0, v1);\n            if (bestDistance &gt; distance) {\n                bestDistance = distance;\n                bestIndex = i + startOffset;\n                single = true;\n            } else if (bestDistance == distance) {\n                single = false;\n            }\n        }\n        return single ? new DistancePair(bestDistance, knownWords[bestIndex]) :\n            \tnew DistancePair(bestDistance);\n    }\n}<\/pre><\/div><p>清单 2 中的 <code>bestMatch()<\/code> 方法构造一个 <code>DistanceTask<\/code>\n                距离列表，然后将该列表传递给 <code>ExecutorService<\/code>。这种对\n                <code>ExecutorService<\/code> 的调用形式将会接受一个\n                <code>Collection&lt;? extends Callable&lt;T&gt;&gt;<\/code>\n                类型的参数，该参数表示要执行的任务。该调用返回一个 <code>Future&lt;T&gt;<\/code>\n                列表，用它来表示执行的结果。<code>ExecutorService<\/code> 使用在每个任务上调用 <code>call()<\/code>\n                方法所返回的值，异步填写这些结果。在本例中，<code>T<\/code> 类型为 <code>DistancePair<\/code>&#8212;\n                一个表示距离和匹配的单词的简单的值对象，或者在没有找到惟一匹配值时近表示距离。<\/p><p><code>bestMatch()<\/code> 方法中执行的原始线程依次等待每个 <code>Future<\/code>\n                完成，累积最佳的结果并在完成时返回它。通过多个线程来处理 <code>DistanceTask<\/code>\n                的执行，原始线程只需等待一小部分结果。剩余结果可与原始线程等待的结果并发地完成。<\/p><h4 id=\"N1016E\">并发性性能<\/h4><p>要充分利用系统上可用的处理器数量，必须为 <code>ExecutorService<\/code>\n                配置至少与处理器一样多的线程。您还必须将至少与处理器一样多的任务传递给 <code>ExecutorService<\/code>\n                来执行。实际上，您或许希望拥有比处理器多得多的任务，以实现最佳的性能。这样，处理器就会繁忙地处理一个接一个的任务，近在最后才空闲下来。但是因为涉及到开销（在创建任务和\n                future 的过程中，在任务之间切换线程的过程中，以及最终返回任务的结果时），您必须保持任务足够大，以便开销是按比例减小的。<\/p><p>图 1 展示了我在使用 Oracle 的 Java 7 for 64-bit Linux&#174; 的四核 AMD\n                系统上运行测试代码时测量的不同任务数量的性能。每个输入单词依次与 12,564\n                个已知单词相比较，每个任务在一定范围的已知单词中找到最佳的匹配值。全部 933 个拼写错误的输入单词会重复运行，每轮运行之间会暂停片刻供 JVM\n                处理，该图中使用了 10 轮运行后的最佳时间。从图 1 中可以看出，每秒的输入单词性能在合理的块大小范围内（基本来讲，从 256 到大于\n                1,024）看起来是合理的，只有在任务变得非常小或非常大时，性能才会极速下降。对于块大小\n                16,384，最后的值近创建了一个任务，所以显示了单线程性能。<\/p><h5 id=\"fig1\">图 1. <code>ThreadPoolDistance<\/code>\n                    性能<\/h5><img alt=\"该图显示了不同块大小下的 ThreadPoolDistance 性能\" src=\"/sunshine_new/images/1428413519/perform1.jpg\" width=\"496\" /><h4 id=\"N1018B\">Fork-Join<\/h4><p>Java 7 引入了 <code>ExecutorService<\/code> 的另一种实现：<code>ForkJoinPool<\/code>\n                类。<code>ForkJoinPool<\/code> 是为高效处理可反复分解为子任务的任务而设计的，它使用\n                <code>RecursiveAction<\/code> 类（在任务未生成结果时）或\n                <code>RecursiveTask&lt;T&gt;<\/code> 类（在任务具有一个 <code>T<\/code>\n                类型的结果时）来处理任务。<code>RecursiveTask&lt;T&gt;<\/code> 提供了一种合并子任务结果的便捷方式，如清单 3\n                所示。<\/p><h5 id=\"listing3\">清单 3. <code>RecursiveTask&lt;DistancePair&gt;<\/code>\n                示例<\/h5><div class=\"codesection\"><pre class=\"displaycode\">private ForkJoinPool threadPool = new ForkJoinPool();\n\nprivate final String[] knownWords;\n\nprivate final int blockSize;\n\npublic ForkJoinDistance(String[] words, int block) {\n    knownWords = words;\n    blockSize = block;\n}\n\npublic DistancePair bestMatch(String target) {\n    return threadPool.invoke(new DistanceTask(target, 0, knownWords.length, knownWords));\n}\n\n/**\n * Shortest distance task implementation using RecursiveTask.\n */\npublic class DistanceTask extends RecursiveTask&lt;DistancePair&gt;\n{\n    private final String compareText;\n    private final int startOffset;\n    private final int compareCount;\n    private final String[] matchWords;\n    \n    public DistanceTask(String from, int offset, int count, String[] words) {\n        compareText = from;\n        startOffset = offset;\n        compareCount = count;\n        matchWords = words;\n    }\n    \n    private int editDistance(int index, int[] v0, int[] v1) {\n        ...\n    }\n    \n    /* (non-Javadoc)\n     * @see java.util.concurrent.RecursiveTask#compute()\n     */\n    @Override\n    protected DistancePair compute() {\n        if (compareCount &gt; blockSize) {\n            \n            // split range in half and find best result from bests in each half of range\n            int half = compareCount / 2;\n            DistanceTask t1 = new DistanceTask(compareText, startOffset, half, matchWords);\n            t1.fork();\n            DistanceTask t2 = new DistanceTask(compareText, startOffset + half,\n                compareCount - half, matchWords);\n            DistancePair p2 = t2.compute();\n            return DistancePair.best(p2, t1.join());\n        }\n        \n        // directly compare distances for comparison words in range\n        int[] v0 = new int[compareText.length() + 1];\n        int[] v1 = new int[compareText.length() + 1];\n        int bestIndex = -1;\n        int bestDistance = Integer.MAX_VALUE;\n        boolean single = false;\n        for (int i = 0; i &lt; compareCount; i++) {\n            int distance = editDistance(i + startOffset, v0, v1);\n            if (bestDistance &gt; distance) {\n                bestDistance = distance;\n                bestIndex = i + startOffset;\n                single = true;\n            } else if (bestDistance == distance) {\n                single = false;\n            }\n        }\n        return single ? new DistancePair(bestDistance, knownWords[bestIndex]) :\n            new DistancePair(bestDistance);\n    }\n}<\/pre><\/div><p>图 2 显示了清单 3 中的 <code>ForkJoin<\/code> 代码与 <a href=\"#listing2\">清单 2<\/a> 中的\n                <code>ThreadPool<\/code> 代码的性能对比。<code>ForkJoin<\/code>\n                代码在所有块大小中稳定得多，仅在您只有单个块（意味着执行是单线程的）时性能会显著下降。标准的 <code>ThreadPool<\/code>\n                代码仅在块大小为 256 和 1,024 时会表现出更好的性能。<\/p><h5 id=\"fig2\">图 2. <code>ThreadPoolDistance<\/code> 与\n                    <code>ForkJoinDistance<\/code> 的性能对比<\/h5><img alt=\"该图对比了 ThreadPoolDistance 和 ForkJoinDistance 在不同块大小下的性能\" src=\"/sunshine_new/images/1428413519/perform2.jpg\" width=\"486\" /><p>这些结果表明，如果可调节应用程序中的任务大小来实现最佳的性能，那么使用标准 <code>ThreadPool<\/code> 比\n                <code>ForkJoin<\/code> 更好。但请注意，<code>ThreadPool<\/code> 的 “最佳性能点”\n                取决于具体任务、可用处理器数量以及您系统的其他因素。一般而言，<code>ForkJoin<\/code>\n                以最小的调优需求带来了优秀的性能，所以最好尽可能地使用它。<\/p><h2 id=\"N101DE\">Scala 并发性基础<\/h2><p>Scala 通过许多方式扩展了 Java\n                编程语言和运行时，其中包括添加更多、更轻松的处理并发性的方式。对于初学者而言，<code>Future&lt;T&gt;<\/code> 的\n                Scala 版本比 Java 版本灵活得多。您可以直接从代码块中创建 future，可向 future 附加回调来处理这些 future\n                的完成。清单 4 显示了 Scala future 的一些使用示例。该代码首先定义了 <code>futureInt()<\/code>\n                方法，以便按需提供 <code>Future&lt;Int&gt;<\/code>，然后通过三种不同的方式来使用 future。<\/p><h5 id=\"listing4\">清单 4. Scala <code>Future&lt;T&gt;<\/code>\n                    示例代码<\/h5><div class=\"codesection\"><pre class=\"displaycode\">import ExecutionContext.Implicits.global\n\nval lastInteger = new AtomicInteger\ndef futureInt() = future {\n  Thread sleep 2000\n  lastInteger incrementAndGet\n}\n\n// use callbacks for completion of futures\nval a1 = futureInt\nval a2 = futureInt\na1.onSuccess {\n    case i1 =&gt; {\n      a2.onSuccess {\n        case i2 =&gt; println(\"Sum of values is \" + (i1 + i2))\n      }\n    }\n}\nThread sleep 3000\n\n// use for construct to extract values when futures complete\nval b1 = futureInt\nval b2 = futureInt\nfor (i1 &lt;- b1; i2 &lt;- b2) yield println(\"Sum of values is \" + (i1 + i2))\nThread sleep 3000\n\n// wait directly for completion of futures\nval c1 = futureInt\nval c2 = futureInt\nprintln(\"Sum of values is \" + (Await.result(c1, Duration.Inf) +\n  Await.result(c2, Duration.Inf)))<\/pre><\/div><p>清单 4 中的第一个示例将回调闭包附加到一对 future 上，以便在两个 future\n                都完成时，将两个结果值的和打印到控制台上。回调是按照创建它们的顺序直接嵌套在 future\n                上，但是，即使更改顺序，它们也同样有效。如果在您附加回调时 future 已完成，该回调仍会运行，但无法保证它会立即运行。原始执行线程会在\n                <code>Thread sleep 3000<\/code> 行上暂停，以便在进入下一个示例之前完成 future。<\/p><p>第二个示例演示了使用 Scala <em><code>for<\/code> comprehension<\/em> 从 future\n                中异步提取值，然后直接在表达式中使用它们。<code>for<\/code> comprehension 是一种 Scala\n                结构，可用于简洁地表达复杂的操作组合（<code>map<\/code>、<code>filter<\/code>、<code>flatMap<\/code>\n                和 <code>foreach<\/code>）。它一般与各种形式的集合结合使用，但 Scala future\n                实现了相同的单值方法来访问集合值。所以可以使用 future\n                作为一种特殊的集合，一种包含最多一个值（可能甚至在未来某个时刻之前之后才包含该值）的集合。在这种情况下，<code>for<\/code>\n                语句要求获取 future\n                的结果，并在表达式中使用这些结果值。在幕后，这种技术会生成与第一个示例完全相同的代码，但以线性代码的形式编写它会得到更容易理解的更简单的表达式。和第一个示例一样，原始执行线程会暂停，以便在进入下一个示例之前完成\n                future。<\/p><p>第三个示例使用阻塞等待来获取 future 的结果。这与 Java future 的工作原理相同，但在 Scala 中，一个获取最大等待时间参数的特殊\n                <code>Await.result()<\/code> 方法调用会让阻塞等待变得更为明显。<\/p><p><a href=\"#listing4\">清单 4<\/a> 中的代码没有显式地将 future 传递给\n                <code>ExecutorService<\/code> 或等效的对象，所以如果没有使用过 Scala，那么您可能想知道 future\n                内部的代码是如何执行的。答案取决于 <a href=\"#listing4\">清单 4<\/a>\n                中最上面一行：<code>import\nExecutionContext.Implicits.global<\/code>。Scala API\n                常常为代码块中频繁重用的参数使用 <code>implicit<\/code> 值。<code>future { }<\/code> 结构要求\n                <code>ExecutionContext<\/code> 以隐式参数的形式提供。这个 <code>ExecutionContext<\/code>\n                是 Java <code>ExecutorService<\/code> 的一个 Scala\n                包装器，以相同方式用于使用一个或多个托管线程来执行任务。<\/p><p>除了 future 的这些基本操作之外，Scala\n                还提供了一种方式将任何集合转换为使用并行编程的集合。将集合转换为并行格式后，您在集合上执行的任何标准的 Scala 集合操作（比如\n                <code>map<\/code>、<code>filter<\/code> 或\n                <code>fold<\/code>）都会自动地尽可能并行完成。（本文稍后会在 <a href=\"#listing7\">清单 7<\/a>\n                中提供一个相关示例，该示例使用 Scala 查找一个单词的最佳匹配值。）<\/p><h4 id=\"N10247\">错误处理<\/h4><p>Java 和 Scala 中的 future 都必须解决错误处理的问题。在 Java 中，截至 Java 7，future 可抛出一个\n                <code>ExecutionException<\/code> 作为返回结果的替代方案。应用程序可针对具体的失败类型而定义自己的\n                <code>ExecutionException<\/code> 子类，或者可连锁异常来传递详细信息，但这限制了灵活性。<\/p><p>Scala future 提供了更灵活的错误处理。您可以通过两种方式完成 Scala\n                future：成功时提供一个结果值（假设要求一个结果值），或者在失败时提供一个关联的\n                <code>Throwable<\/code>。您也可以采用多种方式处理 future 的完成。在 <a href=\"#listing4\">清单\n                    4<\/a> 中，<code>onSuccess<\/code> 方法用于附加回调来处理 future 的成功完成。您还可以使用\n                <code>onComplete<\/code> 来处理任何形式的完成（它将结果或 throwable 包装在一个 <code>Try<\/code>\n                中来适应两种情况），或者使用 <code>onFailure<\/code> 来专门处理错误结果。Scala future\n                的这种灵活性扩展到了您可以使用 future 执行的所有操作，所以您可以将错误处理直接集成到代码中。<\/p><p>这个 Scala <code>Future&lt;T&gt;<\/code> 还有一个紧密相关的\n                <code>Promise&lt;T&gt;<\/code> 类。future 是一个结果的持有者，该结果在某个时刻可能可用（或不可用\n                &#8212; 无法内在地确保一个 future 将完成）。future 完成后，结果是固定的，不会发生改变。promise\n                是这个相同契约的另一端：结果的一个一次性、可分配的持有者，具有结果值或 throwable 的形式。可从 promise 获取 future，在\n                promise 上设置了结果后，就可以在该 future 上设置此结果。<\/p><h4 id=\"N10273\">应用 Scala 并发性<\/h4><p>现在您已熟悉一些基本的 Scala 并发性概念，是时候来了解一下解决 Levenshtein 距离问题的代码了。清单 5 显示了\n                Levenshtein 距离计算的一个比较符合语言习惯的 Scala 实现，该代码基本上与 <a href=\"#listing1\">清单 1<\/a>\n                中的 Java 代码类似，但采用了函数风格。<\/p><h5 id=\"listing5\">清单 5. Scala 中的 Levenshtein\n                距离计算<\/h5><div class=\"codesection\"><pre class=\"displaycode\">val limit = targetText.length\n/** Calculate edit distance from targetText to known word.\n  *\n  * @param word known word\n  * @param v0 int array of length targetText.length + 1\n  * @param v1 int array of length targetText.length + 1\n  * @return distance\n  */\ndef editDistance(word: String, v0: Array[Int], v1: Array[Int]) = {\n\n  val length = word.length\n\n  @tailrec\n  def distanceByRow(rnum: Int, r0: Array[Int], r1: Array[Int]): Int = {\n    if (rnum &gt;= length) r0(limit)\n    else {\n\n      // first element of r1 = delete (i+1) chars from target to match empty 'word'\n      r1(0) = rnum + 1\n\n      // use formula to fill in the rest of the row\n      for (j &lt;- 0 until limit) {\n        val cost = if (word(rnum) == targetText(j)) 0 else 1\n        r1(j + 1) = min(r1(j) + 1, r0(j + 1) + 1, r0(j) + cost);\n      }\n\n      // recurse with arrays swapped for next row\n      distanceByRow(rnum + 1, r1, r0)\n    }\n  }\n\n  // initialize v0 (prior row of distances) as edit distance for empty 'word'\n  for (i &lt;- 0 to limit) v0(i) = i\n\n  // recursively process rows matching characters in word being compared to find best\n  distanceByRow(0, v0, v1)\n}<\/pre><\/div><p><a href=\"#listing5\">清单 5<\/a> 中的代码对每个行值计算使用了尾部递归\n                <code>distanceByRow()<\/code>\n                方法。此方法首先检查计算了多少行，如果该数字与检查的单词中的字符数匹配，则返回结果距离。否则会计算新的行值，然后递归地调用自身来计算下一行（将两个行数组包装在该进程中，以便正确地传递新的最新的行值）。Scala\n                将尾部递归方法转换为与 Java <code>while<\/code> 循环等效的代码，所以保留了与 Java 代码的相似性。<\/p><p>但是，此代码与 Java 代码之间有一个重大区别。<a href=\"#listing5\">清单 5<\/a> 中的 <code>for<\/code>\n                comprehension 使用了闭包。闭包并不总是得到了当前 JVM 的高效处理（参阅 <a href=\"http://www.scalablescala.com/roller/scala/entry/why_is_using_for_foreach\">Why is using for/foreach on a Range\n                    slow?<\/a>，了解有关的详细信息），所以它们在该计算的最里层循环上增加了大量开销。如上所述，<a href=\"#listing5\">清单 5<\/a> 中的代码的运行速度没有 Java 版本那么快。清单 6 重写了代码，将 <code>for<\/code>\n                comprehension 替换为添加的尾部递归方法。这个版本要详细得多，但执行效率与 Java 版本相当。<\/p><h5 id=\"listing6\">清单 6. 为提升性能而重新构造的计算代码<\/h5><div class=\"codesection\"><pre class=\"displaycode\">val limit = targetText.length\n\n/** Calculate edit distance from targetText to known word.\n  *\n  * @param word known word\n  * @param v0 int array of length targetText.length + 1\n  * @param v1 int array of length targetText.length + 1\n  * @return distance\n  */\ndef editDistance(word: String, v0: Array[Int], v1: Array[Int]) = {\n\n  val length = word.length\n  \n  @tailrec\n  def distanceByRow(row: Int, r0: Array[Int], r1: Array[Int]): Int = {\n    if (row &gt;= length) r0(limit)\n    else {\n\n      // first element of v1 = delete (i+1) chars from target to match empty 'word'\n      r1(0) = row + 1\n\n      // use formula recursively to fill in the rest of the row\n      @tailrec\n      def distanceByColumn(col: Int): Unit = {\n        if (col &lt; limit) {\n          val cost = if (word(row) == targetText(col)) 0 else 1\n          r1(col + 1) = min(r1(col) + 1, r0(col + 1) + 1, r0(col) + cost)\n          distanceByColumn(col + 1)\n        }\n      }\n      distanceByColumn(0)\n\n      // recurse with arrays swapped for next row\n      distanceByRow(row + 1, r1, r0)\n    }\n  }\n\n  // initialize v0 (prior row of distances) as edit distance for empty 'word'\n  @tailrec\n  def initArray(index: Int): Unit = {\n    if (index &lt;= limit) {\n      v0(index) = index\n      initArray(index + 1)\n    }\n  }\n  initArray(0)\n\n  // recursively process rows matching characters in word being compared to find best\n  distanceByRow(0, v0, v1)\n}<\/pre><\/div><p>清单 7 给出的 Scala 代码执行了与 <a href=\"#listing2\">清单 2<\/a> 中的 Java\n                代码相同的阻塞的距离计算。<code>bestMatch()<\/code> 方法找到由 <code>Matcher<\/code>\n                类实例处理的特定单词块中与目标文本最匹配的单词，使用尾部递归 <code>best()<\/code>\n                方法来扫描单词。<code>*Distance<\/code> 类创建多个 <code>Matcher<\/code>\n                实例，每个对应一个单词块，然后协调匹配结果的执行和组合。<\/p><h5 id=\"listing7\">清单 7. Scala\n                中使用多个线程的一次阻塞距离计算<\/h5><div class=\"codesection\"><pre class=\"displaycode\">class Matcher(words: Array[String]) {\n\n  def bestMatch(targetText: String) = {\n\n    val limit = targetText.length\n    val v0 = new Array[Int](limit + 1)\n    val v1 = new Array[Int](limit + 1)\n    \n    def editDistance(word: String, v0: Array[Int], v1: Array[Int]) = {\n      ...\n    }\n\n    @tailrec\n    /** Scan all known words in range to find best match.\n      *  \n      * @param index next word index\n      * @param bestDist minimum distance found so far\n      * @param bestMatch unique word at minimum distance, or None if not unique\n      * @return best match\n      */\n    def best(index: Int, bestDist: Int, bestMatch: Option[String]): DistancePair =\n      if (index &lt; words.length) {\n        val newDist = editDistance(words(index), v0, v1)\n        val next = index + 1\n        if (newDist &lt; bestDist) best(next, newDist, Some(words(index)))\n        else if (newDist == bestDist) best(next, bestDist, None)\n        else best(next, bestDist, bestMatch)\n      } else DistancePair(bestDist, bestMatch)\n\n    best(0, Int.MaxValue, None)\n  }\n}\n\nclass ParallelCollectionDistance(words: Array[String], size: Int) extends TimingTestBase {\n\n  val matchers = words.grouped(size).map(l =&gt; new Matcher(l)).toList\n  \n  def shutdown = {}\n  \n  def blockSize = size\n\n  /** Find best result across all matchers, using parallel collection. */\n  def bestMatch(target: String) = {\n    matchers.par.map(m =&gt; m.bestMatch(target)).\n      foldLeft(DistancePair.worstMatch)((a, m) =&gt; DistancePair.best(a, m))\n  }\n}\n\nclass DirectBlockingDistance(words: Array[String], size: Int) extends TimingTestBase {\n\n  val matchers = words.grouped(size).map(l =&gt; new Matcher(l)).toList\n  \n  def shutdown = {}\n  \n  def blockSize = size\n\n  /** Find best result across all matchers, using direct blocking waits. */\n  def bestMatch(target: String) = {\n    import ExecutionContext.Implicits.global\n    val futures = matchers.map(m =&gt; future { m.bestMatch(target) })\n    futures.foldLeft(DistancePair.worstMatch)((a, v) =&gt;\n      DistancePair.best(a, Await.result(v, Duration.Inf)))\n  }\n}<\/pre><\/div><p>清单 7 中的两个 <code>*Distance<\/code> 类显示了协调 <code>Matcher<\/code>\n                结果的执行和组合的不同方式。<code>ParallelCollectionDistance<\/code> 使用前面提到的 Scala 的并行集合\n                feature 来隐藏并行计算的细节，只需一个简单的 <code>foldLeft<\/code> 就可以组合结果。<\/p><p><code>DirectBlockingDistance<\/code> 更加明确，它创建了一组 future，然后在该列表上为每个结果使用一个\n                <code>foldLeft<\/code> 和嵌套的阻塞等待。<\/p><h4 id=\"N102D9\">性能再分析<\/h4><p><a href=\"#listing7\">清单 7<\/a> 中的两个 <code>*Distance<\/code> 实现都是处理\n                <code>Matcher<\/code> 结果的合理方法。（它们不仅合理，而且非常高效。<a href=\"https://github.com/dsosnoski/concur1\">示例代码<\/a>\n                包含我在试验中尝试的其他两种实现，但未包含在本文中。）在这种情况下，性能是一个主要问题，所以图 3 显示了这些实现相对于 Java\n                <code>ForkJoin<\/code> 代码的性能。<\/p><h5 id=\"fig3\">图 3. <code>ForkJoinDistance<\/code> 与 Scala\n                    替代方案的性能对比<\/h5><img alt=\"该图对比了 ForkJoinDistance 和 Scala 替代方案的性能\" src=\"/sunshine_new/images/1428413519/perform3.jpg\" width=\"484\" /><p>图 3 显示，Java <code>ForkJoin<\/code> 代码的性能比每种 Scala 实现都更好，但\n                <code>DirectBlockingDistance<\/code> 在 1,024 的块大小下提供了更好的性能。两种 Scala\n                实现在大部分块大小下，都提供了比 <a href=\"#listing1\">清单 1<\/a> 中的 <code> ThreadPool<\/code>\n                代码更好的性能。<\/p><p>这些性能结果仅是演示结果，不具权威性。如果您在自己的系统上运行计时测试，可能会看到不同的性能，尤其在使用不同数量的核心的时候。如果希望为距离任务获得最佳的性能，那么可以实现一些优化：可以按照长度对已知单词进行排序，首先与长度和输入相同的单词进行比较（因为编辑距离总是不低于与单词长度之差）。或者我可以在距离计算超出之前的最佳值时，提前退出计算。但作为一个相对简单的算法，此试验公平地展示了两种并发操作是如何提高性能的，以及不同的工作共享方法的影响。<\/p><p>在性能方面，<a href=\"#listing7\">清单 7<\/a> 中的 Scale 控制代码与 <a href=\"#listing2\">清单\n                    2<\/a> 和 <a href=\"#listing3\">清单 3<\/a> 中的 Java 代码的对比结果很有趣。Scala\n                代码短得多，而且（假设您熟悉 Scala！）比 Java 代码更清晰。Scala 和 Java 可很好的相互操作，您可以在本文的 <a href=\"https://github.com/dsosnoski/concur1\">完整示例代码<\/a> 中看到：Scala 代码对\n                Scala 和 Java 代码都运行了计时测试，Java 代码进而直接处理 Scala 代码的各部分。得益于这种轻松的互操作性，您可以将 Scala\n                引入现有的 Java 代码库中，无需进行通盘修改。最初使用 Scala 为 Java 代码实现高水平控制常常很有用，这样您就可以充分利用 Scala\n                强大的表达特性，同时没有闭包或转换的任何重大性能影响。<\/p><p><a href=\"#listing7\">清单 7<\/a> 中的 <code> ParallelCollectionDistance<\/code>\n                Scala\n                代码的简单性非常具有吸引力。使用此方法，您可以从代码中完全抽象出并发性，从而编写类似单线程应用程序的代码，同时仍然获得多个处理器的优势。幸运的是，对于喜欢此方法的简单性但又不愿意或无法执行\n                Scala 开发的人而言，Java 8 带来了一种执行直接的 Java 编程的类似特性。<\/p><h2 id=\"N10327\">结束语<\/h2><p>现在您已经了解了 Java 和 Scala 并发性操作的基础知识，本系列下一篇文章将介绍 Java 8 如何改进对 Java\n                的并发性支持（以及从长远来讲，可能对 Scala 的并发性支持）。Java 8 的许多改动您看起来可能都很熟悉（Scala\n                并发性特性中使用的许多相同的概念都包含在 Java 8 中），所以您很快就能够在普通的 Java 代码中使用一些 Scala\n                技术。请阅读下一期文章，了解应该如何做。<\/p><CMA ID: 971153><Site ID: 10><XSLT stylesheet used to transform this file: dw-document-html-7.0.xsl>\r\n\r\n\r\n<\/div>\r\n<\/div>\r\n","createTime":"2014-05-12 00:00:00","deployTime":"2014-05-12 00:00:00","id":0,"intro":"Java 平台对所有基于 JVM 的语言中的并发编程都提供了良好的支持。Scala 扩展了 Java 语言中的并发性支持，提供了更多在处理器之间共享工作和协调结果的方式。本文是一个有关 JVM 并发性的新文章系列的第一篇，将介绍 Java 7 中最新的并发性编程功能，还将介绍一些 Scala 增强。本文还会帮助为了解 Java 8 中的并发性特性奠定基础。","keyword":"","recommend":false,"source":"http://www.ibm.com/developerworks/cn/java/j-jvmc1/index.html","title":"JVM\n            并发性: Java 和 Scala 并发性基础","typeId":0,"updateTime":"2014-05-12 00:00:00"}
{"author":"","clickNumber":0,"content":"\r\n<div class=\"ibm-columns\">\r\n<div class=\"ibm-col-1-1\">\r\n\r\n<h2 id=\"N1006A\">简介<\/h2><p>虚拟系统模式 (VSP) 模型将云工作负载定义为一个中间件镜像拓扑。VSP\n                中间件工作负载拓扑可以有一个或者多个虚拟镜像，即部件。工作负载模型中的每个部件都可配置用于静态扩展。在部署时，IBM Pure\n                Application System（以下简称 PureApplication 系统）将根据部件上的扩展设置创建一个由许多虚拟机（VSP 实例 VM\n                节点）组成的 VSP 实例。VSP 模型<em>不<\/em>支持基于扩展策略的自动扩展。<\/p><div class=\"dw-sidebar ibm-inset\"><h2 id=\"N10075\">常见缩略词<\/h2><ul class=\"ibm-bullet-list\"><li><strong>VSP<\/strong>：虚拟系统模式<\/li><li><strong>VAP<\/strong>：虚拟应用程序模式<\/li><li><strong>VM<\/strong>：虚拟机<\/li><\/ul><\/div><p>本文将介绍如何构建一个虚拟应用程序模式（VAP）的模式类型，可以用它来充当扩展管理器，根据用户定义的策略动态地添加和删除 VSP 实例 VM\n                节点。本文假设您已了解如何使用 VAP 插件开发工具包（VAP PDK）来构建 VAP 模式类型和插件，并且熟悉 VAP 扩展框架。想要获得有关\n                VAP 扩展框架的更多信息，参阅 <a href=\"http://www.ibm.com/developerworks/websphere/techjournal/1309_tost/1309_tost.html\">IBM\n                    PureApplication System 虚拟应用模式中的可扩展性和灵活性<\/a>。<\/p><h2 id=\"1.CreateaVAPpattern-typetoautoscaleVSPinstances|outline\">创建一个 VAP 模式类型自动扩展 VSP 实例<\/h2><p>以下小节将介绍如何创建 “VSP Scaling Manager” VAP 模式类型。VAP 模式类型可以充当管理器，促进 VSP 实例 VM\n                节点的自动扩展。该技术利用了 VAP 监控、策略框架和 VSP Clone API。构建这个模式类型涉及到以下步骤：<\/p><ol type=\"1\"><li>创建 VAP 应用程序模型元数据，捕获 VSP 实例的详细信息。<\/li><li>创建一个策略对象，定义一个扩展策略。<\/li><li>创建一个拓扑模板，将应用程序模型转化为拓扑文档。<\/li><li>创建监控元模型和监控脚本来监控 VSP 实例。<\/li><li>创建 VM 节点扩展脚本的 VSP 实例。<\/li><\/ol><h3 id=\"N1009E\">用例 <\/h3><p>在本文中，我们将使用 WebSphere 集群 VSP 作为自动扩展的目标 VSP。如图 1 所示，WebSphere 集群 VSP\n                    由一个<em>部署管理器<\/em> 部件、一个<em>自定义节点<\/em> 部件和一个 <em>IBM HTTP 服务器<\/em>\n                部件组成。在接下来的小节中，您将了解如何根据系统 CPU 的使用情况自动扩展自定义节点部件。您可以使用该技术根据任何用户定义的扩展标准对任何 VSP\n                部件进行扩展。<\/p><h5 id=\"N100AF\">图 1. WebSphere 集群 VSP<\/h5><img alt=\"WebSphere 集群 VSP\" src=\"/sunshine_new/images/2050429210/images/figure1.jpg\" width=\"850\" /><h2 id=\"_Step_1:_Create\">步骤 1：创建 VAP\n                应用程序模型元数据<\/h2><p>要扩展 VSP 实例的 VM 节点，需要执行以下用户输入：<\/p><ul class=\"ibm-bullet-list\"><li>VSP 实例名称<\/li><li>VSP 节点部件名称<\/li><li>访问运行的实例所需的用户凭据<\/li><li>执行 VSP 命令行 API （部署人员命令行 API）所需的用户凭据）<\/li><\/ul><p>VSP 实例名称和 VSP 节点部件名称被用来惟一地识别被扩展的资源。在我们的 WebSphere 集群 VSP 用例中，VSP\n                节点部件名称的值是自定义节点，VSP 实例名称的值是已部署的 WebSphere 集群 VSP 实例的实例名称。实例用户凭证是在要扩展的 VM\n                上执行监控脚本（使用 ssh）所需要的。部署人员用户凭证是运行 API 所需要的，以便根据监控值来添加或者删除 VM。<\/p><p>使用 VAP 组件对象属性，您可以从用户那里获得所需的输入。可以使用 VAP 应用程序模型元数据为组件对象属性建立模型。清单 1\n                显示了应用程序模型的元数据。图 2 按照这些属性在虚拟应用程序构建器中的显示方式来显示它们。<\/p><h5 id=\"listing1\">清单 1. VSP Scaling Manager\n                    属性元模型（metadata.json）<\/h5><div class=\"codesection\"><pre class=\"displaycode\">{\n      \"id\": \"vsyscloning\",\n      \"type\": \"component\",\n      \"label\": \"VSys Scaling Manager\",\n      \"description\": \"Example for cloning a virtual system\",\n      \"image\": \"appmodel\\/images\\/demoapp.png\",\n      \"thumbnail\": \"appmodel\\/images\\/thumbnail\\/demoappl.png\",\n      \"attributes\": [\n         {\n            \"id\": \"CLONENODE\",\n            \"type\": \"string\",\n            \"required\": true,\n            \"label\": \"Virtual System Node\",\n         },\n         {\n            \"id\": \"CLONEVSYS\",\n            \"type\": \"string\",\n            \"required\": true,\n            \"label\": \"Virtual System Instance Name\",\n         },\n         {\n            \"id\": \"VSYSPASS\",\n            \"type\": \"string\",\n            \"required\": true,\n            \"label\": \"Virtual System password\",\n            \"displayType\": \"password\"\n         },         \n         {\n            \"id\": \"DEPHOST\",\n            \"type\": \"string\",\n            \"required\": true,\n            \"label\": \"Deployer Host Name\",\n          },\n         {\n            \"id\": \"DEPUSER\",\n            \"type\": \"string\",\n            \"required\": true,\n            \"label\": \"Deployer User Id\",\n          },\n         {\n            \"id\": \"DEPPASS\",\n            \"type\": \"string\",\n            \"required\": true,\n            \"label\": \"Deployer password\",\n            \"displayType\": \"password\"\n         }\n      ]\n   }<\/pre><\/div><h5 id=\"N100D4\">图 2. VSP Scaling Manager 的属性<\/h5><img alt=\"VSP Scaling Manager 的属性\" src=\"/sunshine_new/images/2050429210/images/figure2.jpg\" width=\"264\" /><h2 id=\"_Step_2:_Create\">步骤\n                2：创建一个用来定义扩展策略的策略对象<\/h2><p>您可以使用 VAP 策略框架创建一个 VSP 自动扩展策略。VAP 策略框架允许您使用 VAP 应用程序模型元数据定义一个策略对象。参阅 <a href=\"http://www.ibm.com/developerworks/websphere/techjournal/1309_tost/1309_tost.html\"> IBM PureApplication System 虚拟应用模式中的可扩展性和灵活性<\/a>，获得如何使用 VAP 应用程序模型元数据定义策略的详细信息。<\/p><p>清单 2 显示了基于 CPU 的扩展的策略对象定义。图 3 按照该策略在虚拟应用程序构建器中的显示方式来显示它。使用图 3\n                中所示的策略界面，用户可以创建一个扩展策略，根据 VM CPU 的使用情况对 VSP 实例 VM 节点进行扩展。如图 3\n                所示，默认策略定义可以命令系统执行扩展，如果 CPU 使用率超过 80% 则扩大，如果小于 10% 则缩小。<\/p><p>在我们的 WebSphere 集群 VSP 用例中，如果所有自定义节点 VM 的 CPU 使用率超过 80%，那么这个扩展策略就会扩大自定义节点\n                VM，小于 10% 则缩小。<\/p><h5 id=\"listing2\">清单 2. VSP Scaling Manager 的 CPU\n                    扩展策略对象元模型（metadata.json）<\/h5><div class=\"codesection\"><pre class=\"displaycode\">{\t\n        \"id\": \"ScalingPolicyofVSys\",\n        \"label\": \"VSys Scaling Policy\",\n        \"type\": \"policy\",\n        \"applicableTo\": [\n            \"vsyscloning\"\n        ],\n        \"thumbnail\": \"appmodel/images/thumbnail/ClusterPolicy.png\",\n        \"image\": \"appmodel/images/ClusterPolicy.png\",        \n        \"description\": \"VSys scaling policy\",\n        \"groups\": [\n\t\t\t{\n\t\t\t   \"category\":\"Scaling Type\",\n\t\t\t   \"id\":\"CPUVsys\",\n\t\t\t   \"label\":\"CPU Based\",\n\t\t\t   \"defaultValue\":true,\n\t\t\t   \"attributes\":[\n\t\t\t      \"cpuVsys\",\n\t\t\t      \"scaleInstanceRange1\",\n\t\t\t      \"triggerTime1\",\n                             ...\n\t\t\t   ],\n\t\t\t}                                    \n        ],\n        \"attributes\": [\n            {\n                \"id\": \"triggerTime1\",\n                \"label\": \"Minimum time (sec) to trigger add/remove\",\n                \"type\": \"number\",\n                \"max\": 1800,\n                \"min\": 30,\n                \"required\": true,\n                \"sampleValue\": 120,\n                ...\n            },\n            {\n                \"id\": \"scaleInstanceRange1\",\n                \"label\": \"Instance number range of scaling in/out\",\n                \"type\": \"range\",\n                \"min\": 1,\n                \"max\": 10,\n                \"required\": true,\n                \"sampleValue\": [\n                    1,\n                    10\n                ],\n                ...\n            },\n\t    {\n\t\t \"id\":\"cpuVsys\",\n\t\t \"label\":\"Scaling in/out when average CPU usage of clustered members is out \n           of threshold range(#)\",\n\t\t \"type\":\"range\",\n                \"displayType\": \"percentage\",\t\t\t   \n\t\t \"required\":true,\n\t\t \"max\":100,\n\t\t \"min\":1,\n\t\t \"sampleValue\":[\n\t\t      10,\n\t\t      80\n\t\t ],\n                ...\n\t     }     \n        ]\n}<\/pre><\/div><h5 id=\"N100F4\">图 3. VSP Scaling Manager CPU 扩展策略<\/h5><img alt=\"VSP Scaling Manager CPU 扩展策略\" src=\"/sunshine_new/images/2050429210/images/figure3.jpg\" width=\"284\" /><h2 id=\"N100FE\">步骤\n                3：创建一个拓扑模板，将应用程序模型转化为一个拓扑文档<\/h2><p>PureApplication System IaaS 层使用拓扑文档来创建 VAP\n                实例。拓扑文档是从应用程序模型生成的。在使用虚拟应用程序构建器创建 VAP 时，该模型由 PureApplication\n                系统在幕后创建。您可以使用清单 3 中的速率模板，将 “VSP Scaling Manager ” VAP 应用程序模型转化为一个拓扑文档。清单 3\n                中的模板会创建一个名为 “clone” 的角色，以及以下参数值：VSP 实例详细信息（通过 <a href=\"#_Step_1:_Create\">步骤 1<\/a> 获取）和策略定义（通过 <a href=\"#_Step_2:_Create\">步骤 2<\/a> 获取）。这些参数值将用在\n                “VSP 自动扩展管理器” VAP 生命周期脚本中，以推动 VSP 实例的扩展。<\/p><h5 id=\"listing3\">清单 3. VSP Scaling Manager\n                    拓扑模板（vsyscloning.vm）<\/h5><p><a href=\"#N10111\" class=\"ibm-popup-link\" onclick=\"ibmweb.overlay.show('N10111',this);return false;\">点击查看代码清单<\/a><\/p><div id=\"N10111\" class=\"dw-sidefile-overlay ibm-common-overlay ibm-overlay-alt-two\"><div class=\"ibm-head\"><p><a href=\"#close\" class=\"ibm-common-overlay-close\">关闭 [x]<\/a><\/p><\/div><div class=\"ibm-body\"><div class=\"ibm-main\"><div class=\"ibm-title\"><h2>清单 3. VSP Scaling Manager\n                    拓扑模板（vsyscloning.vm）<\/h2><\/div><div class=\"ibm-container ibm-alternate\"><div class=\"ibm-container-body\"><div class=\"codesection\"><pre class=\"displaycode no-auto-overflow\">{\n  #set($spattrs = $provider.getPolicyAttributes($component, \n   \"ScalingPolicyofVSys\"))\t\t\n  \"vm-templates\": [\n   {\n   \"persistent\":false,                 \n    \"name\": \"${prefix}-clone\",\n    \"roles\": [\n    {\n      \"parms\": {\n\"DEPHOST\":\"$attributes.DEPHOST\",\n\"DEPUSER\":\"$attributes.DEPUSER\",\n\"DEPPASS\":\"$attributes.DEPPASS\",\t\t\t\t\t\t\n\"CLONENODE\":\"$attributes.CLONENODE\",\t\n\"CLONEVSYS\":\"$attributes.CLONEVSYS\",\n\"VSYSPASS\":\"$attributes.VSYSPASS\",\n#if_value( $spattrs, \"scaleInstanceRange1\", '\"MININST\": \n    $spattrs.scaleInstanceRange1.get(0),')\n#if_value( $spattrs, \"scaleInstanceRange1\", '\"MAXINST\": \t\t\t\t\t\t\t\n    $spattrs.scaleInstanceRange1.get(1),')\n#if_value( $spattrs, \"cpuVsys\", '\"MINCPU\": $spattrs.cpuVsys.get(0),')\n#if_value( $spattrs, \"cpuVsys\", '\"MAXCPU\": $spattrs.cpuVsys.get(1),')\t\t\n#if_value( $spattrs, \"triggerTime1\", '\"triggerTime\": \t\t\t\t\t\t\t\n    $spattrs.triggerTime1,')\n\"isCloned\": \"FALSE\"\n },\t\t            \t\t                \n     \"type\": \"SClone\",\n     \"name\": \"clone\"                 \n   }\n  ],\n  \"packages\": [\"SClone\"]\n  }        \t\t        \n ]\n}<\/pre><\/div><\/div><\/div><\/div><\/div><div class=\"ibm-footer\"><><\/div><\/div><h2 id=\"N10113\">步骤 4：创建监控元模型和脚本<\/h2><p>在这个步骤中，您将创建所需的资源，以监控 VSP 实例 VM 节点。您可以像扩展策略中定义的那样，根据监控值来触发 VSP 实例 VM\n                节点的扩展。您可以使用 VAP 监控框架来监控 VSP 实例 VM 节点。VAP 监控框架将会触发所监控指标的收集，然后在 VAP\n                控制台中显示这些被监控的指标。为了完成这个步骤，VAP 监控框架期望 VAP 插件提供以下信息：<\/p><ul class=\"ibm-bullet-list\"><li>指标元数据，用于定义指标数据（清单 4 显示了用于度量 CPU 使用率的指标元数据）。<\/li><li>一个脚本（参见所提供的 <a href=\"#download\">代码样例<\/a> 中的 cpuutil.sh），用于从 VSP 实例 VM\n                    节点中收集指标。<\/li><li>指标元数据和收集脚本的注册代码。<a href=\"#listing5\">清单 5<\/a> 显示了向框架注册资产的 maestro API\n                    调用。<\/li><li>指标显示元数据，用于以图形的方式显示所收集的指标。<a href=\"#listing6\">清单 6<\/a> 给出了用于显示 VSP 实例\n                    VM 节点 CPU 指标的元数据。<\/li><\/ul><h5 id=\"listing4\">清单 4. VSP CPU\n                    指标的指标元数据（cpuvsyscollector.json）<\/h5><div class=\"codesection\"><pre class=\"displaycode\">{\n   \"version\":1,\n   \"update_interval\": 60,   \n   \"category\":[\n      \"cpuvsys\"\n   ],\n   \"metadata\":[\n      {\n         \"cpuvsys\":{\n   \t\t\t\"update_interval\":60,         \n            \"metrics\":[\n               {\n                  \"attribute_name\":\"cpuVsys\",\n                  \"metric_name\":\"cpuVsys\",\n                  \"metric_type\":\"COUNTER\"\n               }\n            ]\n         }\n      }\n   ]\n}<\/pre><\/div><h5 id=\"listing5\">清单 5.\n                    注册指标收集器（configure.py）<\/h5><div class=\"codesection\"><pre class=\"displaycode\">#Register cpu vsys collector\nmaestro.monitorAgent.register('{\\\n\"node\":\"%s\",\\\n\"role\":\"%s\",\\\n\"collector\":\"com.ibm.maestro.monitor.collector.script\",\\\n\"config\":{\\\n\"metafile\":\"/home/virtuser/collectors/cpuvsyscollector.json\",\\\n\"executable\":\"/home/virtuser/collectors/cpuutil.sh\",\\\n\"arguments\":\"%s\",\\\n\"validRC\":\"0\",\\\n\"workdir\":\"/tmp\",\\\n\"timeout\":\"120\"}}' % (nodeName,roleName,arguments));<\/pre><\/div><h5 id=\"listing6\">清单 6.\n                    监控指标显示元数据（monitoring_ui.json）<\/h5><div class=\"codesection\"><pre class=\"displaycode\">[\n   {\n      \"version\":2,\n      \"category\":\"cpuvsys\",\n      \"label\":\"CPU Usage\",\n      \"displayRoles\": [\"SClone\"],\n      \"displays\":[\n         {\n            \"label\":\"CPU Usage of Virtual System Instance Node\",\n            \"monitorType\":\"HistoricalNumber\",\n            \"chartType\":\"Lines\",\n            \"metrics\":[\n               {\n                  \"attributeName\":\"cpuVsys\",\n                  \"label\":\"Used Percentage\"\n               }\n            ]\n         }\n      ]\n   }\n]<\/pre><\/div><h2 id=\"N10141\">扩展和监控脚本<\/h2><p>在本小节中，我们将深入介绍监控和扩展脚本（参见所提供的 <a href=\"#download\">代码样例<\/a> 中的\n                cpuutil.sh）。该脚本执行了以下任务：<\/p><ul class=\"ibm-bullet-list\"><li>该脚本将会检索 VSP 实例 VM 节点的 CPU 使用率。在我们的用例中，该脚本将会获取 WebSphere VSP 自定义节点实例的\n                    CPU 利用率。<\/li><li>如果检索到的值比策略中指定的值大，那么一旦达到策略所定义的最大值，就会创建一个新的 VSP 实例 VM\n                    节点。在我们的用例中，如果自定义节点实例的 CPU 使用超过 80，则会创建 WebSphere VSP 自定义节点，直到存在 10\n                    个这样的节点。<\/li><li>如果检索到的值小于策略中定义的值，那么所有节点（除了策略中定义的最小节点数量）都将被删除。在我们的用例中，如果自定义节点实例的 CPU\n                    使用率小于 10，那么除了两个 WebSphere VSP 自定义节点以外，其余所有节点都将被删除。<\/li><li>最后，脚本将指标数据返回给 VAP 监控框架，以便在部署控制台中显示。<\/li><\/ul><p>该脚本由监控框架定期触发。触发周期基于监控元数据中定义的 <code>update_interval<\/code> 参数（参见 <a href=\"#listing4\">清单 4<\/a>）。在此脚本中，我们通常会短时间地连接 VAP 监控框架，以触发 VSP 实例 VM\n                节点的扩展。在接下来的小节中，您将了解如何使用 VSP Clone 和 Delete API 添加或者删除 VSP 实例 VM 节点。<\/p><h2 id=\"N10160\">步骤 5：创建 VSP 实例 VM 节点扩展脚本<\/h2><p>您可以使用 Python 脚本来添加或者删除 VSP 实例 VM 节点。Python 脚本由监控脚本 cpuutil.sh 使用\n                PureApplication System 部署人员命令行工具进行触发。清单 7 和清单 8 显示了用来添加和删除一个 VSP 实例 VM 节点的\n                Python 脚本。这些脚本使用了 VSP 虚拟系统对象、虚拟机对象和它们的克隆。它们还删除了一些方法来扩大和缩小 VSP 实例 VM\n                节点。<\/p><h5 id=\"listing7\">清单 7. 添加新的 VSP 部件 VM 的脚本<\/h5><div class=\"codesection\"><pre class=\"displaycode\">#This python script is used to clone one new node (of type cloneNode)\n#belonging to Vsys instance cloneVSys.\n#No new node will be created if max is reached.\nimport os\nimport sys\ncloneNode=sys.argv[1]\ncloneVSys=sys.argv[2]\nmax=sys.argv[3]\n\n#function to check if the maximum clone limit is reached\ndef isMax(max, system, cloneNode):\n    current=0\n    vms=system.virtualmachines\n    for vm in vms:\n        vmpartname= vm.patternpart.partCaption\n        vmstatus = vm.currentstatus\n        if(vmpartname == cloneNode and vmstatus == \"RM01006\"):            \n             current+=1\n    if(current &lt; max):\n        return \"False\"\n    else:\n        return \"True\"\n\n#Get the input virtual system instance.  \nallsystems=deployer.virtualsystems.list({'name':cloneVSys})\nfound='False'\nfor system in allsystems:\n    vsysname=system.name\n    vsysstatus = system.currentstatus\n    print \"SysName:\" + vsysname + \" SysStatus:\" + vsysstatus\n    if(vsysstatus == \"RM01006\" or vsysstatus == \"RM01070\"):\n        #Get all the running virtual machines\n        vms=system.virtualmachines\n        for vm in vms:\n            vmpartname= vm.patternpart.partCaption\n            vmstatus = vm.currentstatus\n            print \"VMName:\" + vmpartname + \" VMStatus:\" + vmstatus\n            if(vmpartname == cloneNode and vmstatus == \"RM01006\"):\n                found='True'\n                #If max limit not reached then clone.\n                isMaximum = isMax(int(max), system, cloneNode)\n                if(isMaximum == 'False'):\n                    print \"Clone started\"\n                    vm.clone()\n                break\n        if(found=='True'):\n            break<\/pre><\/div><h5 id=\"listing8\">清单 8. 删除 VSP 部件 VM\n                的脚本<\/h5><div class=\"codesection\"><pre class=\"displaycode\">#This python script is used to release all the nodes (of type cloneNode)\n#belonging to Vsys instance cloneVSys.\n#No nodes are released if min specified is reached.\n\nimport os\nimport sys\ncloneNode=sys.argv[1]\ncloneVSys=sys.argv[2]\nmin=int(sys.argv[3])\n\n#Check if minimum number of nodes reached.\ndef isMin(min, system, cloneNode):\n    current=0\n    vms=system.virtualmachines\n    for vm in vms:\n        vmpartname= vm.patternpart.partCaption\n        vmstatus = vm.currentstatus\n        if(vmpartname == cloneNode and vmstatus == \"RM01006\"):\n             current+=1\n    if(current &gt; min):\n        return \"False\"\n    else:\n        return \"True\"\n\n#Get the input virtual system instance.\nallsystems=deployer.virtualsystems.list({'name':cloneVSys})\nfound='False'\nfor system in allsystems:\n    vsysname=system.name\n    vsysstatus = system.currentstatus\n    print \"SysName:\" + vsysname + \" SysStatus:\" + vsysstatus\n    if(vsysstatus == \"RM01006\" or vsysstatus == \"RM01070\"):\n        #Get all the running virtual machines\n        vms=system.virtualmachines\n        for vm in vms:\n            vmpartname= vm.patternpart.partCaption\n            vmstatus = vm.currentstatus\n            print \"VMName:\" + vmpartname + \" VMStatus:\" + vmstatus\n            if(vmpartname == cloneNode and vmstatus == \"RM01006\"):\n                found='True'          \n                #Delete till minimum specified is reached.      \n                isMinimum = isMin(int(min), system, cloneNode)\n                if(isMinimum == 'True'):\n                    break\n                else:\n                    print \"delete started\"\n                    vm.delete()\n        if(found=='True'):\n            break<\/pre><\/div><p>在上述五个步骤中，您实际上完成了以下任务：<\/p><ul class=\"ibm-bullet-list\"><li>使用 VAP 策略对象定义用户定义的扩展策略。<\/li><li>使用 VAP 监控框架触发 VSP 实例 VM 监控，并根据所监控的指标来触发 VSP 实例 VM 的动态自动扩展。<\/li><li>使用 VSP 命令 API 所提供的克隆和删除方法创建一个新的 VSP 实例 VM 节点，或者删除一个现有的 VSP 实例 VM\n                    节点。<\/li><\/ul><h2 id=\"N1017C\">测试用例<\/h2><p>在这一小节中，您将了解如何测试 WebSphere Cluster 自定义节点扩展用例。要测试该用例，首先需要创建一个 WebSphere\n                Cluster VSP 实例。图 4 显示了一个 WebSphere Cluster VSP 实例。您还必须创建一个 VAP 模式类型来推动 VSP\n                的扩展。本文提供的 <a href=\"#download\">示例代码<\/a> 有一个 VAP\n                模式类型（vsysscalingmgr），您可以将它导入您的 PureApplication 系统环境中，以推动 VSP\n                的扩展。一旦导入该模型类型，就可以使用虚拟应用程序构建器创建一个新的 VAP，并部署新创建的 VAP。<\/p><h5 id=\"N10188\">图 4. WebSphere Cluster VSP 实例<\/h5><img alt=\"WebSphere Cluster VSP 实例\" src=\"/sunshine_new/images/2050429210/images/figure4.jpg\" width=\"850\" /><p>图 5 显示了虚拟应用程序构建器中的 WebSphere Cluster Scaling Manager VAP。<\/p><h5 id=\"N10195\">图 5. WebSphere Cluster Scaling Manager\n                    模式<\/h5><img alt=\"WebSphere Cluster Scaling Manager 模式\" src=\"/sunshine_new/images/2050429210/images/figure5.jpg\" width=\"850\" /><p>在完成模式部署之后，就可以使用以下步骤来模拟扩展：<\/p><ol type=\"1\"><li>登录到 <strong>Deployment Manager <\/strong>\n                    控制台。在现有的节点上创建新的服务器，执行一个完全的再同步，或者执行这个节点上的其他操作，增加自定义节点上的 CPU 使用率。<\/li><li>在监控脚本 cpuutil.sh 中，通过取消对清单 9 所示的代码行的注释，您可以对 VSP\n                    实例的自定义节点扩展进行单元测试。这会给出一个虚拟值 85，以此作为脚本中的后续任务的 CPU 使用率。如果想缩小该使用率，可以对取消注释的行进行注释。\n<h5 id=\"listing9\">清单 9. 使用取消注释的行来测试 VSP Scaling Manager\n                            模式<\/h5><div class=\"codesection\"><pre class=\"displaycode\">cpuval=$(ssh -i $DIR_NAME/key -o StrictHostKeyChecking=no $ADMIN_NAME@$i \"top -b -d1 -n2\n| grep -i \\\"Cpu(s)\\\" | cut -d ',' -f1  | awk '{print \\$2}' | cut -d '%' -f1 | sed -n 2p\")\n#To unit test clone un-comment the following line. After cloning to unit-test delete\n#comment this line.\n<strong>#cpuval=85<\/strong>\n#end unit test un-comment\t   \necho \"cpu value is \"$cpuval  &gt;&gt; /home/virtuser/collectors/scaling.log<\/pre><\/div><\/li><\/ol><p>图 6 显示了 VAP 控制台中的监控用户界面。该界面显示了 VSP 实例节点自定义节点的 CPU 使用率。请注意，当您使用清单 9\n                中所描述的方法对模式类型进行单元测试时，图形会激增到 85%，然后回落到 2%。<\/p><h5 id=\"N101B6\">图 6. 虚拟系统实例节点的 CPU 使用率<\/h5><img alt=\"虚拟系统实例节点的 CPU 使用率\" src=\"/sunshine_new/images/2050429210/images/figure6.jpg\" width=\"829\" /><p>图 7 显示了对自定义节点实例的添加。如果所有自定义节点实例的 CPU 使用率都超过 80%，则会创建新的 WebSphere VSP\n                自定义节点，直到达到最大值 10 个节点。当所有自定义节点实例的 CPU 使用率回落到 10%\n                以下，除了两个自定义节点实例以外，其他节点都将被删除。<\/p><h5 id=\"N101C3\">图 7. WebSphere VSP 自定义节点扩展<\/h5><img alt=\"WebSphere VSP 自定义节点扩展\" src=\"/sunshine_new/images/2050429210/images/figure7.jpg\" width=\"850\" /><h2 id=\"N101CD\">结束语<\/h2><p>在本文中，您了解了如何创建 VAP 模式类型来推动 VAP 实例 VM\n                节点的用户定义的自动扩展。使用这项技术，您可以利用用户定义的扩展策略以及最小值或 VSP 原值来自动扩展一个 VSP 实例 VM 节点。您还可以使用\n                VAP 仪表板来进一步监控 VSP 实例指标。该技术的缺点是需要用户输入 VSP 实例 VM 的用户凭据，并且只有能够访问 VSP 实例的\n                PureApplication System 用户才能部署 VAP Scaling Manager 实例。否则，部署人员 CLI\n                会无权添加或删除节点。<\/p><CMA ID: 970950><Site ID: 10><XSLT stylesheet used to transform this file: dw-document-html-7.0.xsl>\r\n<h2 id=\"download\">下载<\/h2><table class=\"ibm-data-table dw-download-table\" cellpadding=\"0\" cellspacing=\"0\" border=\"0\"><thead><tr><th scope=\"col\">描述<\/th><th scope=\"col\">名字<\/th><th scope=\"col\">大小<\/th><\/tr><\/thead><tbody><tr><th scope=\"row\" class=\"ibm-table-row\">代码样例<\/th><td nowrap=\"nowrap\"><a href=\"http://www.ibm.com/developerworks/apps/download/index.jsp?contentid=970950&amp;filename=code_sample.zip&amp;method=http&amp;locale=zh_CN\">code_sample.zip<\/a><\/td><td nowrap=\"nowrap\">52KB<\/td><\/tr><\/tbody><\/table>\r\n\r\n<\/div>\r\n<\/div>\r\n","createTime":"2014-05-12 00:00:00","deployTime":"2014-05-12 00:00:00","id":0,"intro":"虚拟系统模式是一种 IBM PureApplication System 部署模型，它将云工作负载定义为一种中间件镜像拓扑。虚拟系统模式模型只支持虚拟系统模式实例节点的静态扩展。本文将介绍如何构建一个虚拟应用程序模式，该模式可实现虚拟系统模式实例节点的自动扩展。该技术可利用虚拟应用程序模式策略、监控框架和虚拟系统模式克隆 API。","keyword":"","recommend":false,"source":"http://www.ibm.com/developerworks/cn/cloud/library/cl-ps-aim1310-autoscaling/index.html","title":"IBM PureApplication System 中虚拟系统模式实例的自动扩展","typeId":0,"updateTime":"2014-05-12 00:00:00"}
{"author":"","clickNumber":0,"content":"\r\n<div class=\"ibm-columns\">\r\n<div class=\"ibm-col-1-1\">\r\n\r\n<h2 id=\"1.Moco 框架以及其在 Web 集成测试的应用 |outline\">Moco 框架以及其在 Web 集成测试的应用<\/h2><p>我们往往将软件测试可以分为单元测试、集成测试、系统测试和验收测试。而集成测试界于单元测试和系统测试之间，起到\"桥梁作用\"，一般由开发小组采用白盒加黑盒的方式来测试，既验证\"设计\"，又验证\"需求\"。 主要用来测试模块与模块之间的接口，同时还要测试一些主要业务功能。集成测试（也叫组装测试，联合测试）是单元测试的逻辑扩展。它最简单的形式是：把两个已经测试过的单元组合成一个组件，测试它们之间的接口。从这一层意义上讲，组件是指多个单元的集成聚合。在现实方案中，许多单元组合成组件，而这些组件又聚合为程序的更大部分。方法是测试片段的组合，并最终扩展成进程，将模块与其他组的模块一起测试。最后，将构成进程的所有模块一起测试。此外，如果程序由多个进程组成，应该成对测试它们，而不是同时测试所有集成测试进程。<\/p><h3 id=\"N1004F\">Web 集成测试<\/h3><p>在很多时候，我们的 Web 应用程序往往会成为项目的瓶颈，以至于影响整个项目的按时发布。那么我们不禁要问，为什么会出现这样的情况？是什么在阻碍着项目的进度？在我们深入探讨这个问题之前，让我们先回忆一下一个典型的 Web 项目开发所经历的过程，从而寻找出问题的根源。<\/p><p>从开发的流程上看，它与其他的产品开发没有本质的区别，无外乎立项、审核、开发、集成、测试、维护这些具体的过程。每个步骤参与的人员和行为也都大同小异，然而您会发现往往很多的\n    Web 项目总是在集成测试环节出现这样或者那样的问题？（当然集成测试符合普氏原理，其他的产品开发也会遇到这样棘手的问题，只是 Web 显得更加的明显和突出罢了）其实这和具体的 Web 项目没有多大的关系，有点绕？哦，这句话的意思就是，我们需要将思维跳出具体的项目本身，从整个产品的角度来看待问题，这样就很容易找到痛点。那么让我们换个角度来看这个问题：<\/p><p>\n\n\n客户C〉Web/客户端C〉系统基础软件\n\n\n<\/p><p>从上面的关系中我们可以看到，作为\"食物链\"顶端的 Web 项目往往起着一个\"中间人\"的角色，在它之下是系统软件（如操作系统本身或者其上的中间件），而在它之上往往直接面对客户。在软件开发的经典教程里,总是将这种处于中间衔接层的软件设计称为--鲁棒性。也就是说它需要的是某种颠覆性的 OUTPUT,将具体的需求转化为实际的可以操作的架构设计，这样的一个\"中间人\"往往在一个产品的生命周期中扮演者举足轻重的角色。<\/p><h3 id=\"N1005D\">Web 集成测试的痛点<\/h3><p>而 Web 项目区别于其他项目的本质原因就在于，它直接面对需求的提出者--客户，而这部分的需求变动也是最为活跃的。也就是因为这样，往往很多时候我们对于 web\n    的开发要求的就是，快速！但这样的观点仅仅限于在 UI 或者 Web\n    编程方面，对于与底层系统的集成往往素手无策？因为底层系统一般来说是公司产品的核心内容，也遵循着典型的产品开发模式，在需求变更方面也显得很谨慎而小心。面对突入其来的的需求变动，底层系统往往很难跟的上节奏，而且很多时候\n    Web 的开发和底层系统的开发是分开的，或者分属于不同的开发部门，即使是一个方法级别的调用，就会浪费掉大家很多的沟通成本，接口的变更或者是 API 的向下兼容这些都是翻来覆去争论的话题。由于大家所处的开发领域不同，工作的方式，方法的不同，甚至是编程语言的差别，这些问题最终会暴露在集成测试这里，从而影响整体项目的开发进度。<\/p><p>这里就有一个真实的案例。在 Web 开发中，我们遇到了大数据显示的问题，分页显示无疑是最合适，也最很容易想到的解决方案。但由于其他的因素，底层系统无法在既定的项目期限内给予\n    API\n    方面的支持，在经过深入的沟通和相互理解之后发现，这样的功能在系统层面这个角度来说，属于优先级较低的功能。而且在他们开来，客户往往更习惯于使用命令行查看结果，并没有提出这样的需求，当然这样的争论是没有意义的，大家看待问题的角度不同，我们也不能一概而论，毕竟还是还有一些客户并不属于\"专业级\"用户，或者由于其他的原因的限制，他们不得不选择使用浏览器查看执行结果，面对这样的情况，摆在\n    Web 开发人员面前的问题就是如何在既定的情况下修改已有的结构，从而支持数据分页并且保证足够的可扩展性，以保证在未来底层系统可能支持的情况下，将代码修改的成本降低到最小？<\/p><h3 id=\"N10066\">解决思路和方案<\/h3><p>问题已经暴露出来，让我们畅想一下期望的开发模式是什么，可能更容易让我们审核目前的问题，并找到最佳的解决方案。让我们畅想一下，如果我们在 Web\n    开发阶段没有这么多的顾虑而专注于功能本身，或者说我们总是假定底层系统足够的强大，并支持所有可能的的需求变更，是不是就没有这样的问题了？那么是否真的有这样的一个框架开始关注于这些问题，从而将\n    Web 开发人员解放出来，使其更加关注于自身领域的的需求呢？换句话说我们需要一个\"模拟\"的底层系统，它返回所有我们希望的结果，从而让我们将所有的注意力放在 Web\n    这个层面，对，这就是今天要介绍的 Moco！<\/p><h2 id=\"2.Moco 是什么 |outline\">Moco 是什么<\/h2><p>作者是这样描述 Moco 的：<\/p><p><a href=\"https://github.com/dreamhead/moco\">Moco<\/a>是一个简单搭建模拟服务器的程序库/工具，这个基于 Java\n    开发的开源项目已经在 Github 上获得了不少的关注。该项目的简介是这样描述自己的：Moco 是一个简单搭建 stub 的框架，主要用于测试和集成。这个框架的开发灵感来自\n    Mock 框架，如 <a href=\"http://code.google.com/p/mockito/\">Mockito<\/a> 和 <a href=\"http://www.playframework.com/\">Playframework<\/a>。<\/p><p>为什么要开发这个框架？<\/p><p>集成，尤其是基于 HTTP 协议的集成――web service、REST 等，在我们的项目开发中被广泛应用。以前，我们每次都要往 Jetty 或 Tomcat 等应用服务器上部署一个新的 WAR。大家都知道，开发部署一个 WAR 的过程是很枯燥的，即使在嵌入式服务器上也是如此。而且，每次我们做一点改动，整个 WAR 都要重新组装。<\/p><p>Moco 的出现，正是为了解决这些问题。开发团队只要根据自己的需要进行相应的配置，就会很方便得到一个模拟服务器。而且，由于 Moco 本身的灵活性，其用途已经不再局限于最初的集成测试，比如，Moco 可以用于移动开发，模拟尚未开发的服务；Moco 还可以用于前端开发，模拟一个完整的 Web 服务器，等等。<\/p><p>在 2013 年<a href=\"https://www.java.net/dukeschoice\">Duke's Choice Awards<\/a>上，Moco 框架被提名为最具创新力的 Java 项目之一，在 Twitter 上得到了 Martin Fowler 的关注，详见《企业系统集成点测试策略》一文在 InfoQ 英文站<\/p><h3 id=\"N1008D\">Moco 下的 Hello World<\/h3><p>首先，您需要：<\/p><ol type=\"1\"><li>配置您的 Java 环境\n<p>下载 Java 程序，并设置好系统环境变量 （PATH， JAVA_HOME）<\/p><\/li><li>安装并配置 Gradle\n<p>具体可以参考<a href=\"http://www.gradle.org/\">http://www.gradle.org/<\/a><\/p><\/li><\/ol><p>接下来，按照下面的步骤安装 Moco<\/p><ol type=\"1\"><li>获取 Moco 源文件<ul class=\"ibm-bullet-list\"><li>使用 git 命令，获取最新的代码<\/li><\/ul><div class=\"codesection\"><pre class=\"displaycode\">git clone https://github.com/dreamhead/moco.git<\/pre><\/div><ul class=\"ibm-bullet-list\"><li>也可以直接下载编译好的 Jar 文件，目前是 0.9.1<\/li><\/ul><p><a href=\"http://repo1.maven.org/maven2/com/github/dreamhead/moco-runner/0.9.1/moco-runner-0.9.1-standalone.jar\">http://repo1.maven.org/maven2/com/github/dreamhead/moco-runner/0.9.1/moco-runner-0.9.1-standalone.jar<\/a><\/p><ol type=\"1\"><li>编译源代码，生成 Jar 文件 (用以编译好的 Jar 文件的，可以忽略这个步骤) 在命令行执行如下的命令<\/li><\/ol><div class=\"codesection\"><pre class=\"displaycode\">cd &lt;moco directory&gt;\n./gradlew build<\/pre><\/div><\/li><li>编写配置文件，以简单的 Hello World 为例\n<div class=\"codesection\"><pre class=\"displaycode\">[\n  {\n    \"response\" :\n      {\n        \"text\" : \"Hello, Moco\"\n      }\n  }\n]<\/pre><\/div><p>将文件以 json 的后缀存储，比如 foo.json<\/p><\/li><li>启动 Moco 服务\n<p>在命令行输入<\/p><div class=\"codesection\"><pre class=\"displaycode\">java -jar moco-runner-&lt;version&gt;-standalone.jar start -p 12306 -c foo.json<\/pre><\/div><p>注：-p 指定 Moco 服务端口 （目前仅指 Web 端口）<\/p><\/li><li>访问 Web 服务\n<p>打开浏览器，访问 http://localhost:12306<\/p><p>您应该可以立即看到久违了的\"Hello World\"<\/p><\/li><\/ol><h3 id=\"N100D5\">Moco 的复杂实例<\/h3><p>实例一， 带参数的 HTTP 请求<\/p><p>有些时候我们希望能够在请求的同时，传递相应的参数。这时我们需要用到\"queries\"关键字<\/p><ul class=\"ibm-bullet-list\"><li>配置文件<\/li><\/ul><div class=\"codesection\"><pre class=\"displaycode\">{\n  \"request\" :\n    {\n      \"uri\" : \"/foo\",\n      \"queries\" :\n        {\n          \"param\" : \"blah\"\n        }\n    },\n  \"response\" :\n    {\n      \"text\" : \"bar\"\n    }\n}<\/pre><\/div><ul class=\"ibm-bullet-list\"><li>启动浏览器，并访问<\/li><\/ul><div class=\"codesection\"><pre class=\"displaycode\">http://localhost:12306/foo?parm=blash<\/pre><\/div><p>实例二，基于正则表达的 URL 匹配<\/p><p>在很多对 URL 请求的测试中，我们希望对于多个相似的 URL，都返回相同的结果<\/p><ul class=\"ibm-bullet-list\"><li>配置文件<\/li><\/ul><div class=\"codesection\"><pre class=\"displaycode\">{\n  \"request\":\n    {\n      \"uri\":\n        {\n          \"match\": \"/\\\\w*/foo\"\n        }\n    },\n  \"response\":\n    {\n      \"text\": \"bar\"\n    }\n}<\/pre><\/div><ul class=\"ibm-bullet-list\"><li>启动浏览器<\/li><\/ul><p>在地址栏输入多个地址（/foo 前带有任意字符， 比如 http://localhost:12306/xxx/foo）<\/p><p>实例三：跳转<\/p><p>页面的自动跳转也是经常在 Web 开发中遇到的问题之一<\/p><ul class=\"ibm-bullet-list\"><li>配置文件<\/li><\/ul><div class=\"codesection\"><pre class=\"displaycode\">{\n  \"request\" :\n    {\n      \"uri\" : \"/redirect\"\n    },\n  \"redirectTo\" : \"http://www.github.com\"\n}<\/pre><\/div><ul class=\"ibm-bullet-list\"><li>启动浏览器访问 http://localhost:12306/redirect<\/li><\/ul><p>页面将会被自动导向到 http://www.github.com<\/p><p>实例三： 返回 JSON 对象<\/p><p>在 Web 开发中，对于 JSON 的操作是最典型的应用<\/p><ul class=\"ibm-bullet-list\"><li>配置文件<\/li><\/ul><div class=\"codesection\"><pre class=\"displaycode\">{\n    \"request\": {\n        \"uri\": \"/json\"\n    },\n    \"response\": {\n        \"json\": {\n            \"foo\" : \"bar\"\n        }\n    }\n}<\/pre><\/div><ul class=\"ibm-bullet-list\"><li>启动浏览器访问 http://localhost:12306/json<\/li><\/ul><p>页面上会显示输出的 JSON 对象<\/p><h3 id=\"N1011C\">Moco 高级用法<\/h3><p>在 Moco 里您还可以发现一些好玩的，或者说高级用法，比如 Asynchronous、Template。具体用法还是参考 Moco 的文档，这里仅以\n    Asynchronous 为例。<\/p><ul class=\"ibm-bullet-list\"><li>编写配置文件\n<div class=\"codesection\"><pre class=\"displaycode\">{\n    \"request\": {\n        \"uri\" : \"/event\"\n    },\n    \"response\": {\n        \"text\": \"event\"\n    },\n    \"on\": {\n        \"complete\": {\n            \"async\" : \"true\",\n            \"post\" : {\n                \"url\" : \"http://another_site\",\n                \"content\": \"content\"\n            }\n        }\n    }\n}<\/pre><\/div><\/li><li>那么对于/event 的访问，将会是异步。<\/li><\/ul><p>也就是说数据并不会立即返回，而是要等到对 http://another_siter 访问结束后，才会将结果放到 Response 里。<\/p><h3 id=\"N1012E\">Moco 的 API 用法<\/h3><p>前面的这些用法在 Moco 里被称为\"Standalone\", 它强调的是 Moco 的简单性和可配置性，而 Moco 的 API 是它的另一个特色，它更加关注如何在测试用例里如何使用 Moco。<\/p><p>我们先看一个基于 Moco 的典型测试用例<\/p><div class=\"codesection\"><pre class=\"displaycode\">import org.junit.Test;\nimport java.io.IOException;\nimport com.github.dreamhead.moco.HttpServer;\nimport org.apache.http.client.fluent.Content;\nimport org.apache.http.client.fluent.Request;\nimport com.github.dreamhead.moco.Runnable;\n\nimport static com.github.dreamhead.moco.Moco.*;\nimport static com.github.dreamhead.moco.Runner.*;\nimport static org.hamcrest.core.Is.is;\nimport static org.junit.Assert.assertThat;\n\n@Test\npublic void should_response_as_expected() throws Exception {\n    HttpServer server = httpserver(12306);\n    server.response(\"foo\");\n\n    running(server, new Runnable() {\n        @Override\n        public void run() throws IOException {\n            Content content = Request.Get(\"http://localhost:12306\").execute().returnContent();\n            assertThat(content.asString(), is(\"foo\"));\n        }\n    });\n}<\/pre><\/div><p>上面的测试用例，描述了如何启动 Moco，以及调用相应的帮助方法来编写测试。<\/p><p>有时我们希望测试用例本身能够控制 Server 的启动和关闭，这里要用到@Before, @After 这些 Junit 里最常用的注释<\/p><div class=\"codesection\"><pre class=\"displaycode\">import org.junit.After;\nimport org.junit.Before;\nimport org.junit.Test;\n\nimport java.io.IOException;\n\nimport static com.github.dreamhead.moco.Moco.httpserver;\nimport static com.github.dreamhead.moco.Runner.runner;\nimport static org.hamcrest.CoreMatchers.is;\nimport static org.junit.Assert.assertThat;\n\npublic class MocoRunnerTest {\n    private Runner runner;\n\n    @Before\n    public void setup() {\n        HttpServer server = httpserver(12306);\n        server.response(\"foo\");\n        runner = runner(server);\n        runner.start();\n        helper = new MocoTestHelper();\n    }\n\n    @After\n    public void tearDown() {\n        runner.stop();\n    }\n\n    @Test\n    public void should_response_as_expected() throws IOException {\n        Content content = Request.Get(\"http://localhost:12306\").execute().returnContent();\n        assertThat(content.asString(), is(\"foo\"));\n    }\n}<\/pre><\/div><h2 id=\"3.Moco+Web 集成测试案例 |outline\">Moco + Web 集成测试案例<\/h2><p>了解了 Moco 的具体使用方法，我们来看一个真实的基于 Moco 的案例，从而理解为什么 Moco 对于 Web 开发人员来说是革命性的！<\/p><p>用例：<\/p><p>在 Web 上调用 Ajax 获取服务器端的版本（version）号，并根据返回的值显示不同的提示信息。<\/p><p>分析：<\/p><p>其实面对这样的需求，我们很容易看出这个用例本身，关注的是\"显示不同的提示信息\"这个功能，至于返回的 version 值，用户根本不必关心或者说这属于系统内部的逻辑。<\/p><p>我们先来看看以前的做法<\/p><ol><li>安装并配置好 Web Server (Tomcat or Apache)<\/li><li>建立必要的 Web 工程文件，导入与项目相关的框架，比如 struts2<\/li><li>如果底层系统是 Java 本身，需要导入或者编译相关的 jar 文件，如果底层用其他的语言开发，就需要步骤 4<\/li><li>搭建底层开发环境或者在编译机器上编译 Lib 或者 so 文件，在确保能够运行的情况下（需要测试脚本）并导入到项目当中<\/li><li>发布 Web 应用并测试，如果底层 API 有变动或者方法调用错误，需要再次运行步骤 4。<\/li><li>编写并测试 Ajax 逻辑。<\/li><\/ol><p>那么我们看看基于 Moco 的开发步骤会是什么样的：<\/p><ul class=\"ibm-bullet-list\"><li>编写配置文件， 这里要用到刚才说的同步方法\n<div class=\"codesection\"><pre class=\"displaycode\">[\n {\n \"env\" : \"remote\",\n \"include\": \"foo.json\",\n },\n {\n \"env\" : \"local\",\n \"include\": \"bar.json\",\n }\n]<\/pre><\/div><\/li><li>启动 Moco 服务\n<div class=\"codesection\"><pre class=\"displaycode\">java -jar moco-runner-&lt;version&gt;-standalone.jar start -p 12306 -g env.json -e remote<\/pre><\/div><p>在很多时候，我们往往将时间浪费在步骤 3，4 中，即使已经有编译好的 Lib 或者 so，还是存在着测试的必要和风险。Web 的开发人员一方面要完成自己开发任务，另一方面还要扮演底层代码测试员角色。<\/p><\/li><li>编写 Web 应用，调用 ajax 请求\n<p>Moco 让开发人员更关注应用本身，而不必将时间和精力花费在 Lib 或者 so 的可用性上，而且没有复杂的 Web 容器配置，关注的就是切实的功能本身。<\/p><\/li><\/ul><p>同时，它的 API 有利于 Web 开发者编写测试用例，将以前部门之间的无效沟通，建立在可度量的测试用例之上，从而提高了 Web 集成测试的可靠性，并有效地降低了集成测试的风险！<\/p><CMA ID: 970951><Site ID: 10><XSLT stylesheet used to transform this file: dw-document-html-7.0.xsl>\r\n\r\n\r\n<\/div>\r\n<\/div>\r\n","createTime":"2014-05-12 00:00:00","deployTime":"2014-05-12 00:00:00","id":0,"intro":"集成测试介于单元测试和系统测试之间，起到“桥梁作用”。具体到 Web 集成测试，由于其自身的“特殊性”往往需要面对更大的挑战，更多的痛点，本文主要是在这个问题上的一些思考性文章，同时为大家推荐 C 2013 年 Oracle Java 大赛的获奖作品 Moco。","keyword":"","recommend":false,"source":"http://www.ibm.com/developerworks/cn/web/1405_liugang_mocowebtest/index.html","title":"Moco 框架以及其在 Web 集成测试的应用","typeId":0,"updateTime":"2014-05-12 00:00:00"}
{"author":"","clickNumber":0,"content":"\r\n<div class=\"ibm-columns\">\r\n<div class=\"ibm-col-1-1\">\r\n\r\n<h2 id=\"major1\">1. IBM SmartCloud iNotes 功能与特点<\/h2><h3 id=\"major2\">简介<\/h3><p>IBM SmartCloud for Social Business 是基于预订的联机服务，提供多个应用程序，可以快捷有效地与同事、供应商和客户进行协作。IBM SmartCloud? iNotes?以下简称 SCiN，主要提供企业日常的业务需求，例如电子邮件、行事历等相关功能。作为一套可靠且应用简单的云方案，本文将为您介绍 SCiN 的基本功能与特点。<\/p><h2 id=\"major3\">2. IBM SamrtCloud iNotes 的架构简介<\/h2><h3 id=\"major4\">架构图<\/h3><h5 id=\"img001\">图 1 架构图<\/h5><img alt=\"图 1 架构图\" src=\"/sunshine_new/images/负581626592/img001.png\" width=\"500\" /><h2 id=\"major5\">3. 功能介绍 - 邮件<\/h2><p>所有的电子邮件存储在文件夹中。您可以创建文件夹以组织自己的电子邮件。有 5 个缺省文件夹不能删除。您还可以标记自己的电子邮件并设置显示电子邮件的首选项。<\/p><p>您无法更改缺省电子邮件文件夹的名称，也无法删除缺省电子邮件文件夹，但可以删除这些缺省文件夹中的电子邮件<\/p><ul class=\"ibm-bullet-list\"><li>收件箱---收到所有的电子邮件<\/li><li>草稿箱---所有已保存，但尚未发送的电子邮件。可以随时编辑和发送草稿箱文件夹中的电子邮件。<\/li><li>已发送邮件---所有已发送的电子邮件 - 只要将首选项设置为在发送时保存所有电子邮件。此设置缺省为是。<\/li><li>垃圾邮件---所有已识别为垃圾邮件的电子邮件。<\/li><li>废纸篓---所有已删除的电子邮件。您必须清空废纸篓文件夹以永久删除其内容，若邮件在废纸篓存放超过 30 天，系统将自动清理这些邮件。<\/li><\/ul><h3 id=\"major6\">建立新邮件<\/h3><p>您可以从联系人列表或邮件文件夹发送电子邮件，并使用富文本编辑器来丰富您的邮件内容。选择文本属性最快的方式是：输入所有消息文本，选择该文本，然后选择所需的属性。如果向不在联系人列表中的收件人发送电子邮件，那么在寄送邮件之后，可以将该收件人添加到联系人列表中。<\/p><h3 id=\"major7\">自动完成表单<\/h3><p>如图 2，在您输入收件人地址时，可输入联系人部分信息，系统将根据您输入的信息，自动查找相对应的联系人，除了您个人的联系人目录外，系统将一并列出符合结果的组与公司目录，为您带来更方便快速的使用体验。<\/p><h5 id=\"img002\">图 2 自动完成表单<\/h5><img alt=\"图 2 自动完成表单\" src=\"/sunshine_new/images/负581626592/img002.png\" width=\"423\" /><h3 id=\"major8\">自动储存<\/h3><p>当您在编写邮件时，系统将定时为您保存当前的邮件内容，降低您遗失邮件内容的风险。如图 3，当您看到信件左上角系统提示「您的邮件已保存」，并于信中右下角看到时间戳提示时，代表您的邮件已被存入草稿文件夹中，您可以选择继续编写此邮件，或由草稿文件夹读出后再进行编写。<\/p><h5 id=\"img003\">图 3 自动储存<\/h5><img alt=\"图 3 自动储存\" src=\"/sunshine_new/images/负581626592/img003.png\" width=\"559\" /><h3 id=\"major9\">搜索邮件<\/h3><p>如图 4，当您想搜索邮件时，除了使用一般的文本搜索，还可以通过使用通配符、布尔运算符和日期范围进而优化您的结果。<\/p><h5 id=\"img004\">图 4 搜索邮件<\/h5><img alt=\"图 4 搜索邮件\" src=\"/sunshine_new/images/负581626592/img004.png\" width=\"454\" /><p>要搜索日期范围，请输入日期范围的上下界。日期范围搜索的格式如下所示：<\/p><p>arrival:[yyyyMMddHHmmssSSS TO yyyyMMddHHmmssSSS]<\/p><p>其中：<\/p><ul class=\"ibm-bullet-list\"><li>yyyy 表示年份<\/li><li>MM 表示一年中的某一个月<\/li><li>dd 表示月份中的日期<\/li><li>HH 表示日期中的小时时间<\/li><li>mm 表示一小时中的某一分钟 <\/li><li>ss 表示分钟中的秒时间 <\/li><li>SSS 表示秒中的毫秒时间<\/li><\/ul><p>例如，要查找从 2013 年 1 月 15 日至 2013 年 10 月 30 日期间收到的电子邮件，请在搜索字段中输入以下项：<\/p><p>arrival:[20130115000000000 TO 20131031000000000] <\/p><h3 id=\"major10\">管理文件夹<\/h3><p>文件夹使您能够以有意义的方式，将信件聚集在一起，您可以轻易的在管理文件夹页面中，添加、重命名和删除文件夹，亦可将个别的电子邮件拖入其他文件夹中。<\/p><p>当您创建好您所需要的文件夹后，只需选取您的电子邮件，将邮件拖曳至左侧的文件夹中，即可轻易的分类邮件。<\/p><h5 id=\"img005\">图 5 将邮件拖至文件夹<\/h5><img alt=\"图 5 将邮件拖至文件夹\" src=\"/sunshine_new/images/负581626592/img005.png\" width=\"542\" /><h2 id=\"major11\">4. 功能介绍 - 联系人<\/h2><h3 id=\"major12\">添加和编辑联系人信息<\/h3><p>您可以添加、编辑和删除您的个人联系人信息，您最多可以拥有 2000 名个人联系人。如果您需要添加或删除企业联系人，请联系您的管理员，此功能需有管理员特权方可进行操作。<\/p><h5 id=\"img006\">图 6 添加联系人<\/h5><img alt=\"图 6 添加联系人\" src=\"/sunshine_new/images/负581626592/img006.png\" width=\"470\" /><h3 id=\"major13\">名片<\/h3><p>在本产品中，随处可通过联系人名片获取此联系人基本信息。<\/p><h5 id=\"img007\">图 7 显示联系人名片<\/h5><img alt=\"图 7 显示联系人名片\" src=\"/sunshine_new/images/负581626592/img007.png\" width=\"497\" /><p>如图 7 所示，在邮件列表中，您可将鼠标移至发件人姓名上方，联系人名片将立刻显示此联系人的基本信息；若您尚未将此联系人加入联系人列表，亦可通过联系人名片，快速的将此联系人加入，如图 8 所示。<\/p><h5 id=\"img008\">图 8 未加入联系人名片<\/h5><img alt=\"图 8 未加入联系人名片\" src=\"/sunshine_new/images/负581626592/img008.png\" width=\"497\" /><h3 id=\"major14\">使用个人组<\/h3><p>使用个人组为日历邀请和电子邮件创建通讯组列表。您的帐户中最多可以有 200 个个人组，每个个人组中成员的最大数目是 50 个。<\/p><p>当您创建好您所需要的个人组后，您可以在寄送电子邮件与发送事件邀请时，使用您创建的个人组，快速的将信息发送给相关的人员。<\/p><h3 id=\"major15\">导入个人联系人<\/h3><p>您可以从逗号分隔值 (csv) 文件、vCard (VCF) 文件或任何不带扩展名的文件名（如 testfile）中导入个人联系人。导入过程接受 10 MB（包含）以内的文件。如果您需要添加企业联系人，请联系您的管理员，此功能需有管理员特权方可进行操作。<\/p><p>您最多可拥有 2000 名联系人。如果您正在导入的 .csv 或 .vcf 文件包含的联系人数量超过 2000 个，或者，如果现有联系人的数目加上 .csv 或 .vcf 文件中联系人的数目超出了 2000 个，那么将忽略导入文件中超出的联系人。<\/p><h3 id=\"major16\">导出个人联系人<\/h3><p>您可以将个人联系人导出到逗号分隔值 (csv) 文件或 vCard (VCF) 文件。此外，您无法导出企业目录中所列的联系人。如果您需要导出企业联系人，请联系您的管理员，此功能需有管理员特权方可进行操作。<\/p><h2 id=\"major17\">5. 功能介绍 - 日历<\/h2><h3 id=\"major18\">创建日历事件<\/h3><p>您可以安排会议或创建各式事件，如预约事件、重复事件、全天事件。<\/p><h5 id=\"img009\">图 9 安排会议<\/h5><img alt=\"图 9 安排会议\" src=\"/sunshine_new/images/负581626592/img009.png\" width=\"468\" /><p>在添加事件中，只需在受邀方字段中输入您想邀请的个别联系人，或是使用您已建立好的个人组，即可快速的安排会议。<\/p><h3 id=\"major19\">安排重复的会议<\/h3><p>您可以快速的安排重复的会议，只需在添加事件中，点击重复，即可依据您的需求安排重复的会议。<\/p><h3 id=\"N1015D\">搜索适合安排会议的空闲时间<\/h3><p>当您使用个人日历安排或编辑事件时，可通过查看空闲状态，取得其他用户的空闲和忙碌时间，以便于您安排会议。<\/p><h5 id=\"img010\">图 10 查看受邀方空闲状态<\/h5><img alt=\"图 10 查看受邀方空闲状态\" src=\"/sunshine_new/images/负581626592/img010.png\" width=\"457\" /><p>如图 10 所示，在创件事件页面中，点击显示空闲状态，即可查看所有受邀者的空闲与忙碌时间。如果受邀者已有安排，该时间段将以褐色区块进行显示。若您想查看其他日期，点击日期选择器，即可快速切换至您想了解的日期。<\/p><h3 id=\"major20\">共享日历<\/h3><p>如图 11 所示，通过共享日历，您可以与整个公司或与选定的用户组共享日程安排。<\/p><h5 id=\"img011\">图 11 共享日历<\/h5><img alt=\"图 11 共享日历\" src=\"/sunshine_new/images/负581626592/img011.png\" width=\"396\" /><p>若有其他联系人将日历分享给您，如图 12 所示，点击我的日历中右方的向下小箭头，再点击查找日历，即可轻易地关注他人的日历。<\/p><h5 id=\"img012\">图 12 查找日历<\/h5><img alt=\"图 12 查找日历\" src=\"/sunshine_new/images/负581626592/img012.png\" width=\"255\" /><p>当您设置完成后，即可轻易的查看您所关注的联系人日历。如图 13 所示，您可以在自己的日历中，同时看到您与其他联系人的日程安排。<\/p><h5 id=\"img013\">图 13 显示关注日历<\/h5><img alt=\"图 13 显示关注日历\" src=\"/sunshine_new/images/负581626592/img013.png\" width=\"594\" /><h2 id=\"major21\">6. 功能介绍 - 首选项<\/h2><h3 id=\"major22\">邮件<\/h3><p>您可以在设置电子邮件首选项中，进一步的依照您个人的喜好阅读、组织、过V和转发您的电子邮件。<\/p><ul class=\"ibm-bullet-list\"><li>邮件显示---在邮件显示中，您可以指定每页上要显示的电子邮件数目，每页最多可显示 100 封邮件，并指定邮件的排列顺序。<\/li><li>阅读---在阅读设置中，您可以指定移动或删除邮件时所发生的情况。图像阻止功能会阻止收到的电子邮件中包含的外部图像，若您想立即看到图像，只需更改此功能设置即可。<\/li><li>发送---在发送设置中，选择发送以保存所有已发送电子邮件的副本，若您不需要此功能，亦可关闭。您还可以指定在回复电子邮件时是否包含电子邮件历史记录。当您发送了一封电子邮件给一位新的联系人，可将发送消息后，询问我是否要添加新联系人，设置为是，此设置将协助您快速的将邮件地址加入至联系人列表中。<\/li><li>不在办公室---无论您因为旅行、突发事件、请假亦或是出差，当您不在办公室时，使用不在办公室通知可在您外出时针对收到的电子邮件发送自动回复。通知服务会在您所指定的离开和返回日期间发送回复，并且仅向各发件人发送一封回复。<\/li><li>签名---想设计一个个性化的签名吗？在设置设签名中，您可以使用富文本编辑器来设计一个独特的签名，设置完成后，系统将自动添加到所有要发送的电子邮件末尾。<\/li><li>邮件服掌魃柚---若您想通过一般的邮件客户端对您的 SCiN 进行查看和发送电子邮件，可以使用 IMAP 或 POP 访问以及 SMTP 认证来设置各种电子邮件程序。如图 14 所示，此信息可通用于配置您邮件客户端的 IMAP、POP 或 SMTP。<\/li><\/ul><h5 id=\"img014\">图 14 邮件服掌魃柚<\/h5><img alt=\"图 14 邮件服掌魃柚\" src=\"/sunshine_new/images/负581626592/img014.png\" width=\"355\" /><p>更多信息：<\/p><p>1. 收信和外发邮件服务器需要使用用户名和密码才能成功发送和接收电子邮件。<\/p><p>2. 如果电子邮件客户端提出要求，请选中与需要认证的接收和外发邮件服务器有关的任何复选框。此外，确保对收信和外发邮件服务器使用相同的设置。如果不满足此需求，那么可能无法发送或接收电子邮件。<\/p><p>3.SSL 必须开启。<\/p><p>4. 因特网连接的速度会影响设置 IMAP 或 POP 所需的时间。<\/p><p>5.IMAP 为首选协议。如果 IMAP 不可用，请使用 POP。<\/p><p>6. 通过 IMAP 访问电子邮件时，文件夹名称的最大长度为 255 个字符，并且最多可以有 5 个文件夹级别。文件夹名称中的非 ASCII 字符使用含 UTF-7 的 base64 进行编码。<\/p><ul class=\"ibm-bullet-list\"><li>转发---如图 15 所示，您可以指定向其他电子邮件帐户自动转发收到的电子邮件，需要注意的是，您只能指定一个电子邮件帐户用于转发电子邮件。<\/li><\/ul><h5 id=\"img015\">图 15 转发<\/h5><img alt=\"图 15 转发\" src=\"/sunshine_new/images/负581626592/img015.png\" width=\"367\" /><p>当您设置完成后，会有一封提示电子邮件发送到您信箱中。<\/p><p>此外，会有一封确认电子邮件发送到您指定的电子邮件地址，如果您要启动邮件转发过程，请遵循确认电子邮件中的指示信息。<\/p><p>您随时可以取消邮件转发，如图 16，在转发窗口中选择不转发即可。<\/p><h5 id=\"img016\">图 16 取消转发电子邮件<\/h5><img alt=\"图 16 取消转发电子邮件\" src=\"/sunshine_new/images/负581626592/img016.png\" width=\"342\" /><ul class=\"ibm-bullet-list\"><li>规则---在规则页面中，如图 17，您可以创建规则，以便按发件人、收件人和主题过滤收到的电子邮件。如果收到的电子邮件满足多个过滤规则，那么会使用规则列表中的第一个规则来过滤该电子邮件，您也可以重新排序过滤规则，以便应用其他规则。<\/li><\/ul><h5 id=\"img017\">图 17 规则<\/h5><img alt=\"图 17 规则\" src=\"/sunshine_new/images/负581626592/img017.png\" width=\"367\" /><p>您可以依照您的需求，创建不同的电子邮件过V规则，这将更有效地帮助您管理电子邮件。如图 18，通过规则设置，可以将电子邮件自动放入不同文件夹或转发给其他用户。<\/p><h5 id=\"img018\">图 18 创建规则<\/h5><img alt=\"图 18 创建规则\" src=\"/sunshine_new/images/负581626592/img018.png\" width=\"270\" /><h3 id=\"major23\">日历<\/h3><p>通过设置日历首选项，您可以指定在工作日通常工作的小时数，以及典型工作周的起始日。当您设置完成后，切换到日历页面，如图 19 所示，系统将依据您的设置进行显示。若您想查看工作时间之外的时间段，只需点击显示工作时间之前的时间，或是显示工作时间之后的时间，即可进行查看。<\/p><h5 id=\"img019\">图 19 自订日历显示<\/h5><img alt=\"图 19 自订日历显示\" src=\"/sunshine_new/images/负581626592/img019.png\" width=\"576\" /><h3 id=\"major24\">联系人<\/h3><p>在设置联系人首选项页面中，您可以选择在联系人列表里，每一页所显示的联系人数目，并且依照您的习惯显示联系人的姓名信息。<\/p><h3 id=\"major25\">其他 C iOS 设备设置<\/h3><p>您可以使用个人档案，在您的 iOS 设备上通过一次操作设置邮件 (IMAP)、联系人 (CardDAV) 和日历 (CalDAV)。此外如果您不希望在 iOS 设备上同时对这三个功能进行设置，您也可以分别设置您所需的功能。<\/p><p>设置方式：<\/p><p>1. 请在 iOS 设备上的浏览器窗口中输入以下 URL，或使用快速响应 (QR) 代码浏览到该页面。<\/p><p>2. 请遵循提供的指示信息操作<\/p><p>URL:<a href=\"https://usw.mail.collabserv.com/mobile/dav/profile\">https://usw.mail.collabserv.com/mobile/dav/profile<\/a><\/p><h2 id=\"major26\">7. 与 BSS 的集成<\/h2><p>您可以在帐户设置中，轻地变更姓名或是更新您的所在的时区以及您所习惯的语言。<\/p><h3 id=\"major27\">变更姓名<\/h3><p>进入帐户设置页面后，在姓名字段中点击更改链结，即可进入到变更姓名页面，输入您的姓名后，点击保存更改，将立即在导航栏中显示您更新后的姓名。如图 20。<\/p><h5 id=\"img020\">图 20 导航栏更新<\/h5><img alt=\"图 20 导航栏更新\" src=\"/sunshine_new/images/负581626592/img020.png\" width=\"521\" /><h3 id=\"major28\">变更语言与时区<\/h3><p>SCiN 目前总共支持 22 种语言。SCiN 显示的语言主要取决于您在帐户设置中的设置，进入帐户设置页面后，在本地化字段中点击更改链结，即可进入到变更本地化页面，选择您习惯的语言与您需要的时区，点击保存更改，系统将立即使用您的设置。<\/p><p>值得一提的是，您为本地化选择的语言决定了在日历中采用 12 小时制还是 24 小时制显示。例如，如果选择英语或中文 (简体)，那么系统将采用 12 小时制显示。如果选择日语，那么系统则采用 24 小时制显示。<\/p><CMA ID: 972536><Site ID: 10><XSLT stylesheet used to transform this file: dw-document-html-7.0.xsl>\r\n\r\n\r\n<\/div>\r\n<\/div>\r\n","createTime":"2014-05-09 00:00:00","deployTime":"2014-05-09 00:00:00","id":0,"intro":"IBM SmartCloud for Social Business 是基于预订的联机服务，提供多个应用程序，可以快捷有效地与同事、供应商和客户进行协作。","keyword":"","recommend":false,"source":"http://www.ibm.com/developerworks/cn/lotus/ls-cn-smartcloud-inotes/index.html","title":"IBM SmartCloud iNotes 基本功能与特点介绍","typeId":0,"updateTime":"2014-05-09 00:00:00"}
{"author":"","clickNumber":0,"content":"\r\n<div class=\"ibm-columns\">\r\n<div class=\"ibm-col-1-1\">\r\n\r\n<h2 id=\"major1\">背景介绍<\/h2><p> 近年来，商业分析（Business Analytics，BA）软件逐渐成为企业增强洞察力的利器。其中，IBM SPSS Statistics\n                是统计分析领域中久享盛名的应用软件。企业在实际运营中，已根据不同的业务需求，开发或购买了满足自身需求的商业数据整合方案，并期待与\n                Statistics 进行集成，以便更高效、准确的分析数据，提取数据中隐含的信息。<\/p><p>Statistics 不仅为用户提供了丰富的统计算法来帮助用户分析数据，而且也提供了非常灵活的编程接口，供外部用户将自定义的功能模块与\n                Statistics 集成。用户可以通过自定义模块对 Statistics 进行功能扩展。借助\n                Statistics，用户自定义模块可以获得更加完整、有意义的输入数据。<\/p><p>Statistics 16.0（及以上）为用户提供了的可编程插件（Programmability plug-ins）包括 Python\n                plug-in、R plug-in 和 Microsoft .NET plug-in。其中，Python\n                语法简洁而清晰、具有丰富强大的类库，并且其能够很轻松的与其他语言实现的模块集成在一起。所以，本文将使用 Python 功能模块作为演示。<\/p><h3 id=\"minor1.1\">Customer Dialog 简介<\/h3><p>Statistics 在编程插件的基础上提供了 Extension Command 机制使用户能够以 Statistics 内部语法命令（syntax\n                command） 的形式来包装使用编程插件开发出来的功能模块。Customer Dialog 为 Extension Command\n                提供了相应的用户界面。<\/p><p>Customer Dialog 允许用户创建符合 Statistics 界面风格的对话窗口，以及创建自定义的 Statistics\n                内置统计程序。对话窗口作为该统计程序的用户界面，可接受并传递基于用户输入的参数，并调用相应的内置统计程序。通过 Customer Dialog\n                Builder，用户可以<\/p><ol type=\"1\"><li> 创建自定义的对话过程，调用内置统计程序。<\/li><li> 为一组扩展命令集创建用户界面。扩展命令是指，用户自定义的、由 Python 或 R 实现的 SPSS Statistics\n                    命令。<\/li><li> 保存创建完成的 Customer Dialog，并将其安装至 Statistics 中。<\/li><\/ol><h3 id=\"minor1.2\">Statistics Syntax 和 Python\n                plug-in 简介<\/h3><p>SPSS Statistics 具备强大的数据处理和分析功能，除了提供友好、灵活的 UI 操作界面外，Statistics\n                为其所有的功能设计了相应的命令，即 Statistics 的语法 Syntax。除此之外，Syntax 具有高级编程的功能，可以完成比 UI\n                所提供的功能更为复杂的数据分析工作。SPSS Statistics 内核是基于命令驱动的，Syntax 是其灵魂。用户在 UI\n                界面的所有操作，均会被转换成 Syntax 命令传递至内核执行。详见下图。<\/p><h5 id=\"fig1\">图 1. Statistics 执行过程<\/h5><img alt=\"图 1. Statistics 执行过程\" src=\"/sunshine_new/images/负2046989534/image001.jpg\" width=\"263\" /><p>Python plug-in 和 Statistics 产品的交互方式很灵活。用户既可以在自定义的 Python 代码中引入 SPSS 模块，运用\n                Statistics 完成数据的读取、处理、分析、输出任务，也可以在 Syntax 中直接加入 Python 代码块（BEGIN PROGRAM\n                PYTHON-END PROGRAM）来控制 Syntax 工作流。本文采用了后一种方式。如：<\/p><h5 id=\"fig2\">图 2. Python Plug-in 程序段 1<\/h5><img alt=\"图 2. Python Plug-in 程序段 1\" src=\"/sunshine_new/images/负2046989534/image002.jpg\" width=\"206\" /><p>使用 Python Plug-in 的好处是，可以动态的创建 string 字符串以及 Syntax 命令。<\/p><h2 id=\"major2\">集成方法论述<\/h2><p>由上节讨论可知，我们可以利用 Statistics 中的 Python Plug-in 对自定义 Python 模块进行集成，包括：利用\n                Customer Dialog 设计满足用户习惯的 UI 交互界面；编写内置统计程序；与 Statistics 进行集成。<\/p><p>本文设计的 Python\n                功能模块实现了一种客户分群方法。其依据大量的客户属性数据和消费数据，将客户分组，属于同一组的客户具有极大的相似性，可以采用相同的商业策略；不同组的客户具有极大的差异性，保证组与组之间的差别最大化，以便采取不同的商业策略，获得最大的商业利润。<\/p><h3 id=\"minor2.1\">UI 界面设计及参数传递<\/h3><p>本节将讨论 UI 界面的布局以及 UI 参数传递。在设计 UI 界面前，我们首先应该明确，Python 功能模块所需的输入参数，这些参数将出现在 UI\n                界面上。同时，若模块功能较为复杂，可以添加子对话过程实现特定的功能。该功能模块的输入包括：数据文件、控制文件以及最大分组数。输出为客户分群结果文件，包括用户的基本信息以及所属的群组号。子对话的功能为客户分群结果上传至数据库。<\/p><p>运行 Utilities -&gt; Customer Dialog Builder，出现 Customer Dialog\n                编辑界面。通过拖拽控件的方式，用户可以快捷地对界面进行编辑，并且指定相应控件的属性。各属性含义参见 <a href=\"http://pic.dhe.ibm.com/infocenter/spssstat/v20r0m0/index.jsp?topic=%2Fcom.ibm.spss.statistics.help%2Fuibuilder_manage.htm&amp;lang%3Dzh_CN\">Statistics 教程<\/a>。<\/p><h5 id=\"fig3\">图 3. Customer Dialog 1- 主对话框界面<\/h5><img alt=\"图 3. Customer Dialog 1- 主对话框界面\" src=\"/sunshine_new/images/负2046989534/image003.jpg\" width=\"528\" /><p>图中，该 dialog 有 5 个控件。Item 1 为该对话窗口的标题，将显示在该窗口的标题栏中；Item 2、Item 3 以及 Item 4\n                用于用户输入 Python 功能模块参数 , 分别为控制文件路径，数据文件路径以及最大分组数；Item 5\n                为该对话窗口的子对话窗口，用于实现特定子功能。本文中设计的子功能是将 Python 模块的执行结果上传至数据库中。Item 5 的 UI\n                界面如下图。<\/p><h5 id=\"fig4\">图 4. Customer Dialog 2 C\n                    子对话框界面<\/h5><img alt=\"图 4. Customer Dialog 2 C 子对话框界面\" src=\"/sunshine_new/images/负2046989534/image004.jpg\" width=\"524\" /><p>图 4 中 Item 6 为子对话框的标题，Item 7、Item8 以及 Item9 用于输入上传数据库所需参数，分别为 DSN\n                名称、数据库名称，以及待建的数据表名。<\/p><p>以 Item 2 为例，我们演示如何传递参数。下图为 Item 2 的属性。<\/p><h5 id=\"fig5\">图 5. Customer Dialog 3 C 控件属性<\/h5><img alt=\"图 5. Customer Dialog 3 C 控件属性\" src=\"/sunshine_new/images/负2046989534/image005.jpg\" width=\"500\" /><p>其中，属性“Identifier”用于传递参数，如图中的“control_file_path”。它记录用户的输入值，在 Python\n                程序中，以“%%”标记对读出该输入值，传递给 Syntax 和 Python 程序。传递过程如下图所示。<\/p><h5 id=\"fig6\">图 6. Python Plug-in 程序段 2 C Python\n                    Plug-in 参数传递<\/h5><img alt=\"图 6. Python Plug-in 程序段 2 C Python Plug-in 参数传递\" src=\"/sunshine_new/images/负2046989534/image006.jpg\" width=\"370\" /><p>编辑好 UI 界面后，将其保存为 customer dialog package file(.spd) 文件，本文中为\n                CustomerClustering.spd。使用“Preview”功能，对界面进行预览。<\/p><h5 id=\"fig7\">图 7. Customer Dialog 4 - Preview\n                    1<\/h5><img alt=\"图 7. Customer Dialog 4 - Preview 1\" src=\"/sunshine_new/images/负2046989534/image007.jpg\" width=\"306\" /><p>图 7 红框部分是子对话窗口按钮，用户点击该按钮将出现子对话框，如下图所示。<\/p><h5 id=\"fig8\">图 8. Customer Dialog 5 - Preview\n                    2<\/h5><img alt=\"图 8. Customer Dialog 5 - Preview 2\" src=\"/sunshine_new/images/负2046989534/image008.jpg\" width=\"287\" /><p>在设计子对话窗口控件属性时，我们为“DSN”以及“Database Name”设置了默认值“TEST”。<\/p><h3 id=\"minor2.2\">集成 Python 功能模块<\/h3><p>本文涉及到的自定义 Python 模块主要实现两类功能。一类是客户分群，是用嵌入了 Python 程序的 Syntax 实现\n                (CustomerClustering.sps) ；另一类是分群结果上传至数据库，是用 Python 脚本实现\n                (UploadtoDatabase.py)。我们利用 Customer Dialog 里的 Syntax Template 将 UI 参数与\n                Python 程序进行关联。<\/p><ol type=\"1\"><li><strong>集成客户分群功能<\/strong><\/li><\/ol><p>在集成该功能时，本文选择了 Statistics 提供的“INSERT”命令。该命令用法详见 <a href=\"http://pic.dhe.ibm.com/infocenter/spssstat/v20r0m0/index.jsp?topic=%2Fcom.ibm.spss.statistics.help%2Fuibuilder_manage.htm&amp;lang%3Dzh_CN\">Statistics 教程<\/a>。我们通过用户从 UI 界面的输入 control_file_path、input_file_path\n                获得待操作的数据集，通过 max_clusters_ui 获取到命令文件运行所需参数，并将该参数赋值给变量\n                max_clusters。max_clusters 为命令文件中定义的全局变量 , 以实现参数传递。最后，我们利用 spss.Submit( )\n                函数执行该命令。至此，内置统计程序在运行时，可以调用指定的命令文件，并将运行时参数传递给该命令文件。具体实现如下图所示。<\/p><h5 id=\"fig9\">图 9. 集成客户分群功能<\/h5><img alt=\"图 9. 集成客户分群功能\" src=\"/sunshine_new/images/负2046989534/image009.jpg\" width=\"419\" /><ol start=\"2\" type=\"1\"><li><strong>集成数据库上传功能<\/strong><\/li><\/ol><p>出于安全性考虑，我们将 UploadtoDatabase.py 文件编辑为二进制的 UploadtoDatabase.pyc\n                文件以避免暴露源代码，所以图中“import UploadtoDatabase”所引入的实际为 .pyc 文件。这里，在引入 .pyc\n                文件时，需要指定所引入文件的路径，即“sys.path.append('C:\\\\Integration\\\\PythonScript\\\\')”所示。dsn，db_name\n                和 db_tablename 为用户通过 UI 界面传递的数据库信息。调用方法如下。<\/p><h5 id=\"fig10\">图 10. 集成数据库上传功能<\/h5><img alt=\"图 10. 集成数据库上传功能\" src=\"/sunshine_new/images/负2046989534/image010.jpg\" width=\"355\" /><p>图中 UploadtoDatabase 中 run 函数的声明和实现方式如下：<\/p><h5 id=\"fig11\">图 11. Python Script 主函数定义<\/h5><img alt=\"图 11. Python Script 主函数定义\" src=\"/sunshine_new/images/负2046989534/image011.jpg\" width=\"455\" /><h3 id=\"minor2.3\">保存 Python 功能模块运行结果<\/h3><p>我们可以将 Python 功能模块的运行结果保存为指定格式文件，或上传至数据库。使用 Syntax “SAVE TRANSLATE\n                OUTFILE”命令可将运行结果保存为指定格式的文件。其中，数据集 RESULT 为 Python\n                功能模块的输出数据集，output_result_file 为待保存文件的文件名。我们首先设置操作的主数据集是 RESULT，然后使用\n                spss.Submit( ) 函数执行保存输出结果命令，就可以将 RESULT 数据集保存为指定格式的文件。具体命令如下。<\/p><h5 id=\"fig12\">图 12. 文件保存程序段<\/h5><img alt=\"图 12. 文件保存程序段\" src=\"/sunshine_new/images/负2046989534/image012.jpg\" width=\"424\" /><p>本例中，我们将 RESULT 数据集分别保存为 .csv 文件以及 .sav 文件。除此之外，我们还可以利用 ODBC 连接将输出数据集 RESULT\n                上传至数据库，为此，我们需要在系统中设定 DSN（Data Source Name）。DSN 为 ODBC 指定了某一数据源和相对应的 ODBC\n                驱动程序。接着，使用 Syntax “SAVE TRANSLATE ”命令实现上传数据库功能，具体命令如下。<\/p><h5 id=\"listing1\">清单 1. 数据库上传程序段<\/h5><div class=\"codesection\"><pre class=\"displaycode\"> begin program python. \n import spss \n import spssaux \n\n DSN = r\"%%DSN%%\"\n db_name=r\"%%DBName%%\"\n table_name=r\"%%TableName%%\"\n spss.Submit(\"dataset active RESULTS . \\n\") \n spss.Submit(\"execute . \\n\") \n\n varcount=spss.GetVariableCount() \n data_str = spss.GetVariableName(0) \n if spss.GetVariableType(0) &gt; 0: \n    data_type_str=spss.GetVariableName(0)+' '+'varchar'\n else: \n    data_type_str=spss.GetVariableName(0)+' '+ 'double'\n\n for i in range(1,varcount): \n    data_str = data_str +', '+ spss.GetVariableName(i) \n    data_type_str = data_type_str +', \n'+spss.GetVariableName(i) \n    if spss.GetVariableType(i) &gt; 0: \n        data_type_str = ' '+data_type_str+' ' +'varchar'\n    else: \n        data_type_str = ' '+data_type_str+' ' + 'double'\n print DSN,db_name,table_name \n\n commands=\"\"\" \n     SAVE TRANSLATE /TYPE=ODBC \n /CONNECT='DSN=\"\"\"+DSN+\"\"\";UID= ;PWD=,3;DBALIAS=\"\"\"+db_name+ \n\"\"\";'\n  /ENCRYPTED \n  /MISSING=IGNORE \n  /SQL='CREATE TABLE \"\"\"+table_name+\"\"\" \n (\"\"\"+data_type_str+\"\"\" )'\n  /REPLACE \n  /TABLE='SPSS_TEMP'\n  /KEEP=All \n  /SQL='INSERT INTO \"\"\"+table_name+\"\"\" (\"\"\"+data_str+\"\"\") \n SELECT \"\"\"+data_str+\"\"\" FROM SPSS_TEMP'\n  /SQL='DROP TABLE SPSS_TEMP'.\"\"\"\n print commands \n spss.Submit(commands) \n end program.<\/pre><\/div><p>我们首先取得数据集 RESULT 中各数据值及其类型，根据这些数据信息用 SQL 命令在数据库中创建数据表，该表的表名是由用户通过 UI\n                界面指定的。<\/p><h3 id=\"minor2.4\">与 Statistics 进行集成<\/h3><p>在 Customer Dialog 中设计完 UI 界面，把 UI 界面与上述的 Python 程序进行关联后，我们需要在 Statistics\n                中安装该 Customer Dialog，便于用户通过 UI 来使用我们自定义的 Python 功能模块。安装方式如图。<\/p><h5 id=\"fig13\">图 13. 安装 Customer Dialog 1<\/h5><img alt=\"图 13. 安装 Customer Dialog 1\" src=\"/sunshine_new/images/负2046989534/image013.jpg\" width=\"436\" /><p>如图所示，在 Customer Dialog Builder 界面选择 File -&gt;\n                Install，选择保存好的对话框文件（CustomerClustering.spd）并指定安装位置本例中我们把创建的名为 Customer\n                Clustering 的功能安装 至 Utilities 菜单下。安装完成结果如下所示。<\/p><h5 id=\"fig14\">图 14. 安装 Customer Dialog 2<\/h5><img alt=\"图 14. 安装 Customer Dialog 2\" src=\"/sunshine_new/images/负2046989534/image014.jpg\" width=\"388\" /><p>如图所示，Statistics 的菜单栏 Utilities 下，出现了我们自定义的功能模块 Customer Clustering。<\/p><h2 id=\"major3\">自定义 Python\n                模块运行演示及结果分析<\/h2><p>本节分为两部分，讨论如何利用 Statistics 对自定义 Python 功能模块进行数据预处理以及对该功能模块的执行结果进行分析。<\/p><h3 id=\"minor3.1\">数据预处理<\/h3><p>在大多数数据分析中，原始数据不适合直接使用，而需要进行预处理才能满足需求。比如，将多个小分类值组合为一个大分类值，或将一个连续变量转换成分类变量，这可以使得分析结果更易理解。本文需要把连续型变量“销售额”定义为一组分类变量，如：高、中、低，从而提高了数据的易用性。同时会使用\n                Statistics 的 Visual Binning 对功能模块输入数据进行预处理。<\/p><p>下面是处理过程。输入数据文件如下所示：<\/p><h5 id=\"fig15\">图 15. 输入文件演示<\/h5><img alt=\"图 15. 输入文件演示\" src=\"/sunshine_new/images/负2046989534/image015.jpg\" width=\"464\" /><p>如图所示，我们需要对三类销售额进行分类，分别为“SALES_RETAIL”、“SALES_ONLINE”以及“SALES_TOTAL”。我们以“SLAES_RETAIL”为例，其余两个变量处理过程与其类似。<\/p><p>在 Statistics 工具栏中，选择 Transform -&gt; Visual Binning，出现 Visual Binning\n                对话框，选中“SALES_RETAIL”，如下图所示。<\/p><h5 id=\"fig16\">图 16. Visual Binning 1<\/h5><img alt=\"图 16. Visual Binning 1\" src=\"/sunshine_new/images/负2046989534/image016.jpg\" width=\"292\" /><p>选择“Continue”，指定新变量名 B_SALES_RETAIL。在“Grid”栏设置分类点（bin cut\n                point）。这里，我们依据业务含义，选择了 9 个分类点，并点击 Make Lable 按钮，Statistics\n                会自动为分类变量生成标签。<\/p><h5 id=\"fig17\">图 17. Visual Binning 2<\/h5><img alt=\"图 17. Visual Binning 2\" src=\"/sunshine_new/images/负2046989534/image017.jpg\" width=\"550\" /><p>如图所示，我们把原始的“SALES_RETAIL”变量分为了 10\n                类，由图示可知，连续型变量“SALES_RETAIL”的值，将会分别落入分类类型\"B_SALES_RETAIL\"的 10\n                个分类值中。运行结果部分展示如下图所示。<\/p><h5 id=\"fig18\">图 18. Visual Binning 3<\/h5><img alt=\"图 18. Visual Binning 3\" src=\"/sunshine_new/images/负2046989534/image018.jpg\" width=\"527\" /><h3 id=\"minor3.2\">示例 Python 模块集成结果演示<\/h3><p>原始数据的经过预处理后，已经满足了本文用户自定义功能模块的数据要求。现在，用户可以直接进入 Utilities-&gt;Customer\n                Clustering，来调用自定义的方法并获得结果。<\/p><p>运行 Statistics 工具栏 Utilities -&gt; Customer Clustering ，出现自定义对话框。<\/p><h5 id=\"fig19\">图 19. 集成结果演示 1<\/h5><img alt=\"图 19. 集成结果演示 1\" src=\"/sunshine_new/images/负2046989534/image019.jpg\" width=\"320\" /><p>如图所示，输入所需参数，红框部分为我们数据预处理 Visual Binning 后的输入文件，用户规定最大分组为 8，则共有 9 个客户分群，分别为\n                0 至 8。点击“OK”运行，运行结果保存为 .csv 文件和 .sav 文件。除此之外，我们还可以将执行结果上传至数据库。点击“Upload to\n                Database”，出现如下子对话框。<\/p><h5 id=\"fig20\">图 20. 集成结果演示 2<\/h5><img alt=\"图 20. 集成结果演示 2\" src=\"/sunshine_new/images/负2046989534/image020.jpg\" width=\"320\" /><p>如图所示，输入上传数据库所需参数，表“CustomerClustering”用于存储客户分群结果。<\/p><p>输出结果文件如下图所示。<\/p><h5 id=\"fig21\">图 21. 集成结果演示 3<\/h5><img alt=\"图 21. 集成结果演示 3\" src=\"/sunshine_new/images/负2046989534/image021.jpg\" width=\"516\" /><p>其中，“CUSTOMER_CLUSTER”为客户的分组信息，如 Customer ID 分别为 1 的客户，属于分组\n                5。数据库上传结果如下所示。<\/p><h5 id=\"fig22\">图 22. 集成结果演示 4<\/h5><img alt=\"图 22. 集成结果演示 4\" src=\"/sunshine_new/images/负2046989534/image022.jpg\" width=\"551\" /><p>由图可知，我们在指定数据库 TEST 中，创建了表 CUSTOMERCLUSTERING，红框 3 中为 CUSTOMERCLUSTER\n                属性，其包含了客户所属分组信息。<\/p><h3 id=\"minor3.3\">示例 Python 模块集成结果分析<\/h3><p>为了更加清楚的了解客户分群情况，我们可以利用 Statistics 中的 Frequencies 方法对其进行分析。分析结果如下。<\/p><h5 id=\"N101ED\">表 1. 统计结果<\/h5><table border=\"0\" cellpadding=\"0\" cellspacing=\"0\" class=\"ibm-data-table\" summary=\"\"><thead xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"><tr><th align=\"center\" colspan=\"3\">Statistics<\/th><\/tr><\/thead><tbody xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"><tr><td align=\"center\" colspan=\"3\">USTOMER_CLUSTER<\/td><\/tr><tr><td align=\"center\" rowspan=\"2\" valign=\"middle\">N<\/td><td> Valid <\/td><td> 50000 <\/td><\/tr><tr><td> Missing <\/td><td> 0 <\/td><\/tr><tr><td colspan=\"2\">Median<\/td><td> 4.0000 <\/td><\/tr><tr><td colspan=\"2\">Mode<\/td><td> 1.00 <\/td><\/tr><\/tbody><\/table><p>由表 1 可知，输出结果中，针对客户分组“CUSTOMER_CLUSTER”共有 50000 条有效的客户记录，其中中位数为分组\n                4，说明大部分的客户都集中在前半部分的分组当中（分组 1 至分组 4），分组 1 拥有最多的客户。表 1\n                只能提供给我们大概的统计结果，业务含义较少，详细统计信息如下。<\/p><h5 id=\"N10220\">表 2. 统计结果明细<\/h5><table border=\"1\" cellpadding=\"0\" cellspacing=\"0\" class=\"ibm-data-table\" summary=\"\"><thead xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"><tr><th align=\"center\" colspan=\"6\">CUSTOMER_CLUSTER<\/th><\/tr><\/thead><tbody xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"><tr><td colspan=\"2\"/><td> Frequency <\/td><td> Percent <\/td><td> Valid Percent <\/td><td> Cumulative Percent <\/td><\/tr><tr><td rowspan=\"10\"> Valid <\/td><td> .00 <\/td><td> 427 <\/td><td> .9 <\/td><td> .9 <\/td><td> .9 <\/td><\/tr><tr><td> 1.00 <\/td><td> 6217 <\/td><td> 12.4 <\/td><td> 12.4 <\/td><td> 13.3 <\/td><\/tr><tr><td> 2.00 <\/td><td> 6190 <\/td><td> 12.4 <\/td><td> 12.4 <\/td><td> 25.7 <\/td><\/tr><tr><td> 3.00 <\/td><td> 6194 <\/td><td> 12.4 <\/td><td> 12.4 <\/td><td> 38.1 <\/td><\/tr><tr><td> 4.00 <\/td><td> 6191 <\/td><td> 12.4 <\/td><td> 12.4 <\/td><td> 50.4 <\/td><\/tr><tr><td> 5.00 <\/td><td> 6188 <\/td><td> 12.4 <\/td><td> 12.4 <\/td><td> 62.8 <\/td><\/tr><tr><td> 6.00 <\/td><td> 6191 <\/td><td> 12.4 <\/td><td> 12.4 <\/td><td> 75.2 <\/td><\/tr><tr><td> 7.00 <\/td><td> 6194 <\/td><td> 12.4 <\/td><td> 12.4 <\/td><td> 87.6 <\/td><\/tr><tr><td> 8.00 <\/td><td> 6208 <\/td><td> 12.4 <\/td><td> 12.4 <\/td><td> 100.0 <\/td><\/tr><tr><td> Total <\/td><td> 50000 <\/td><td> 100.0 <\/td><td> 100.0 <\/td><td/><\/tr><\/tbody><\/table><p>由表 2 可知，分组 0 拥有最少的客户数 427，分组 1 拥有最多的客户数 6217，并且客户较为均匀的分布在分组 1 至分组\n                8。客户分布情况图如下。<\/p><h5 id=\"fig23\">图 23. 客户分组图示<\/h5><img alt=\"图 23. 客户分组图示\" src=\"/sunshine_new/images/负2046989534/image023.jpg\" width=\"524\" /><p>上图是对客户分群情况更为直观的展示，分组 1 至分组 8 拥有较多的客户，且分布较均匀。针对分组\n                0，由于其人数较少，业务优先级较低，我们可以对该组客户采用一般的销售策略。而对于分组 1 至分组\n                8，由于其人数较多，业务优先级较高，我们需要对该组客户进行进一步的分析，以便采取更加准确的销售策略，提升客户的忠诚度，减少客户流失。<\/p><h2 id=\"major4\">结束语<\/h2><p>本文介绍了用户自定义 Python 功能模块与 IBM SPSS Statistics\n                集成的方法，并对集成结果进行了演示与分析。通过本文，读者可以了解，如何设计满足用户习惯的 UI 交互界面，如何编写内置统计程序，以及如何与\n                Statistics 进行集成。<\/p><CMA ID: 970476><Site ID: 10><XSLT stylesheet used to transform this file: dw-document-html-7.0.xsl>\r\n\r\n\r\n<\/div>\r\n<\/div>\r\n","createTime":"2014-05-08 00:00:00","deployTime":"2014-05-08 00:00:00","id":0,"intro":"本文介绍了如何将用户自定义的功能模块与 IBM SPSS Statistics 进行集成， 如何利用 Statistics 提供的统计分析方法对功能模块的输入数据进行预处理，并对集成结果进行分析与演示。","keyword":"","recommend":false,"source":"http://www.ibm.com/developerworks/cn/data/library/ba/1405-ba-spss-statistics-integration/index.html","title":"IBM SPSS Statistics 与用户自定义 Python 模块的集成及分析","typeId":0,"updateTime":"2014-05-08 00:00:00"}
{"author":"","clickNumber":0,"content":"\r\n<div class=\"ibm-columns\">\r\n<div class=\"ibm-col-1-1\">\r\n\r\n<div class=\"dw-sidebar ibm-inset\"><h2 id=\"N1004D\">关于本系列<\/h2><p>Java&#8482; 传承的是平台，而不是语言。有超过 200 种语言可以在 JVM 上运行，它们之中不可避免地会有一种语言最终取代\n                    Java 语言，成为编写 JVM 程序的最佳方式。本系列将探讨三种下一代 JVM 语言：Groovy、Scala 和\n                    Clojure，比较并对比新的功能和范例，让 Java 开发人员对自己近期的未来发展有大体的认识。<\/p><\/div><p>\n                函数式编程语言包含多个系列的常见函数。但开发人员有时很难在语言之间进行切换，因为熟悉的函数具有不熟悉的名称。函数式语言倾向于基于函数范例来命名这些常见函数。从脚本背景衍生而来的语言倾向于使用更具描述性的名称（有时是多个名称，包含多个指向同一个函数的别名）。 <\/p><p> 在本期文章中，我将继续探讨 3 种重要函数（过滤、映射和缩减）的实用性，展示来自每种 Java 下一代语言的实现细节。文中的讨论和示例旨在减轻 3\n                种语言对类似函数结构使用的不一致名称时可能引起的混淆。 <\/p><h2 id=\"N10059\">过滤<\/h2><p> 在<em>过滤<\/em>\n                    函数中，您可指定一个布尔值条件（通常为一个高阶函数的形式），将它应用到一个集合。该函数返回集合的子集，其中的元素与该条件匹配。过滤与<em>查找<\/em>\n                函数紧密相关，后者返回集合中第一个匹配的元素。 <\/p><h3 id=\"N10066\">Scala<\/h3><p> Scala 拥有多个过滤函数变体。最简单的情形基于传递的条件来过滤某个列表。在第一个示例中，我创建一个数字列表。然后使用了\n                <code>filter()<\/code> 函数，并传递了一个代码块，指定了所有元素都可以被 3 整除的条件： <\/p><div class=\"codesection\"><pre class=\"displaycode\">val numbers = List.range(1, 11)\nnumbers filter (x =&gt; x % 3 == 0)\n// List(3, 6, 9)<\/pre><\/div><p> 我可依靠隐式的参数来创建该代码快的更加简洁的版本： <\/p><div class=\"codesection\"><pre class=\"displaycode\">numbers filter (_ % 3 == 0)\n// List(3, 6, 9)<\/pre><\/div><p> 第二个版本不那么冗长，因为在 Scala 中，您可以将参数替换为下划线。两个版本都可以得到相同的结果。 <\/p><p> 过滤操作的许多示例都使用了数字，但 <code>filter()<\/code> 适用于任何集合。此示例将 <code>filter()<\/code>\n                应用到一个单词列表来确定 3 字母单词： <\/p><div class=\"codesection\"><pre class=\"displaycode\">val words = List(\"the\", \"quick\", \"brown\", \"fox\", \"jumped\", \"over\", \"the\", \"lazy\", \"dog\")\nwords filter (_.length == 3)\n// List(the, fox, the, dog)<\/pre><\/div><p> Scala 中的另一个过滤函数变体是 <code>partition()<\/code>\n                函数，它将一个集合拆分为多个部分。这种拆分基于您传递的高阶函数来确定分离条件。在这里，<code>partition()<\/code>\n                函数将返回两个列表，它们依据哪些列表成员可被 3 整除来进行拆分： <\/p><div class=\"codesection\"><pre class=\"displaycode\">numbers partition (_ % 3 == 0)\n// (List(3, 6, 9),List(1, 2, 4, 5, 7, 8, 10))<\/pre><\/div><p><code>filter()<\/code> 函数返回一个匹配元素集合，而 <code>find()<\/code> 仅返回第一个匹配元素： <\/p><div class=\"codesection\"><pre class=\"displaycode\">numbers find (_ % 3 == 0)\n// Some(3)<\/pre><\/div><p> 但是，<code>find()<\/code> 的返回值不是匹配的值本身，而是一个包装在 <code>Option<\/code>\n                类中的值。<code>Option<\/code> 有两个可能的值：<code>Some<\/code> 或\n                <code>None<\/code>。像其他一些函数式语言一样，Scala 使用 <code>Option<\/code>\n                作为一种约定来避免在缺少某个值时返回 <code>null<\/code>。<code>Some()<\/code> 实例包装实际的返回值，在\n                <code>numbers find (_ % 3 == 0)<\/code> 的情况下，该值为\n                <code>3<\/code>。如果我尝试查找某个不存在的值，那么返回值将为 <code>None<\/code>： <\/p><div class=\"codesection\"><pre class=\"displaycode\">numbers find (_ &lt; 0)\n// None<\/pre><\/div><p> Scala 还包含多个函数，它们基于一个判定函数来处理一个集合并返回值或丢弃它们。<code>takeWhile()<\/code>\n                函数返回集合中满足判定函数的最大的值集： <\/p><div class=\"codesection\"><pre class=\"displaycode\">List(1, 2, 3, -4, 5, 6, 7, 8, 9, 10) takeWhile (_ &gt; 0)\n// List(1, 2, 3)<\/pre><\/div><p><code>dropWhile()<\/code> 函数跳过满足判定条件的最大元素数量：<\/p><div class=\"codesection\"><pre class=\"displaycode\">words dropWhile (_ startsWith \"t\")\n// List(quick, brown, fox, jumped, over, the, lazy, dog)<\/pre><\/div><h3 id=\"N100CF\">Groovy<\/h3><p> Groovy 不是一个函数式语言，但它包含许多函数范例，一些范例的名称源自脚本语言。例如，在函数式语言中，该函数在传统上被称为\n                <code>filter()<\/code> 的函数，就是 Groovy 中的 <code>findAll()<\/code> 方法： <\/p><div class=\"codesection\"><pre class=\"displaycode\">(1..10).findAll {it % 3 == 0}\n// [3, 6, 9]<\/pre><\/div><p> 像 Scala 的过滤函数一样，Groovy 可处理所有类型，包括字符串： <\/p><div class=\"codesection\"><pre class=\"displaycode\">def words = [\"the\", \"quick\", \"brown\", \"fox\", \"jumped\", \"over\", \"the\", \"lazy\", \"dog\"]\nwords.findAll {it.length() == 3}\n// [The, fox, the, dog]<\/pre><\/div><p> Groovy 还有一个类似 <code>partition()<\/code> 的函数，称为 <code>split()<\/code>： <\/p><div class=\"codesection\"><pre class=\"displaycode\">(1..10).split {it % 3}\n// [[1, 2, 4, 5, 7, 8, 10], [3, 6, 9]]<\/pre><\/div><p><code>split()<\/code> 方法的返回值是一个嵌套数组，就像 Scala 中从 <code>partition()<\/code>\n                返回的嵌套列表。 <\/p><p> Groovy 的 <code>find()<\/code> 方法返回集合中第一个匹配的元素： <\/p><div class=\"codesection\"><pre class=\"displaycode\">(1..10).find {it % 3 == 0}\n// 3<\/pre><\/div><p> 不同于 Scala，Groovy 遵循 Java 约定，在 <code>find()<\/code> 未能找到元素时返回\n                <code>null<\/code>： <\/p><div class=\"codesection\"><pre class=\"displaycode\">(1..10).find {it &lt; 0}\n// null<\/pre><\/div><p> Groovy 还拥有 <code>takeWhile()<\/code> 和 <code>dropWhile()<\/code> 方法，它们具有与\n                Scala 的版本类似的语义： <\/p><div class=\"codesection\"><pre class=\"displaycode\">[1, 2, 3, -4, 5, 6, 7, 8, 9, 10].takeWhile {it &gt; 0}\n// [1, 2, 3]<\/pre><\/div><div class=\"codesection\"><pre class=\"displaycode\">words.dropWhile {it.startsWith(\"t\")}\n// [quick, brown, fox, jumped, over, the, lazy, dog]<\/pre><\/div><p> 与 Scala 示例中一样，<code>dropWhile<\/code>\n                被用作一个专门的过滤器：它丢弃与判定条件匹配的最大前缀，仅过滤列表的第一部分： <\/p><div class=\"codesection\"><pre class=\"displaycode\">def moreWords = [\"the\", \"two\", \"ton\"] + words\nmoreWords.dropWhile {it.startsWith(\"t\")}\n// [quick, brown, fox, jumped, over, the, lazy, dog]<\/pre><\/div><h3 id=\"N1011F\">Clojure<\/h3><p> Clojure 拥有令人震惊的集合操作例程数量。由于 Clojure 的动态类型，其中许多例程都是通用的。许多开发人员倾向于使用\n                Clojure，因为它的集合库非常丰富和灵活。Clojure 使用传统的函数式编程名称，如 <code>(filter )<\/code> 函数所示： <\/p><div class=\"codesection\"><pre class=\"displaycode\">(def numbers (range 1 11))\n(filter (fn [x] (= 0 (rem x 3))) numbers)\n; (3 6 9)<\/pre><\/div><p> 像其他语言一样，Clojure 为简单的匿名函数提供了简洁的语法： <\/p><div class=\"codesection\"><pre class=\"displaycode\">(filter #(zero? (rem % 3)) numbers)\n; (3 6 9)<\/pre><\/div><p> 而且与其他语言中一样，Clojure 的函数适用于任何适用的类型，比如字符串： <\/p><div class=\"codesection\"><pre class=\"displaycode\">(def words [\"the\" \"quick\" \"brown\" \"fox\" \"jumped\" \"over\" \"the\" \"lazy\" \"dog\"])\n(filter #(= 3 (count %)) words)\n; (the fox the dog)<\/pre><\/div><p> Clojure 的 <code>(filter )<\/code> 返回类型为\n                <code>Seq<\/code>，它通过圆括号来描述。<code>Seq<\/code> 是 Clojure 中的顺序集合的核心抽象。 <\/p><h2 id=\"N10141\">映射<\/h2><p> 所有 Java\n                下一代语言中常见的第二个主要的函数变形是<em>映射<\/em>。映射函数接受一个高阶函数和一个集合，然后向每个元素应用传递的函数并返回一个集合。返回的集合（不同于过滤）的大小与原始集合相同，但更新了值。 <\/p><h3 id=\"N1014B\">Scala<\/h3><p> Scala 的 <code>map()<\/code> 函数接受一个代码块并返回转换的集合： <\/p><div class=\"codesection\"><pre class=\"displaycode\">List(1, 2, 3, 4, 5) map (_ + 1)\n// List(2, 3, 4, 5, 6)<\/pre><\/div><p><code>map()<\/code>\n                函数适用于所有适用的类型，但它不一定返回集合元素的已转换集合。在此示例中，我在一个字符串中返回所有元素的大小列表： <\/p><div class=\"codesection\"><pre class=\"displaycode\">words map (_.length)\n// List(3, 5, 5, 3, 6, 4, 3, 4, 3)<\/pre><\/div><p> 在函数式编程语言中常常会产生嵌套列表，以至于嵌套列表对解除嵌套（通常称为<em>扁平化<\/em>）的库支持很常见。以下是扁平化一个嵌套列表的示例： <\/p><div class=\"codesection\"><pre class=\"displaycode\">List(List(1, 2, 3), List(4, 5, 6), List(7, 8, 9)) flatMap (_.toList)\n// List(1, 2, 3, 4, 5, 6, 7, 8, 9)<\/pre><\/div><p> 获得的 <code>List<\/code> 中仅包含元素，删除了额外的基础架构。<code>flatMap<\/code>\n                函数也适用于可能未以传统方式嵌套的数据结构。例如，您可将一个字符串视为一个嵌套字符系列： <\/p><div class=\"codesection\"><pre class=\"displaycode\">words flatMap (_.toList)\n// List(t, h, e, q, u, i, c, k, b, r, o, w, n, f, o, x, ...<\/pre><\/div><h3 id=\"N10172\">Groovy<\/h3><p> Groovy 还包含多个称为 <code>collect()<\/code> 的映射变体。默认的变体接受一个代码块，以便将该变体应用到集合的每个元素： <\/p><div class=\"codesection\"><pre class=\"displaycode\">(1..5).collect {it += 1}\n// [2, 3, 4, 5, 6]<\/pre><\/div><p> 像其他语言一样，Groovy 允许对简单的匿名高阶函数使用简写；<code>it<\/code> 保留字用于替代单独的参数。 <\/p><p><code>collect()<\/code> 方法适用于您可向其提供合理的判定条件的任何集合，比如一个字符串列表： <\/p><div class=\"codesection\"><pre class=\"displaycode\">def words = [\"the\", \"quick\", \"brown\", \"fox\", \"jumped\", \"over\", \"the\", \"lazy\", \"dog\"]\nwords.collect {it.length()}\n// [3, 5, 5, 3, 6, 4, 3, 4, 3]<\/pre><\/div><p> Groovy 还有一个类似于 <code>flatMap()<\/code> 的折叠内部结构的方法，称为\n                <code>flatten()<\/code>： <\/p><div class=\"codesection\"><pre class=\"displaycode\">[[1, 2, 3], [4, 5, 6], [7, 8, 9]].flatten()\n// [1, 2, 3, 4, 5, 6, 7, 8, 9]<\/pre><\/div><p><code>flatten()<\/code> 方法也适用于不太明显的集合，比如字符串： <\/p><div class=\"codesection\"><pre class=\"displaycode\">(words.collect {it.toList()}).flatten()\n// [t, h, e, q, u, i, c, k, b, r, o, w, n, f, o, x, j, ...<\/pre><\/div><h3 id=\"N1019D\">Clojure<\/h3><p> Clojure 包含一个 <code>(map )<\/code> 函数，它接受一个高阶函数（其中包含运算符）和一个集合： <\/p><div class=\"codesection\"><pre class=\"displaycode\">(map inc numbers)\n; (2 3 4 5 6 7 8 9 10 11)<\/pre><\/div><p><code>(map )<\/code> 的第一个参数可以是任何接受单个参数的函数：命名函数、匿名函数或已存在的函数，比如递增其参数的\n                <code>inc<\/code>。此示例中演示了更典型的匿名语法，它生成一个字符串中的单词长度的集合： <\/p><div class=\"codesection\"><pre class=\"displaycode\">(map #(count %) words)\n; (3 5 5 3 6 4 3 4 3)<\/pre><\/div><p> Clojure 的 <code>(flatten )<\/code> 函数类似于 Groovy 的： <\/p><div class=\"codesection\"><pre class=\"displaycode\">(flatten [[1 2 3] [4 5 6] [7 8 9]])\n; (1 2 3 4 5 6 7 8 9)<\/pre><\/div><h2 id=\"N101BC\">折叠/缩减<\/h2><p> 在 3 种 Java 下一代语言中，第三个常见函数在名称上拥有最多变体和许多细微的区别。<em>foldLeft<\/em> 和\n                    <em>reduce<\/em> 是一个名为 <em>catamorphism<\/em>\n                的列表操作概念上的特定变体，该概念是列表折叠的一种泛化。在此示例中，“折叠左侧” 表示： <\/p><ol><li>使用一个二进制函数或运算符将列表的第一个元素与第二个元素相结合，创建一个新的第一个元素。<\/li><li>重复第一步，直到列表用完且您得到一个单一元素。<\/li><\/ol><p> 请注意，这是您在对一组数字求和时所做的操作：从 0 开始，加第一个元素，将结果与第二个元素相加，一直执行此操作，直到列表元素被用完为止。 <\/p><h3 id=\"N101D3\">Scala<\/h3><p> Scala 拥有最丰富的折叠运算集合，这是因为它在一定程度上简化了动态类型的 Groovy 和 Clojure\n                中没有的多种类型场景。缩减函数常用于执行求和： <\/p><div class=\"codesection\"><pre class=\"displaycode\">List.range(1, 10) reduceLeft((a, b) =&gt; a + b)\n// 45<\/pre><\/div><p> 提供给 <code>reduce()<\/code> 的函数通常是一个接受两个参数，并返回单个结果的函数或运算符，以便可以使用一个列表。您可以使用\n                Scala 的语法糖来缩短函数定义： <\/p><div class=\"codesection\"><pre class=\"displaycode\">List.range(1, 10).reduceLeft(0)(_ + _)\n// 45<\/pre><\/div><p><code>reduceLeft()<\/code>\n                函数假设第一个元素是运算的左侧。对于相加等运算符，操作数的位置无关紧要，但放置顺序对相除等运算至关重要。如果希望反转运算符应用的顺序，可以使用\n                <code>reduceRight()<\/code>： <\/p><div class=\"codesection\"><pre class=\"displaycode\">List.range(1, 10) reduceRight(_ - _)\n// 5<\/pre><\/div><p> 了解何时可使用缩减等高级抽象是掌握函数编程的一个关键。此示例使用 <code>reduceLeft()<\/code> 来确定集合中最常的单词： <\/p><div class=\"codesection\"><pre class=\"displaycode\">words.reduceLeft((a, b) =&gt; if (a.length &gt; b.length) a else b)\n// jumped<\/pre><\/div><p> 缩减和折叠运算拥有重叠的功能，它们具有细微的差别，但这不属于本文的讨论范围。但是，通常可以看到它们的一个明显区别。在 Scala 中，签名\n                <code>reduceLeft[B &gt;:A](op:(B, A) =&gt; B):B<\/code>\n                表明惟一想要的参数就是组合元素的函数。初始值应该是集合中的第一个值。相对而言，签名\n                <code>foldLeft[B](z:B)(op:(B, A) =&gt; B):B<\/code>\n                表示结果的一个初始种子值，所以您可以返回与列表元素类型不同的类型。 <\/p><p>以下是一个使用 <code>foldLeft<\/code> 对集合求和的示例： <\/p><div class=\"codesection\"><pre class=\"displaycode\">List.range(1, 10).foldLeft(0)(_ + _)\n// 45<\/pre><\/div><p> Scala 支持运算符重叠，所以两个常见的折叠操作 <code>foldLeft<\/code> 和 <code>foldRight<\/code>\n                分别拥有相应的运算符：<code>/:<\/code> 和 <code>:\\<\/code>。因此，您可以使用\n                <code>foldLeft<\/code> 创建 <code>sum<\/code> 的简洁版本： <\/p><div class=\"codesection\"><pre class=\"displaycode\">(0 /: List.range(1, 10)) (_ + _)\n// 45<\/pre><\/div><p> 类似地，要找到一个列表中每个元素的级联区别（求和运算的反向操作，无可否认这种需求很少见），您可以使用\n                <code>foldRight()<\/code> 函数或 <code>:\\<\/code> 运算符： <\/p><div class=\"codesection\"><pre class=\"displaycode\">(List.range(1, 10) :\\ 0) (_ - _)\n// 5<\/pre><\/div><h3 id=\"N10229\">Groovy<\/h3><p> Groovy 通过使用重叠来支持与 Scala 的 <code>reduce()<\/code> 和 <code>foldLeft()<\/code>\n                选项相同的功能，从而进入缩减类别。该函数的一个版本接受一个初始值。此示例使用 <code>inject()<\/code> 方法生成一个集合的总和： <\/p><div class=\"codesection\"><pre class=\"displaycode\">(1..10).inject {a, b -&gt; a + b}\n// 55<\/pre><\/div><p> 替代形式接受一个初始值： <\/p><div class=\"codesection\"><pre class=\"displaycode\">(1..10).inject(0, {a, b -&gt; a + b})\n// 55<\/pre><\/div><p> Groovy 拥有一个比 Scala 或 Clojure 小得多的函数库 &#8212; Groovy\n                是一种不强调函数式编程的多范例编程，看到这种情况毫不奇怪。 <\/p><h3 id=\"N10245\">Clojure<\/h3><p> Clojure 主要是一种函数式编程语言，所以它支持 <code>(reduce )<\/code>。<code>(reduce )<\/code>\n                函数接受一个可选的初始值，以便同时涵盖 Scala 所处理的 <code>reduce()<\/code> 和\n                <code>foldLeft()<\/code> 情形。<code>(reduce )<\/code>\n                函数没有给用户带来任何惊喜。它接受一个需要两个参数的函数和一个集合： <\/p><div class=\"codesection\"><pre class=\"displaycode\">(reduce + (range 1 11))\n; 55<\/pre><\/div><p> Clojure 将对类似 <code>reduce<\/code> 的功能的高级支持包含在一个名为 <em>reducers<\/em>\n                的库中，后面的一期文章将会介绍这个库。 <\/p><h2 id=\"N10266\">结束语<\/h2><p> 学习不同范例（比如函数式编程）的部分挑战在于学习新术语。在不同社区使用不同的词汇时，这一过程会变得更加复杂。但一旦掌握了相似性，您就会看到，所有 3\n                种 Java 下一代语言都以令人惊奇的方式在语法上提供了重叠的功能。 <\/p><p> 在下一期中，我将探讨 Java 下一代语言中的<em>内存化<\/em>，讨论函数特性如何结合使用来实现简洁有力。 <\/p><CMA ID: 970398><Site ID: 10><XSLT stylesheet used to transform this file: dw-document-html-7.0.xsl>\r\n\r\n\r\n<\/div>\r\n<\/div>\r\n","createTime":"2014-05-08 00:00:00","deployTime":"2014-05-08 00:00:00","id":0,"intro":"上一期 Java 下一代文章（“函数式编码风格”）对比和比较了 Scala、Groovy 和 Clojure 中的函数式编码风格。在本文中，系列作家 Neal Ford 将会更深入地剖析 Java 下一代语言中的过滤、映射和缩减（reduce）功能。文中提供的一系列简短的编码示例可帮助您整理这 3 种语言在命名这些重要的函数结构的方式上的比较容易混淆的区别。","keyword":"","recommend":false,"source":"http://www.ibm.com/developerworks/cn/java/j-jn11/index.html","title":"Java\n            下一代: 克服同义词干扰","typeId":0,"updateTime":"2014-05-08 00:00:00"}
{"author":"","clickNumber":0,"content":"\r\n<div class=\"ibm-columns\">\r\n<div class=\"ibm-col-1-1\">\r\n\r\n<h2 id=\"major1\">引言<\/h2><p>IBM 在 2012 年 6 月 15 日发布的 WebSphere Application Server （以下简称为 WAS）V8.5。WAS V8.5 中的一个重大变化，就是将之前独立的产品 WebSphere Virtual Enterprise （以下简称为 WVE）的功能完全并入到了 WAS 中。之前由 WVE 提供的相关功能，在 WAS V8.5 中，我们称之为智能管理。智能管理中包括了应用程序版本管理、动态集群、健康管理和智能路由。本文主要向您介绍应用程序版本管理这个功能。<\/p><p>应用程序版本管理的目标就是在不间断对外服务的情况下，部署和管理应用程序版本。<\/p><h2 id=\"major2\">应用程序版本管理相关概念<\/h2><p><strong>应用程序版本管理器<\/strong><\/p><p>不间断的生产应用程序部署是由 应用程序版本管理器来控制的，它是应用程序版本管理中的核心组件。在此类环境中安装应用程序更新时，能够使应用程序不间断对外提供服务。<\/p><p>应用程序版本管理器提供了应用程序版本控制模型，访模型支持在智能管理单元中对同一应用程序进行多次布署。每次部署都使用唯一版本名。通过应用程序版本管理器，可以选择要在智能管理集群上进行激活的版本，这样，您可以执行转出应用程序更新或还原为先前的级别。<\/p><p>应用程序版本管理器与智能管理完全集成在一起，从而与随需应变路由器（ODR）、动态工作负载均衡和应用程序布置管理器进行交互。此集成确保在对应用程序进行更新时可预测应用程序的行为，并在系统继续管理应用程序性能目标的同时，确保从一个应用程序版本平滑地转移至另一个应用程序版本。可以使用管理控制台访问应用程序更新过程，其中包括在应用程序服务器之间进行的版本激活操作。对应用程序编程接口进行脚本编制使版本管理功能能够与自动执行的应用程序部署集成在一起。<\/p><p>Java EE 应用程序支持应用程序版本，包括 EAR 文件和符合批处理编程模型的批处理应用程序。<\/p><p>WAS 本身提供了一个称为转出更新的管理功能。转出更新提供了基本的应用程序升级，但是它间断的。应用程序版本管理器是升级应用程序的首选方式。应用程序版本管理器支持应用程序的整个生命周期，并支持对生产环境中运行的应用程序的更新和无缝的的不间断的应用程序部署。<\/p><p><strong>运行环境<\/strong><\/p><p>应用程序版本管理器运行的环境就是一个智能管理单元。如下图所示，应用程序版本管理器管理部署到动态集群中的应用程序，这些集群通过随需应变路由器（ODR）接受工作请求。<\/p><h5 id=\"fig1\">图 1. 带有 ODR 和动态集群的应用程序版本管理器示意图<\/h5><img alt=\"图 1. 带有 ODR 和动态集群的应用程序版本管理器示意图\" src=\"/sunshine_new/images/472436315/images/image01.jpg\" width=\"582\" /><p>智能管理也支持 SIP 协议<\/p><p>应用程序版本管理器提供不间断的应用程序更新，但仅限于通过 HTTP 和 HTTPS 经由 ODR 来访问应用程序。在应用程序升级期间，如果不是借助 HTTP 和 HTTPS 并通过另一个 ODR 层来实现应用程序间访问，那么不能确保访问的服务的连续性，例如，不能确保一个 Java EE 应用程序对另一个应用程序所进行的调用的服务连续性。<\/p><p><strong>版本兼容性<\/strong><\/p><p>该应用程序版本管理器仅支持版本转出兼容的应用程序升级，这表示无中断升级仅用于与以前版本兼容的版本。当您部署包含具有不兼容更改的版本时，您可能需要采用并行激活模式并使用路由规则来分离先前版本的用户与当前版本的用户之间的请求流量。借助并行激活，可以同时主管同一应用程序的多个版本，同时每个版本支持载然不同且不交叉的用户集。但是并行激活可能不提供不间断升级。<\/p><p>在部署应用程序版本的时候，要考虑如下的兼容性问题：<\/p><ul class=\"ibm-bullet-list\"><li>\n应用程序接口或语义：在尝试版本切换的时候，如果应用程序版本之间的接口或是语义发生的变化，那么正在使用应用程序的活动用户就会受到影响。更改的例子包括对现有接口的改变，其中包括修改或移除现有接口。另外，对接口语义的行为的变化也会影响到现有的活动用。例如，如果某一接口原来允许某一参数为 null，然后又修改为要求同一参数不能为 null。对于现在用户有有影响的变化被认为是不向后兼容的，也不能是做为不间断更新的一部分。如果对现有用户的影响不是问题的话，那么就可以考虑使用 WAS 的转出更新。<\/li><li>\n HTTP 会话状态：如果 HTTP 会话状态是可持久化或者可复制的，那么应用程序中添加或改变存储在会话中数据的类型也被视为是不兼容的变化。当前版本可能没办法使用之前版本创建的会话状态信息。<\/li><li>\n Web 内容高速缓存：如果新版本的应用程序包含了对于静态 Web 内容的缓存，而您正使用 ODR 缓存内容的，那么您可能需要在做版本转出的时候，手动的清除一下缓存。<\/li><\/ul><p><strong>Version 与 Edition<\/strong><\/p><p>术语 Version 和 Edition  对开和构建环境与部署和操作环境进行了区分。Version 是连续分代的界面、功能、实现或整个应用程序等的集合。Version 是一个开发和构建的概念。Edition 是连续部署分代，例如，对一组受版本控制的特定工件进行的部署。Edition 是一个部署和运营的概念。<\/p><p>应用程序版本是指对特定应用程序的唯一部署。在 WAS 管理环境中，应用程序版本由应用程序名和版本名组合进行唯一标识的应用程序。虽然同一应用程序的多个版本具有相同的应用程序名，但是具有不同的版本名。版本名可以是数字，例如 1.0 或 2.0；名称也可是描述性的，例如 first edition 或 blue edition。<\/p><h2 id=\"major3\">版本转出算法<\/h2><p>许多业务应用程序都需要稳定的可用性。应用程序可用性的标准主张将应用程序部署在应用服务器集群上。集群的冗余对于能否提供持续可用性至关重要。不间断的应用程序更新指的是在维持应用程序可用性的同时进行更新的能力。换句话说，在进行应用程序更新期间，应用程序的用户不会遇到服务中断的情况。<\/p><p>对某个版本执行转出时，会将活动版本替换为新版本。要提供无中断应用程序更新，对版本执行转出操作包含以下项：<\/p><ul class=\"ibm-bullet-list\"><li>\n阻止服务器接收新的请求。<\/li><li>\n在特定的服务器上停止应用程序的请求。<\/li><li>\n停止当前活动版本。<\/li><li>\n启动新版本。<\/li><li>\n恢复发向新版本应用程序的请求流。<\/li><\/ul><p>不间断更新有两种基本模式：组转出或原子转出。转出新版本时所执行的步根据选择的不同而有所不同。<\/p><p><strong>注意<\/strong>：在转出期间会将动态集群的模式置为手动方式。如果在转出期间负载变重，那么智能管理也不会进行负载均衡之类的操作，所以要避免在业务高峰期，进行转出。当转出结束之后，动态集群又会回复到原来的模式。<\/p><h3 id=\"minor3.1\">分组转出<\/h3><p>分组转出是将集群中的服务器分成若干个组，并定义组的大小，这是指定一次要处理的节点数量。对某个组执行转出，可以使该组中的服务器同时更新到新版本。在管理控制台中一次仅可在一个组上执行转出操作。当新版本中的任何成员变为可用时，所有的请求都将路由至该新版本。<\/p><p>在您对版本执行转出时，集群中的某些服务器会已经从旧版本切换到新版本，某些服务器正在进行切换，而其他服务器尚未开始切换。如果有任何服务器上的应用程序是最新版本，其实例处理活动状态并且正在运行，那么所有应用程序请求都将发送到该服务器。例如，当您执行版本 1.0 到 2.0 的转出操作时，一旦版本 2.0 在某个服务器中变为可用，那么所有应用程序请求都将由版本 2.0 进行处理。任何仍在运行版本 1.0 的服务器都不会对请求进行处理，直到此服务器更新为版本 2.0。以下是组转出示意图：<\/p><h5 id=\"fig2\">图 2. 组转出示例<\/h5><img alt=\"图 2. 组转出示例\" src=\"/sunshine_new/images/472436315/images/image02.jpg\" width=\"582\" /><p>执行组转出时，会在服务器组中跨集群转出。每个服务器都会执行以下步骤：<\/p><ol type=\"1\"><li>停顿向服务器发送请求。<\/li><li>停止应用程序或停止服务器。<\/li><li>更新服务器配置。<\/li><li>重新启动应用程序或服务器。<\/li><li>服务器就绪，可使用新版本应用程序。<\/li><\/ol><h3 id=\"minor3.2\">原子转出<\/h3><p>对某个版本执行原子转出就是一次替换半个集群上的版本，以使用一致的应用程序版本处理所有用户请求。所有用户请求都由旧版本或新版本进行处理，而不是由两个版本同时处理。<\/p><p>原子转出确保所有应用程序请求都由一致的版本进行处理，例如，由版本 1.0 或 2.0 进行处理，而不是由两者同时进行处理。当前版本可用的版本从组成集群一半的服务器上脱机。虽然新版本在那些服务器中激活并启动，但那些服务器保持脱机直到下一步完成为止。下一步是使剩下一半集群中的服务器上当前处于活动状态的版本脱机。此时任何务器上都没有旧版本或新版本的实例可用于处理应用程序请求。ODR 将临时对到达应用程序的任何请求进行排队。在后一半集群上的应用程序完脱机后，前一半集群将返回到联机状态。集群的后半部分将从先前版本切换到新版本，并返回联机状态。以下示例是原子转出示意图：<\/p><h5 id=\"fig3\">图 3. 原子转出示意图<\/h5><img alt=\"图 3. 原子转出示意图\" src=\"/sunshine_new/images/472436315/images/image03.jpg\" width=\"582\" /><p>在您执行原子转出前，需要确定目标服务器集群的负载能力。执行原子转出时实际上只有一半集群有服务请求。所以选择原子转出方式时，最好事先验证一半集群是否能在转出期间能否处理整个负载。<\/p><p>选择执行原子转出时，会执行下列步骤：<\/p><ol type=\"1\"><li>\n停顿向一半服务器发送请求。<\/li><li>\n停止前一半服务器中应用程序或服务器。<\/li><li>\n更新配置，激活新版本的应用程序。<\/li><li>\n启动前一半应用服务器中应用程序或服务器。<\/li><li>\n停顿向后一半服务器发送请求。<\/li><li>\n开始将请求路由到前一半服务器运的新版本。<\/li><li>\n在后一半服务器上，停止应用程序或服务器，更新配置，然后启动应用程序或服务器。<\/li><li>\n转出完成。<\/li><\/ol><h3 id=\"minor3.3\">两种典型使用场景<\/h3><p>接下来，我将通过示例给您讲解应用程序版本管理的两种典型使用场景：并行激活和版本验证<\/p><p><strong>并行激活<\/strong><\/p><p>并行激活是指同时激活并启用同一应用程序的多个版本。并行处于活动状态的版本可以向一组用户提供对一个版本的访问权，而向其他用户提供另一个版本的访问权。使用并行激活时，必须建立路由策略以便对具有某个版本的访问权的用户予以区别。路由策略作为应用程序配置元数据的一部分。另外，路由策略可防止产生歧义并确定哪个版本获取控制权。<\/p><p>使用场景举例：某电信运营商<\/p><p>用户需求：因地域不同，资费标准、套餐内容、优惠促销活动也不同，所以需要同一应用程序的在各地的版本略有不同，并要求这些版本同时运行，根据用户登录 IP 来将用户请求路由到相应版本的应用程序上去。<\/p><h5 id=\"fig4\">图 4. 并行激活场景示意图<\/h5><img alt=\"图 4. 并行激活场景示意图\" src=\"/sunshine_new/images/472436315/images/image04.gif\" width=\"577\" /><p>操作过程：<\/p><p>首先必须至少将这个应用程序的不同版本安装到不同的目标集群上去。例如，my_application 应用程序 1.0 安装在 dynamic_cluster_1 动态集群上，而应用程序版本 2.0 安装在 dynamic_cluster_2 动态集群上，以此类推，关于如何安装应用程序参见参考资源。<\/p><ol type=\"1\"><li>激活应用程序版本。单击应用程序 &gt; 版本控制中心 &gt; <em>application_name<\/em>。选择不活动的版本，并单击 <strong>激活<\/strong>。<\/li><li>为了能够来自不同 IP 的请求路由到不同的应用程序版本上，我们需要事先设定路由策略，具体做法参见参考资源<\/li><li>验证 ODR 是否正常运行。单击 <strong>服务器 &gt; 随需应变路由器<\/strong>。要路由请求，状态必须是 <strong>已启动<\/strong>。<\/li><\/ol><p>这样我们就完成了并行激活， ODR 会根据事先设定好的路由策略将请求路由到不同的<\/p><p><strong>验证版本<\/strong><\/p><p>验证某个版本是确定新版本是否可用并准备移动到生产环境和替换当前版本的过程。它会在生产环境中克隆一套跟生产环境一模一样的环境，来用于新版本的测试。采用这种方式，使得您的生产应用程序可以继续维护请求同时，在真实的生产条件下安装和验证新版本。<\/p><p>使用场景举例：某全球购物网站<\/p><p>用户需求：购物网站竞争激烈，需要根据市场情况，随时推出并更新促销活动，要求新版本上线之前，能够在与生产环境相同的环境下进行测试，并要求在应用程序更新时，不间断对外面服务。<\/p><h5 id=\"fig5\">图 5. 验证版本场景示意图<\/h5><img alt=\"图 5. 验证版本场景示意图\" src=\"/sunshine_new/images/472436315/images/image05.gif\" width=\"576\" /><p>操作步骤：<\/p><p>首先，确保将应用程序布署到相同的动态集群中。版本 1.0 处于活动状态并且在动态集群上运行。版本 2.0 是候选验证版本，已安装同一动态集群并处不活动状态。<\/p><ol type=\"1\"><li>\n单击 <strong>应用程序 &gt; 版本控制中心<\/strong>以验证是否安装了应用程序的两个版本，而且只有其中一个版本处理活动状态。<\/li><li>\n在版本控制中心，选择版本 2.0 并单击 <strong>验证<\/strong>。“验证状态”页显示了如何在当动态集群  dynamic_cluster 上验证新版本和将版本 2.0 部署到克隆集群上的第个步骤。应用和序版本控制中心显示了其中一个版本处于验证方式，而“管理版本”页显示了版本 2.0 是部署在 dynamic_cluster-Validation 动态集群上的。“动态集群”页面显示创建了 dynamic_cluster-Validation 这样一个克隆的动态集群，而“服务器”页面显示了克隆的服务器。<\/li><\/ol><p>提示：在执行转出后或者取消验证后，用于验证的克隆动态集群将会会删除。如果想保留该集群可以通过在验证集群上设定 saveClonedCluster 定制属性，来保留验证集群。<\/p><ol type=\"1\"><li>\n验证是否正确执行了验证。单击 <strong>应用程序 &gt; 企业应用程序或应用程序 &gt; 所有应用程序<\/strong>，选择版本 2.0 应用程序，在 <strong>管理模块<\/strong>中，验证版本 2.0 是否已经映射到验证集群。<\/li><li>\n测试新版本。启动验证集群，并设置好路由规则。<\/li><\/ol><p>现在，您就可以在真实的生产环境中，测试新版本的应用程序了，在测试完成之后，可以进行转出操作，切换到新版本上。<\/p><h2 id=\"major4\">小结<\/h2><p>本文向您分绍了 WAS V8.5 中智能管理中的应用程序版本管理功能，它使得您能够在不间断对外服务的情况下，对应用程序版本进行部署和更新，并且介绍了两种不同的版本转出模式，和应用版本管理使用的两种典型场景。希望本文能够对您了解 WAS 中智能管理功能有所帮助。<\/p><CMA ID: 970762><Site ID: 10><XSLT stylesheet used to transform this file: dw-document-html-7.0.xsl>\r\n\r\n\r\n<\/div>\r\n<\/div>\r\n","createTime":"2014-05-08 00:00:00","deployTime":"2014-05-08 00:00:00","id":0,"intro":"自 WebSphere Application Server V8.5（简称 WAS V8.5）起，之前独立的产品 WebSphere Virtual Enterprise（简称 WVE）并入到了 WAS 产品中。之前在由 WVE 提供的相关功能在 WAS V8.5 中，我们称之为智能管理。智能管理中包括了应用程序版本管、动态集群、健康管理和智能路由。本文主要向您介绍应用程序版本管理。","keyword":"","recommend":false,"source":"http://www.ibm.com/developerworks/cn/websphere/library/techarticles/1405_limh_versionmag/1405_limh_versionmag.html","title":"WebSphere Application Server V8.5 智能管理之应用程序版本管理","typeId":0,"updateTime":"2014-05-08 00:00:00"}
{"author":"","clickNumber":0,"content":"\r\n<div class=\"ibm-columns\">\r\n<div class=\"ibm-col-1-1\">\r\n\r\n<h2 id=\"intro\">简介<\/h2><p>在 14 个月的服务活动中，我与多个团队的成员合作过，不断增强现有流程，最大限度地提高开发团队的生产力，并满足客户为大型 Web 应用程序而设定的所有预期，这个 Web 应用程序是客户在竞争异常激烈的行业中取得全面成功的关键。该应用程序的实际用途对本讨论并不重要，我只想分享一下我在领导一个团队不断向业务关键型应用程序提供版本时学到的一些经验。<\/p><p>我的这个开发团队包括 7 位开发人员、1 位业务分析师、1 位部署经理和 1 位团队技术主管。快速了解一下每个角色可能会有所帮助：<\/p><ul class=\"ibm-bullet-list\"><li><strong>业务分析师  <\/strong><p>生产支持团队收到的大部分通知单都是在现有代码中写入的缺陷，但在一些情况下，支持团队收到的通知单还需要更新业务规则。在这些情况下，业务分析师与业务团队（客户）合作创建一个需求文档，供技术主管和开发人员用于开发解决方案。 <\/p><\/li><li><strong>构建和发布经理  <\/strong><p>编写构建脚本并管理向测试和生产环境的部署。构建和发布经理也是所有构建工具的管理员，包括一个持续集成工具，监视所有与构建和部署相关的配置变更和日志。<\/p><\/li><li><strong>开发人员  <\/strong><p>责任包括调查分析和修复分配给团队的通知单，执行同行评审，记录主要变更，以及依据流程在不同环境中验证代码修复结果。<\/p><\/li><li><strong>团队/技术主管  <\/strong><p>管理所有版本，执行流程，并向开发人员分配通知单。主管担当开发人员与业务团队之间的联络人，确保所有日期和最后期限都得到满足和遵守。还在代码开发期间担当顾问，帮助做出架构决策。<\/p><\/li><li><strong>测试团队  <\/strong><p>在发布到生产环境之前测试所有修复结果，确保新的代码基准的质量。 <\/p><\/li><\/ul><p>在我任职的初期，所有团队成员每周发布一个版本。我们的时间安排允许将任意数量的构建版本提供给测试服务器，但没有具体的最后期限。这些流程没有全面开发或执行，开发人员发现他们将时间浪费在了错误的任务上，或者过度承担了别人的任务职责，留给他们执行实际开发的时间很少。这种结构上的缺乏导致我们无法正确地、甚至大体地预测每个版本将完成的通知单数量，更糟的情况是，最后期限无法满足。由于不确定任何给定版本中将修复哪些通知单，测试团队没有足够的时间为提供给他们的通知单准备测试方案，最终可能无法在将新代码基准部署到生产环境之前全面测试它们。在许多情况下，最终结果是我们需要延迟一天或一星期发布一个版本，将它与后续版本一起发布；在一些情况下，新代码基准没有经过全面测试就发布到了生产环境中，导致客户开具了更多通知单。<\/p><p>为了克服这些（常见的）困难并成功地每周提供一个版本，我们需要明确地定义挑战和目标，努力修复现有流程，使我们能够遵守明确的开发周期。<\/p><p>重要的目标是：<\/p><ul class=\"ibm-bullet-list\"><li>提高生产力<\/li><li>提高质量<\/li><li>满足最后期限<\/li><li>满足客户的预期<\/li><li>渐进地完成这些增强，同时不中断每周的版本发布。<\/li><\/ul><p>为了消除实现这些目标的阻碍，我们实施了一组战略行动，如以下各节所述。<\/p><h2 id=\"sec2\">行动 1：进行同行评审<\/h2><p>在第一次试验中，我们保持每周发布时间表不变，这意味着我们要像以前一样每周发布一个新的代码基准。我们引入的第一个变更是向流程添加同行评审。<\/p><p>之前，开发人员没有执行过同行评审；他们要完成一次代码修复，在新版本分支中检查它，在开发服务器上测试它，然后让测试团队测试有无缺陷。引入同行评审，使我们能够提供更高的质量和更少的缺陷，最大限度减少开发周期的中断。<\/p><p>在一位开发人员完成一个通知单时，分配的一位同行会执行这个评审过程： <\/p><ol><li>评审通知单和需求，确保代码修复是完整的，并且解决了所有报告的问题。 <\/li><li>评审代码更改，确保它在程序设计上是正确的。（我们研究了各种各样的同行评审指南，然后创建了自己的指南。）<\/li><li>评审文档（如果需要文档）。<\/li><li>在开发环境中运行并测试代码修复。<\/li><\/ol><p>如果上述任何方面未通过测试，评审人员会将该通知单分配回开发人员，并提供注释。开发人员将继续完成这项任务，将它分配给同行人员进行评审，如此循环往复，直到通知单得到评审人员批准。最终将更高质量的代码提供给测试团队。<\/p><h2 id=\"sec3\">行动 2：修改时间安排<\/h2><p>下一个更改是创建一个新的时间安排供所有团队遵守，然后执行它。我们还将发送给测试服务器的构建版本数量限制为 2 个。<\/p><p>图 1 显示了每周一个版本的时间安排示例。<\/p><h5 id=\"fig1\">图 1. 每周一个版本的时间安排<\/h5><img alt=\"每周一个版本的时间安排\" src=\"/sunshine_new/images/1285617702/images/image01.jpg\" width=\"756\" height=\"336\" /><p><a href=\"#N1009A\" class=\"ibm-popup-link\" onclick=\"ibmweb.overlay.show('N1009A',this);return false;\">点击查看大图<\/a><\/p><div id=\"N1009A\" class=\"dw-sidefile-overlay ibm-common-overlay ibm-overlay-alt-two\"><div class=\"ibm-head\"><p><a href=\"#close\" class=\"ibm-common-overlay-close\">关闭 [x]<\/a><\/p><\/div><div class=\"ibm-body\"><div class=\"ibm-main\"><div class=\"ibm-title\"><h2>图 1. 每周一个版本的时间安排<\/h2><\/div><div class=\"ibm-container ibm-alternate\"><div class=\"ibm-container-body\"><img alt=\"每周一个版本的时间安排\" src=\"/sunshine_new/images/1285617702/images/image01.jpg\" width=\"1057\" /><\/div><\/div><\/div><\/div><div class=\"ibm-footer\"><><\/div><\/div><p>在这个时间安排中，第一列描述了不同的任务。第二列列出了将负责该任务的小组。剩余列表示该版本所在星期的每一天。<\/p><p>我们看看该时间安排中涉及的每个任务：<\/p><ul class=\"ibm-bullet-list\"><li><strong>代码稳定化和提交给同行评审<\/strong><p>开发人员必须完成所有代码开发，确保所有代码都已在开发环境中签入、部署并测试。他们然后将通知单转交给同行进行评审。 <\/p><\/li><li><strong>代码签入最后期限和同行评审结束<\/strong><p>在同行评审期间，评审人员将通知单发回给开发人员，以修复找到的所有问题。开发人员和评审人员应在这个最后期限内完成这个周期，准备好并最终确定通知单。<\/p><\/li><li><strong>代码合并<\/strong><p>在以前和当前的版本之间执行代码合并。<\/p><\/li><li><strong>部署到测试环境<\/strong><p>构建和发布经理将新代码基准部署到测试环境，完成之后通知开发人员。<\/p><\/li><li><strong>开发人员验证<\/strong><p>开发人员在测试服务器上执行验证，确认所有这些代码修复已正确部署并在服务器上按预期运行。如果发现任何数据或配置错误，他们会修复并记录问题，确保在生产服务器上发生该问题会正确处理它。<\/p><\/li><li><strong>测试<\/strong><p>测试团队开始测试。 <\/p><\/li><li><strong>所有团队签字<\/strong><p>举行<strong>最终决定电话会议<\/strong>，开发、构建和部署、业务及测试团队至少派一位代表参加，其他任何相关的客户人员也可参加。这是一个版本的生命周期中的最后一次会议。现在，所有团队都将清除部署生产环境中的版本，释放测试环境供下一个版本使用。如果在此版本中有任何问题或担忧尚未解决，那么他们会在会议中提出这些问题，并制定一个行动计划来解决这些问题。如果发生任何延迟，在条件允许的情况下，可将版本延后发布。 <\/p><\/li><li><strong>生产部署<\/strong><p>构建和发布经理向生产服务器发布代码基准。<\/p><\/li><\/ul><p>现在我们看看时间安排：<\/p><ol class=\"ibm-alpha-list\" type=\"a\"><li>在上面 10.21.0 版的示例中，开发团队第一个随后期限是 12 月 5 日下午 1:00，稳定代码并提交给同行人员评审。实际的代码签入最后期限是在 12 月 5 日下午 5:00 点。这为开发人员提供了 4 小时来执行同行评审并修复找到的所有问题。 <\/li><li>在星期五早上，构建和发布经理会将代码部署到测试环境中，然后通知执行验证的开发人员。 <\/li><li>下午 1:00，测试团队将执行测试，直到当天结束。 <\/li><li>第二次构建始于 12 月 9 日，类似该周期的第一部分：开发团队将解决测试团队列出的所有缺陷，执行同行评审，然后在当天结束时签入代码。 <\/li><li>12 月 10 日，新代码将部署到测试服务器，测试人员将确认所有缺陷都已修复。 <\/li><li>12 月 11 日，测试团队将继续测试，直到举行最终决定电话会议。 <\/li><\/ol><p>从此时间安排可以看到，如果返回到 10.20.0，如果开发人员的第一个构建版本没有任何缺陷，那么他可在 11 月 29 日完成验证步骤后立即开发下一个版本。这为开发人员提供了每个版本最长 36 个小时的开发时间。如果他需要解决缺陷，这意味着他有大约 24 小时的开发时间。对于列出的缺陷，团队将始终优先解决 10.20.0 版本的缺陷，而不是 10.21.0 版本；解决完缺陷后，他们会继续开发 10.21.0 版本。<\/p><p>实施新时间安排后，各个版本都非常小，每个版本平均修复并完成 4 个通知单（一些通知单需要超过 36 小时的开发时间，意味着不是所有开发人员都会参与每个版本的开发）。这与前几个月的数字是一致的。但是，区别是我们最终能够稳定该流程 ― 而且在团队开始遵循该流程时，版本的质量得到了改进。<\/p><p>此刻的抱怨主要来自测试团队，因为他们没有足够的时间来测试，还有一些开发人员，他们必须在同行评审后在一个通知单上返工。另一方面，业务合作伙伴非常高兴我们能够向一个版本的每个日期分配通知单并按时解决它们，但他们可能对生产力感到不满意，因为他们希望每周解决更多的通知单。<\/p><p>公平地讲，这个时间表没有过多地考虑任何外部问题，比如服务器故障和其他系统问题。考虑到紧张的时间表，这些类型的问题常常影响到可交付结果和发布日期，有时导致发布一个仅有两处修复的版本，或者延后一个版本并将它与后续版本合并。<\/p><p>随着我们对此方法的进一步了解，我们对比了优缺点并与所有各方进行了协商，开发了两种新的不同的时间安排，为利益相关者提供不同的选择：<\/p><ul class=\"ibm-bullet-list\"><li><strong>选项 1：<\/strong>第一个替代方案是将团队拆分为两个，以便每个更小的团队每两周处理一个版本。这在部署到生产环境之前，为每个团队提供了时间来开发他们的版本并提供支持。该方案还遵守了之前的每周一个版本的时间表。<\/li><li><strong>选项 2：<\/strong>第二个替代方案是保持该团队为单个团队，但将版本发布时间表更改为双周（每两周一个版本）。 <\/li><\/ul><p>如果查看选项 1 的时间安排，可以看到两个版本之间存在一定的重叠。尽管涉及的资源不同，但此方法需要管理两个团队，他们同时处理其版本的不同阶段。而且，一些通知单将需要比分配的更多的开发时间，促使开发人员处理与最初分配不同的版本，导致团队规模（进而导致输出）不平衡。<\/p><p>图 2 给出了一个包含两个替代团队，一周发布一个版本的时间安排示例。<\/p><h5 id=\"fig2\">图 2. 每周一个版本，两个团队<\/h5><img alt=\"每周一个版本的时间安排\" src=\"/sunshine_new/images/1285617702/images/image02.jpg\" width=\"850\" height=\"530\" /><p><a href=\"#N100FB\" class=\"ibm-popup-link\" onclick=\"ibmweb.overlay.show('N100FB',this);return false;\">点击查看大图<\/a><\/p><div id=\"N100FB\" class=\"dw-sidefile-overlay ibm-common-overlay ibm-overlay-alt-two\"><div class=\"ibm-head\"><p><a href=\"#close\" class=\"ibm-common-overlay-close\">关闭 [x]<\/a><\/p><\/div><div class=\"ibm-body\"><div class=\"ibm-main\"><div class=\"ibm-title\"><h2>图 2. 每周一个版本，两个团队<\/h2><\/div><div class=\"ibm-container ibm-alternate\"><div class=\"ibm-container-body\"><img alt=\"每周一个版本的时间安排\" src=\"/sunshine_new/images/1285617702/images/image02.jpg\" width=\"1187\" /><\/div><\/div><\/div><\/div><div class=\"ibm-footer\"><><\/div><\/div><p>执行以下计划： <\/p><ol class=\"ibm-alpha-list\" type=\"a\"><li>团队 A 处理版本 10.20.0 和 10.22.0，同时团队 B 处理版本 10.21.0。<\/li><li>团队 A 将在 11 月 28 日中午完成版本 10.20.0 的处理，同时开始处理版本 10.22.0。 <\/li><li>每个版本的开发时间从 6.5 到 9.5 天不等，具体时间取决于是否存在缺陷。<\/li><li>对于 10.22.0，团队的第一个最后期限是，他们需要在 12 月 10 日提交代码修复，以便进行同行评审。此时，所有代码修复都应签入 10.22.0 版本分支中，由开发人员部署到开发环境并进行验证。 <\/li><li>我们还需要将 10.21.0 版本合并到 10.22.0 版本基准中。这将在批准 10.21.0 版本发布到生产环境中后完成。 <\/li><li>12 月 12 日，构建和发布经理将 10.22.0 基准部署到测试环境，然后开发人员将执行验证，测试人员随后将开始测试。 <\/li><\/ol><p>在新时间安排中，测试人员有大约两天的测试时间。所有通知单的所有测试都应在 12 月 12 日结束之前执行和完成，回归测试（如果需要）将在 12 月 13 日执行。开发团队将在写入缺陷后立即处理它们，确保它们满足第二个构建最后期限，也就是 12 月 16 日。向测试环境的第二次构建和部署将在 12 月 17 日执行，随后开发人员验证并向测试团队释放该环境。<\/p><p>请注意，在团队 B 执行 10.21.0 版本的开发的同一周，团队 A 将最终确定 10.20.0 版本，执行同行评审和开发人员验证，确保所有列出的缺陷都已在 10.20.0 的第二次构建中按时修复。如果没有向团队 A 分配 10.20.0 版的缺陷，他们可开始开发 10.22.0。另请注意，在 12 月 5 日之前，开发环境将由团队 B 用于开发 10.21.0，所以团队 A 将需要在 12 月 5 日之前在本地开发代码。<\/p><p>选项 2 更进了一步，通过捆绑通知单并删除以前的模型中的一些开销，提高了生产力。在此模型中，我们将把一个团队拆分为两个。我们将拥有更少的测试服务器部署（这可能让所有团队中断工作），而且代码合并量极少。<\/p><p>图 3 给出了一个两周一个版本，包含单个团队的时间安排示例。<\/p><h5 id=\"fig3\">图 3. 两周一个版本，一个团队的时间安排<\/h5><img alt=\"每周一个版本的时间安排\" src=\"/sunshine_new/images/1285617702/images/image03.jpg\" width=\"849\" height=\"333\" /><p><a href=\"#N1011D\" class=\"ibm-popup-link\" onclick=\"ibmweb.overlay.show('N1011D',this);return false;\">点击查看大图<\/a><\/p><div id=\"N1011D\" class=\"dw-sidefile-overlay ibm-common-overlay ibm-overlay-alt-two\"><div class=\"ibm-head\"><p><a href=\"#close\" class=\"ibm-common-overlay-close\">关闭 [x]<\/a><\/p><\/div><div class=\"ibm-body\"><div class=\"ibm-main\"><div class=\"ibm-title\"><h2>图 3. 两周一个版本，一个团队的时间安排<\/h2><\/div><div class=\"ibm-container ibm-alternate\"><div class=\"ibm-container-body\"><img alt=\"每周一个版本的时间安排\" src=\"/sunshine_new/images/1285617702/images/image03.jpg\" width=\"1186\" /><\/div><\/div><\/div><\/div><div class=\"ibm-footer\"><><\/div><\/div><p>表 1 给出了所有 3 种版本时间安排之间的对比结果。<\/p><h5 id=\"table1\">表 1. 开发版本时间安排对比<\/h5><table border=\"0\" cellpadding=\"0\" cellspacing=\"0\" class=\"ibm-data-table\"><thead xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"><tr><th scope=\"col\">项目元素<\/th><th scope=\"col\">每周一个版本（最初）<\/th><th scope=\"col\">每周一个版本，包含替代团队<\/th><th scope=\"col\">两周一个版本<\/th><\/tr><\/thead><tbody xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"><tr><th class=\"ibm-table-row\" scope=\"row\">开发时间（天）<\/th><td>3 到 4.5<\/td><td>6.5 到 9.5<\/td><td>6.5 到 9.5<\/td><\/tr><tr><th class=\"ibm-table-row\" scope=\"row\">开发人员验证（小时）<\/th><td>4<\/td><td>4<\/td><td>4<\/td><\/tr><tr><th class=\"ibm-table-row\" scope=\"row\">同行评审（小时）<\/th><td>10<\/td><td>13<\/td><td>21<\/td><\/tr><tr><th class=\"ibm-table-row\" scope=\"row\">测试（小时）<\/th><td>10.5<\/td><td>18.5<\/td><td>26<\/td><\/tr><\/tbody><\/table><p>在有一个重要的通知单无法等到计划的版本发布时，我们仍会为我们未计划发布版本的一周维护一种时间安排。这可向不同的合作伙伴保证，我们能够仍然根据需要处理未计划的版本，充当一个 “安全网络”；我们能够按这些日期发布版本而不影响计划的版本。例如，如果我们需要激活一个未计划版本的时间安排来修复一个缺陷，那么只需一位开发人员来处理它即可，构建、部署和测试工作极少，这使得我们能够集中精力处理主要的两周版本。<\/p><p>图 4 显示了一种需要计划外的例外版本的情况。<\/p><h5 id=\"fig4\">图 4. 例外版本的时间安排<\/h5><img alt=\"例外版本的时间安排\" src=\"/sunshine_new/images/1285617702/images/image04.jpg\" width=\"847\" height=\"149\" /><p><a href=\"#N10170\" class=\"ibm-popup-link\" onclick=\"ibmweb.overlay.show('N10170',this);return false;\">点击查看大图<\/a><\/p><div id=\"N10170\" class=\"dw-sidefile-overlay ibm-common-overlay ibm-overlay-alt-two\"><div class=\"ibm-head\"><p><a href=\"#close\" class=\"ibm-common-overlay-close\">关闭 [x]<\/a><\/p><\/div><div class=\"ibm-body\"><div class=\"ibm-main\"><div class=\"ibm-title\"><h2>图 4. 例外版本的时间安排<\/h2><\/div><div class=\"ibm-container ibm-alternate\"><div class=\"ibm-container-body\"><img alt=\"例外版本的时间安排\" src=\"/sunshine_new/images/1285617702/images/image04.jpg\" width=\"1183\" /><\/div><\/div><\/div><\/div><div class=\"ibm-footer\"><><\/div><\/div><p>可以理解，开发人团队最喜欢第二种两周版本的选项，但不容易让其他一些团队同意。最终，此方法的优点多于缺点，我们能够说服合作伙伴采用新计划，让我们每两周发布一个版本。采用第二个时间安排选项后，我们能够最大化版本周期，给同行评审和测试留出更多的时间。<\/p><p>得益于这个新的版本时间安排，按完成的通知单数量和每季度的开发小时数算，团队的生产力提高了近 100%。团队每两周平均处理 16 个通知单，而最初每周仅处理 4 个通知单。<\/p><h2 id=\"sec4\">行动：3 细化服务水平协议<\/h2><p>除了定义时间安排和版本周期长度，我们还需要定义（并执行）成功的版本的必要条件：<\/p><ul class=\"ibm-bullet-list\"><li><strong>向一个版本提交通知单的最后期限<\/strong><p>我们在服务水平协议 (SLA) 中添加了一条新内容，规定将通知单提交到计划的版本内的最后期限是第一个构建代码冻结前的 6 个工作日（排除需要立即关注的很重要的通知单）。这还意味着通知单已准备好开发；例如，如果需要使用需求文档，该工作应该已经完成。<\/p><\/li><li><strong>需要同行评审<\/strong><p>通过要求同行评审，包括评审代码，确保修复完成，并确认问题已得到解决，而且修复结果已经过测试，我们可确保更高的质量和更少的缺陷。（这一步将每个版本列出的缺陷数量减少了一半以上，可确保开发人员在完成当前版本后，立即就能自信地开始开发下一个版本）。 <\/p><\/li><li><strong>每个版本周期内向测试环境部署的构建版本数量<\/strong><p>最初，我们允许使用无限多个构建版本，该数量取决于每天可解决的通知单数量和每天列出的缺陷数量。在一些两周版本中，我们可能每天创建一个构建版本，在生产发布之前的最后一天创建的构建版本可能更多。我们决定将此限制为每个版本周期两个构建版本。SLA 现在规定，分配给一个版本的所有通知单都需要准备好在向测试服务器提供第一个构建版本中进行测试。<\/p><p>测试团队需要遵守时间安排，在分配的时间范围内完成所有通知单的测试，在找到缺陷后立即列出它们，然后将它们分配给开发人员，开发人员随后会解决这些缺陷，以便在提供给测试环境的第二个构建版本中修复它们。测试团队下次的测试时间更短，但他们仅需验证为第一个构建版本列出的缺陷的修复结果。<\/p><\/li><li><strong>测试<\/strong><p>测试团队现在有更多时间在测试环境中工作，他们之前需要处理的由多个构建版本和部署所导致的中断很少。自现在定义该周期后，他们还能够更好地管理他们的资源。<\/p><p>他们会在开始处理该版本之前 7 个工作日准确了解该版本中的通知单列表，为他们提供足够的时间来准备测试案例和方案，从而确保提供更高质量的可交付结果。<\/p><\/li><li><strong>在未满足最后期限时采取的行动<\/strong><p>当然，有时预计的工作水平不准确，导致未满足最后期限。SLA 定义了 3 个处理此情形的选项： <\/p><ul class=\"ibm-bullet-list\"><li>如果需要的外开发时间不到半天，我们会将整个时间安排延长半天，以便为完成开发提供时间。<\/li><li>如果需要的额外开发时间超过半天，我们会回滚更改并将通知单转移到下一个版本。<\/li><li>在非常特殊的情况下，在通知单必须在当前分配的版本中修复时，我们允许在第二个构建版本的最后期限之前准备好该通知单，分配额外的同行评审时间，并提前通知测试团队，以确保有足够的资源可用于按时完成测试。<\/li><\/ul><\/li><li><strong>在第二次构建后有缺陷时采取的行动：<\/strong><p>在很少的情况下，我们可能面临着在第二次构建后列出了新缺陷的情形。在这种情况下，我们有两个选项：<\/p><ul class=\"ibm-bullet-list\"><li>如果该缺陷导致比最初报告的更多的问题，或者如果业务合作伙伴将它视为很高的风险，我们会回滚与导致该缺陷的通知单相关的所有代码，并在下一个版本中解决它。这样，就为开发人员提供了足够的时间来完全修复问题。在这种情况下，开发人员将回滚代码更改，还需要向测试服务器提供第三个构建版本。测试团队随后会重新进行测试，确保基准已返回到之前的状态。<\/li><li>部署包含该已知缺陷的当前版本并在下一个版本中修复该缺陷 ― 或者如果它至关重要，可作为一次应急修复，只要准备就绪了。<\/li><\/ul><p>决策主要基于该缺陷的新修复结果与最初的通知单相比是否具有更多的不足。如果是，我们会从该版本中删除它。如果不是，我们会部署这个已知缺陷的修复结果，并在下一个版本中部署另一个修复结果。<\/p><\/li><\/ul><h2 id=\"sec6\">行动 4：管理版本控制<\/h2><p>很少有事情像版本控制对软件开发项目那么重要，尤其是在项目在项目规模、团队规模和可视性等所有元素上都被放大时。<\/p><ul class=\"ibm-bullet-list\"><li><strong>分支和合并<\/strong><p>每次团队开始处理一个版本，该流程就会要求从代码中创建一个新分支。开发人员被要求跟踪所有分支并将其代码签入到所有开放的分支中。我们更改了该流程，以便从最新的生产支持开放分支创建分支，而且开发人员只需将其代码签入到他们正在处理的版本中，这减少了不断跟踪多个分支的开销。在两种情况下，我们需要与向生产环境的最新部署执行一次合并。<\/p><p>该合并将由一位开发人员在一次循环后执行。给定两周一个版本的时间表，基于何时创建分支和我们是否有第二个构建版本，您可以在时间表上看到合并可能不是必需的或作用很小。<\/p><\/li><li><strong>管理可用的环境<\/strong><p>最初设置是，每个版本都要经历 3 个不同的环境（服务器），才会部署到生产环境中：<\/p><ol class=\"ibm-alpha-list\" type=\"a\"><li><strong>开发：<\/strong>开发人员在其本地环境中完成开发和测试后，使用此环境测试他们的代码。开发人员拥有服务器的完整访问权，可使用一个构建工具部署该代码。这里不需要版本经理。所有开发人员都使用他们的本地设置来执行开发工作，完成之后，使用开发环境来执行测试和同行评审。 <\/li><li><strong>稳定：<\/strong>此环境设置为测试环境的完全相同的副本，而测试环境应是生产环境的完全相同的副本。版本经理将执行构建来测试他的脚本。开发人员验证所有签入的代码和配置是否已成功部署。如果有任何问题，开发人员会努力修复它，版本经理记下笔记，确保向测试环境（以及然后向生产环境）的部署是完整的。 <\/li><li><strong>测试：<\/strong>版本经理将代码基准部署到这个环境中，然后测试团队运行他们的测试脚本，确保代码基准已为生产发布做好准备。<\/li><\/ol><p>我们做了一项更改，以便提供更多开发和测试时间，并减少环境相关缺陷，这项更改那就直接跳到第二步。我们部署到测试环境，允许开发人员和版本经理验证构建版本是否已成功，然后将该环境转交给测试团队。<\/p><p>我们前一个模型的主要问题是，在许多情况下，稳定环境不是测试环境的完全相同的副本，所以我们最终存在与环境相关的问题；也就是说，一个问题会在一个环境中出现，在另一个环境中却不会出现。例如，开发人员将在稳定环境中验证他们的代码，然后传递给下一个环境。然后，如果测试环境中的数据或配置存在问题，测试人员可能会列出针对不一定与代码相关的问题的缺陷。<\/p><p>现在，因为开发人员在测试环境中进行了验证，所以我们可确定他们转交的环境没有数据或部署问题，使测试人员能够仅处理版本缺陷，而不处理与环境相关的缺陷。<\/p><p>稳定环境仍在使用，但作为一个开发环境，供开发人员测试第一个构建版本中列出的缺陷的修复结果，以便为第二个构建版本做好准备。 <\/p><\/li><li><strong>版本 ID<\/strong><p>我们执行了一项细微更改，将版本 ID 从日期更改为版本编号。这影响到了我们使用的分支和通知单队列中分配的版本 ID。采用这种简单的命名约定，我们不再需要经历在版本日期更改时更新所有引用的过程。 <\/p><\/li><\/ul><h2 id=\"conclusion\">结束语<\/h2><p>本文重点介绍了我作为一个生产支持团队的主管所总结的一些经验，该团队负责一个维护商业企业的 Web 应用程序。尽管这个实际项目很大，而且持续时间较长，但这里描述的许多挑战在所有规模的项目中都存在。类似地，在寻找提高您自己开发项目的质量和满足您承诺的方法时，执行的解决方案（包括用来管理资源、设置时间安排、评审和更改流程、重新建立 SLA 等的方法）可能也适用 ― 或者至少值得讨论。<\/p><CMA ID: 970500><Site ID: 10><XSLT stylesheet used to transform this file: dw-document-html-7.0.xsl>\r\n\r\n\r\n<\/div>\r\n<\/div>\r\n","createTime":"2014-05-06 00:00:00","deployTime":"2014-05-06 00:00:00","id":0,"intro":"管理持续时间长、规模庞大的开发项目是一件既不轻松也不简单的事。本文将重点介绍我作为一个生产支持团队的主管所总结的一些经验，该团队负责一个维护商业企业的大型 Web 应用程序。具体地讲，本文将讨论多个与如何管理版本有关的挑战，还将介绍为了提高生产力和质量而引入的一些变更。","keyword":"","recommend":false,"source":"http://www.ibm.com/developerworks/cn/websphere/techjournal/1402_col_weller/1402_col_weller.html","title":"评论专栏: 开发项目平衡实战","typeId":0,"updateTime":"2014-05-06 00:00:00"}
{"author":"","clickNumber":0,"content":"\r\n<div class=\"ibm-columns\">\r\n<div class=\"ibm-col-1-1\">\r\n\r\n<h2 id=\"intro\">简介<\/h2><p>IBM WebSphere DataPower SOA Appliances 的构建是为了简化部署和加强安全性，它衔接了多个协议，并以线速执行转换。这些功能可帮助组织实现和维护安全性和操作策略。<\/p><p>DataPower 通常被用作处理企业的传入流量的逆向代理和安全网关，您也可以将它用作出站连接的网关。此外，还有一些客户端需求，企业政策要求所有出站连接通过一个网关发出，以方便监视和路由。DataPower 也可用作网关来满足这样的需求。<\/p><p>IBM Worklight 向通知中介（比如 APNS (Apple Push Notification Service) 和 GCM (Google Cloud Messaging servers)）发出出站连接，以便向移动应用程序推送通知。因此，DataPower 应能够用作 IBM Worklight Server 和 APNS/GCM 之间的代理。<\/p><p>本文将介绍如何设置 DataPower，以便将它用作推送通知代理。<\/p><h2 id=\"sec1\">将 DataPower 配置为 GCM 代理<\/h2><p>有两种可能的 DataPower 配置使它能够被用作 Worklight 的 GCM 代理：一种 <a href=\"#sec1a\">TCP 代理配置<\/a> 和一种 <a href=\"#sec1b\">Web 应用程序防火墙配置<\/a>。<\/p><h3 id=\"sec1a\">TCP 代理 <\/h3><p>一个 <strong>TCP（传输控制协议）代理<\/strong>用作 TCP 网络层的代理。它使用一个 TCP 连接将指定本地地址上收到的所有流量中继到一个指定的远程对等地址。<\/p><p><strong>A.DataPower 配置<\/strong><\/p><ol><li>登录到 DataPower 设备。<\/li><li>导航到 <strong>Services &gt; Other Services<\/strong>，选择 <strong>TCP Proxy Service<\/strong> 并单击 <strong>Add<\/strong>。<\/li><li>提供一个可用于标识该配置的名称。<\/li><li>输入这些配置细节：\n                            \n<ul class=\"ibm-bullet-list\"><li><strong>Local IP Address：<\/strong>选择正确的别名或保留默认值 (0.0.0.0)<\/li><li><strong>Port Number：<\/strong><code>443<\/code><\/li><li><strong>Remote Host：<\/strong><code>android.googleapis.com<\/code><\/li><li><strong>Remote Port：<\/strong><code>443<\/code><\/li><\/ul><\/li><li>单击 <strong>Apply<\/strong>。<\/li><li>保存配置。<\/li><\/ol><p><strong>B. Worklight Server 配置<\/strong><\/p><ol><li>编辑 Worklight Server 机器的 <strong>hosts<\/strong> 文件。主机文件位于：\n                            \n<ul class=\"ibm-bullet-list\"><li>Linux：<code>/etc/hosts<\/code><\/li><li>Windows：<code>SystemRoot%\\system32\\drivers\\etc\\hosts<\/code><\/li><\/ul><p>在以下行中：<\/p><p><code>&lt;ip address of datapower&gt;    android.googleapis.com<\/code><\/p><p>将 <em>&lt;ip address of datapower&gt;<\/em> 替换为实际的 IP 地址。<\/p><\/li><li><strong>worklight.properties<\/strong> 文件中的通知代理设置不需要修改。<\/li><li>重新启动 Worklight Server。<\/li><\/ol><h3 id=\"sec1b\">Web 应用程序防火墙 <\/h3><p><strong>A. DataPower 配置<\/strong><\/p><ol><li>登录到 DataPower 设备。<\/li><li>使用 CN 值 <code>android.googleapis.com<\/code> 创建一个<strong>密钥-证书对<\/strong>：\n                                \n<ol class=\"ibm-alpha-list\" type=\"a\"><li>导航到 <strong>Administration &gt; Miscellaneous<\/strong>，然后导航到 <strong>Crypto Tools<\/strong>。<\/li><li>在 Generate Key 选项卡下，输入 <code>android.googleapis.com<\/code> 作为 Common Name (CN) 的值。 <\/li><li>如果计划在以后导出私钥，那么可以选择 <strong>Export private key<\/strong>。<\/li><\/ol><\/li><li>创建一个 Crypto Identification Credential：\n                                \n<ol class=\"ibm-alpha-list\" type=\"a\"><li>导航到 <strong>Objects &gt; Crypto Configuration<\/strong> 并单击 <strong>Crypto Identification Credentials<\/strong>。<\/li><li>单击 <strong>Add<\/strong>。<\/li><li>提供一个可用来在以后识别该加密识别凭据的名称。<\/li><li>对于 Crypto Key 和 Certificate，从下拉菜单选择第 2 步中生成的密钥和证书。<\/li><li>单击 <strong>Apply<\/strong>。<\/li><\/ol><\/li><li>创建一个 Crypto Profile：\n                                \n<ol class=\"ibm-alpha-list\" type=\"a\"><li>导航到 <strong>Objects &gt; Crypto Configuration<\/strong> 并单击 <strong>Crypto Profile<\/strong>。<\/li><li>单击 <strong>Add<\/strong>。<\/li><li>提供一个可用来在以后识别加密概要文件的名称。<\/li><li>对于 Identification Credentials，从下拉菜单选择第 3 步中创建的识别凭据。<\/li><li>单击 <strong>Apply<\/strong>。<\/li><\/ol><\/li><li>创建一个 Web 应用程序防火墙：\n                                \n<ol class=\"ibm-alpha-list\" type=\"a\"><li>转到 <strong>Control Panel &gt; Web Application Firewall<\/strong> 并单击 <strong>Add Wizard<\/strong>。<\/li><li>单击 <strong>Add<\/strong>。<\/li><li>提供一个可用于在以后识别 Web 应用程序防火墙的名称。 <\/li><li>单击 <strong>Next<\/strong>。<\/li><li>在 Back End (Server) Information 下，输入以下值：\n                                                \n<ul class=\"ibm-bullet-list\"><li><strong>Remote Host：<\/strong>android.googleapis.com<\/li><li><strong>Remote Port：<\/strong>443。<\/li><li>在屏幕刷新后选择 <strong>SSL<\/strong> 复选框，然后选择第 4 步中的加密概要文件。<\/li><li>单击 <strong>Next<\/strong>。<\/li><\/ul><\/li><li>在 Front End (Client-Facing) Information 下：\n                                                \n<ul class=\"ibm-bullet-list\"><li>对于 IP，选择正确的别名或保留默认值 (0.0.0.0)。<\/li><li>选择 <strong>SSL<\/strong> 复选框并单击 <strong>Add<\/strong>。<\/li><li>屏幕刷新后，选择第 4 步中的加密概要文件。<\/li><\/ul><\/li><li>单击 <strong>Next<\/strong>，直到到达 Confirm Your Changes and Commit 面板，单击 <strong>Commit<\/strong>。<\/li><li>如果希望查看该配置，可单击 <strong>View Web Application Firewall<\/strong>，否则单击 <strong>Done<\/strong>。<\/li><\/ol><\/li><li>保存配置。<\/li><\/ol><p><strong>B.  Worklight Server 配置<\/strong><\/p><p>上面 DataPower 使用的证书是一个自签名证书。除非该证书添加到 Worklight 所使用的 JRE 中，否则与 DataPower 的连接将会失败。 <\/p><ol><li>要将该自签名证书添加到 JRE 密钥库中，可按照 <a href=\"http://pic.dhe.ibm.com/infocenter/wrklight/v5r0m5/topic/com.ibm.worklight.help.doc/admin/t_ibm_worklight_server_and_self-signed_certificates.html\">Worklight 信息中心<\/a> 的说明进行操作。<\/li><li>编辑 Worklight Server 机器的 <strong>hosts<\/strong> 文件。主机文件位于：\n                            \n<ul class=\"ibm-bullet-list\"><li>Linux：<code>/etc/hosts<\/code><\/li><li>Windows：<code>SystemRoot%\\system32\\drivers\\etc\\hosts<\/code><\/li><\/ul><p>在以下行中：<\/p><p><code>&lt;ip address of datapower&gt;    android.googleapis.com<\/code><\/p><p>将 <em>&lt;ip address of datapower&gt;<\/em> 替换为实际的 IP 地址。<\/p><\/li><li><strong>worklight.properties<\/strong> 中的通知代理设置不需要修改。<\/li><li>重新启动 Worklight Server。<\/li><\/ol><h2 id=\"sec2\">将 DataPower 配置为 APNS 代理<\/h2><p><strong>A. DataPower 配置<\/strong><\/p><ol><li>登录到 DataPower 设备。<\/li><li>导航到 <strong>Services &gt; Other Services<\/strong>，选择 <strong>TCP Proxy Service<\/strong> 并单击 <strong>Add<\/strong>。<\/li><li>提供一个可用于标识该配置的名称。<\/li><li>输入这些配置细节：\n                            \n<ul class=\"ibm-bullet-list\"><li><strong>Local IP Address：<\/strong>选择正确的别名或保留默认值 (0.0.0.0)<\/li><li><strong>Port Number：<\/strong><code>2195<\/code><\/li><li><strong>Remote Host：<\/strong><code>gateway.sandbox.push.apple.com<\/code><\/li><li><strong>Remote Port：<\/strong><code>2195<\/code><\/li><\/ul><\/li><li>单击 <strong>Apply<\/strong>。<\/li><li>保存配置。<\/li><\/ol><p><strong>B. Worklight Server 配置<\/strong><\/p><ol><li>编辑 Worklight Server 机器的 <strong>hosts<\/strong> 文件。主机文件位于：\n                            \n<ul class=\"ibm-bullet-list\"><li>Linux：<code>/etc/hosts<\/code><\/li><li>Windows：<code>SystemRoot%\\system32\\drivers\\etc\\hosts<\/code><\/li><\/ul><p>在以下行中：<\/p><p><code>&lt;ip address of datapower&gt;    gateway.sandbox.push.apple.com<\/code><\/p><p>将 <em>&lt;ip address of datapower&gt;<\/em> 替换为实际的 IP 地址。<\/p><\/li><li><strong>worklight.properties<\/strong> 文件中的通知代理设置不需要修改。<\/li><li>重新启动 Worklight Server。<\/li><\/ol><h2 id=\"sec3\">从 Worklight 发送通知<\/h2><p>完成上述 Worklight 和 DataPower 配置后，即可开始从 Worklight 发送通知。有关 Worklight 推送通知的信息，请参阅 <a href=\"http://pic.dhe.ibm.com/infocenter/wrklight/v5r0m6/index.jsp?topic=%2Fcom.ibm.worklight.help.doc%2Fadmin%2Fc_push_notification.html\">Worklight 信息中心<\/a>。<\/p><p>请参阅 Worklight <a href=\"http://www.ibm.com/developerworks/cn/mobile/worklight/getting-started.html#advanced\">入门文档<\/a> 了解推送通知示例。<\/p><p>一定要检查 DataPower 和 Worklight 日志，以防出现任何错误。<\/p><h2 id=\"conc\">结束语<\/h2><p>本文重点介绍了如何使用 IBM WebSphere DataPower Appliances 用作一个逆向代理和安全网关，用它来处理企业的出站推送通知。这里详细介绍的 DataPower 配置被用作 IBM Worklight Server 和通知中介之间的代理，以确保企业策略和安全合规性在发出出站请求时得到满足。 <\/p><CMA ID: 970528><Site ID: 10><XSLT stylesheet used to transform this file: dw-document-html-7.0.xsl>\r\n\r\n\r\n<\/div>\r\n<\/div>\r\n","createTime":"2014-05-06 00:00:00","deployTime":"2014-05-06 00:00:00","id":0,"intro":"IBM WebSphere DataPower Appliances 的构建是为了简化部署和加强安全性，它衔接了多个协议，并以线速执行转换。这些功能可帮助您实现和维护安全性和操作策略。DataPower 通常被用作处理企业的传入流量的逆向代理和安全网关，您也可以将它用作出站连接的网关，以方便监视和路由。IBM Worklight 与通知中介建立出站连接，向移动应用程序推送通知。本文将介绍如何设置 DataPower，将它用作推送通知代理。","keyword":"","recommend":false,"source":"http://www.ibm.com/developerworks/cn/websphere/techjournal/1402_ramachandra/1402_ramachandra.html","title":"使用 WebSphere DataPower 作为 Worklight 移动应用程序的推送通知代理","typeId":0,"updateTime":"2014-05-06 00:00:00"}
{"author":"","clickNumber":0,"content":"\r\n<div class=\"ibm-columns\">\r\n<div class=\"ibm-col-1-1\">\r\n\r\n<h2 id=\"2.从“陪练”到“虚拟化”|outline\">从“陪练”到“虚拟化”<\/h2><p>虚拟化这个词语,有点文绉绉,不太好理解。我们找个生活中的例子，中国乒乓球，羽毛球水平厉害吧，奥运金牌都是全包，很牛！ 为什么呢？举国体制，群众基础好。<\/p><p>更具体点，我认为有一点很重要，咱们人多，更重要的是\"陪练多\"，有那么多陪练天天去\"模仿\"国外的主要对手的打法，然后来给运动员提供更多\"实战\"的机会...<\/p><p>这是模拟，是仿真，对，仿真对应的计算机术语就是\"虚拟化\",去\"模拟\"对方的打法,球路甚至习惯等。 <\/p><p>不同的是，国家队陪练模拟的打球，是国外对手的打法习惯。而软件里面\"虚拟化\"模拟的是软件系统要提供的服务，它能和正常系统一样，能处理您发送的指令，给出正确的响应。而陪练要专业，比如在乒乓球队，陪练 A 模仿的是韩国的柳承敏；陪练 B 模仿的是欧洲骁将萨莫索诺夫。这就要求他们本身的球路要和被模仿者比较类似，要专门刻意去模仿。<\/p><h2 id=\"1.IT 界的“虚拟化”|outline\">IT 界的“虚拟化”<\/h2><p>体育界有\"陪练\"，我们 IT 业，有\"虚拟化\"，就是一个陪练公司，可以根据顾客的要求，过来挑选合适的\"陪练\"，并且我们\"更胜一筹\"，拥有如下的特点：<\/p><ul class=\"ibm-bullet-list\"><li>IT 的\"虚拟化\"可以定制，如\"硬件虚拟化\"中，您要什么样的 CPU，多大的内存和硬盘，好，直接定制；在\"服务虚拟化\"中，也可以快速定制符合业务逻辑的返回值。<\/li><li>IT 业的\"虚拟化\"更多层次化，要虚拟硬件，好，用 PowerVM、VMware 等技术，这些组成了基础架构云\"IAAS\",如果需要的是硬件里面都安装好了操作系统，甚至安装好了中间件，数据库，有 IBM Pure 等技术，更有众多的平台云\"PAAS\";如果直接想要这些平台上的服务，好吧，就有我们的讨论重点，\"服务虚拟化\"了，\"服务虚拟化\"提供的就是五彩斑斓的服务云\"SAAS\"。<\/li><li>和体育界一个陪练可以陪多个人一样，\"服务虚拟化\"也一样，虚拟化出来的服务也可以给多个系统使用。这一点，软件\"虚拟化\"更占优势，计算机的特性就是可以\"快速复制\"，一个\"虚拟化的服务\"完成了，快速复制出来多份，这样就达到了分身两个\"萨莫索诺夫\"，分别和马琳，王励勤同时过招！ 很牛吧？我们 IT 业的\"虚拟化\"更容易复制，有了一套虚拟机，直接 Copy,第二台就出来了。这是我们 IT 业固有的特点。<\/li><\/ul><p>同样的道理，在航空航天业，也有\"虚拟化\"技术，比如模拟机。我们的飞机驾驶员在真正飞上蓝天之前，不知道在\"模拟机\"里面留下了多少汗水。而针对空客 A380 和波音 787 的模拟机是很不一样的，对吧，\"模拟机\"也要专业。<\/p><h2 id=\"1.虚拟化，懂；但,服务虚拟化,是什么？|outline\">虚拟化，懂；但,服务虚拟化,是什么？<\/h2><p>好的，\"虚拟化\"就是一种\"仿真\"，我们 IT 行业的\"虚拟化\"技术也很多，最熟悉的大概是 VMware,VMware 是硬件虚拟化。而这里是\"服务虚拟化\"，比 VMware 更直接，省掉了很多步骤，直接提供客户最需要的服务！<\/p><p>用图表说话，如下图，最下面的是硬件，包括 CPU 内存存储等等；其上面是操作系统，Windows 还是 Linux 等；操作系统上面是系统软件，如中间件\n    Websphere、Weblogic、Tomcat、数据库 DB2、Oracle 等；在这些系统软件之上就是具体的应用服务了，也是我们经常写代码实现的地方，如提供了一个\"天气预报\"的服务。信息保存在数据库中，用户访问 Tomcat 网站，输入\"北京\"，提交后就返回了\"北京\"当天的天气情况\"晴转多云\"，这是一个应用中的具体服务。<\/p><p>我们搭建硬件，安装系统软件，再写代码,最终的目标还是提供最上层的服务。<\/p><h5 id=\"N10087\">图 1.应用服务的层次<\/h5><img alt=\"应用服务的层次\" src=\"/sunshine_new/images/739579839/image003.jpg\" width=\"338\" /><p>想一想，VMware\"虚拟化\"的是哪部分？ 是最下面的\"硬件系统\"，您在一台强悍的机器上安装了 VMware，打开 VMware,里面建立了一个虚拟机，分配了 2CPU、8G\n    内存等。这就虚拟出来了一台硬件电脑，不过现在是台\"裸机\"，上面没有安装任何操作系统和系统软件，然后呢？您的目的是把您的网站部署在这台电脑上最终对外提供服务，所以，您需要继续在这台\"VMware\"虚拟机中安装操作系统，比如 Windows 2008， 继续安装 Tomcat、DB2 数据库。最后部署您的应用到这台电脑上，启动应用。 好吧，网站终于架起来了，可以对外提供\"天气预报\"服务了。<\/p><p>在上面的过程，您虚拟化的是硬件，然后在这个硬件基础上继续安装了完整的操作系统，系统软件，应用软件等。那么我们还能做的更简单吗？ 能不能不安装这么多，就快速的提供\"天气预报\"服务？ 我要的很简单，就是发送\"北京\"，日期\"2013/08/02\"给您，您给我返回\"晴转多云\"。<\/p><p>这个可以简单，我们可以使用\"服务虚拟化\"来完成这个要求，我们可以模拟服务，检查您发送\"北京\"，\"2013/08/02\"过来，就给您返回\"晴转多云\"。如果您选择其他日期，我也给您返回。我的能力是提供最近一周的天气信息，这些信息直接保存在我的虚拟化服务中。根据您的输入返回不同日期的天气。<\/p><h5 id=\"N10099\">图 2.硬件虚拟化和服务虚拟化的服务层次<\/h5><img alt=\"图 2.硬件虚拟化和服务虚拟化的服务层次\" src=\"/sunshine_new/images/739579839/image005.jpg\" width=\"534\" /><p>这个的确更简单吧，那么我们来对比下硬件虚拟化和服务虚拟化的特点：<\/p><h5 id=\"N100AE\">表 1.硬件虚拟化和服务虚拟化的对比<\/h5><table border=\"0\" cellpadding=\"0\" cellspacing=\"0\" class=\"ibm-data-table\" summary=\"\"><thead xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"><tr><th style=\"text-align:center; vertical-align:top\">\n类别\n<\/th><th style=\"text-align:center; vertical-align:top\">\nVMware 等硬件虚拟化\n<\/th><th style=\"text-align:center; vertical-align:top\">\nRTW 等服务虚拟化\n<\/th><\/tr><\/thead><tbody xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"><tr><td style=\"text-align:center; vertical-align:top\">\n虚拟化的对象\n<\/td><td style=\"text-align:center; vertical-align:top\">\n硬件\n<\/td><td style=\"text-align:center; vertical-align:top\">\n应用\n<\/td><\/tr><tr><td style=\"text-align:center; vertical-align:top\">\n虚拟化的方法和技术\n<\/td><td style=\"text-align:center; vertical-align:top\">\n把 VMware 软件安装在电脑上；启动后新建 VMware 应用，设定硬件信息；然后上安装操作系统，系统软件等\n<\/td><td style=\"text-align:center; vertical-align:top\">\n把 RTW 安装在电脑上；<br />\n启动后，新建一个应用服务，<br />\n配置服务的协议，服务的内容等；不需要安装操作系统，系统软件等。\n<\/td><\/tr><tr><td style=\"text-align:center; vertical-align:top\">\n虚拟后的工作\n<\/td><td style=\"text-align:center; vertical-align:top\">\n虚拟化后，根据需要，继续安装操作系统，系统软件，应用程序等，才可以对外提供服务\n<\/td><td style=\"text-align:center; vertical-align:top\">\n虚拟化后，被虚拟化的服务，其底层操作系统和硬件，后台的其他服务都可以不再需要，完全变成一个黑盒子\n<\/td><\/tr><\/tbody><\/table><p>现在的软件系统，后台都往往有多个子系统，这些系统，又依赖外部的系统，每个要提供服务的系统，而下面呢，往往都有各自的中间件，数据库等系统软件，这些系统软件都运行在各自的硬件服务器上。我们如果把外部的服务虚拟化实现了，后面的系统软件，硬件都不再需要．．．节省的就不仅仅是硬件费用了。继续用图来说明，更形象：<\/p><h5 id=\"N100E3\">图 3.虚拟化服务，不再需要后台和底层系统<\/h5><img alt=\"图 3.虚拟化服务，不再需要后台和底层系统\" src=\"/sunshine_new/images/739579839/image007.jpg\" width=\"563\" /><p>如上图，WAS 服务器提供 Web Services 给前面的 IBM HTTP server。而为了提供这个服务，需要安装 WAS 系统软件，在其底层又需要硬件系统和操作系统；而在 WAS 后台又往往需要更多的服务器，如 DB2 数据库服务器等；现在我们把 WAS 提供的这个 Web Services 的服务通过虚拟化实现了，那就不再需要 WAS 服务器，继而不需要其后台的数据库服务器，以及每个服务器所依赖的硬件系统和操作系统了；而对于前台的 Web Services 服务消费方，IBM HTTP server 来说，后面的部分完全是一个黑盒子，只要继续返回其需要的响应信息，即可。则整个黑色长方形的区域都被替代．．．服务虚拟化的作用。<\/p><p>简单说，VMware 虚拟化出了一台电脑，要使用这台裸机电脑，需要安装操作系统，系统软件，应用软件等；而\"服务虚拟化\"是仿真并接管了服务接口，接口后面的所有硬件，软件都不需要，节省了多少投资？<\/p><p>服务虚拟化的作用是\"仿真\" 外提供服务的这些接口服务。所以在软件行业，其也有一些类似的名称，如\"接口虚拟化\"，\"桩程序\"等。通过\"仿真\"依赖的，不可控制，或者高成本的这些服务接口，快速解决测试环境和开发环境搭建中的环境\"短板\"，从而使开发和测试工作可以更早开展。<\/p><h2 id=\"1.怎么实现“服务虚拟化”|outline\">怎么实现“服务虚拟化”<\/h2><p>好的，服务虚拟化的英文名称是\"Service Virtualization\" ,听起来很奇妙，虚拟化（仿真）的是服务(接口）；接口仿真是不是更顺口？的确是，不过服务虚拟化听起来更大气,大家了解意思即可，不拘泥说法。那么上面讲到了可以去\"虚拟化服务\"，如何实现，什么原理？ 要虚拟化某个服务，首先必须了解之，\"知己知彼\"，继而学习之，才能\"虚拟之\"。<\/p><h3 id=\"N100FB\">了解服务：服务=接口<\/h3><p>那我们就看看\"服务\"如何组成的，继续拿我们经常使用的 Web Services 为例，为了方便理解，我们在这里不再区分\"服务(Service)\"和\"接口(Interface）\"，这两个词在这里是同义词。<\/p><p>\"提供什么服务\"，\"以什么形式提供服务\"，\"服务的表示方式\"等，这些需要明确。如一个加法运算的 Web Services，其实现的服务，就是根据传递过来的两个数字，返回数字的和。接口定义呢，发送过来的数据要包装在 XML 格式的数据包中，返回值也要使用 XML 数据格式；怎么传输呢？ 采用了 HTTP(SOAP)协议。谁来提供这个服务呢？IBM WAS 提供这个服务，谁来消费（申请）这个服务呢，前台的 IBM HTTP server 消费这个服务。这些就共同组成了这个服务。<\/p><p>如一个典型的 Web Services，就包括了下面的内容：<\/p><p><strong>名称：Add<\/strong><\/p><p><strong>模式：请求/应答<\/strong><\/p><p><strong>传输协议：HTTP<\/strong><\/p><p><strong>传输 Server: CalculatorPort<\/strong><\/p><p>这就对应了消息传递中的几个要素，传输表示通讯协议，即\"消息采用什么通道，传递到哪里\"；而模式则首先按照大类来区分，是\"请求／响应\"模式，还是\"广播\"等其他模式；确定了大模式，就该定暗号和标准了，即\"发送什么格式数据给对方，对方什么格式返回过来\"，即传输对应了 Where;而模式对应了 How。<\/p><h2 id=\"3.中间埋伏...虚拟化产生了 |outline\">中间埋伏...虚拟化产生了<\/h2><p>好了，了解了服务，接下来，如何实现仿真?<\/p><p>有点类似安全里面的中间攻击。发送的请求，中途中了埋伏被捕获，然后被假冒应答;如下图：Web 服务器发送给后台中间件服务器的 HTTP 请求（黑色）被捕获（蓝色）传递到了虚拟化服务器上。继而虚拟化服务器 IBM RTVS 取代了真实的 WAS,对外提供 Web Services 的服务。<\/p><h5 id=\"N1011D\">图 4.捕获服务器之间的消息，保存为虚拟服务<\/h5><img alt=\"图 4.捕获服务器之间的消息，保存为虚拟服务\" src=\"/sunshine_new/images/739579839/image009.jpg\" width=\"459\" /><p>好，那么怎么实现中间捕获呢？网络安全监听工具？可以！第一种捕获方法是基于网络的，如安装 winpcap 等网络抓报工具，监听 IBM HTTP server 这台机器发送出去的数据包，然后把\"发送/接收\"的内容都保存起来。不过这种方式必须要求服务的发送方和接收方在物理上是分开的,所以对捕获虚拟机的网卡请求，对无线网络的支持也比较弱,存在一些局限性。<\/p><p>更普遍使用的是\"代理服务器\"的模式。代理服务器，Proxy Server，大家可能都熟悉，为了上网，您是否需要设置浏览器使用代理服务器，然后您发送的所有信息都需要经过代理服务器转发出去？在代理服务器这里，就可以看到您的所有上网记录，对吧？ 既然 IE,FireFox 等浏览器可以使用代理服务器，为什么 IBM HTTP server 不能使用？IBM 推荐使用 RTW 来实现服务虚拟化，其是一个产品家族，更具体点，服务虚拟化使用的是 RTW 家族中的 RIT 模块，而在其实现服务虚拟化的过程中，有一个应用是经常提到的，RIT Platform Pack ,简称 RIT PP,其作用就是代理服务器。如下图，其支持 HTTP,TCP,JDBC 等多种技术的代理。<\/p><h5 id=\"N1012D\">图 5.RIT 的代理服务器技术(RIT Platform Pack)<\/h5><img alt=\"图 5.RIT 的代理服务器技术(RIT Platform Pack)\" src=\"/sunshine_new/images/739579839/image011.jpg\" width=\"402\" /><p>使用了代理服务器后，如下图中，<strong>WEB 服务器<\/strong>发送给<strong>后台 WAS<\/strong>的请求，都被<strong>代理服务器<\/strong>捕获，并保存在<strong>虚拟化服务器<\/strong>上，这样就实现服务虚拟化。<\/p><h5 id=\"N10147\">图 6.录制过程，使用了代理服务器技术(RIT Platform Pack)<\/h5><img alt=\"图 6.录制过程，使用了代理服务器技术(RIT Platform Pack)\" src=\"/sunshine_new/images/739579839/image013.jpg\" width=\"534\" /><p>当然，代理服务器启动了，我不上钩，怎么捕获？ 这还需要一个\"叛徒\"，有叛徒来带路，把应用带到代理服务器上。<\/p><p>记得吧，我们使用 IE/FireFox 浏览器去上网的时候，如果需要代理服务器，那就需要在浏览器中主动设定，如在 IE 浏览器的工具-internet 选项-局域网设置-代理服务器中。同样，对于 WEB 服务器，也需要设置使用代理服务器。<\/p><p>如配置 Apache Tomcat 以使用 HTTP/TCP 代理的方法如下：<\/p><p>配置 Tomcat 启动脚本（如果使用 Windows，那么为 %CATALINA_HOME%\\bin\\catalina.bat；如果使用 Linux/UNIX，那么为 $CATALINA_HOME/bin/catalina.sh），方法是使用 JAVA_OPTS 变量按如下所示来设置 HTTP/TCP 代理属性：SET JAVA_OPTS=%JAVA_OPTS% -DHTTP.proxyHost=&lt;HTTP/TCP 代理的主机名或 IP 地址&gt; -DHTTP.proxyPort=&lt;在安装 Rational Integration Tester Platform Pack 和/或编辑 registration.xml 文件期间指定的端口号，例如，3128&gt;<\/p><ol type=\"1\"><li>保存并关闭文件。<\/li><li>重新启动 Tomcat。<\/li><\/ol><p>同样，如果捕获 WAS 向后台的请求，就需要设置 WAS 使用代理，同样，对 Weblogic 等也有专门的设置。如下图就是 WAS 控制台中设置 WAS 使用代理服务器的步骤。<\/p><div class=\"codesection\"><pre class=\"displaycode\">打开应用程序服务器 &gt; server1 &gt; 进程定义 &gt; Java 虚拟机 &gt; 定制属性<\/pre><\/div><h5 id=\"N10168\">图 7<\/h5><img alt=\"图 7\" src=\"/sunshine_new/images/739579839/image015.jpg\" width=\"554\" /><div class=\"codesection\"><pre class=\"displaycode\">新增 http.proxyHost 和 http.proxyPort 两个属性，http.proxyHost 是安装 RTW Proxy 所在服务器，http.proxyPort 默认值是 3128<\/pre><\/div><h5 id=\"N10179\">图 8<\/h5><img alt=\"图 8\" src=\"/sunshine_new/images/739579839/image017.jpg\" width=\"554\" /><div class=\"codesection\"><pre class=\"displaycode\">重启服务器，这样通过 WAS 发出的 HTTP 请求就能够被捕获，从而在 RIT 中记录<\/pre><\/div><p>所以说，为了录制得到虚拟化的服务，我们利用代理服务器捕获后台服务器之间传递的消息，从而保存为虚拟化服务。<\/p><p>同时，我们需要强调，在有些场景下，是不能使用录制功能的，如开发过程只是设计完毕，这个 Web Services 服务还没有开发部署；那么也没有关系，既然设计完毕了，就说明接口的分工明确了，\"走什么协议\"，\"发送什么请求，返回什么响应\"已经明确，那么就可以在工具中，采用\"构造\"的方式，把这些定义信息维护进去，完成服务虚拟化的设计。<strong>类似，为了仿真某个乒乓球选手，最好亲自和他过过招，这样可以有第一手资料，更好模仿。如果实在没有机会过招也不要紧，多<\/strong>\"<strong>观察<\/strong>\"<strong> ，多看他的比赛录像，从而也可以学习之，仿真之。<\/strong><\/p><h2 id=\"1.部署服务虚拟化 |outline\">部署服务虚拟化<\/h2><p>还要使用到上面的图片，我们使用录制功能，录制得到的是什么？录制得到到的是请求/响应信息，是成对出现的。把请求/响应信息保存下来，下次网络上如果再有请求，符合这里的请求信息，那么我就用第一次录制好的\"响应\"内容去回应，这样就实现了虚拟化服务的作用，\"李鬼顶替了李逵\"。<\/p><h5 id=\"N1019C\">图 9. 服务虚拟化取代了真实的服务<\/h5><img alt=\"图 9. 服务虚拟化取代了真实的服务\" src=\"/sunshine_new/images/739579839/image019.jpg\" width=\"559\" /><p>可以把虚拟化的服务部署在专门的服务器上，这样，虚拟化的服务就\"共享\"了，可以给多个系统使用。<\/p><h2 id=\"1.来点技术含量的，陪练员不是一堵墙,直来直挡...来点弧圈球 |outline\">来点技术含量的，陪练员不是一堵墙,直来直挡...来点弧圈球<\/h2><p>  \t类似乒乓球的陪练，我们的陪练总不能就像一堵墙一样，无论什么球过来，就直接直线反弹回来吧？要增加点旋转，拉点弧圈，再时不时来个抢攻，这才是真正模仿柳承敏了嘛，柳承敏的球路也是变化多端，有自己特色的\"业务逻辑\"的。（哎，突然想起小时候，俺练习乒乓球时候，没机会找陪练，就在家对着墙练习抽球，所以到现在的球路还是以直板快抽为主，有速度，没弧度)。<\/p><p>好的，回到 IT 业，在还记得在《<a href=\"http://www.ibm.com/developerworks/cn/rational/r-cn-rtwandroidapptesting/\">使用 Rational Integration Tester 和 <\/a><a href=\"http://www.ibm.com/developerworks/cn/rational/r-cn-rtwandroidapptesting/\">Rational Test Virtualization Server 测试并仿真 Web Services<\/a>》 文章中，我们实现了一个虚拟化的\"加法运算\"服务。如果测试人员按照下面的格式发送两个输入 1,2 出去，虚拟服务会捕获，并且返回 3。当然这里输入值和返回值的类型都符合 XML 文件的标准。按照下图显示的格式。<\/p><h5 id=\"N101BA\">图 10.RIT 中的接口定义，包括格式和内容<\/h5><img alt=\"图 10.RIT 中的接口定义，包括格式和内容\" src=\"/sunshine_new/images/739579839/image021.jpg\" width=\"582\" /><p>既然仿真的接口是完成加法运算的，那么如果您把发送的值，修改为 2，3，那么仿真服务是否会自动返回 5 呢？ 很不幸，默认情况下虚拟化的这个服务不会返回 5，因为它现在还类似\"裸机\"，是一个\"死板的服务\"，不知道如何做加法运算。<\/p><p>能加点技术含量，如业务逻辑吗？如仿真模块自动判断两个输入，自动把两个输入做加法运算，然后返回值？ 这样，就不简单是 1+2=3 了，如果传递过来 2，3，就给您返回 5。呵呵。 对，这就是要求仿真能实现业务逻辑！<\/p><p>这个可以有，必须有！在 RIT 工具中编辑虚拟化服务的时候，在业务逻辑模块（Business logic)，就可以完成这个任务。如下，在\"业务逻辑\"模块，增加一个函数，完成加法运算。<\/p><h5 id=\"N101CC\">图 11.RIT 中的虚拟化服务实现：业务逻辑层的操作<\/h5><img alt=\"图 11.RIT 中的虚拟化服务实现：业务逻辑层的操作\" src=\"/sunshine_new/images/739579839/image023.jpg\" width=\"489\" /><p>\t在上图中，可以看到一长串的工具栏，里面提供了更多的\"武器\"，可以进一步发送请求到其他服务器，获取信息，包装以后再返回。如调用第三方系统的解密函数，把 value1,value2 解密后再运算；运算后调用加密函数，加密后才返回。同样，在服务虚拟化中，还有更多的一些设置，如\"符合条件\"的输入才捕获，才处理，没有匹配成功则放过。<\/p><p>\t陪练员不能使用万能的，全懂就代表全不精。羽毛球的陪练员不能陪您练乒乓球。所以，服务仿真也是有范围的。 要仿真，您就要懂他们的语言，了解接口的定义信息。而不同的接口是千变万化的，所以仿真不同的服务接口就有不同的技术要求。<\/p><p>\t什么是服务，怎么找到服务。这就是一个问题。这里我们换一个例子，从天津到上海，有多种途径，比如火车，飞机，轮船；而不同的途径，对应不同的使用方式， 比如乘坐火车需要检查身份证和火车票，飞机只要有身份证就可以，同时要先拿身份证换登机牌。服务接口定义的就是这些，<strong>走什么途径对应协议，怎么对暗号（办什么手续）对应约定交互的信息格式等。这些就是协议和报文格式(Schema)<\/strong>。<\/p><p>\t不同的软件系统之间接口交互都会预先约定这些途径和暗号。如 WSDL 文件就定义了 Web Services 请求的 schema,它说明了送什么样的信息给提供方，它会返回什么格式的信息。一般 WSDL 都采用的 HTTP 协议传输，也偶尔有采用 HTTPS 协议的。<\/p><p>在远洋运输行业，EDI（电子数据交互）就定义了类似的报文格式。采用的协议经常是 FTP 或者邮件相关的协议等。<\/p><p>\t所以，我们如果要仿真服务，就需要支持仿真的协议，细化点，包含了报文的传输方式和报文的格式两个方面的支持。对于一个服务仿真工具，其会专门说明其支持的应用协议和数据格式范围，如 RIT 支持的类型如下表：Messaging Protocols 是协议，包括我们常见的 HTTP,HTTPS,TCP 等；而 Message Formats 就是具体的报文格式，如海关行业使用的 EDI,医疗行业的 HL7 等。<\/p><h5 id=\"N101E8\">图 12.RIT 支持仿真的协议和消息格式<\/h5><img alt=\"图 12.RIT 支持仿真的协议和消息格式\" src=\"/sunshine_new/images/739579839/image025.jpg\" width=\"582\" /><p>而中间的 SOA,ESB,Others 代表什么呢？不代表协议，也不代表报文格式，其代表的 RIT 对他们有独特的支持，可以更快更方便的对这些类型的应用获取到协议和报文格式...不需要您再一个个手工配置了。典型的如这里列出的\"WSDL\",就代表 RIT 可以直接根据 WSDL 的内容自动获取使用的协议，要发送到的服务器（什么途径，发送到哪里?），发送／接受的消息格式。还记得否？在《<a href=\"http://www.ibm.com/developerworks/cn/rational/r-cn-rtwandroidapptesting/\">使用 Rational Integration Tester 和 Rational Test Virtualization Server 测试并仿真 Web Services<\/a>》 文章中，我们拷贝了 WSDL 的链接到 RIT 中，其自动弹出了接口同步界面，同步后自动产生的服务接口的调用逻辑关系图？就是因为 WSDL 是超级 VIP,所以 RIT 很关照，有专门的支持。类似的，航空公司的 VIP 都可以进休息室，因为他们牛，VIP，不服不行。<\/p><p>同时，在这里我们请思考\"如果 RIT 支持我的协议，但是不支持我的报文格式，会发生什么？\"支持协议，代表 RIT 可以捕获到您的协议，捕获到报文内容；但是由于报文格式不支持，就无法解读，无法分析，无法替换，无法参数化。这里很类似间谍战中，您捕获了我的消息，但是没有我的密码/解密本，所以，您不懂我传递的具体内容...<\/p><h3 id=\"N101FB\">选择哪些服务来虚拟化？<\/h3><p>服务虚拟化，看起来很好；马上找个服务，开始虚拟化...且慢...在实际工作中，我们应该选择哪些服务来虚拟化呢？总要讲究方法吧?<\/p><p>回到乒乓球的陪练，还记得一开头我们就提到了要仿真韩国的柳承敏吗？ 为什么是他？<\/p><ul class=\"ibm-bullet-list\"><li>因为他是中国队重要的竞争对手，他水平高，我们的选手在国际大赛中总能遇到他；<\/li><li>更关键的是，他不是中国人！他是我们的竞争对手！马琳水平也不错，王励勤更全面，为什么不仿真他们？ 因为他们都是中国人，都很听蔡振华教练的话；谁如果想和他们过招，蔡导就可以安排！就是这些资源是我们自己的，可控。<\/li><li>柳承敏相对容易仿真，中国队人才储备好，兵多将广，有球路和柳承敏类似的选手，所以仿真相对容易；如果是德国队，本身自己的队员就还需要进口，哪里有精力有资源去模仿别人？<\/li><\/ul><p>类似的，选择哪些服务需要虚拟化，也经常考虑如下的因素：<\/p><ul class=\"ibm-bullet-list\"><li><strong>服务是否可控<\/strong>：如果服务容易建立，随时可用，那就使用真实的服务即可，没有必要使用\"替身\"。<\/li><li><strong>服务的重要性／依赖性<\/strong>：没有这个服务不可行！对业务来说，这个服务是必不可少的。<\/li><li><strong>是否容易仿真这个服务<\/strong>：投入产出比，仿真这个服务的技术难度？需要的投入等。<\/li><\/ul><p>所以，总结下，选择虚拟化的服务往往是\"必不可少的\"，\"存在资源竞争的\"。<\/p><p>如一个公司，已经使用了面向服务的架构（SOA），其一个在线订购应用的实现需要利用各种服务，如订购移交服务，第三方的信用查询服务，第三方的支付服务，提供新设备的客户服务，以及数据库。<\/p><h5 id=\"N1021E\">图 13.服务虚拟化让不可用的服务变得可用<\/h5><img alt=\"图 13.服务虚拟化让不可用的服务变得可用\" src=\"/sunshine_new/images/739579839/image027.jpg\" width=\"488\" /><p>现在第三方的信用查询服务 URGoodForIt 服务是服务虚拟化的一个很好的候选，因为<\/p><ul class=\"ibm-bullet-list\"><li>依赖性：这个服务是必须需要的，如果它的可用性被延迟，在开始测试之前，团队不得不等待服务可用。<\/li><li>不可控：URGoodForIt 服务属于第三方，而且每次执行的时候都有成本。<\/li><li>投入产出比：由于 URGoodForIt 是由第三方提供的，测试中每次使用服务时，企业都需要支付一定的费用。而在性能测试中，该费用上升的非常快。<\/li><li>技术可行性：URGoodForIt 是一个标准的 Web Services 服务，有明确的 WSDL 接口定义信息，容易仿真。<\/li><\/ul><h2 id=\"1.真真假假，虚虚实实？仿真和真实在一起 |outline\">真真假假，虚虚实实？ 仿真和真实在一起<\/h2><p>想象下这个需求：一个服务器提供了 6 个服务，我要仿真并取代其中的 2 个服务，其余 4 个继续使用真实的服务，这个可以有。就比如北京移动的手机缴费系统，缴费可以使用银行卡，信用卡，支付宝等。如果现在招行信用卡暂时不可以使用，那就仿真招行信用卡的服务，其他的业务正常使用真实接口工作。这个术语叫做 Pass-through。Rational 服务虚拟化是支持这个特性的。<\/p><p>如下图，对于符合\"条件\"的请求，Proxy server 会发送给 RTVS 虚拟化服务器直接响应，而对于不符合条件的请求，直接转发到原始的的服务器处理（这里是 WAS 服务器）。<\/p><h5 id=\"N1023E\">图 14.真实模块和虚拟模块混合工作：虚拟化服务器把不符合条件的请求继续转发给真实的服务器<\/h5><img alt=\"图 14.真实模块和虚拟模块混合工作：虚拟化服务器把不符合条件的请求继续转发给真实的服务器\" src=\"/sunshine_new/images/739579839/image029.jpg\" width=\"566\" /><p>正是因为可以和真实的服务配合工作，我们可以提供虚虚实实的组合服务，从而满足过渡阶段的需要。为了使用这个功能，需要在 RIT 中编辑虚拟化服务的时候来设定，如下图，设置 HTTP 请求没有符合条件的响应时候，是继续\"传递\"到<\/p><p>真实的服务，还是\"废弃\"掉，或者是模拟一个具体的错误。<\/p><h5 id=\"N1024F\">图 15.RIT 中设置继续传递消息到真实服务<\/h5><img alt=\"图 15.RIT 中设置继续传递消息到真实服务\" src=\"/sunshine_new/images/739579839/image031.jpg\" width=\"566\" /><p>如上，在 RIT 中编辑虚拟化服务时候，可以全局设置，也可以针对单个的\"虚拟化服务\"设置其是否采用继续\"传递\"请求到真实服务。<\/p><h2 id=\"1.致谢 |outline\">致谢<\/h2><p>本文介绍\"服务虚拟化\"等，分析其技术原理，适用场景，并且和众多的相关技术进行了对比；为了简单易懂，尽量用简单的文字，类比的方法来介绍，如有不严谨处，欢迎指正！也希望多与大家交流，共同完善。本文在写作过程中，得到了诸多同事和协助和启发，包括 IBM 软件部市场部的李丹，夏鑫琪，技术部门的姚炳雄，IBM 开发实验室刘昕鹏等的支持，在此一并表示感谢！<\/p><h2 id=\"1.术语列表 |outline\">术语列表<\/h2><p>本书使用到了多个术语，概括介绍如下：<\/p><p><strong>服务虚拟化<\/strong>，也被称为服务仿真，接口仿真，桩程序，存根等，通过模仿一个服务接口的业务逻辑，对外提供该接口的服务。<\/p><p><strong>RTW<\/strong>: 全称是 Rational Test Workbench, Rational 测试工作台，是 IBM Rational 推出的全面的软件测试工具集，包括自动化功能测试 RFT, 自动化性能测试 RPT,自动化接口测试 RIT,自动化手机应用测试 RTW eclipse 等主要模块； 其中 RIT 可以完成接口自动化测试，以及服务虚拟化的生成和编辑。其和 RTVS 配合可以完成完整的服务虚拟化环境搭建。<\/p><p><strong>RTVS<\/strong>: Rational Test Virtualization Server,Rational 测试虚拟化服务器，是一个 B/S 结构的管理平台，统一管理 RIT 产生的虚拟化服务，安装以后也叫做 Rational Test Control Panel。<\/p><p>URL: <a href=\"http://www.ibm.com/developerworks/cn/rational/products/testworkbenchseries.html\">http://www.ibm.com/developerworks/cn/rational/products/testworkbenchseries.html<\/a><\/p><p><em>IBM Rational Test Workbench（简称 RTW）是 IBM Rational 的统一的测试工具 集，包括功能测试、性能测试、接口 SOA 测试等模块，满足客户多种类型的自动化测试需求。本系列文章结合具体的应用，和大家一起分析如何使用 RTW 完成手机自动化测试，接口集成测试，以及通过服务虚拟化实现测试环境的仿真，从而展示 RTW 全面的自动化测试能力，方便大家了解 RTW 并在您的实际工作中应用 RTW。<\/em><\/p><CMA ID: 970520><Site ID: 10><XSLT stylesheet used to transform this file: dw-document-html-7.0.xsl>\r\n\r\n\r\n<\/div>\r\n<\/div>\r\n","createTime":"2014-05-06 00:00:00","deployTime":"2014-05-06 00:00:00","id":0,"intro":"2012 年初，通过收购绿帽子（GreenHat），IBM 进入了软件 Service Virtualization 领域，什么是服务虚拟化，为什么需要服务虚拟化？怎么进行服务虚拟化？本文希望用简单易懂的语言，引领大家进入“服务虚拟化”的世界，一起讨论，共同学习！","keyword":"","recommend":false,"source":"http://www.ibm.com/developerworks/cn/rational/1405_zhuangjq_servicevirtual/index.html","title":"漫谈“服务虚拟化”","typeId":0,"updateTime":"2014-05-06 00:00:00"}
{"author":"","clickNumber":0,"content":"\r\n<div class=\"ibm-columns\">\r\n<div class=\"ibm-col-1-1\">\r\n\r\n<h2 id=\"1.CSS 基础 |outline\">CSS 基础<\/h2><h3 id=\"1.1.背景 |outline\">背景<\/h3><p>CSS, Cascading Style Sheets，中文称层叠样式表，它是一种描述性语言也是一种规范，它用来描述用标记语言写成的文档(如 HTML, XML, SVG)的外观和样式。CSS 规范由 W3C 组织来维护。<\/p><p>CSS 最初被设计用来分离文档的内容和显示样式如颜色字体排版。这种内容和显示的分离可以使得文档的内容可读性增强，并且显示的样式易于管理。除此之外，CSS 还可以用于文档在不同的设备或不同的渲染方式下灵活的展现。<\/p><p>CSS 为什么要叫做层叠样式表呢？这个层叠主要是指样式的覆盖，当一个元素被应用上多种同类型的样式时，浏览器必须选择一个最终的样式，这个过程就叫做层叠。具体如何选择涉及到样式的优先级判定，我们会在下文中详细介绍。<\/p><h3 id=\"1.2.语法 |outline\">语法<\/h3><p>\tCSS 的语法非常简单明了，一个 CSS 样式表文件包含了一系列的样式规则(rules or rule-sets)，每个样式规则都由一个选择器(selector)或分组选择器和一个样式描述块(declaration block)组成。<\/p><a id=\"1.2.1.选择器 Selector|outline\"><\/a><p><strong>选择器 Selector<\/strong><\/p><p>\t选择器主要是在 CSS 用来声明一个文档中的哪些部分需要被添加上该选择器对应的 Declaration block 中描述的 CSS 样式。<\/p><p>\t选择器的类型主要有常用的元素选择器，ID 选择器，类选择器以及属性选择器和伪类等。<\/p><a id=\"1.2.2.Declarationblock|outline\"><\/a><p><strong>Declaration block<\/strong><\/p><p>\t每一个选择器或分组选择器后都对应一个花括号包围的样式声明块 Declaration block，在这个块中可以包含多条不同类型的样式，每条样式之间用逗号隔开。<\/p><a id=\"1.2.3.使用 |outline\"><\/a><p><strong>使用<\/strong><\/p><p>\tCSS 的使用主要有以下三种方式，<\/p><ol type=\"1\"><li>内联样式，直接添加到 HTML 元素上的样式\n<div class=\"codesection\"><pre class=\"displaycode\">&lt;div style=\"width:400px\"&gt;<\/pre><\/div><\/li><li>外部样式，用&lt;link&gt;标签添加任意个对外部 CSS 的引用，需要注意的是&lt;link&gt;只能出现在&lt;head&gt;块内。\n<div class=\"codesection\"><pre class=\"displaycode\">&lt;link rel=\"stylesheet\" href=\"path/file.css\"/&gt;<\/pre><\/div><\/li><li>内部样式，&lt;style&gt;中直接添加 CSS 样式，同样地，&lt;style&gt;也只能出现在&lt;head&gt;块内。\n<div class=\"codesection\"><pre class=\"displaycode\">&lt;style tyle=\"text/css\"&gt;<\/pre><\/div><\/li><\/ol><h3 id=\"1.3.CSS 历史 |outline\">CSS 历史<\/h3><p>\tCSS 第一版规范也就是我们常说的 CSS1 是由 W3C 在 1996 年公布的，规范中主要提出了对 font，color，spacing，alignment，margin，padding 等方面的规定。但是从规范发布一直到 1999 年的这三年间，当时市面上的浏览器 IE3，IE4，NetScape4.x 对 CSS1 的支持都不是很好，很多实现不符合规范要求并且 bug 很多。三年之后，市面主流的各大浏览器才开始完整地支持 CSS1 规范，2000 年发布的 IE5 是第一个完整支持 CSS1 的浏览器。<\/p><p>\tCSS2 与 1998 年发布，CSS2 在 CSS1 的基础上增加了对元素位置方面的规定如 absolute/relative/fixed 和 z-index。<\/p><p>\tCSS3 最初于 1999 年发布 Draft 版本的时候采用了一个新的理念，它把整个规范拆分为若干个文档，每个文档称为一个模块（module），每个模块针对不同的方面增加或扩展新的属性。截止 2013 年末，已经拥有 W3C 正式的推荐规范（Recommendation Specification）的 Level3 模块有如下 4 个：Media Queries，Namespaces，Color，Selectors。此外还有 Backgrounds and Borders，Syntax，Display 等几十个模块拥有候选推荐规范（Candidate Recommendation Specification）或草拟规范（Working Draft）等一些还没有完成的规范状态。<\/p><p>\t目前 W3C 组织只对 CSS2 和 CSS3 进行维护更新，所以现在 W3C 都是独立发布某个模块的规范。<\/p><h2 id=\"2.CSSOM 接口介绍及浏览器支持分析 |outline\">CSS OM 接口介绍及浏览器支持分析<\/h2><p>\t通过上一章的介绍我们对 CSS 的语法结构，发展历史以及如何使用有了一个大概的了解。我们知道 CSS 可以通过外部引用，内部定义以及元素内联这三种静态的方式引入页面从而影响 HTML 页面的展示。那么 CSS 可以动态变化吗？答案是肯定的。<\/p><p>\t当前 JavaScript 等脚本语言广泛地应用在各种 HTML 页面中，脚本使得页面可以根据用户的交互而动态展示。这种效果很多就是通过脚本去操作 CSS 来实现的，所以本文研究的就是用户通过脚本语言去操作页面中的 CSS 时不同的浏览器对这些操作的支持程度。<\/p><p>\t要研究脚本语言如何操作 CSS，首先就要清楚一个概念，那就是 CSS Object Model。CSS Object Model 指的是 CSS 的对象模型，CSS 的整个内容会转化为相应的对象，如样式表对象 StyleSheet，选择器对象 Selector，规则对象 Rule 等等，而这些对象都是定义在 W3C 规范&lt;Document Object Model (DOM) Level 2 Style Specification&gt; (http://www.w3.org/TR/DOM-Level-2-Style/)中的接口。该规范包含两章，第一章主要围绕 Style Sheets 模块展开，对应的是对整个样式表的操作；第二章主要包含两个模块，CSS Module 和 CSS2 Module，对应的是样式表中的选择器和规则的操作。下面我们分别详细介绍这三个模块中的接口以及浏览器的支持程度分析。<\/p><h3 id=\"2.1.StyleSheetsModule|outline\">Style Sheets Module<\/h3><p>\t这个模块包含了共 5 个接口。<\/p><p>\t第一个是 StyleSheet，这个接口是一个抽象的基础接口，主要描述了文档(HTML/XML)中的一个单独的样式表。当文档是 HTML 时，这个接口描述的可能是&lt;link&gt;标签添加的外部 CSS 文件，也可能是&lt;style&gt;标签添加的一些内部样式。当文档是 XML 时，这个接口描述的是通过&lt;?xml-stylesheet&gt;添加的外部 CSS 文件。<\/p><p>\tStyleSheet 接口中声明了如下几个样式表的属性：<\/p><ul class=\"ibm-bullet-list\"><li>\ttype 表示该样式表的描述语言，一般值为 text/css，<\/li><li>\tdisabled\t表示该样式表是否为 disabled 状态，<\/li><li>\townerNode\t表示该样式表所属的节点，对 HTML 来言可能是&lt;link&gt;或&lt;style&gt;，<\/li><li>\tparentStyleSheet\t表示了该样式表的父样式表，如果不支持样式表包含那么值为 null，<\/li><li>\thref  表示了该样式表的源文件，当 ownerNode 为&lt;style&gt;时 href 为 null，<\/li><li>\ttitle\t  表示了该样式表的 title 信息，<\/li><li>\tmedia   表示了该样式在什么的显示媒体下生效，media 属性返回的是一个 MediaList 实例。<\/li><li>\tStyleSheetList 是一个包含了 StyleSheet 的有序集合。我们可以通过 document.styleSheets 来得到这个集合，然后直接通过下标访问每个 StyleSheet，如 document.styleSheets[0]。StyleSheetList 有一个属性 length 和一个方法 item(index)。Length 表示集合的长度，方法可以通过索引来取得对应的 StyleSheet。<\/li><li>\tMediaList 包含了 StyleSheet 中的 media 信息集合，该接口中声明了如下几个属性和方法：<\/li><li>\tmediaText   表示 media 属性的字符串值，可能有多个值，用逗号隔开，如\"screen,print,projection\"等，<\/li><li>\tlength\t表示含有几个 media 字符串，<\/li><li>\titem(index)\t通过 index 访问对应位置的 media 字符串，<\/li><li>\tdeleteMedium(oldMedium)  删除一个 media 字符串，<\/li><li>\tappendMedium(newMedium)\t  添加一个 media 字符串。<\/li><\/ul><p>\t以上三个接口主要是针对 StyleSheet 定义的新接口，而下面的两个接口实际上是针对 Document 扩展的子接口。<\/p><p>\tLinkStyle 接口主要是提供一种从&lt;link&gt;，&lt;style&gt;节点获取样式表的方式。LinkStyle 的实例可以从 HTMLLinkElement，HTMLStyleElement(或 ProcessingInstruction)中获得。LinkStyle 接口只有一个属性就是 sheet，这个属性存储从节点获得的 StyleSheet 实例。<\/p><p>\tDocumentStyle 接口提供一种从嵌入文档的样式中获得样式表的方式。DocumentStyle 的实例可以从 Document 的实例中获得。DocumentStyle 只有一个属性就是 styleSheets，这个属性存储的是嵌入文档中的所有样式列表 StyleSheetList。<\/p><p>\t对这 5 个接口的测试结果如下表所示，<\/p><h5 id=\"2.1.1.表 1StyleSheetsModule 中五个接口测试结果 |outline\">表 1.Style Sheets Module 中五个接口测试结果<\/h5><table border=\"0\" cellpadding=\"0\" cellspacing=\"0\" class=\"ibm-data-table\" summary=\"\"><thead xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"><tr><th style=\"vertical-align:top\"/><th style=\"text-align:center; vertical-align:top\">\n      IE\n    <\/th><th style=\"text-align:center; vertical-align:top\">\n      FireFox\n    <\/th><th style=\"text-align:center; vertical-align:top\">\n      Chrome\n    <\/th><\/tr><\/thead><tbody xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"><tr><td colspan=\"4\" style=\"text-align:left; vertical-align:top\">\nStyleSheet\n<\/td><\/tr><tr><td style=\"text-align:center; vertical-align:top\">\ntype/disabled /title\n<\/td><td style=\"text-align:center; vertical-align:top\">\n支持\n<\/td><td style=\"text-align:center; vertical-align:top\">\n支持\n<\/td><td style=\"text-align:center; vertical-align:top\">\n支持\n<\/td><\/tr><tr><td style=\"text-align:center; vertical-align:top\">\nhref\n<\/td><td style=\"text-align:center; vertical-align:top\">\n支持，从 IE8 开始显示完整 URL\n<\/td><\/tr><tr><td style=\"text-align:center; vertical-align:top\">\nmedia\n<\/td><td style=\"text-align:center; vertical-align:top\">\n错误的字符串值\n<\/td><\/tr><tr><td style=\"text-align:center; vertical-align:top\">\nownerNode\n<\/td><td style=\"text-align:center; vertical-align:top\">\n从 IE9 开始支持\n<\/td><\/tr><tr><td style=\"text-align:center; vertical-align:top\">\nparentStyleSheet\n<\/td><\/tr><tr><td colspan=\"4\" style=\"text-align:left; vertical-align:top\">\nStyleSheetList\n<\/td><\/tr><tr><td style=\"text-align:center; vertical-align:top\">\nlength\n<\/td><td style=\"text-align:center; vertical-align:top\">\n支持\n<\/td><td style=\"text-align:center; vertical-align:top\">\n支持\n<\/td><td style=\"text-align:center; vertical-align:top\">\n支持\n<\/td><\/tr><tr><td style=\"text-align:center; vertical-align:top\">\nitem()\n<\/td><\/tr><tr><td colspan=\"4\" style=\"text-align:left; vertical-align:top\">\nMediaList\n<\/td><\/tr><tr><td style=\"text-align:center; vertical-align:top\">\nmediaList\n<\/td><td style=\"text-align:center; vertical-align:top\">\n从 IE9 开始支持\n<\/td><td style=\"text-align:center; vertical-align:top\">\n支持\n<\/td><td style=\"text-align:center; vertical-align:top\">\n支持\n<\/td><\/tr><tr><td style=\"text-align:center; vertical-align:top\">\nlength\n<\/td><\/tr><tr><td style=\"text-align:center; vertical-align:top\">\nitem()\n<\/td><\/tr><tr><td style=\"text-align:center; vertical-align:top\">\ndeleteMedium()\n<\/td><\/tr><tr><td style=\"text-align:center; vertical-align:top\">\nappendMedium()\n<\/td><\/tr><tr><td colspan=\"4\" style=\"text-align:left; vertical-align:top\">\nLinkStyle\n<\/td><\/tr><tr><td style=\"text-align:center; vertical-align:top\">\nsheet\n<\/td><td style=\"text-align:center; vertical-align:top\">\n从 IE9 开始支持\n<\/td><td style=\"text-align:center; vertical-align:top\">\n支持\n<\/td><td style=\"text-align:center; vertical-align:top\">\n支持\n<\/td><\/tr><tr><td colspan=\"4\" style=\"text-align:left; vertical-align:top\">\nDocumentStyle\n<\/td><\/tr><tr><td style=\"text-align:center; vertical-align:top\">\nstyleSheets\n<\/td><td style=\"text-align:left; vertical-align:top\">\n支持\n<\/td><td style=\"text-align:center; vertical-align:top\">\n支持\n<\/td><td style=\"text-align:center; vertical-align:top\">\n支持\n<\/td><\/tr><\/tbody><\/table><p>\t通过测试可以看出来，FF，Chrome 对这三个接口的实现都是比较好的。<\/p><p>\tIE 对这个模块的支持非常差，仅仅实现了简单了 type/disabled/title/href 属性。需要注意的是，IE 对 StyleSheet 的 media 属性没有根据 W3C 标准返回 MediaList 实例而是返回 media 属性的字符串。<\/p><p>\t另外，在 IE9 之前用户如果想通过 HTMLLinkElement 和 HTMLStyleElement 元素来取得对应的 StyleSheet 时，由于 IE 不支持 sheet 属性，它有一个替代的方法 styleSheets(id)，这个方法可以通过 ID 取到对应的 StyleSheet 实例。从 IE9 开始，它遵守了 W3C 规范，可以通过 HTMLLinkElement 和 HTMLStyleElement 实例的 sheet 属性来访问到对应的 StyleSheet 实例。<\/p><h3 id=\"2.2.CSSModule|outline\">CSS Module<\/h3><p>\t这个模块包含了 CSSStyleSheet，CSSRuleList，CSSRule，CSSStyleRule，CSSStyleDeclaration 等 21 个接口，这些接口主要是为了让 web 程序开发者可以直接操作样式表中的样式，动态添加或移除某些样式。<\/p><p>\t这个模块和前面介绍的一个模块的区别在于，前面一个模块中包含的接口主要是通过 Document 接口来访问样式表 StyleSheet 实例，而对于实例内部所包含的用户定义样式则通过这个模块的接口来控制。<\/p><p>\t对每一个&lt;link&gt;或&lt;style&gt;嵌入文档的样式表，都有一个 CSSStyleSheet 的实例与之对应，这个接口是 StyleSheet 的子接口。这个接口允许访问样式表中的用户定义样式规则的集合 CSSRuleList，并且可以进行增删改的操作。<\/p><p>\t对 CSSRuleList 中的每一条样式，CSSStyleRule 接口提供了对选择器 Selector 和 Declaration block 的访问。<\/p><p>\t下面详细说明每个接口中常用的属性和方法。<\/p><p>\tCSSStyleSheet 继承自 StyleSheet，<\/p><p>\townerRule \t当这个样式表是&lt;link&gt;或者&lt;style&gt;嵌入文档中时该属性为 null，当这个样式表是@import 进文档时，该属性返回一个 CSSImportRule 的实例，<\/p><p>\tcssRules\t\t返回样式表对应的样式规则列表 CSSRuleList 实例，<\/p><p>\tinsertRule(rule,index)\t在指定位置插入一条样式规则，<\/p><p>\tdeleteRule(index)\t删除指定位置的样式规则。<\/p><p>\tCSSRuleList 是样式表中样式规则的集合，每个样式都是一个 CSSRule 的实例，可以通过位置信息被访问，<\/p><p>\tlength\t样式表中包含的规则数量，<\/p><p>\titem(index)\t通过位置信息访问对应的某条规则。<\/p><p>\tCSSRule 是任意类型的样式规则（包含普通的规则和@规则）的一个抽象接口，，有一系列的实际类型的规则接口继承自这个上层接口，<\/p><p>\t这个接口有 7 个常量，分别来描述不同类型的规则：<\/p><div class=\"codesection\"><pre class=\"displaycode\">  UNKNOWN_RULE           = 0;\n  STYLE_RULE             = 1;\n  CHARSET_RULE           = 2;\n  IMPORT_RULE            = 3;\n  MEDIA_RULE             = 4;\n  FONT_FACE_RULE         = 5;\n  PAGE_RULE              = 6;<\/pre><\/div><p> type\t返回该条规则的数字类型值，<\/p><p> cssText\t返回规则的内容，注意这个属性得到的是当前的值（可能被修改过）而不是初始化的值，<\/p><p>\tparentRule\t如果这个规则是被包含在另外一条规则中（如@media 中包含的规则），那么返回包含它的规则，否则返回 null，<\/p><p>\tparentStyleSheet\t返回包含规则的 StyleSheet。<\/p><p>\t继承自 CSSRule 的接口有以下一些，用一个表格来对比，<\/p><h5 id=\"2.2.1.表 2 继承自 CSSRule 的接口介绍 |outline\">表 2.继承自 CSSRule 的接口介绍<\/h5><table border=\"0\" cellpadding=\"0\" cellspacing=\"0\" class=\"ibm-data-table\" summary=\"\"><thead xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"><tr><th style=\"text-align:center; vertical-align:top\">\n接口\n<\/th><th style=\"text-align:center; vertical-align:top\">\n定义\n<\/th><th style=\"text-align:center; vertical-align:top\">\n属性与方法\n<\/th><\/tr><\/thead><tbody xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"><tr><td style=\"text-align:center; vertical-align:top\">\nCSSStyleRule\n<\/td><td style=\"text-align:center; vertical-align:top\">\n代表一条普通的规则\n<\/td><td style=\"text-align:center; vertical-align:top\">\nselectorText 返回 selector 文本，可能包含逗号分隔<br />\nstyle 返回 block 中描述的信息，是一个 CSSStyleDeclaration\n<\/td><\/tr><tr><td style=\"text-align:center; vertical-align:top\">\nCSSMediaRule\n<\/td><td style=\"text-align:center; vertical-align:top\">\n代表 at 规则中的@media 规则，用来指定具体 media 时不同的样式\n<\/td><td style=\"text-align:center; vertical-align:top\">\nmedia 返回 MediaList<br />\ncssRules 返回@media 内部的 CSSRuleList<br />\ninsertRule(rule,index)<br />\ndeleteRule(index)\n<\/td><\/tr><tr><td style=\"text-align:center; vertical-align:top\">\nCSSFontFaceRule\n<\/td><td style=\"text-align:center; vertical-align:top\">\n代表 at 规则中的@font-face 规则，用来指定字体的信息\n<\/td><td style=\"text-align:center; vertical-align:top\">\nstyle\n<\/td><\/tr><tr><td style=\"text-align:center; vertical-align:top\">\nCSSPageRule\n<\/td><td style=\"text-align:center; vertical-align:top\">\n代表 at 规则中的@page 规则，用来指定页面的尺寸，方向，margin 等信息\n<\/td><td style=\"text-align:center; vertical-align:top\">\nstyle\n<\/td><\/tr><tr><td style=\"text-align:center; vertical-align:top\">\nCSSImportRule\n<\/td><td style=\"text-align:center; vertical-align:top\">\n代表 at 规则中的@import 规则，用来在规则中导入其他规则\n<\/td><td style=\"text-align:center; vertical-align:top\">\nhref<br />\nmedia<br />\nstyleSheet\n<\/td><\/tr><tr><td style=\"text-align:center; vertical-align:top\">\nCSSCharsetRule\n<\/td><td style=\"text-align:center; vertical-align:top\">\n代表 at 规则中的@charset 规则，用来指定 CSS 文档的字符集属性，如果 CSS 是嵌入到 HTML 文档中的，那么 charset 将使用 HTML 的设定\n<\/td><td style=\"text-align:center; vertical-align:top\">\nencoding\n<\/td><\/tr><tr><td style=\"text-align:center; vertical-align:top\">\nCSSUnknownRule\n<\/td><td style=\"text-align:center; vertical-align:top\">\n代表不识别的 at 规则\n<\/td><td style=\"vertical-align:top\"/><\/tr><\/tbody><\/table><p>\t针对各种 CSSStyleRule，CSSFontFaceRule 和 CSSPageRule，其中的样式 Declaration block 对应一个 CSSStyleDeclaration 实例，可以通过 style 属性访问到。除此之外，CSS2Properties 接口还提供了直接访问 CSSStyleDeclaration 实例的各个属性值的机制，关于这个接口我们在后面会讲到。<\/p><p>测试结果如下，<\/p><h5 id=\"2.2.2.表 3CSSModule 中主要的接口测试结果 |outline\">表 3.CSS Module 中主要的接口测试结果<\/h5><table border=\"0\" cellpadding=\"0\" cellspacing=\"0\" class=\"ibm-data-table\" summary=\"\"><thead xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"><tr><th style=\"vertical-align:top\"/><th style=\"text-align:center; vertical-align:top\">\n      IE\n    <\/th><th style=\"text-align:center; vertical-align:top\">\n      FireFox\n    <\/th><th style=\"text-align:center; vertical-align:top\">\n      Chrome\n    <\/th><\/tr><\/thead><tbody xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"><tr><td colspan=\"4\" style=\"text-align:left; vertical-align:top\">\nCSSStyleSheet\n<\/td><\/tr><tr><td style=\"text-align:center; vertical-align:top\">\nownerRule\n<\/td><td style=\"text-align:center; vertical-align:top\">\n从 IE9 开始支持，IE9 之前的版本提供了替代的 rules/addRule()/removeRule()\n<\/td><td style=\"text-align:center; vertical-align:top\">\n支持\n<\/td><td style=\"text-align:center; vertical-align:top\">\n支持\n<\/td><\/tr><tr><td style=\"text-align:center; vertical-align:top\">\ncssRules\n<\/td><\/tr><tr><td style=\"text-align:center; vertical-align:top\">\ninsertRule()\n<\/td><\/tr><tr><td style=\"text-align:center; vertical-align:top\">\ndeleteRule()\n<\/td><\/tr><tr><td colspan=\"4\" style=\"text-align:left; vertical-align:top\">\nCSSRuleList\n<\/td><\/tr><tr><td style=\"text-align:center; vertical-align:top\">\nlength\n<\/td><td style=\"text-align:center; vertical-align:top\">\n从 IE9 开始支持\n<\/td><td style=\"text-align:center; vertical-align:top\">\n支持\n<\/td><td style=\"text-align:center; vertical-align:top\">\n支持\n<\/td><\/tr><tr><td style=\"text-align:center; vertical-align:top\">\nItem()\n<\/td><td style=\"text-align:center; vertical-align:top\">\n支持，IE9 之前返回的不是 CSSRule 实例\n<\/td><\/tr><tr><td colspan=\"4\" style=\"text-align:left; vertical-align:top\">\nCSSRule\n<\/td><\/tr><tr><td style=\"text-align:center; vertical-align:top\">\ntype\n<\/td><td style=\"text-align:center; vertical-align:top\">\n从 IE9 开始支持\n<\/td><td style=\"text-align:center; vertical-align:top\">\n支持\n<\/td><td style=\"text-align:center; vertical-align:top\">\n支持\n<\/td><\/tr><tr><td style=\"text-align:center; vertical-align:top\">\ncssText\n<\/td><\/tr><tr><td style=\"text-align:center; vertical-align:top\">\nparentRule\n<\/td><\/tr><tr><td style=\"text-align:center; vertical-align:top\">\nparentStyleSheet\n<\/td><\/tr><tr><td colspan=\"4\" style=\"text-align:left; vertical-align:top\">\nCSSStyleRule\n<\/td><\/tr><tr><td style=\"text-align:center; vertical-align:top\">\nselectorText\n<\/td><td style=\"text-align:center; vertical-align:top\">\n支持\n<\/td><td style=\"text-align:center; vertical-align:top\">\n支持\n<\/td><td style=\"text-align:center; vertical-align:top\">\n支持\n<\/td><\/tr><tr><td style=\"text-align:center; vertical-align:top\">\nstyle\n<\/td><\/tr><tr><td colspan=\"4\" style=\"text-align:left; vertical-align:top\">\nCSSMediaRule/ CSSFontFaceRule/ CSSPageRule/ CSSImportRule\n<\/td><\/tr><tr><td style=\"vertical-align:top\"/><td style=\"text-align:left; vertical-align:top\">\n从 IE9 开始支持\n<\/td><td style=\"text-align:center; vertical-align:top\">\n支持\n<\/td><td style=\"text-align:center; vertical-align:top\">\n支持\n<\/td><\/tr><tr><td colspan=\"4\" style=\"text-align:left; vertical-align:top\">\nCSSCharsetRule\n<\/td><\/tr><tr><td style=\"vertical-align:top\"/><td style=\"text-align:left; vertical-align:top\">\n不支持\n<\/td><td style=\"text-align:center; vertical-align:top\">\n支持\n<\/td><td style=\"text-align:center; vertical-align:top\">\n支持\n<\/td><\/tr><tr><td colspan=\"4\" style=\"text-align:left; vertical-align:top\">\nCSSStyleDeclaration\n<\/td><\/tr><tr><td style=\"text-align:center; vertical-align:top\">\ncssText\n<\/td><td style=\"text-align:left; vertical-align:top\">\n支持\n<\/td><td style=\"text-align:center; vertical-align:top\">\n支持\n<\/td><td style=\"text-align:center; vertical-align:top\">\n支持\n<\/td><\/tr><tr><td style=\"text-align:center; vertical-align:top\">\ngetPropertyCSSValue()\n<\/td><td style=\"text-align:left; vertical-align:top\">\n不支持\n<\/td><td style=\"text-align:center; vertical-align:top\">\n错误的结果 null\n<\/td><td style=\"text-align:center; vertical-align:top\">\n支持\n<\/td><\/tr><tr><td style=\"text-align:center; vertical-align:top\">\nlength\n<\/td><td style=\"text-align:left; vertical-align:top\">\n从 IE9 开始支持<br /><\/td><td style=\"text-align:center; vertical-align:top\">\n支持\n<\/td><td style=\"text-align:center; vertical-align:top\">\n支持\n<\/td><\/tr><tr><td style=\"text-align:center; vertical-align:top\">\nparentRule\n<\/td><\/tr><tr><td style=\"text-align:center; vertical-align:top\">\ngetPropertyValue()\n<\/td><\/tr><tr><td style=\"text-align:center; vertical-align:top\">\nremoveProperty()\n<\/td><\/tr><tr><td style=\"text-align:center; vertical-align:top\">\ngetPropertyPriority()\n<\/td><\/tr><tr><td style=\"text-align:center; vertical-align:top\">\nsetProperty()\n<\/td><\/tr><tr><td style=\"text-align:center; vertical-align:top\">\nItem()\n<\/td><\/tr><\/tbody><\/table><p>\t对 CSSStyleRule 而言，在 IE9 之前的版本是不支持 cssRules 属性的，其替代属性 rules 会忽略 at-rules 并且拆分多选择器，如下面的例子，<\/p><h5 id=\"2.2.3.清单 1|outline\">清单 1<\/h5><div class=\"codesection\"><pre class=\"displaycode\">@charset \"UTF-8\";\n.testClass\n{\n\tfont-size: 14pt;\n}\n@media print\n{\n\t.noprint\n\t{\n\t\tdisplay: none;\n\t}\n}\n.h1\n{\n\tfont-size: 14pt;\n\tfont-weight: bold;\n\tdisplay: block;\n}\n.list,\n.crosstab\n{\n\tcolor: #000000;\n}<\/pre><\/div><p>\t这个 CSS 片段在 IE9 之前的 rules 属性得到.testClass，.noprint，.h1，.list，.crosstab 共 5 个样式规则。从 IE9 开始支持了 cssRules，上面 css 片段返回的是 3 条 CSSStyleRule 和 1 条 CSSMediaRule，这与 FF 和 Chrome 仍然有点差别，因为 IE 忽略了第一条 CSSCharsetRule。需要注意的是从 IE9 开始 rules 属性虽然没有废除，但是推荐不要使用，因为结果中忽略了 at-rules 并且在拆分多选择器的时候有些错误的结果。<\/p><h3 id=\"2.3.CSS2Module|outline\">CSS2 Module<\/h3><p>\t这个模块只有一个接口 CSS2Properties，这个接口提供了一种方便的方式来获取和设置 CSSStyleDeclaration 的属性值。实际上这个接口没有包含任何方法，只有对应了 CSS2 规范的属性值。直接访问一个 CSSStyleDeclaration 的属性值就相当于调用了其 getPropertyValue()或 setPropertyValue()的方法。<\/p><p>需要注意的是， CSSStyleDeclaration 的实例是可以直接类型转换为 CSS2Properties 的，这也就是为什么我们在浏览器环境中可以直接访问 CSSStyleDeclaration 实例的各种 CSS2 属性的原因（JavaScript 是一种弱类型化语言，每个对象都是用 var 来声明，不需要显示地做类型转换）。<\/p><p>对于浏览器而言，IE，FireFox 和 Chrome 都实现了 CSS2Properties 接口。但是需要指出的是直接访问 CSS2 属性可能不同的浏览器结果会有些差异，但是这已经不在本文讨论的范畴，所以就不展开详细讨论。<\/p><h2 id=\"3.结束语 |outline\">结束语<\/h2><p>Web Application 开发者很难避免浏览器对 DOM 支持不一致带来的各种问题。遇到这种问题的时候就需要去查 W3C Specification，做测试用例来实际证明这些差异。<\/p><p>本文将 W3C Specification 中和 CSS OM 相关的模块统一分析，从规范出发先讲述各个接口的定义，然后分别在 IE，FireFox 和 Chrome 中对接口定义的大量属性和方法进行测试，最后将测试结果汇总进行对比。<\/p><p>通过本文可以让 Web 开发工程师对 CSS OM 有一个直观系统的认识，帮助工程师在日常的工作中避免浏览器的差异导致的程序问题，从而开发出更加健壮的 Web 程序。<\/p><CMA ID: 970400><Site ID: 10><XSLT stylesheet used to transform this file: dw-document-html-7.0.xsl>\r\n\r\n\r\n<\/div>\r\n<\/div>\r\n","createTime":"2014-05-05 00:00:00","deployTime":"2014-05-05 00:00:00","id":0,"intro":"本文将 W3C Specification 中和 CSS OM 相关的模块统一分析，分别在 IE，Firefox 和 Chrome 中对接口定义的大量属性和方法进行对比测试。通过本文可以让 Web 开发工程师对 CSS OM 有一个直观系统的认识，帮助工程师在日常的工作中避免浏览器的差异导致的程序问题，从而开发出更加健壮的 Web 程序。","keyword":"","recommend":false,"source":"http://www.ibm.com/developerworks/cn/web/1405_shatao_cssmodel/index.html","title":"CSS Object Model 介绍及浏览器差异化分析","typeId":0,"updateTime":"2014-05-05 00:00:00"}
{"author":"","clickNumber":0,"content":"\r\n<div class=\"ibm-columns\">\r\n<div class=\"ibm-col-1-1\">\r\n\r\n<h2 id=\"0.1.Introduction|outline\">简介<\/h2><p>DevOps 通过推广一组务实的原则和实践从根本上转换了开发和运维专业人员一起工作的方式，可以帮助交付可靠、安全和没有缺陷的软件和系统，尤其是当这些软件和系统有可能会威胁整个企业的成功的话。DevOps 的主要关注点在于改善沟通和协作，这是任何团队得以一起有效工作的两个核心的质量要素。许多组织认识到还有更多其他利益相关者也可以同样从 DevOps 方法中受益，包括信息安全（InfoSec）、质量保证（QA）以及测试。应用生命周期管理（Application Lifecycle Management，ALM）的范畴非常广泛，包括从由产品所有者所设想的服务策略和设计，到当发生事故时所需的帮助中心电话服务，所有这些都会影响交付给客户的服务的成功交付。这篇文章描述了如何来对整个应用生命周期应用 DevOps 原则和实践。<\/p><h2 id=\"0.2.Effectsofchangesonsoftwarereliability,security,andquality|outline\">变更对软件可靠性、安全性和质量的影响<\/h2><p>软件及系统开发是一个复杂的工作，通常牵涉到许多利益相关者并需要可观的时间和资源来完成。应用生命周期管理（ALM）提供了相关的结构和过程来从开始到结束指导这些工作。应用生命周期帮助指导每一个对系统实现有贡献的资源，例如包括从帮助定义需求的产品所有者，到确保服务持续可用的运维专业人员。<\/p><p>大型企业系统开发很容易由于软件或系统开发工作中任何一个步骤所引入的缺陷而受到严重影响。很常见的是，组织层面的各种竖井会导致沟通和协作的缺乏，而且这一问题可以引起非常严重的后果。DevOps 的原则可以被成功应用在开发和运维之间的沟通和协作上，可以改善应用生命周期中每一个利益相关者与团队其他成员之间交互的方式。这种自组织、跨功能的团队已经逐渐显见于很多成功的敏捷开发项目，而且被认为是核心的组成部分。这些高性能的团队可以担当很多方面，从而让整个软件和系统开发工作更加成功。在整个应用生命周期中使用 DevOps 最佳实践的关键是理解生命周期中每一个功能之间的联系。<\/p><h2 id=\"0.3.ALMfunctionsandlinkagesbetweenfunctions|outline\">应用生命周期功能和不同功能之间的联系<\/h2><p>应用生命周期中的许多点要求跨多个利益相关者的沟通与协作。这些点有许多是生命周期中的不同阶段，其他的则是在众多功能之间交集中的点，这些都是团队应当了解和管理的：<\/p><ul class=\"ibm-bullet-list\"><li><a href=\"#_Requirements_Definition\">需求定义<\/a><\/li><li><a href=\"#_Service_asset_and\">系统设计<\/a><\/li><li><a href=\"#_Release_and_deployment\">建模依赖关系<\/a><\/li><li><a href=\"#_Service_validation_and\">中间件管理<\/a><\/li><li><a href=\"#_Change_evaluation\">数据库专家<\/a><\/li><li><a href=\"#_Request_fulfillment\">质量保证及测试<\/a><\/li><li><a href=\"#_Knowledge_management\">知识管理<\/a><\/li><\/ul><p>任何软件或系统开发工作应当从一个关于要构建什么的清晰的规格说明开始。<\/p><h3 id=\"#_Requirements_Definition\">需求定义<\/h3><p>生命周期中每一个利益相关者都需要理解需求。需求变更总是发生，经常是由于：<\/p><ul class=\"ibm-bullet-list\"><li>您对于所想要构建的东西有了更多的理解。<\/li><li>市场发生了改变。<\/li><\/ul><p><strong>当您理解更多的时候所发生的需求变更<\/strong><\/p><p>通过每一次的迭代，在进一步理解技术和系统的能力（或局限性）之后，业务专家经常都会精炼和校准他们的需求。显然，对需求的变更需要被追踪和控制。许多组织使用版本管理工具来维护一个关于需求变更的完成记录，并监管需求变更的审批。实现在需求与测试用例之间的可追溯性也是很常见的，这可以用来验证发布版本中的功能是否符合预期。这些都是追踪需求的重要方面，而且他们与 DevOps 原则中关于良好的沟通与协作的原则是一致的。多个 IBM 产品支持这些协作化生命周期管理（Collaborative Lifecycle Management，CLM）的功能：<\/p><ul class=\"ibm-bullet-list\"><li><a href=\"http://www.ibm.com/developerworks/cn/rational/products/rrc/\">IBM&#174; Rational&#174; Requirements Composer&#8482;<\/a> 使得在生命周期开发项目中可以更加容易地定义、管理和报告需求。<\/li><li><a href=\"http://www.ibm.com/developerworks/cn/rational/products/rtc/\">IBM&#174; Rational Team Concert&#8482;<\/a> 帮助定义和追踪工作项。<\/li><li><a href=\"http://www.ibm.com/developerworks/cn/rational/products/qualitymanager/\">IBM&#174; Rational Quality Manager<\/a>，一个基于 web 的集中式测试管理环境，为追踪和度量报表提供了一个协作化的解决方案。<\/li><\/ul><p>一个更加务实的场景例子要求所有产品所有者之间必须有有效的沟通，无论是开发团队、测试团队还是运维团队之间的沟通，这对管理由于外部业务压力所带来风险来说是必须的，包括市场上竞争者的涌入。<\/p><p><strong>由于市场压力所带来的需求变更<\/strong><\/p><p>一个发布版本如果突然赶着投入生产环境通常会产生不可接受的风险。DevOps 关注于管理部署相关风险的需求。同时还创建工具和过程来提供敏捷性，从而来使得持续交付竞争优势成为可能。有时候，一个未按时完成的最后期限（deadline）会比一个赶工期的部署更能招致更大的风险。作为一个部署工程师，我知道很多时候，更快交付应用到市场会有多重要，因为未按时完成的最后期限有可能会将公司的未来毁于一旦。为了选择对公司从整体上来说最佳的行动，技术专家和业务专家需要更加有效的协作与沟通。<\/p><p>比竞争者抢先交付系统的一个测试版（beta version）到市场，有时候远远胜过系统故障或停机所带来的风险。在这些案例中，您需要完全理解风险，并与所有利益相关者进行沟通。通常，风险可以被额外的随叫随到支持服务（on-call support service）所缓解，这在 ITIL V3 框架中被称为<em>早期生命支持（early life support）<\/em>。<\/p><p>例如，在一个用例中，一个新交易平台的测试版被交付到一个只有两个客户的市场，而且这两个客户喜于尝试新的测试版平台。通过提供额外的支持，故障可以被解决。很快之后，销售团队得到了大量新订单，公司在市场上从众多相近的竞争者中胜出。<\/p><p>在本例中，运维团队理解部署一个并不完美的系统的要求。在一个月之后，团队为剩余的其它客户交付了经过完全测试的系统。这一案例中，团队同意交付一个测试版到生产环境，因为业务专业人员表达了迫切感，并认识到首先交付市场的竞争优势。<\/p><p><strong>系统设计<\/strong><\/p><p>系统设计要求来自许多不同利益相关者的专业技能。在设计阶段，DevOps 原则对于项目的成功来说非常关键。<\/p><ul class=\"ibm-bullet-list\"><li><strong>开发人员（developer）<\/strong>通常更加理解技术，但对于基础设施是否可以满足峰值性能要求方面并不一定完全了解。<\/li><li><strong>架构团队（architecture team）<\/strong>可以帮助开发和运维团队理解特定技术框架的能力和风险。<\/li><li><strong>业务用户（business user）<\/strong>可以帮助技术专家理解潜在的峰值用量以及潜在的长期增长和性能需求。<\/li><\/ul><p>通过跨功能视图，系统基础设施团队可以创建一个务实的系统设计，可以让产品更快交付到市场，符合预算，并具备满足长期能力需求的潜能。在系统设计阶段，团队需要以组件接口的术语来理解和文档化所有依赖关系，并考虑运行时依赖关系。<\/p><h3 id=\"_Release_and_deployment\">建模依赖关系<\/h3><p>当今的软件系统有很多优秀的能力，但它们同样涉及到了显著的复杂性。参与开发、集成和定制这些系统的技术专家通常需要拥有广泛的专业技能，和对技术及其依赖关系有深入的知识。很常见的是，这些专家通常只短期参与项目，并随后参与到下一个项目，对维护系统所需的依赖关系和接口没有留下足够的信息。<\/p><p>即便软件可以在它首次部署时运行得很好，如果未来需要进行变更，对依赖关系没有足够的知识的话，这对于更新系统来说便充满了挑战。为了在未来避免问题，您需要沟通和文档化一个全面的模型，以展示所需要的接口以及所有的依赖关系。因为这一信息会很快变得过时和不可靠，系统需要被重新设计以便使其依赖关系可以被自动发现和被很好地理解。<\/p><p>架构团队可以帮助开发团队派生一个文档化依赖关系的方法。例如，一个 XML 文件可以被用于发现和沟通依赖关系。为了设计可以易于维护的复杂系统，开发团队可以依赖于其他利益相关者所拥有的专业技能，包括架构、信息安全、质量保证（QA）、测试，以及对于系统成功运行来说非常核心的中间件维护专家。考虑试用 <a href=\"http://www.ibm.com/developerworks/cn/rational/products/rhapsody/\">IBM&#174; Rational&#174; Rhapsody&#174;<\/a>，一个模型驱动开发环境，面向创建实时或嵌入式系统工程及软件的软件开发人员。<\/p><h3 id=\"#_Service_validation_and\">中间件管理<\/h3><p>中间件（Middleware）通常被描述为介于操作系统和应用程序之间，或介于数据库与应用程序之间的软件层。中间件被认为是核心的但又是不可见的，包括支持消息队列的服务或内存缓存管理器等等。中间件经常被一个专职的团队所管理，并需要专门的专业技能 。中间件专家被认为至少需要与开发团队、运维团队以及架构团队进行协作。在许多案例中，咨询数据库专家也是非常有帮助的。IBM 产品中帮助管理中间件的有：<\/p><ul class=\"ibm-bullet-list\"><li><a href=\"https://www.ibm.com/developerworks/websphere/zones/businessintegration/wmq.html\">IBM&#174; WebSphere&#174; MQ<\/a>，一个业界领先的消息解决方案，可以在几乎所有平台上集成应用程序和 Web 服务，帮助您部署一个全功能的企业消息总线（Enterprise Service Bus，ESB）来作为您面向服务架构（Service-Oriented Architecture，SOA）的连接层。<\/li><li><a href=\"http://www.ibm.com/developerworks/websphere/zones/was/\">IBM&#174; WebSphere&#174; Application Server<\/a> 交付了一个满足您 SOA 所需的安全、可靠、规模化、弹性的应用基础架构。<\/li><\/ul><h3 id=\"#_Change_evaluation\">数据库专家<\/h3><p>数据库对于任何系统来说都是一个关键技术，但通常数据库管理员并未包括在 DevOps 跨功能团队中。因为数据库可以成为系统一个单独的失败点，对数据库的变更需要被理解和进行版本控制，这与其他任何配置项（configuration item）一样。DevOps 方法为了改善沟通与协作，对于想要获得成功的团队，推荐数据库管理员也应被包括进来。为了基于对数据库变更的理解来规划相关的应用程序变更，开发团队需要与数据库管理员一起协作。质量和测试团队也同样应该在整个应用生命周期中被考虑。<\/p><h3 id=\"#_Request_fulfillment\">质量保证及测试<\/h3><p>在整个软件和系统开发生命周期当中，质量保证及测试团队需要成为跨功能团队中的主动成员。在应用生命周期中的每一个利益相关者都可以从将质量保证及测试策略包括进来的决定当中获益，而且这一决定应当贯穿从早期阶段的需求收集，设计与开发，以及到功能与用户验收测试的整个生命周期。质量保证及测试同时还在系统维护中担当重要的角色，可以帮助管理与缺陷修复相关的风险，并持续进行维护。许多 IBM 产品支持质量保证及测试周期：<\/p><ul class=\"ibm-bullet-list\"><li><a href=\"http://www.ibm.com/developerworks/cn/rational/products/qualitymanager/\">IBM&#174; Rational&#174; Quality Manager<\/a>，一个基于 web 的集中化测试管理环境，为跟踪和度量报告提供了一个协作化的解决方案。<\/li><li>IBM&#174; Rational Integration Tester 是 <a href=\"http://www.ibm.com/developerworks/cn/rational/products/testworkbench/\">IBM&#174; Rational&#174; Test Workbench<\/a> 的一部分，组合了对高度复杂应用的功能测试、性能测试、回归测试、加载测试和集成测试等自动化测试功能。<\/li><\/ul><h3 id=\"#_Knowledge_management\">知识管理<\/h3><p>许多技术专家拥有贯穿整个应用生命周期所需要的广泛的知识和专业技能。DevOps 方法就是要应用优秀的沟通与协作方法，以便所有利益相关者可以作为一个跨功能和高度有效的团队进行工作。捕获每一个利益相关者所处理的知识非常重要，以便使团队可以定位和处理在系统的生命周期当中经常发生的事故。<\/p><h2 id=\"0.4.Continuousintegrationanddelivery|outline\">持续集成与交付<\/h2><p>贯穿整个应用生命周期，技术专家需要经常了解系统到底需要什么做什么和当前应当如何运作。持续集成（Continuous Integration）与持续交付（Continuous Delivery）提供了根本性技术用于集成经常发生的变更，并使它们变得可用。集成一个小的变更比集成一组变更要容易。而且，如果一个小变更无法工作，从中回退也要比判断一组变更为何中断系统并从它们中回退要容易得多。持续集成很有效，因为它降低了复杂性并使得识别集成事故的根本原因变得更加简单。如果您拥有自动化的集成过程而且经常执行这一任务的话，您将会更加容易识别和修复问题。<\/p><p>持续交付也以同样的方式运作。为了帮助一个团队从发布和部署中解放出来，应当让他们更加经常地交付小的代码包，而不是过段时间交付一个大的代码包。在部署任务方面，每周发布两次版本的团队要比每个月只发布一次版本的团队要轻松得多。即便如果您每次都发布整个系统，一小集合的变更也明显风险更低，即便问题发生也更容易定位问题。许多产品支持迭代开发：<\/p><ul class=\"ibm-bullet-list\"><li><a href=\"http://www-01.ibm.com/software/tivoli/products/prov-mgr/\">IBM Tivoli&#8482; Provisioning Manager<\/a> 支持一个动态的基础架构。它自动化了对物理服务器、虚拟服务器、软件、存储和网络的管理。<\/li><li><a href=\"http://www-01.ibm.com/software/tivoli/products/prov-mgr-os-deploy/\">IBM Tivoli Provisioning Manager for OS Deployment<\/a> 自动化了操作系统的远程部署。<\/li><li><a href=\"http://www.urbancode.com/html/products/deploy/\">IBM UrbanCode Deploy&#8482;<\/a> 提供了一个自动化的部署框架，可以减少部署错误和改善效率、正确率和可追溯性。<\/li><\/ul><p>从整个应用生命周期的视角看，持续集成和持续部署最大的回报，就是提供了最新的代码可以被所有利益相关者进行评审的能力。里程碑发布版本（Milestone Release）或甚至测试发布版本（Test Release）都可以从 Scrum 迭代中获益，并使得验证需求、建立持续测试和更新改善系统设计成为可能，并让每一个利益相关者得以积极地参与到应用生命周期管理当中。这些变更也帮助持续改善过程。<\/p><h2 id=\"0.5.RetrospectivesintheALM|outline\">对应用生命周期的回顾<\/h2><p>许多组织由于他们不能以一种开放和诚实的方式讨论他们的成功及失败之处，而错失了业务机会。回顾是一个强有力的工具，可以使生命周期管理所有参与者都能开放和直接地讨论什么做得好，什么可以改进。DevOps 方法培育利益相关者之间开放的沟通，并使之迫切保持尽早和经常进行回顾。这一实践开发了一种诚实和开放沟通的文化。<\/p><h2 id=\"0.6.Conclusion|outline\">结论<\/h2><p>DevOps 并不仅仅是开发和运维这么简单。团队中所有参与到应用生命周期过程的重要信息的成员，都可以帮助跨功能团队变得更加有效和使之成为一个更高性能的团队。在开发团队和运维团队之间增加协作与沟通，可以改善双方的生产力和可靠性。扩展这些 DevOps 原则和实践到整个应用生命周期中，来将您整个组织转换成为一个更加合作和高性能的团队，从而获得更大的成功。<\/p><CMA ID: 970521><Site ID: 10><XSLT stylesheet used to transform this file: dw-document-html-7.0.xsl>\r\n\r\n\r\n<\/div>\r\n<\/div>\r\n","createTime":"2014-05-05 00:00:00","deployTime":"2014-05-05 00:00:00","id":0,"intro":"DevOps 提供了一组原则和实践帮助开发和运维团队更有效地一起工作。但很多组织认识到，其实还存在更多其他利益相关者，例如信息安全、质量管理（QA）、测试，以及其他更多的利益相关人同样可以从 DevOps 方法获益。应用生命周期管理（Application Lifecycle Management，ALM）帮助定义整个软件及系统生命周期，它为一组广泛的任务和利益相关者提供了指南。这些利益相关者在创建可靠和安全的系统方面担任了核心的角色。应用 DevOps 方法来改善沟通和协作来驱动整个应用生命周期。通过本文了解如何使用 DevOps 来理解应用生命周期中每一个利益相关者之间的依赖性。","keyword":"","recommend":false,"source":"http://www.ibm.com/developerworks/cn/rational/d-drive-agile-lifecycle-management-devops/index.html","title":"DevOps 最佳实践: 第 4 部分 通过 DevOps 驱动敏捷应用生命周期管理","typeId":0,"updateTime":"2014-05-05 00:00:00"}
{"author":"","clickNumber":0,"content":"\r\n<div class=\"ibm-columns\">\r\n<div class=\"ibm-col-1-1\">\r\n\r\n<h2 id=\"intro\">简介<\/h2><p>对计算机的恶意攻击与日俱增。尽管编写的用于攻击 GNU/Linux 系统的病毒比 Windows 系统少得多，但 GNU/Linux 病毒确实存在。此外，可感染运行 Linux 的计算机的其他类型的恶意软件的数量（以及纯攻击数量）也在不断增长。最近 Wirenet.1 攻击了运行 Linux 和 Mac OS X 的计算机。该恶意软件盗窃了存储在计算机上的 Internet 浏览器、电子邮件客户端和即时消息工具中的密码和其他信息。<\/p><div class=\"dw-sidebar ibm-inset\"><h2 id=\"Myths\">关于安全性的流言是如何流传的<\/h2><p>在恶意攻击者的焦点是恶作剧时，Windows 系统是主要的目标，因为该系统容易使用，而且许多无经验的用户都购买它们。一些攻击的动机是为 Microsoft 带来负面形象，Microsoft 被认为是不支持开源社区的公司。这些攻击在计算领域中助长了 Windows 安全性很脆弱的流言。<\/p><\/div><p>独立于平台的环境（比如 OpenOffice.org、Perl 和 Firefox）也未能幸免于难。举例而言，我们在运行 Windows、Mac OS X 和 Linux 的机器上都发现了 Dropper.MsPMs &#8212; 一个恶意的 Java 归档 (JAR) 文件。<\/p><p>一些恶意的包是专为 GNU/Linux 编写的。<em>rootkit<\/em> 是一个允许攻击者获得计算机上的 root（管理员）帐户访问权限的工具集合，它是和特洛伊密码一样的恶意软件系列中的一部分。这些恶意软件包具有不同的名称，比如 tOrn 和 ARK。<\/p><h2 id=\"malware\">防御恶意软件<\/h2><p>许多因素决定了系统的安全程度，但最重要的是系统的配置方式。本文将介绍 GNU/Linux 桌面的配置。通过执行一些步骤来正确配置您的计算机系统，从而保障计算机的安全。首先从反病毒保护开始。<\/p><h4 id=\"clamAV\">安装反病毒保护软件：ClamAV<\/h4><p>ClamAV 是一个开源 (GPL) 反病毒引擎，其设计目标是检测特洛伊木马、病毒、恶意软件和其他恶意威胁。安装它时，您可以指定希望手动运行该程序，还是通过将它连接到后台进程让它持续运行。对于桌面，以后台进程形式运行该程序最为理想，因为在这种状况下您仍然可以选择执行手动扫描。<\/p><p>要将 ClamAV 安装为持续运行的后台进程，可执行以下步骤：<\/p><ol><li>打开计算机并登录。<\/li><li>在菜单栏中，单击 <strong>Applications &gt; Accessories &gt; Terminal<\/strong>。 <\/li><li>在启动终端后，输入以下命令：<div class=\"codesection\"><pre class=\"displaycode\">sudo apt-get install clamav-daemon<\/pre><\/div><\/li><li>在系统提示您时，输入您的密码。<p>这么做会安装一个名为 <code>clamav-freshclam<\/code> 的包，它是 ClamAV 应用程序的更新程序包。<\/p><\/li><li>您现在会看到一条消息，提醒您安装该软件时需要使用多大的磁盘空间。在提示符上输入 <code>Y<\/code> 来开始安装。<p>安装流程只需两分钟的时间。完成安装后，您将看到一个警报，指出您的病毒数据库是 <em>x<\/em> 天以前的，您应该使用以下的一系列步骤来更新它。 <\/p><\/li><li>在提示符下，运行命令 <code>sudo freshclam<\/code>。<\/li><\/ol><p>运行 <code>freshclam<\/code> 会将病毒定义更新为最新版本。保持定义最新非常重要，因为这是 ClamAV 识别恶意软件的方式。<\/p><p><em>病毒定义<\/em> 是恶意软件程序所独有的代码模式。反病毒扫描器将您文件的内容与病毒定义数据库中的代码模式进行比较。如果找到匹配值，该程序会提醒您计算机上有一个受感染的文件，并阻止该文件中的代码执行。<\/p><p>如果恶意软件的某个特定部分的定义未在您的病毒定义数据库中，那么反病毒扫描器无法知道它就是恶意代码，因此会让它继续运行，并承受执行它所带来的损害。定期更新您的定义，以提供最全面的保护。<\/p><h4 id=\"start_scan\">启动 ClamAV<\/h4><div class=\"dw-sidebar ibm-inset\"><h2 id=\"ClamTk\">ClamTk：您的反病毒应用程序的 GUI<\/h2><p>如果不喜欢从终端工作，那么可以选择为 ClamAV 安装一个名为 ClamTk 的 GUI。这个 GUI 可以使用 Ubuntu 中的 Add/Remove Applications 工具轻松安装。完成安装之后，单击 <strong>Applications &gt; System Tools &gt; Virus Scanner<\/strong> 运行它。<\/p><\/div><p>在更新病毒定义后，就可以启动 ClamAV 了。要对您的主文件夹运行手动扫描，可以转到终端提示符并输入 <code>clamscan<\/code>。完成 <code>clamscan<\/code> 命令后，您会看到一个关于扫描了多少目录和文件以及找到了有多少受感染文件的报告。<\/p><p>要以后台进程形式运行 ClamAV，可以转到终端提示符并输入 <code>clamdscan<\/code>。<code>clamdscan<\/code> 命令创建了一个名为 ClamAV 的用户。然后，您可以将此用户添加到拥有您想要扫描的文件的组中。<\/p><h4 id=\"rootkits\">通过 rkhunter 防御 rootkit<\/h4><p>GNU/Linux 用户面对的最危险的恶意软件或许是 rootkit。Rootkit Hunter (<code>rkhunter<\/code>) 和 <code>chkrootkit<\/code> 程序会在桌面上扫描可疑的文件，攻击者可能安装这些文件来获取您计算机的控制权。<\/p><p>要安装 <code>rkhunter<\/code>（查找并删除 rootkit 的最优秀程序之一），可执行以下步骤：<\/p><ol><li>要导航回终端，可单击 <strong>Applications &gt; Accessories &gt; Terminal<\/strong>。 <\/li><li>在终端 shell 中，输入以下命令：<div class=\"codesection\"><pre class=\"displaycode\">sudo aptitude install rkhunter<\/pre><\/div><\/li><li>在收到一条告诉您该软件需要使用多少空间的消息后，输入 <code>Y<\/code> 开始安装。 <\/li><\/ol><p><code>rkhunter<\/code> 安装后，您可运行它来检查桌面中的攻击破坏。转到终端提示符并输入 <code>sudo rkhunter --check<\/code>。<\/p><p>如果 <code>rkhunter<\/code> 正确运行，您会看到一个在旁边包含词汇 <code>OK<\/code> 或 <code>Warning<\/code> 的目录列表。启动后，<code>rkhunter<\/code> 会执行多种类型的扫描。一次扫描完成后，按下 <strong>Enter<\/strong> 键开始下一次扫描。扫描类型包括：<\/p><ul class=\"ibm-bullet-list\"><li>目录<\/li><li>桌面上的攻击破坏<\/li><li>常用于后门访问的端口<\/li><li>启动文件、组和帐户、系统配置文件和文件系统 <\/li><li>应用程序<\/li><\/ul><p>所有扫描都完成后，<code>rkhunter<\/code> 将为您提供一份报告，并使用结果创建一个日志文件。<\/p><p>和 ClamAV 一样，您需要定期更新 <code>rkhunter<\/code>，以便它可以检测最新的漏洞和攻击破坏：<\/p><ol><li>从终端输入 <code>sudo rkhunter --update<\/code>。<\/li><li>在系统提示您时输入您的密码。<\/li><\/ol><h4 id=\"tiger\">使用 Tiger 扫描您的系统<\/h4><p>在安全性方面，建立基准是您可做的最重要的事情之一。从这里，您可以确定是否有任何内容被篡改，因为篡改会修改基准内容。如果安装一个 Office 办公套件，您也会修改基准，但您已经能批准进行此添加。如果在您的机器上安装了一个恶意软件，对基准的检查也会发现这个恶意软件。<\/p><p>大多数人都不了解如何手动创建其计算机配置的基准。但是，一个名为 Tiger 的程序会审核计算机系统，查看是否修改了任何内容。如果内容被修改，该软件会提供一个错误代码。<\/p><p>要将 Tiger 安装在 Ubuntu 桌面上，请先打开终端。从这里运行以下命令：<\/p><div class=\"codesection\"><pre class=\"displaycode\"> sudo aptitude -y install tiger<\/pre><\/div><p>该命令将 Tiger 软件放在您的机器上。现在，您需要运行它。<\/p><p>在终端仍处于打开状态的情况下，运行 <code>sudo tiger<\/code> 来创建一个安全问题报告，将该报告保存到 /var/log/tiger 中。该文件的名称常常包含计算机的主机名，后跟日期和时间，例如 <code>security.report.hostname.121220-8:46<\/code>。该文件的名称会在报告完成时提供给您。<\/p><p>要查看报告，可运行 <code>sudo gedit<\/code> 并包含 /var/log/tiger 和文件名。使用此示例，该命令为：<\/p><div class=\"codesection\"><pre class=\"displaycode\"> sudo gedit /var/log/tiger/security.report.hostname.121220-8:46<\/pre><\/div><p>该报告随后会提供它找到的问题的错误代码。您可以在线查找每个错误代码的含义（参见 <a href=\"#resources\">参考资料<\/a>）。<\/p><h2 id=\"firewall\">使用防火墙<\/h2><p>您应采取的下一个预防性步骤是使用内置于操作系统中的防火墙。在默认情况下，Ubuntu 会在每个发行版上运行 <code>iptables<\/code> 作为防火墙。在安装防火墙之后，该防火墙的默认设置会允许所有传入和传出的流量。要有效地使用防火墙，您需要创建规则来锁定桌面。<\/p><p>您可以通过终端配置 <code>iptables<\/code> 来编写防火墙规则，也可以使用一个称为 Gufw 的 GUI，基于 Ubuntu 随带的 Uncomplicated Firewall (UFW) 程序来编写防火墙规则。<\/p><p>打开终端并运行以下命令来安装 Gufw：<\/p><div class=\"codesection\"><pre class=\"displaycode\"> sudo apt-get install gufw<\/pre><\/div><p>完成安装后，您可以从 <strong>System &gt; Administration &gt; Firewall<\/strong> 访问它。打开并启用 Gufw，默认情况下它处于禁用状态。在标题 <strong>Actual Status<\/strong> 下，单击 <strong>Enabled<\/strong> 复选框来打开它。这么做会将所有传入流量都设置为 <strong>Deny<\/strong>。然后单击 <strong>Add<\/strong>，依据您想要 UFW 如何处理某些类型的流量，基于 4 个可用选项来创建规则：<\/p><ul class=\"ibm-bullet-list\"><li><strong>Allow。<\/strong>系统允许从一个端口进入的流量。<\/li><li><strong>Deny。<\/strong>系统拒绝进入一个端口的流量。<\/li><li><strong>Reject。<\/strong>系统拒绝进入一个端口的流量，并传达其流量被拒绝的连接系统的请求。<\/li><li><strong>Limit。<\/strong>如果某个 IP 地址尝试在过去 30 秒内发起 6 个或更多的连接，系统会拒绝这些连接。<\/li><\/ul><p>单击 <strong>Add<\/strong> 时，会出现一个包含 3 个选项卡的窗口：<strong>Preconfigured<\/strong>、<strong>Simple<\/strong> 和 <strong>Advanced<\/strong>。<strong>Preconfigured<\/strong> 选项卡是创建规则的最轻松方式，因为您可以从一个下拉列表中选择您希望允许或拒绝的流量<\/p><p>使用 <strong>Simple<\/strong> 选项卡，您可以告诉 UFW 您希望允许还是拒绝某些流量，然后选择协议/服务和端口号。<\/p><p>您可以使用 <strong>Advanced<\/strong> 选项卡进一步调优规则。<\/p><h2 id=\"backup\">备份和还原桌面文件<\/h2><p>保护 GNU/Linux 桌面的另一个步骤涉及到建立一个备份和恢复流程。<\/p><p>在过去，您需要在大多数 Linux 发行版中安装备份和恢复软件。但是，拥有一个合理的灾难恢复解决方案的需求已促使许多发行版在安装中包含备份和恢复软件。Ubuntu 依赖于 Duplicity，该程序使用了 <code>rsync<\/code>。为了让事情变得更简单，Ubuntu 随带了 Deja Dup，这是 Duplicity 的图形前端。<\/p><p>要开始使用 Deja Dup，可单击齿轮图标中的 <strong>System Settings<\/strong>。在 <strong>System Settings<\/strong> 窗口中，单击 <strong>Backup<\/strong>。<\/p><p>在打开自动备份之前，单击 <strong>Storage<\/strong> 设置备份位置。您可以使用 Ubuntu One（一个云存储选项），通过 FTP 将您的备份发送到另一个服务器，保存到本地文件夹，或者设置一个自定义位置。确定备份文件的最佳位置后，单击 <strong>Folders<\/strong> 选择想要备份的内容。这里有两个选项：<strong>Folders to back up<\/strong> 和 <strong>Folders to ignore<\/strong>。可从每一栏添加或删除任何文件夹。<\/p><p>现在，单击 <strong>Schedule<\/strong>，告诉 Deja Dup 运行备份的频率和它们的保留时间。您可以选择每日、每周、双周或每月备份一次，这些备份可存储至少一周到至少一年，甚至是永久存储。<\/p><p>现在，返回到 <strong>Overview<\/strong> 并将 <strong>Automatic backups<\/strong> 滑动到 <strong>On<\/strong>。这就是该软件的全部操作。如果需要还原文件，可单击 <strong>Restore<\/strong>，Deja Dup 会询问您希望从何处、哪个日期还原，以及您希望将文件还原到哪个位置。通过时常还原文件来确保您的备份正常工作，这是一个不错的想法。<\/p><h2 id=\"updates\">安装更新<\/h2><p>许多对计算机的攻击，都是在恶意的攻击者在操作系统软件或另一个软件中找到漏洞时发起的。安全专家会查找这些漏洞，创建软件补丁和更新来修补它们。<\/p><p>请保持您的软件最新。大部分操作系统都有一个内置的功能来通知您更新何时可用，许多 GNU/Linux 发行版都包含这种类型的功能。单击桌面菜单栏上的齿轮图标，然后单击 <strong>Software Up to Date<\/strong> 启动 Update Manager。Update Manager 通常会在更新可用时自行打开。<\/p><p>在 Update Manager 窗口中，您可以单击 <strong>Install Updates<\/strong>。您也可以单击 <strong>Settings<\/strong> 来选择更新频率和想要更新的软件。只要 <strong>Important security updates<\/strong> 复选框已被选中并且 <strong>When there are security updates<\/strong> 选项被设置为 <strong>Download and install automatically<\/strong>，默认选项就应该足够用了。<\/p><h2 id=\"bootloader\">通过密码保护引导加载程序<\/h2><p>使用 GNU/Linux 时，您可以引导计算机来更改 root 密码，无需输入一个密码。这种方法被称为<strong>单用户模式<\/strong>。要通过密码保护此功能，您有两个引导加载程序选项：GRUB 和 LILO。如果使用 GRUB，那么您可以加密密码，让信息更加安全。LILO 的用户没有此选项。如果使用 GRUB，那么请执行以下步骤：<\/p><ol><li>启动终端。<\/li><li>在提示符下输入 <code>grub<\/code>。<\/li><li>为了确保不会将要创建的密码存储为明文，可输入 <code>md5crypt<\/code>。<\/li><li>在提示符下，输入您想用于单用户模式的密码。然后您会获得一个加密的密码版本。不要关闭这个终端窗口 &#8212; 后续步骤中需要使用这个加密的密码。 <\/li><\/ol><p>现在，您需要编辑 GRUB 配置文件。当然，首先要备份它：<\/p><ol><li>输入以下命令：<div class=\"codesection\"><pre class=\"displaycode\">sudo cp /boot/grub/menu.lst /boot/grub/menu.lst-backup<\/pre><\/div><\/li><li>在系统提示您时输入您的密码。<\/li><li>输入以下命令：<div class=\"codesection\"><pre class=\"displaycode\">gedit /boot/grub/menu.lst<\/pre><\/div><p>这会调出 GRUB 配置文件。<\/p><\/li><li>找到文件中显示为 <code>password --md5<\/code> 的一行，将现有的密码替换为您之前创建的加密密码。<p>清单 1 显示了在密码更改时 GRUB 配置文件应该是什么样的：<\/p><h5 id=\"list1\">密码更改后的 GRUB 配置文件<\/h5><div class=\"codesection\"><pre class=\"displaycode\"> # Set a timeout, in SEC seconds before\nautomatically booting the default entry # (normally the first entry\ndefined). timeout 3 ## hiddenmenu # Hides the menu by default (press ESC\nto see the menu) hiddenmenu # Pretty colours #color cyan/blue while/blue\n## password ['--md5'] passwd # If used in the first section of the menu\nfile, disable all interactive editing # control (menu entry editor and\ncommand-line) and entries protected by the # command 'lock' # e.g.\npassword topsecret # password --md5 $1$jLhUO/$aW78kHK1QfV3P2b2znUoe/ #\npassword topsecret # # examples # # title Windows 95/98/NT/2000<\/pre><\/div><\/li><\/ol><p>不同于 GRUB，LILO 不允许使用加密的密码。如果使用 LILO 引导加载程序，那么可以执行以下步骤：<\/p><ol><li>启动终端。<\/li><li>在提示符下输入 <code>edit cat /etc/lilo.conf<\/code>。<\/li><li>编辑器打开时，搜索密码部分并在其中创建新密码。<\/li><\/ol><h2 id=\"conclusion\">结束语<\/h2><p>本文介绍了一些可帮助您加强 GNU/Linux 桌面的安全的工具。即使您安装了所有可用的工具来保护计算机和其中存储的数据，也应该掌握这些工具的使用。<\/p><p>请设定一个时间表来检查 ClamAV 和 <code>rkhunter<\/code> 的更新。每周和在安装新软件时运行这些实用程序。为您的数据设置一个备份时间表，并关注计算机安全领域的最新趋势（这一点最为重要）。新的漏洞不断被发现。您需要与时俱进，采取适当的操作来保持计算机的安全。<\/p><CMA ID: 970399><Site ID: 10><XSLT stylesheet used to transform this file: dw-document-html-7.0.xsl>\r\n\r\n\r\n<\/div>\r\n<\/div>\r\n","createTime":"2014-05-05 00:00:00","deployTime":"2014-05-05 00:00:00","id":0,"intro":"尽管 GNU/Linux? 拥有比 Windows? 安全得多的操作系统的声誉，但您仍需要保护 Linux 桌面。本文将详细介绍如何安装反病毒软件，创建备份和还原计划，以及使用防火墙，帮助您加强 Linux 桌面对大多数攻击的防御，并防止对您的计算机的未授权访问。","keyword":"","recommend":false,"source":"http://www.ibm.com/developerworks/cn/linux/l-harden-desktop/index.html","title":"加强 Linux 桌面安全","typeId":0,"updateTime":"2014-05-05 00:00:00"}
{"author":"","clickNumber":0,"content":"\r\n<div class=\"ibm-columns\">\r\n<div class=\"ibm-col-1-1\">\r\n\r\n<p>前面一篇文章对教育行业知识管理需求进行了分析，介绍了如何使用团队空间实现企业级知识共享及管理，以及使用 EDS 在客户端运行时对字段属性及值进行定制。本文将会继续介绍如何使用 Plugin 对教育行业知识管理系统进行扩展及使用 IBM Content Navigator 定制个性化知识管理界面。<\/p><h2 id=\"major1\">使用 Plugin 对教育行业知识管理系统的扩展<\/h2><h3 id=\"minor1.1\">客户需求<\/h3><p>随着教育机构业务的不断发展，新的需求会不断的涌现，知识管理系统是否有良好的扩展性也是一个关键的指标。比如该教育机构对系统中知识资源的交互功能提出了新的需求。<\/p><p>用户希望可以在平台中对发布的知识资源进行多项互动操作。用户可以针对知识资源的质量进行打分，系统可以按照加权算法对打分情况进行总结，形成对知识资源质量的最终评分。用户可以针对知识资源进行相应评论和补充。用户可以对感兴趣或者有用知识资源进行收藏，也可以对感兴趣或者有用知识资源进行订阅，当知识资源有更新或评论时，订阅的知识会有通知提示。用户可以对感兴趣或者有用知识资源进行关注，当知识资源有评论时，关注的知识会有通知提示。用户可以对优秀知识资源或评论，可以推荐给其他用户，推荐数相应增加。用户可以将知识资源或评论推送到外部系统中，如微博、IM 等。<\/p><p>同时在教育行业知识管理系统的解决方案中，我们常常要面对的一个问题是如何把新建立的知识管理系统与企业现有系统进行整合。其中最流行的需求是如何把知识管理系统中的内容与企业 2.0(Enterprise 2.0) 系统进行整合。这对知识管理系统来说其实是另一种扩展的方式。<\/p><p>为了提高企业内部的效率，信息与知识分享的效率和范围，信息与知识的利用度，企业尤其是教育行业的企业已经拥有或者开始筹划企业 2.0 系统。企业 2.0 系统重在加强企业内部的沟通，分享，开放与协作。虽然 IBM Content Navigator（ICN）已经提供了一定程度的社会化知识管理和分享的功能（通过 Teamspace），但该功能还不足以涵盖整个企业 2.0 系统所需要提供的功能。所以最合理也是最有效率的做法就是对知识管理系统和企业 2.0 系统进行整合。<\/p><p>这种整合的需求在知识管理系统解决方案中非常常见，因为知识和信息的利用方式是没有穷尽的。在使用 ICN 实现的知识管理系统解决方案中，实现这种类型的整合非常方便和优雅。ICN 提供了一种机制，叫做插件（plug-in），使用插件可以<\/p><ol type=\"1\"><li>\n扩展 UI<\/li><li>\n扩展 Java 服务层<\/li><li>\n覆盖现有的功能<\/li><li>\n扩展现有的功能<\/li><li>\n创建新功能<\/li><\/ol><p>ICN 的提供的插件扩展点包括：<\/p><ol type=\"1\"><li>\n扩展工具栏或者菜单的功能<\/li><li>\n创建新的工具栏和菜单<\/li><li>\n创建新功能<\/li><li>\n集成新的 viewer<\/li><li>\n创建或扩展新的 Java 服务<\/li><li>\n可以扩展网络 request 和 response 的过滤器<\/li><li>\n创建完全不同的界面布局<\/li><li>\n扩展配置界面<\/li><\/ol><h3 id=\"minor1.2\">根据客户需求创建企业内部微博分享插件<\/h3><p>首先我们需要来看一下 ICN 的插件如何进行开发。在 ICN 中包含一个叫做 samplePlugin 的 java 项目。用户可以直接把这个项目在 Eclipse 中打开，查看及编辑客户需要的插件。<\/p><p>在这个项目中，包含了大量的代码范例。方便客户参考创建自己的插件。客户也可以直接把这个项目中自己需要的部分修改为需要的功能，而把不需要的部分删除即可。<\/p><p>针对我们的客户需求：在企业内部微博分享知识文档，在 ICN 中实现其实非常简单。我们来分析一下该需求应该如何实现。分享文档有两种方式：分享文档本身，或者分享文档的链接。在已经有了知识管理系统的前提下，知识文档已经得到了很好的管理，同时也有安全的保证，如果在企业内部微博分享文档本身将会导致知识文档的安全性在从知识管理系统转移到企业内部微博时丢失，这是客户绝对不能接受的事。那么实现这个需求我们将采用分享文档链接的方式。<\/p><p>如果使用传统的系统扩展集成来实现这个需求将会有点复杂，甚至不改动产品代码就无法实现。而使用 ICN 实现的知识管理系统，则会让客户体会到扩展系统实现这个需求是多么的轻松惬意。<\/p><p>首先 ICN 中每一个文档都有自己的链接，用户得到这个链接后，点击登录，ICN 会根据该文档和用户的安全信息，决定把文档传递给用户或者拒绝。所以文档链接功能可以直接采用 ICN 提供的现成功能。<\/p><p>接下来就是在文档的右键菜单中添加一项选项“分享到企业微博”。实现这项功能可以参考 samplePlugin 中的 SamplePluginFileUploadAction.java，SamplePluginFileUploadService.java，SamplePlugin.js 和 FileUploadCustomAction.js。<\/p><p>在 SamplePluginFileUploadAction.java 中是扩展菜单选项的 java 模块，继承自 PluginAction。我们当然可以把所有的关于 sample 的字样都修改为我们需要的字样，但关键的步骤是把 getName( Locale locale ) 中返回的内容改为 “分享到企业微博”。<\/p><p>把 getServerTypes() 方法中 return 的服务器类型改为需要的类型，比如我们的知识管理系统是架构在 IBM Content Engine 上的，那么服务其类型就要更改为”p8”。<\/p><p>在 getActionModelClass() 中指定的路径是 javascript 中对应模块的路径，客户如果需要可以更改，但该路径一定要真实有效。<\/p><p>我们再来看看 FileUploadCustomAction.js。该 dojo 模块继承自 Action，其中 isEnabled 函数判断了只有在文档有内容的时候才会显示启用该菜单。该函数可以由客户根据需求调整，如果所有的文档都可以分享，则该函数可以全部删除，或者直接返回 true。<\/p><p>这个菜单项关键的功能部分代码在 SamplePlugin.js 中，lang.setObject(“samplePluginFileuploadAction”, function(repository, items)) 语句的内容定义了菜单项“分享到企业微博”的执行内容。针对 IBM Content Engine 作为服务器，跟踪一下显示链接的代码就知道获取链接的 dojo 方法为 ecm.model.Item.getBookmark( item, version )。现在我们把 SamplePlugin.js 中的语句块更改为：<\/p><h5 id=\"listing1\">清单 1. SamplePlugin.js 中的语句块示例<\/h5><div class=\"codesection\"><pre class=\"displaycode\"> var bookmarkUrl = ecm.model.Item.getBookmark( items[0], “released”); \n alert( bookmarkUrl );<\/pre><\/div><p>现在所有的修改就结束了。该段代码只是展示了文档链接，因为各企业内部微博的接口方式都不同，基本上都是以 REST API 作为接口，那么只要做好单点登陆，在 alert 的地方调用一下企业内部微博的分享链接 API，把 bookmarkUrl 作为要发布的内容传进去就可以了。<\/p><p>以上是所有的代码更改，我们可以看到，非常简单。如果用户希望能有一个对话框确认一下再提交，也可以修改 FileUploadPopupDialog.js 去满足这个要求，在这里就不赘述了。<\/p><p>接下来是把这个插件部署到 ICN 上去。<\/p><p>首先我们要编译这个插件，关键的步骤是运行 samplePlugin 中的 build.xml，作为 ant 脚本运行，在运行的输出中可以看到编译打包的 jar 文件路径，比如 c:\\samplePlugin\\SamplePlugin.jar。<\/p><p>ICN 有一个默认的管理界面，在 ICN 的链接后面加上 ?desktop=admin 即可登录进入。然后在左边菜单选择 Plug-ins，选择”新建”，输入刚才编译打包的插件 jar 文件路径，点击 Load，就可以看到插件的信息了。在 SamplePlugin 中包含了很多其它内容，我们需要输入 2 个必填的参数就可以保存并关闭了。参数可以随便设置。<\/p><h5 id=\"fig1\">图 1. ICN plug-ins 管理界面<\/h5><img alt=\"图 1. ICN plug-ins 管理界面\" src=\"/sunshine_new/images/1505087508/images/image01.jpg\" width=\"576\" /><p>在这里我们可以看到，“分享到企业微博”的菜单项已经列出。<\/p><p>然后我们点击左边的 Menus 菜单，找到“缺省文档”上下文菜单（该菜单为文档右键菜单），右键选择“copy”，会有一份复制的菜单出现。填写名称，比如 sampleMenu，然后把“分享到企业微博”添加到菜单项中去，为方便测试，可以把该菜单放到最顶端，保存即可。<\/p><h5 id=\"fig2\">图 2. ICN sample Menu 管理界面<\/h5><img alt=\"图 2. ICN sample Menu 管理界面\" src=\"/sunshine_new/images/1505087508/images/image02.jpg\" width=\"576\" /><p>最后一项工作是把该菜单添加到 Desktop 中去。点击左边的 Desktops，打开需要修改的 desktop，选择 Menus 项目，把“文档”上下文菜单更改为”sampleMenu”，然后保存。<\/p><h5 id=\"fig3\">图 3. ICN Menus 管理界面<\/h5><img alt=\"图 3. ICN Menus 管理界面\" src=\"/sunshine_new/images/1505087508/images/image03.jpg\" width=\"576\" /><p>全部的更改和设置就完成了，下面我们来看看运行的效果。登录刚才修改的 desktop，找到一个文件，右键单击，可以看到“分享到企业微博”菜单项出现在菜单中，点击该项，会显示该文档的链接。<\/p><h5 id=\"N100CD\">图 4. “分享到企业微博”菜单项<\/h5><img alt=\"图 4. “分享到企业微博”菜单项\" src=\"/sunshine_new/images/1505087508/images/image04.png\" width=\"267\" /><h5 id=\"fig5\">图 5. 文档链接<\/h5><img alt=\"图 5. 文档链接\" src=\"/sunshine_new/images/1505087508/images/image05.png\" width=\"357\" /><h3 id=\"minor1.3\">总结<\/h3><p>在本文中详细描述了如何使用 ICN 的插件机制，在教育行业知识管理系统中，根据客户需求添加“分享到企业微博”功能。可以看到与传统的解决方案相比，ICN 的可扩展性非常优秀，在教育行业知识管理系统的搭建中，极大的减小了扩展功能的成本和时间。<\/p><h2 id=\"major2\">使用 IBM Content Navigator 定制个性化知识管理界面<\/h2><p>每个企业都有定制个性化应用界面的需求。教育行业企业可以根据教育行业的特点以及企业自身的需求对 IBM Content Navigator 做个性化定制。IBM Content Navigator 在设计架构上的重要目标是 : 模块化和组件重用 , 可定制性 , 灵活的扩展性。<\/p><p>对企业知识管理系统的个性化定制可以分为 2 类：一类是通过管理界面设置选项对企业知识管理系统进行个性化定制，另一类是通过 IBM Content Navigator API 对企业知识管理系统做全面的定制和客户化。<\/p><p>对于第一类通过管理界面设置的方式对企业知识管理进行个性化定制的方式适用于现有 IBM Content Navigator 功能以及界面布局已经满足企业需求。我们可以对外观，桌面，菜单，图标，应用程序标以及查看器等进行设置，以满足用户的个性化定制需求。<\/p><p>对于第二类通过 IBM Content Navigator API 对企业知识管理系统做全面的定制和客户化的方式适用于现有 IBM Content Navigator 功能以及界面布局不能满足企业需求。企业希望完全使用自己的业务逻辑功能和界面布局开发全新的应用。IBM Content Navigator 提供全套可重用的可视控件，Dojo 控件库和 ECM 控件库，为用户提供充分使用 ECM 内容库的能力。<\/p><h3 id=\"minor2.1\">通过管理员设置定制企业个性化知识管理界面<\/h3><p>通过 IBM Content Navigator 的管理界面，我们可以对以下内容进行客户化定制：<\/p><ul class=\"ibm-bullet-list\"><li>\n定制桌面，以及桌面外观<\/li><li>\n定制菜单<\/li><li>\n定制查看器映射<\/li><li>\n标签<\/li><li>\n图标映射<\/li><\/ul><h5 id=\"fig6\">图 6. ICN 配置界面<\/h5><img alt=\"图 6. ICN 配置界面\" src=\"/sunshine_new/images/1505087508/images/image06.jpg\" width=\"575\" /><p>我们通过以下用户场景来举例说明教育行业用户如何通过管理设置来定制企业的个性化知识管理界面：<\/p><ol type=\"1\"><li>\n用户需要定制企业自己的应用名称，企业徽标，颜色风格，登陆页面内容等。<\/li><li>\n需要根据使用者不同，确定不同的桌面：教师与学生看到的桌面是不同的。不同桌面拥有不同存储库，功能部件，菜单，文档查看器，工作流等。<\/li><li>\n定制企业自己的文档类型图标，状态图标，标签等。<\/li><\/ol><h3 id=\"minor2.2\">桌面定义<\/h3><p>根据使用者不同，确定不同的桌面：教师与学生看到的桌面是不同的。不同桌面拥有不同存储库，功能部件，菜单，文档查看器，工作流等<\/p><p>在桌面定义中，我们可以对桌面中使用的查看器，是否 enable 移动终端，存储库，桌面外观，菜单以及工作流等<\/p><h5 id=\"fig7\">图 7. ICN Default Desktop<\/h5><img alt=\"图 7. ICN Default Desktop\" src=\"/sunshine_new/images/1505087508/images/image07.jpg\" width=\"576\" /><h3 id=\"minor2.3\">存储库定义<\/h3><p>在存储库定义中我们可以设置 ICN 所使用的存储库。ICN 支持所有 IBM 内容管理存储库产品以及支持 CMIS 标准的存储库，IBM 的内容管理存储库包括：IBM Content Manager Enterprise Edition repositories，IBM Content Manager OnDemand repositories 和 IBM FileNet? P8 repositories。在管理界面设置中用户可以根据实际使用的后台存储库对后台存储库进行设置，设置好的存储库可以在不同的桌面中使用。<\/p><h5 id=\"fig8\">图 8. ICN 存储库配置<\/h5><img alt=\"图 8. ICN 存储库配置\" src=\"/sunshine_new/images/1505087508/images/image08.jpg\" width=\"575\" /><h3 id=\"minor2.4\">设置 定义<\/h3><p>在设置页面中，我们可以对全局的设置项进行设置，包括文件类型过滤，管理界面的管理员，系统日志设置，图标映射等。<\/p><h5 id=\"fig9\">图 9. ICN 设置项配置<\/h5><img alt=\"图 9. ICN 设置项配置\" src=\"/sunshine_new/images/1505087508/images/image09.jpg\" width=\"576\" /><h3 id=\"minor2.5\">插件<\/h3><p>插件管理允许我们注册为 ICN 开发的插件。通过插件可以使用 IBM Content Navigator API 对企业知识管理系统做全面的定制和客户化的方式适用于现有 IBM Content Navigator 功能以及界面布局不能满足企业需求。企业希望完全使用自己的业务逻辑功能和界面布局开发全新的应用。IBM Content Navigator 提供全套可重用的可视控件，Dojo 控件库和 ECM 控件库，为用户提供充分使用 ECM 内容库的能力。<\/p><h5 id=\"fig10\">图 10. ICN 插件配置<\/h5><img alt=\"ICN 插件配置\" src=\"/sunshine_new/images/1505087508/images/image10.jpg\" width=\"576\" /><h3 id=\"minor2.6\">查看器映射<\/h3><p>在查看器映射中，我们可以定义不同的存储库中不同文档类型的打开方式。对于用户特殊的文档类型，可以通过插件的方式实现对特殊文档类型查看的支持。<\/p><h5 id=\"fig11\">图 11. ICN 查看器映射配置<\/h5><img alt=\"图 25. ICN 查看器映射配置\" src=\"/sunshine_new/images/1505087508/images/image11.jpg\" width=\"576\" /><h3 id=\"minor2.7\">菜单<\/h3><p>在菜单设置中，我们可以对系统中所有使用的菜单进行个性化定制。在桌面设置中选择不同桌面所使用的不同菜单。<\/p><h5 id=\"fig12\">图 12. ICN 菜单配置<\/h5><img alt=\"图 12. ICN 菜单配置\" src=\"/sunshine_new/images/1505087508/images/image12.jpg\" width=\"576\" /><h3 id=\"minor2.8\">标签<\/h3><p>在标签设置项中，我们可以对系统所有使用的标签进行个性化定制，以符合教育行业企业的标准以及使用习惯等。<\/p><h5 id=\"fig13\">图 13. ICN 标签配置<\/h5><img alt=\"图 13. ICN 标签配置\" src=\"/sunshine_new/images/1505087508/images/image13.jpg\" width=\"576\" /><p>对于第二类通过 IBM Content Navigator API 对企业知识管理系统做全面的定制和客户化的方式我们已在插件章节中详细介绍。<\/p><h2 id=\"major3\">结束语<\/h2><p>IBM 企业内容管理平台能够帮助用户获取、存储、管理、保护内容信息，提高企业运营效率和降低企业成本。ICN(IBM Content Navigator) 是 IBM 企业内容管理的新一代统一 Web 客户端。本文详细介绍了基于 IBM Content Navigator 的教育行业知识管理中心解决方案，通过基于 IBM Content Navigator 实施的知识管理系统，能够迅速的实现教育行业知识管理的几大需求。<\/p><CMA ID: 970176><Site ID: 10><XSLT stylesheet used to transform this file: dw-document-html-7.0.xsl>\r\n\r\n\r\n<\/div>\r\n<\/div>\r\n","createTime":"2014-04-30 00:00:00","deployTime":"2014-04-30 00:00:00","id":0,"intro":"IBM 企业内容管理平台能够帮助用户获取、存储、管理、保护内容信息，提高企业运营效率和降低企业成本。ICN(IBM Content Navigator) 是 IBM 企业内容管理的新一代统一 Web 客户端。基于 IBM Content Navigator 实施的知识管理系统，能够迅速的实现教育行业知识管理的几大需求。本文将会继续介绍如何使用 Plugin 对教育行业知识管理系统进行扩展及使用 IBM Content Navigator 定制个性化知识管理界面。","keyword":"","recommend":false,"source":"http://www.ibm.com/developerworks/cn/data/library/techarticle/dm-1404ecm-education2/dm-1404ecm-education2.html","title":"ECM 在教育行业知识管理系统解决方案，第 2 部分: 插件开发、个性化定制","typeId":0,"updateTime":"2014-04-30 00:00:00"}
{"author":"","clickNumber":0,"content":"\r\n<div class=\"ibm-columns\">\r\n<div class=\"ibm-col-1-1\">\r\n\r\n<h2 id=\"intro\">简介<\/h2><p><strong>JPA 增强<\/strong>是修改实体类，添加监视它们之中的更改并持久保存这些更改的能力的过程。在使用 IBM WebSphere Application Server 所提供的 OpenJPA 时，此增强过程使用了一种称为<strong>字节码编织 (byte-code weaving)<\/strong> 的技术。通常，对于 WebSphere Application Server，JPA (Java&#8482; Persistence API) 实体的增强是在初始化 Java EE 应用程序期间执行的。<\/p><p>尽管不需要使用构建时增强，但它确实提供了一定的优势：<\/p><ul class=\"ibm-bullet-list\"><li>因为该增强不需要在每个服务器启动期间完成，所以减少了服务器的启动时间。  <\/li><li>如果 JPA 实体传递到 Java EE 应用程序外部，构建时增强可确保序列化或外部化的实体类与客户端中定义的类兼容。  <\/li><\/ul><p>尽管 JPA 一般会在将实体传递到客户端应用程序时将其序列化，但 JPA <strong>persistence.xml<\/strong> 文件中的一些设置（比如使用 <strong>openjpa.DetachState<\/strong> 属性的 <code>loaded(DetachedStateField=true)<\/code> 值）会导致 JPA “外部化” 该实体，而不是将它序列化。使用<strong>运行时增强<\/strong>时，这些实体只能供同样在实现运行时增强的客户端使用。这意味着客户端必须包含一个 persistence.xml 文件，支持同一个 JPA 运行时，而且在支持运行时增强的环境中运行。使用<strong>构建时增强<\/strong>是一种更好的解决方案。 <\/p><div class=\"dw-sidebar ibm-inset\"><p>本信息基于使用 Rational Application Developer V8 和 WebSphere Application Server V8 进行的联系，但针对其他 Rational 开发产品和版本以及 WebSphere Application Server 的其他版本的步骤与此类似。<\/p><\/div><p>本文将介绍在使用 IBM Rational Application Developer 和 IBM WebSphere Application Server 时，配置 JPA 构建时增强所需执行的步骤。尽管也有其他教程介绍构建时 JPA 增强的设置，但大部分或所有这些教材似乎都要下载额外的 OpenJPA 库才能执行该功能。如果两个 OpenJPA 版本不是完全相同，则可能导致出现问题。这里描述的步骤<strong>仅<\/strong>使用了 WebSphere Application Server 提供的库，所以它们将始终兼容。  <\/p><h2 id=\"sec1\">配置构建时增强<\/h2><p>构建时增强的设置可通过 3 个主要步骤轻松完成，下面几节将会介绍这些步骤。<\/p><h3 id=\"sec1a\">1. 创建 WebSphere Application Server 安装的引用 <\/h3><p>第一步是创建一个 <strong>classpath<\/strong> 变量来定义 WebSphere Application Server 的安装目录。  <\/p><ol class=\"ibm-alpha-list\" type=\"a\"><li>在 Rational Application Developer 中，从菜单栏导航到 <strong>Windows &gt; Preferences<\/strong>。 <\/li><li>在 Preferences 面板中，选择 <strong>Java &gt; Build Path &gt; Classpath Variables<\/strong>。<\/li><li>单击 <strong>New<\/strong> 按钮。对于 Name 字段，输入 <code>WAS_HOME<\/code>。使用 <strong>Folder...<\/strong> 按钮找到 WebSphere Application Server 安装目录并单击 <strong>OK<\/strong>。（WebSphere Application Server 安装目录通常以 “AppServer” 结尾。）现在单击 New Variable Entry 面板中的 <strong>OK<\/strong>（参见图 1）。 \n            <h5 id=\"fig1\">图 1. New Variable Entry<\/h5><img alt=\"New Variable Entry\" src=\"/sunshine_new/images/1476102762/images/image01.jpg\" width=\"800\" /><\/li><\/ol><h3 id=\"sec1b\">2. 创建 build.xml 文件<\/h3><p><strong>build.xml<\/strong> 文件定义增强 JPA 实体所需的过程和引用。  <\/p><ol class=\"ibm-alpha-list\" type=\"a\"><li>右键单击 JPA 项目中的 <strong>src<\/strong> 文件夹并选择 <strong>New &gt; Other...<\/strong><\/li><li>在 New 面板中的 General 文件夹下，选择 <strong>File<\/strong> 并单击 <strong>Next<\/strong>（参见图 2）。\n            <h5 id=\"fig2\">图 2. 选择一个向导<\/h5><img alt=\"选择一个向导\" src=\"/sunshine_new/images/1476102762/images/image02.jpg\" width=\"790\" /><\/li><li>输入 <code>build.xml<\/code> 作为文件名，然后单击 <strong>Finish<\/strong>（参见图 3）。 \n            <h5 id=\"fig3\">图 3. 创建一个新文件资源<\/h5><img alt=\"创建一个新文件资源\" src=\"/sunshine_new/images/1476102762/images/image03.jpg\" width=\"792\" /><\/li><li>将清单 1 中所示的代码插入到 build.xml 文件中，以用作起点。\n                <h5 id=\"listing1\">清单 1. build.xml<\/h5><div class=\"codesection\"><pre class=\"displaycode\">&lt;project  name=\"MyProject\" default=\"defaultBuild\"&gt;\n   &lt;!-- set global properties for this build --&gt;\n   &lt;property  name=\"src\" location=\"src\"/&gt; \n      &lt;!-- Location of JPA entity .java files in relation to project --&gt;\n   &lt;property  name=\"bin\" location=\"src\"/&gt; \n      &lt;!-- Location of JPA entity .class files in relation to project --&gt;\n\n   &lt;target  name=\"enhance\"&gt;\n      &lt;path  id=\"enhance.classpath\"&gt;\n         &lt;pathelement  location=\"${was.home}/dev/JavaEE/j2ee.jar\"/&gt;\n         &lt;pathelement  location=\"${was.home}/plugins/com.ibm.ws.jpa.jar\"/&gt;\n         &lt;pathelement  location=\"${was.home}/plugins/com.ibm.ws.prereq.commons-collections.jar\"/&gt;\n         &lt;pathelement  location=\"${bin}\"/&gt;\n             &lt;!-- Where the entity .class files are --&gt;\n         &lt;pathelement  location=\"${src}/../../&lt;project&gt;/\"/&gt; \n            &lt;!-- Use for reference to class outside this project if needed --&gt;\n      &lt;/path&gt;\n      &lt;property  name=\"cp\" refid=\"enhance.classpath\"/&gt;\n      &lt;echo  message=\"Classpath: ${cp}\"/&gt;\n      &lt;echo  message=\"Source:    ${src}\"/&gt;\n      &lt;echo  message=\"Bin:       ${bin}\"/&gt;\n      &lt;java  classname=\"org.apache.openjpa.enhance.PCEnhancer\" \n            logError=\"true\" failonerror=\"false\" fork=\"true\"&gt;\n         &lt;classpath  refid=\"enhance.classpath\"/&gt;\n         &lt;arg  value=\"-properties\" /&gt;\n         &lt;arg  value=\"${src}/META-INF/persistence.xml\" /&gt;\n      &lt;/java&gt;\n   &lt;/target&gt;\n\n   &lt;target  name=\"defaultBuild\" depends=\"enhance\"/&gt;\n\n&lt;/project&gt;<\/pre><\/div><\/li><li>尽管上面的 build.xml 文件内容应适合大部分 JPA 项目，但您可能仍然需要修改一些地方。例如：\n                            <ul class=\"ibm-bullet-list\"><li><strong>src<\/strong> 属性位置值应指向项目中包含 Java 源文件的目录，该目录通常是 src 文件夹。<\/li><li><strong>bin<\/strong> 属性位置值应指向项目中存储类文件的目录。在这个示例中，它们和 Java 源文件一起存储在 src 目录中。如果将类文件存储在不同的目录中，可能需要将该位置设置为 <code>bin<\/code>。<\/li><li>如果从您的实体中引用了 JPA 项目外部的类，则需要为每个项目引用包含一个 <strong>pathelement<\/strong>。在下一步中，您将看到一个已提供的条目，可将其中的 <code>&lt;project&gt;<\/code> 替换为您引用的项目。您可能需要附加一个额外的目录，比如 <code>bin/<\/code>，具体情况取决于该项目的类文件的位置。如果没有 JPA 项目外部的引用，那么删除该 pathelement 行即可。<\/li><\/ul><\/li><li>保存文件。<\/li><\/ol><h3 id=\"sec1c\">3. 创建 Ant 构建器<\/h3><p><strong>Ant 构建器<\/strong>是  Rational Application Developer 调用的一个任务，它将利用 build.xml 文件中的信息来增强 JPA 实体。  <\/p><ol class=\"ibm-alpha-list\" type=\"a\"><li>从菜单栏中选择 <strong>Project &gt; Properties<\/strong>。<\/li><li>在 Properties 面板中，选择 <strong>Builders<\/strong>。<\/li><li>单击 <strong>New...<\/strong>按钮。在 Choose configuration type 对话框中，选择 <strong>Ant Builder<\/strong> 并单击 <strong>OK<\/strong>。<\/li><li>更新 Edit Configuration 面板的 Main 选项卡中的以下字段（参见图 4）。（屏幕截图中的 JPA 项目称为 “TutorialJPA”。）\n                                <ul class=\"ibm-bullet-list\"><li>提供一个名称，比如 <code>AntBuilder<\/code> 或任何您最喜欢的名称。  <\/li><li>对于 Buildfile，单击 <strong>Browse Workspace...\n                                    <\/strong>导航到您第 2 步中创建的 build.xml 文件。选择 <strong>build.xml<\/strong> 文件并单击 <strong>OK<\/strong>。<\/li><li>对于 Base Directory，单击 <strong>Browse Workspace...<\/strong> 来选择 JPA 项目。单击 <strong>OK<\/strong>。<\/li><li>在 Arguments 字段中，输入 <code>\"-Dwas.home=${WAS_HOME}\"<\/code>（包含引号）。这会将 build.xml 文件中使用的 <strong>was.home<\/strong> 变量连接到类路径变量 <strong>WAS_HOME<\/strong>。<\/li><li><strong>不要<\/strong>单击 OK。<\/li><\/ul><h5 id=\"fig4\">图 4. 创建 Ant 构建配置<\/h5><img alt=\"创建 Ant 构建配置\" src=\"/sunshine_new/images/1476102762/images/image04.jpg\" width=\"800\" /><\/li><li>选择 <strong>Targets<\/strong> 选项卡并更新这些字段（参见图 5）：\n                        <ul class=\"ibm-bullet-list\"><li>在 After a \"Clean\" 部分中，单击 <strong>Set Targets...<\/strong>。取消选择 <strong>DefaultBuild [default]<\/strong> 目标并单击 Set Targets 面板上的 <strong>OK<\/strong>。 <\/li><li>在 Manual Build 部分中，默认目标应已选择。如果没有，则单击 <strong>Set Targets...<\/strong>。选择 <strong>DefaultBuild [default]<\/strong> 目标并单击 Set Targets 面板上的 <strong>OK<\/strong>。 <\/li><li>在 Auto Build 部分中，单击 <strong>Set Targets...<\/strong>。选择 <strong>DefaultBuild [default]<\/strong> 目标并单击 Set Targets 面板上的 <strong>OK<\/strong>。 <\/li><li>在 During a \"Clean\" 部分中，构建器应该已经被设置为不运行。<\/li><\/ul><h5 id=\"fig5\">图 5. 目标配置参数<\/h5><img alt=\"目标配置参数\" src=\"/sunshine_new/images/1476102762/images/image05.jpg\" width=\"800\" /><\/li><li>单击 <strong>OK<\/strong> 保存新构建器。<\/li><li>现在单击 Properties 面板上的 <strong>OK<\/strong>。<\/li><\/ol><p>您的构建时增强设置现在应已完成。您应在控制台窗口中看到清单 2 中所示的消息，因为 Ant Builder 增强已自动运行。 <\/p><h5 id=\"listing2\">清单 2. Ant 构建器消息<\/h5><div class=\"codesection\"><pre class=\"displaycode\">Buildfile: C:\\MyWorkspace\\TutorialJPA\\src\\build.xml\nTrying to override old definition of datatype description\nTrying to override old definition of datatype artifact\n\nenhance:\n        [echo] Classpath: C:\\Progra~2\\IBM\\WebSphere\\AppServer\\dev\\JavaEE\\j2ee.jar;C:\n\\Progra~2\\IBM\\WebSphere\\AppServer\\plugins\\com.ibm.ws.jpa.jar;C:\\Progra~2\\IBM\\WebSphere\n\\AppServer\\plugins\\com.ibm.ws.prereq.commons-collections.jar;C:\\MyWorkspace\\TutorialJPA.\n\\src;C:\\MyWorkspace\\ReferencedProject\n        [echo] Source:    C:\\MyWorkspace\\TutorialJPA\\src\n        [echo] Bin:       C:\\MyWorkspace\\TutorialJPA\\src\n        [java] 62  testJpa  INFO   [main] openjpa.Tool - No targets were given.  Running \non all classes in your persistent classes list, or all metadata files in classpath \ndirectories if you have not listed your persistent classes.  Use -help to display tool \nusage information.\n\ndefaultBuild:\nBUILD SUCCESSFUL\nTotal time: 7 seconds<\/pre><\/div><h2 id=\"conc\">结束语<\/h2><p>通过完成本文中描述的过程，您可以将 JPA 项目设置为在构建它时增强实体。完成该设置后，WebSphere Application Server 将不再需要在启动期间执行此操作。此外，对 JPA 实体的任何引用都会自动引用增强版本，以实现完全兼容。<\/p><CMA ID: 970003><Site ID: 10><XSLT stylesheet used to transform this file: dw-document-html-7.0.xsl>\r\n\r\n\r\n<\/div>\r\n<\/div>\r\n","createTime":"2014-04-29 00:00:00","deployTime":"2014-04-29 00:00:00","id":0,"intro":"本文展示了一个在 IBM Rational 开发产品中设置构建时 JPA 增强的过程，在此过程中，仅使用了 IBM WebSphere Application Server 提供的库。构建时增强可减少启动时间，能够无缝地支持在 JPA 应用程序与非 JPA 客户端之间传输 JPA 实体。","keyword":"","recommend":false,"source":"http://www.ibm.com/developerworks/cn/websphere/techjournal/1402_hollman/1402_hollman.html","title":"使用 WebSphere Application Server 实现构建时 JPA 增强","typeId":0,"updateTime":"2014-04-29 00:00:00"}
{"author":"","clickNumber":0,"content":"\r\n<div class=\"ibm-columns\">\r\n<div class=\"ibm-col-1-1\">\r\n\r\n<h2 id=\"Introduction\">简介<\/h2><p>客户制定这个术语指的是一个流程，在该流程中，客服代表（CSR）有权使用客户/购物者的身份，代表他们执行某些操作。这些客户是系统中的已注册购物者。客户制定这个术语可以与引导购物互换使用。<\/p><p>WebSphere Commerce 提供业务用户工具 (WebSphere Commerce Accelerator and Sales \n        Center)，CSR 可以在这里管理来自潜在客户的查询。不过，这些工具是不同的应用程序，并且与消费者用于购物的店面应用程序的外观有所不同。虽然通过这些工具来执行 CSR 操作很常见，但一些商家希望利用店面体验为其客户提供客户支持。使用店面来提供客户支持的一些主要驱动因素包括：<\/p><ul class=\"ibm-bullet-list\"><li>为所有用户提供一致的用户界面<\/li><li>让 CSR 可以查看购物者在店面上看到了什么，以便他们能够缩短事件的处理时间<\/li><li>在购物者在网站上进行购物的时候协助他们<\/li><\/ul><p>本文展示了如何利用 Madisons 店面来实现客户支持操作。<\/p><h2 id=\"N10062\">客户制定<\/h2><p>客户制定流程允许 CSR 执行多种操作，比如： <\/p><ul class=\"ibm-bullet-list\"><li>修改购物者的个人资料信息<\/li><li>查看订单信息<\/li><li>查看在订单上计算的折扣<\/li><li>查看优惠券的状态<\/li><li>修改购物者正在处理的订单<\/li><\/ul><p>WebSphere Commerce 提供了可以完成客户制定场景的 API。管理员可以通过运行 <code>RunAsUserSetInSession<\/code> URL，在一个会话中代表注册客户执行多个请求。如果管理员具有代表注册客户所需的权限，那么管理员可以使用该客户的身份执行所有后续请求。默认情况下，代表注册用户的管理员可以执行该注册客户有权执行的所有操作。<em>但是，在管理员代表注册客户进行操作时，管理员不能运行任何管理命令。<\/em><\/p><p>在 <code>RunAsUserSetInSession<\/code> URL 成功地将管理员的身份切换为注册客户的身份后，WebSphere Commerce：<\/p><ul class=\"ibm-bullet-list\"><li>将与当前请求关联的用户 ID 设置为指定客户的 ID<\/li><li>导致命令上下文重新计算值，如客户的有效组织<\/li><li>导致所有后续命令（直到切换是反向的）将客户的身份和有效组织包括在管理员的会话信息中<\/li><li>在每个后续请求的过程中，从管理员的会话中提取客户的身份和有效组织<\/li><\/ul><p>在 WebSphere Commerce 允许管理员以客户的身份运行一个命令之前，确保管理员具有执行该操作所需的授权。WebSphere Commerce：<\/p><ul class=\"ibm-bullet-list\"><li>检查客户是否在管理员的授权域内已注册<\/li><li>检查是否已在 forUser 访问控制策略中定义了该命令<\/li><li>检查客户是否可以执行该命令<\/li><\/ul><p>为了切换回管理员的原始身份，管理员运行 <code>RestoreOriginalUserSetInSession<\/code> URL。此命令从管理员的会话中删除客户的信息，并将管理员的会话信息恢复到切换为顾客身份之前的状态。<\/p><h2 id=\"N10098\">订单锁定<\/h2><p>在结帐过程中，订单实体经历多种状态，而且它对订单金额有直接的影响。因此，与其他实体不同，它是由 WebSphere Commerce 中被称为订单锁定的程序守护。作为零售商，您可能允许 CSR 和购物者同时更新购物者的个人资料。但是，您可能不希望让 CSR 和购物者同时更新购物者的订单。因此，让我们来探索有关订单锁定的更多信息。<\/p><p>订单锁定可防止多个用户同时修改订单。当第一个用户开始编辑订单时，订单就被锁定。如果其他用户试图编辑同一个订单，他们会收到一条消息，指出他们不能编辑订单。默认情况下，已启用订单锁定。<\/p><p>您可以通过更改商务实例配置文件来禁用订单锁定。允许多个用户同时处理同一个订单，这可能导致出现数据完整性问题，因此，必须小心处理。<\/p><p>在此定制中，不会禁用订单锁定；而是保留默认的订单锁定设置。但是，您需要了解在启用锁定的情况下，系统如何允许购物者和 CSR 处理相同的订单。<\/p><h2 id=\"APIs\">API<\/h2><p>以下是在此实现中要使用的 API。本文对每个这些组件都进行了详细说明。<\/p><ul class=\"ibm-bullet-list\"><li><code>RunAsUserSetInSession<\/code> - 允许拥有所需权限的管理员以指定客户的身份在同一个会话中运行后续命令。访问控制框架会检查当前用户是否属于下列角色之一： \n<ul class=\"ibm-bullet-list\"><li>客服代表 (CSR)<\/li><li>客服主管 (CSS)<\/li><li>运营经理<\/li><li>销售经理<\/li><li>销售人员<\/li><\/ul><p>参数值是：<\/p><ul class=\"ibm-bullet-list\"><li>langId<\/li><li>URL - 在成功完成命令时调用的 URL<\/li><li>storeId<\/li><li>runAsUserId - 注册客户的用户 ID，这是运行后续请求的客户身份<\/li><\/ul><p>示例 URL：https://hostname/webapp/wcs/stores/servlet/RunAsUserSetInSession?runAsUserId=32005\n                        &amp;URL=UserAccountView<\/p><\/li><li><code>RestoreOriginalUserSetInSession<\/code> - 重置后续命令的会话，则管理员通过运行 <code>RunAsUserSetInSession<\/code> 命令在会话中建立 runAsUser 值后，他们恢复到原来的管理员用户 ID。\n                    \n<p>参数值是：<\/p><ul class=\"ibm-bullet-list\"><li>langId<\/li><li>URL - 在成功完成命令时调用的 URL<\/li><li>storeId<\/li><\/ul><p>示例 URL：https://hostname/webapp/wcs/stores/servlet/RestoreOriginalUserSetInSession?storeId=11001&amp;URL=AjaxLogonForm&amp;myAcctMain=1<\/p><\/li><li><code>AdvancedOrderEditBegin<\/code> - 建立一个订单，以便编辑或更改它，并开始一个编辑会话。它将一个编辑器 ID 附加到订单。此 URL 检查订单和订单项目是否可编辑。如果它们是可编辑的，除非它们的状态是 NEW、P 或 E，否则将其状态修改为 E。同时，如果订单和订单项目在购物车中，则不修改状态。在释放已提交的订单来执行它们之前，可以修改它们。\n                    \n<p>参数值是：<\/p><ul class=\"ibm-bullet-list\"><li>orderId<\/li><li>URL - 在成功完成命令时调用的 URL<\/li><li>storeId<\/li><\/ul><p>示例 URL： http://hostname/webapp/wcs/stores/servlet/AdvancedOrderEditBegin?orderId=13502&amp;URL=StoreView<\/p><\/li><li><code>AdvancedOrderEditEnd<\/code> - 关闭订单的编辑状态，并从订单中删除编辑器 ID。也就是说，这个 URL 从 ORDERS 表的订单中删除 EDITOR_ID 值。只有当订单的状态为 NEW、P 或 E 时，<code>AdvancedOrderEditEnd<\/code> URL 才可以被用来关闭订单的编辑。主状态在调用之后就不会发生改变。\n                    \n<p>参数值是：<\/p><ul class=\"ibm-bullet-list\"><li>orderId<\/li><li>URL - 在成功完成命令时调用的 URL<\/li><li>storeId<\/li><\/ul><p>示例 URL： http://hostname/webapp/wcs/stores/servlet/AdvancedOrderEditEnd?orderId=13502&amp;URL=StoreView<\/p><\/li><li><code>OrderLockingHelper<\/code> - 此辅助类实现了一些方法来执行订单资源的锁定和解锁。<\/li><\/ul><h2 id=\"N10102\">定制步骤<\/h2><p>客户制定流程从一个客户搜索开始。当前的 Madisons 商店没有可以供 CSR 用于执行制定的客户搜索特性。因此，您需要在 Madisons 商店中为 CSR 执行一些配置，以搜索一个客户，然后为选定的客户执行制定。定制的另一个方面是在制定过程中处理订单锁定。<\/p><p>为了处理由购物者创建的订单，CSR 需要获得该订单上的锁。同样，在完成订单修改时，CSR 需要释放该锁。正如在 <a href=\"#APIs\">API<\/a> 部分中所提到的那样，<code>AdvancedOrderEditBeginCmd<\/code> 和 <code>AdvancedOrderEditEndCmd<\/code> 命令了提供这些操作。但是，这些命令有一个限制。可以释放订单上的锁的惟一用户就是获得该订单上的锁的用户。如果其他 CSR 尝试获得或释放锁，这些命令都将失败。不过，在真实的场景中，这种限制可能不被接受。企业可能会希望，无论谁锁定了订单，都允许所有授权 CSR 删除订单上的锁，使购物者可以继续处理该订单。您的定制可确保准确地满足这种需求。系统首先检查订单是否被锁定。如果订单已被锁定，则对其解锁，然后允许 CSR 释放订单上的锁。<\/p><p>为此定制开发的所有视图和命令都可以由只具有一个客户服务角色的用户来调用。确保访问控制策略是相同的。您可以在附带的源中查看相同的内容。<\/p><h3 id=\"N10118\">UI 定制<\/h3><p>Madisons starter store 提供了一个正常运作的消费者在线直销商店所需的所有页面和特性。本节将介绍 Madisons 店面中所需的一些定制。<\/p><h4 id=\"N1011F\">客户搜索<\/h4><p>为了让 CSR 可以执行客户制定，第一步是执行配置，让 CSR 可以搜索客户。所以，要构建一个只能由 CSR 执行的新 Customer Search 页面。<\/p><ol><li>创建一个名为 CustomerSearchDisplay.jsp 的 JSP，如 <a href=\"#list1\">清单 1<\/a> 所示。此 JSP 显示搜索表单。在 struts 配置扩展文件中注册此视图。CustomerSearchView 让 CSR 可以搜索客户。\n\n<h5 id=\"list1\">清单 1. CustomerSearchDisplay.jsp<\/h5><div class=\"codesection\"><pre class=\"displaycode\">&lt;action path=\"/CustomerSearchView\" \ntype=\"com.ibm.commerce.struts.BaseAction\"&gt;\n&lt;set-property property=\"credentialsAccepted\" value=\"&lt;storeId&gt;:P \"/&gt;\n&lt;/action&gt;\n\n&lt;forward className=\"com.ibm.commerce.struts.ECActionForward\" \nname=\"CustomerSearchView/&lt;storeId&gt;\" \npath=\"/UserArea/AccountSection/UserCustomSearchDisplay.jsp\"/&gt;<\/pre><\/div><\/li><li>通过运行 <code>acpload<\/code> 命令加载访问控制策略。<\/li><\/ol><h4 id=\"N10139\">客户搜索结果<\/h4><p>在 CSR 提交搜索后，显示搜索结果页面。<\/p><ol><li>创建一个名为 CustomerSearchResultsDisplay 的 JSP，如 <a href=\"#list2\">清单 2<\/a> 所示。此 JSP 将会显示搜索结果。它调用 Person 服务来检索客户详细信息，而且还允许 CSR 从搜索结果选择要制定的客户。CSR 单击 <strong>Start Enactment<\/strong> 按钮。在 struts 配置扩展文件中注册此视图。\n    \n\n<h5 id=\"list2\">清单 2. CustomerSearchResultsDisplay.jsp<\/h5><div class=\"codesection\"><pre class=\"displaycode\">&lt;action path=\"/CustomerSearchResultsView\"\ntype=\"com.ibm.commerce.struts.BaseAction\"&gt;\n&lt;set-property property=\"credentialsAccepted\" value=\"&lt;storeId&gt;:P \"/&gt;\n&lt;/action&gt;\n\n&lt;forward className=\"com.ibm.commerce.struts.ECActionForward\" \nname=\"CustomerSearchResultsView/&lt;storeId&gt;\" \npath=\"/UserArea/AccountSection/CustomSearchResultsDisplay.jsp\"/&gt;<\/pre><\/div><\/li><li>通过运行 <code>acpload<\/code> 命令加载访问控制策略。<\/li><\/ol><h4 id=\"N10156\">页眉链接<\/h4><p>页眉菜单包含商店徽标，徽标的下方左侧有类别列表。在右侧，页眉提供了一个搜索栏，并在它的下方显示迷你购物车。在搜索栏和迷你购物车之间还有多个链接，比如 Shopping Cart、Advanced Search 和 Sign Out。让我们在 Sign Out 链接前面添加一个 <strong>Customer Search<\/strong> 链接。<\/p><ol><li>在页眉中添加 <strong>Customer Search<\/strong> 导航链接，这样 CSR 就可以导航到 Customer Search 页面。此链接仅供客户服务用户角色使用。<\/li><li>同样的，在页眉中创建一个新的链接，用它来终止制定流程。您可以将此链接称为 <strong>Drop Customer Session<\/strong>。当制定为活动状态时，用户可通过单击此链接来结束制定。需要重点注意的是，直到 CSR 结束制定时，<strong>Customer Search<\/strong> 选项才对 CSR 可用。该操作的思路是：先完成制定，然后继续下一次客户搜索。要进行这些更改，可修改名为 CachedHeaderDisplayExt.jspf 的现有扩展页眉 JSP，如 <a href=\"#list3\">清单 3<\/a> 所示。\n       \n\n<h5 id=\"list3\">清单 3. CachedHeaderDisplayExt.jspf<\/h5><div class=\"codesection\"><pre class=\"displaycode\">&lt;wcbase:useBean id=\"eBean\" \nclassname=\"com.ibm.commerce.sample.beans.MyCompanyEnactmentDataBean\"&gt;\n&lt;/wcbase:useBean&gt;\n\n&lt;c:if test=\"${eBean.CSRActive}\"&gt;\n\t&lt;wcf:url var=\"CustomerSearchURL\" value=\"CustomerSearchView\" &gt;\n         &lt;wcf:param name=\"langId\" value=\"${langId}\" /&gt;\n         &lt;wcf:param name=\"storeId\" value=\"${WCParam.storeId}\" /&gt;\n         &lt;wcf:param name=\"catalogId\" value=\"${WCParam.catalogId}\" /&gt;\n\t&lt;/wcf:url&gt;\n\t\n\t&lt;span&gt;&lt;a href='&lt;c:out value=\"${CustomerSearchURL}\"/&gt;' &gt;&lt;fmt:message \nkey=\"TITLE_CUSTOM_SEARCH\" bundle=\"${storeText}\" /&gt;&lt;/a&gt;\n\t&lt;/span&gt;\n\t&lt;fmt:message key=\"DIVIDING_BAR\" bundle=\"${storeText}\" /&gt;\n&lt;/c:if&gt;<\/pre><\/div><p>如您所见，这个 JSP 片段是依据 databean 来确定的：<\/p><ul class=\"ibm-bullet-list\"><li>制定是否有效。<\/li><li>登入的用户是否拥有客户服务角色。<\/li><\/ul><\/li><li>创建一个名为 MyCompanyEnactmentDataBean 的智能 databean，并实现一个逻辑，用于确定制定是否有效。从附件的源查看代码。<\/li><\/ol><h3 id=\"N10182\">业务逻辑定制<\/h3><p>您可以在现有的业务逻辑之前或之后添加新的业务逻辑，或者在其之前和之后都添加新的业务逻辑。在这里，需要在 <code>RunAsSetInSession<\/code> 之前添加逻辑，以确保在 CSR 处理订单之前解锁订单。同样，您需要添加逻辑来解锁在 CSR 恢复会话后被锁定的订单。<\/p><h4 id=\"N1018C\">订单解锁<\/h4><p>订单锁定可防止多个用户同时修改订单。在 CSR 处理订单之前，您需要确保用户的订单已被解锁。<\/p><ol><li>创建一个名为 <code>MyCompanyExtAdvancedOrderEditBeginCmd<\/code> 的命令，该命令扩展了 <code>AdvancedOrderEditBeginCmd<\/code> 命令。在 performExecute() 方法中实现逻辑（如 <a href=\"#list4\">清单 4<\/a> 所示）。\n    \n\n<h5 id=\"list4\">清单 4. 解锁订单<\/h5><div class=\"codesection\"><pre class=\"displaycode\">OrderLockingHelper helper = new OrderLockingHelper ();\nif(helper.isLocked(orderId)) {\n   Logger.log(\"The Order is currently locked by \" + \nhelper.getLockedByLogonId(orderId));\n   helper.lock(orderId, true);\n   Logger.log(\"Order is now locked by  \" + getCommandContext().getUserId());\n   super.performExecute();\n}<\/pre><\/div><\/li><li>在 CMDREG 中注册此命令实现。您需要更新 CMDREG 项，如 <a href=\"#list5\">清单 5<\/a> 所示。\n\n<h5 id=\"list5\">清单 5. 在 CMDREG 中注册 MyCompanyExtAdvancedOrderEditBeginCmd 命令<\/h5><div class=\"codesection\"><pre class=\"displaycode\">update cmdreg set \nclassname='com.ibm.commerce.sample.commands.MyCompanyExtAdvancedOrderEditBeginCmdIm\npl' where \ninterfacename='com.ibm.commerce.ordermanagement.commands.AdvancedOrderEditBeginCmd' \nand storeent_id=0;<\/pre><\/div><\/li><\/ol><h4 id=\"N101B4\">制定命令<\/h4><p>您需要一个新的控制器命令，使用它作为一个制定命令。当 CSR 在 Customer \nSearch 页面上单击 <strong>Start Enactment<\/strong> 时，调用该命令。<\/p><ol><li>创建一个名为 <code>MyCompanyEnactmentCmd<\/code> 的控制器命令。制定逻辑包括：\n    \n<ul class=\"ibm-bullet-list\"><li>查找用户的挂起订单<\/li><li>对挂起订单调用 <code>AdvancedOrderEditBeginCmd<\/code><\/li><li>调用 <code>RunAsSetInSession<\/code> URL 初始化制定<\/li><li>将用户重定向到 Home 页面<\/li><\/ul><p>要重点注意的是，只有具有客户服务角色的用户才能调用 <code>AdvancedOrderEditBeginCmd<\/code> 命令。换句话说，如果在制定后调用此命令，调用将会失败。所以，需要确保在 <code>RusAsUserSetInSession<\/code> 命令之前调用它。<\/p><\/li><li>在 CMDREG 中注册 <code>MyCompanyEnactmentCmd<\/code> 命令，如 <a href=\"#list6\">清单 6<\/a> 所示。\n    \n\n<h5 id=\"list6\">清单 6. 在 CMDREG 中注册 MyCompanyEnactmentCmd 命令<\/h5><div class=\"codesection\"><pre class=\"displaycode\">insert into CMDREG (STOREENT_ID, INTERFACENAME, DESCRIPTION, CLASSNAME, \nTARGET) values (0,'com.ibm.commerce.sample.commands.MyCompanyEnactmentCmd', \n'This is a new controller command for enactment.', \n'com.ibm.commerce.sample.commands.MyCompanyEnactmentCmdImpl','Local');<\/pre><\/div><\/li><li>为 <code>MyCompanyEnactmentCmd<\/code> 命令创建 struts 操作映射。<\/li><li>通过运行 <code>acpload<\/code> 命令加载访问控制策略。<\/li><\/ol><h4 id=\"N101F4\">会话终止命令<\/h4><p>需要使用会话终止命令来还原会话并解锁订单，让购物者可以继续处理这个订单。<\/p><ol><li>创建一个名为 <code>MyCompanyEnactmentEndCmd<\/code> 的控制器命令。当 CSR 单击在页面的页眉部分中的 <strong>Drop Customer Session<\/strong> 链接时调用它。该链接首先调用 \n<code>RestoreOriginalUserSetInSession<\/code> 命令，然后将请求重定向到该命令。在制定过程中不能调用此命令，所以必须先通过调用 <code>Restore<\/code> 命令终止它。<\/li><li>如果订单在制定过程中被锁定，则需要该命令来解锁订单。\n    \n<ul class=\"ibm-bullet-list\"><li>读取 enactedUserId，并找到用户的挂起订单。如果它是由当前用户锁定的，则调用 <code>AdvancedOrderEditEndCmd<\/code> 命令。<\/li><li>将用户重定向到 Home 页面。<\/li><\/ul><\/li><li>在 CMDREG 中注册 <code>MyCompanyEnactmentEndCmd<\/code> 命令，如 <a href=\"#list7\">清单 7<\/a> 所示。\n\n<h5 id=\"list7\">清单 7. 在 CMDREG 中注册 MyCompanyEnactmentEndCmd 命令<\/h5><div class=\"codesection\"><pre class=\"displaycode\">insert into CMDREG (STOREENT_ID, INTERFACENAME, DESCRIPTION, CLASSNAME, TARGET) \nvalues (0,'com.ibm.commerce.sample.commands.MyCompanyEnactmentEndCmd', 'This is a \nnew controller to terminate the enactment.', \n'com.ibm.commerce.sample.commands.MyCompanyEnactmentEndCmdImpl','Local');<\/pre><\/div><\/li><li>为 <code>MyCompanyEnactmentEndCmd<\/code> 命令创建 struts 操作映射。<\/li><li>通过运行 <code>acpload<\/code> 命令来加载访问控制策略。<\/li><\/ol><h2 id=\"N1022E\">运行业务场景<\/h2><p>本节概述了两个业务场景。第一个场景演示了 CSR 如何处理一个由客户创建的挂起订单。在第二个场景中，CSR 帮助客户编辑客户的个人信息，并创建一个订单。<\/p><h3 id=\"N10236\">场景 1<\/h3><p>CSR 处理一个由客户创建的挂起订单。CSR 与购物者都处于登录状态，并试图同时修改同一个订单。<\/p><ol><li>构建项目并重新启动服务器。<\/li><li>启动一个 Firefox 会话，并导航到 Madisons 主页。以注册用户的身份登录，并且将物品添加到购物车。保持浏览器会话打开。\n    \n<h5 id=\"fig1\">图 1. 购物者登录<\/h5><img alt=\"一个较小的 Madisons 截图，可以看到在购物车中显示的物品。\" src=\"/sunshine_new/images/负1771994218/figure1-small.jpg\" width=\"850\" /><p><a href=\"#N1024E\" class=\"ibm-popup-link\" onclick=\"ibmweb.overlay.show('N1024E',this);return false;\">点击查看大图<\/a><\/p><div id=\"N1024E\" class=\"dw-sidefile-overlay ibm-common-overlay ibm-overlay-alt-two\"><div class=\"ibm-head\"><p><a href=\"#close\" class=\"ibm-common-overlay-close\">关闭 [x]<\/a><\/p><\/div><div class=\"ibm-body\"><div class=\"ibm-main\"><div class=\"ibm-title\"><h2>图 1. 购物者登录<\/h2><\/div><div class=\"ibm-container ibm-alternate\"><div class=\"ibm-container-body\"><img alt=\"Madisons 截图，可以看到在购物车中显示的物品。\" src=\"/sunshine_new/images/负1771994218/figure1.jpg\" width=\"1500\" /><\/div><\/div><\/div><\/div><div class=\"ibm-footer\"><><\/div><\/div><\/li><li>启动 Internet Explorer，并导航到 Madisons 主页。以 CSR 身份登录。如果您没有 CSR 配置文件，可以在 Organization Administration Console 中创建一个。\n    \n<h5 id=\"fig2\">图 2. CSR 登录<\/h5><img alt=\"较小的屏幕截图，显示 CSR 登录后的 Madisons 页面\" src=\"/sunshine_new/images/负1771994218/figure2-small.jpg\" width=\"850\" /><p><a href=\"#N10261\" class=\"ibm-popup-link\" onclick=\"ibmweb.overlay.show('N10261',this);return false;\">点击查看大图<\/a><\/p><div id=\"N10261\" class=\"dw-sidefile-overlay ibm-common-overlay ibm-overlay-alt-two\"><div class=\"ibm-head\"><p><a href=\"#close\" class=\"ibm-common-overlay-close\">关闭 [x]<\/a><\/p><\/div><div class=\"ibm-body\"><div class=\"ibm-main\"><div class=\"ibm-title\"><h2>图 2. CSR 登录<\/h2><\/div><div class=\"ibm-container ibm-alternate\"><div class=\"ibm-container-body\"><img alt=\"Madisons 屏幕截图显示 CSR 登录后的 Madisons 页面\" src=\"/sunshine_new/images/负1771994218/figure2.jpg\" width=\"1500\" /><\/div><\/div><\/div><\/div><div class=\"ibm-footer\"><><\/div><\/div><\/li><li>单击页眉中的 <strong>Customer Search<\/strong> 链接。显示 Customer Search 表单，如 <a href=\"#fig3\">图 3<\/a> 所示。\n    \n<h5 id=\"fig3\">图 3. CSR - 客户搜索<\/h5><img alt=\"较小的屏幕截图，显示了 Customer Search 链接和 Customer Search 输入栏\" src=\"/sunshine_new/images/负1771994218/figure3-small.jpg\" width=\"850\" /><p><a href=\"#N1027B\" class=\"ibm-popup-link\" onclick=\"ibmweb.overlay.show('N1027B',this);return false;\">点击查看大图<\/a><\/p><div id=\"N1027B\" class=\"dw-sidefile-overlay ibm-common-overlay ibm-overlay-alt-two\"><div class=\"ibm-head\"><p><a href=\"#close\" class=\"ibm-common-overlay-close\">关闭 [x]<\/a><\/p><\/div><div class=\"ibm-body\"><div class=\"ibm-main\"><div class=\"ibm-title\"><h2>图 3. CSR - 客户搜索<\/h2><\/div><div class=\"ibm-container ibm-alternate\"><div class=\"ibm-container-body\"><img alt=\"Madisons 屏幕截图，显示了 Customer Search 链接和 Customer Search 输入栏\" src=\"/sunshine_new/images/负1771994218/figure3.jpg\" width=\"1500\" /><\/div><\/div><\/div><\/div><div class=\"ibm-footer\"><><\/div><\/div><\/li><li>使用 Customer Search 表单在系统中搜索一个客户。搜索操作将在 Customer Search Results 屏幕中显示匹配的客户，如 <a href=\"#fig4\">图 4<\/a> 所示。\n    \n<h5 id=\"fig4\">图 4. 客户搜索结果<\/h5><img alt=\"较小的 Madisons 屏幕截图，显示了客户搜索的结果\" src=\"/sunshine_new/images/负1771994218/figure4-small.jpg\" width=\"850\" /><p><a href=\"#N10292\" class=\"ibm-popup-link\" onclick=\"ibmweb.overlay.show('N10292',this);return false;\">点击查看大图<\/a><\/p><div id=\"N10292\" class=\"dw-sidefile-overlay ibm-common-overlay ibm-overlay-alt-two\"><div class=\"ibm-head\"><p><a href=\"#close\" class=\"ibm-common-overlay-close\">关闭 [x]<\/a><\/p><\/div><div class=\"ibm-body\"><div class=\"ibm-main\"><div class=\"ibm-title\"><h2>图 4. 客户搜索结果<\/h2><\/div><div class=\"ibm-container ibm-alternate\"><div class=\"ibm-container-body\"><img alt=\"Madisons 屏幕截图，显示客户搜索的结果\" src=\"/sunshine_new/images/负1771994218/figure4.jpg\" width=\"1500\" /><\/div><\/div><\/div><\/div><div class=\"ibm-footer\"><><\/div><\/div><\/li><li>选中客户并单击 <strong>Enact Customer<\/strong>。观察 <a href=\"#fig5\">图 5<\/a> 中的页眉。再也看不到 <strong>Customer Search<\/strong> 链接，而且改为显示 <strong>Drop Customer Session<\/strong> 链接。\n    \n<h5 id=\"fig5\">图 5. CSR 在制定客户<\/h5><img alt=\"较小的 Madisons 屏幕截图，显示了 Customer Search 链接已被 Drop Customer Session 链接取代\" src=\"/sunshine_new/images/负1771994218/figure5-small.jpg\" width=\"850\" /><p><a href=\"#N102B2\" class=\"ibm-popup-link\" onclick=\"ibmweb.overlay.show('N102B2',this);return false;\">点击查看大图<\/a><\/p><div id=\"N102B2\" class=\"dw-sidefile-overlay ibm-common-overlay ibm-overlay-alt-two\"><div class=\"ibm-head\"><p><a href=\"#close\" class=\"ibm-common-overlay-close\">关闭 [x]<\/a><\/p><\/div><div class=\"ibm-body\"><div class=\"ibm-main\"><div class=\"ibm-title\"><h2>图 5. CSR 在制定客户<\/h2><\/div><div class=\"ibm-container ibm-alternate\"><div class=\"ibm-container-body\"><img alt=\"Madisons 屏幕截图，显示了 Customer Search 链接已被 Drop Customer Session 链接取代\" src=\"/sunshine_new/images/负1771994218/figure5.jpg\" width=\"1500\" /><\/div><\/div><\/div><\/div><div class=\"ibm-footer\"><><\/div><\/div><\/li><li>导航到购物车页面。<\/li><li>在 Internet Explorer 中通过将物品添加到购物车来修改订单，如 <a href=\"#fig6\">图 6<\/a> 所示。\n    \n<h5 id=\"fig6\">图 6. CSR 修改客户的订单<\/h5><img alt=\"较小的图像显示了 Shopping Cart 页面，其中 CSR 已添加其他物品\" src=\"/sunshine_new/images/负1771994218/figure6-small.jpg\" width=\"850\" /><p><a href=\"#N102CB\" class=\"ibm-popup-link\" onclick=\"ibmweb.overlay.show('N102CB',this);return false;\">点击查看大图<\/a><\/p><div id=\"N102CB\" class=\"dw-sidefile-overlay ibm-common-overlay ibm-overlay-alt-two\"><div class=\"ibm-head\"><p><a href=\"#close\" class=\"ibm-common-overlay-close\">关闭 [x]<\/a><\/p><\/div><div class=\"ibm-body\"><div class=\"ibm-main\"><div class=\"ibm-title\"><h2>图 6. CSR 修改客户的订单<\/h2><\/div><div class=\"ibm-container ibm-alternate\"><div class=\"ibm-container-body\"><img alt=\"该图显示了 Shopping Cart 页面，其中 CSR 已添加其他物品\" src=\"/sunshine_new/images/负1771994218/figure6.jpg\" width=\"1500\" /><\/div><\/div><\/div><\/div><div class=\"ibm-footer\"><><\/div><\/div><\/li><li>现在，您可以尝试从购物者的浏览器会话对同一个订单进行修改。您会看到一个错误，如 <a href=\"#fig7\">图 7<\/a> 所示。错误的出现是因为该订单已由 CSR 锁定。\n    \n<h5 id=\"fig7\">图 7. 客户尝试修改订单<\/h5><img alt=\"较小的图像，显示了在 Shopping Cart 页面上的错误，原因是客户试图修改目前由 CSR 锁定的订单\" src=\"/sunshine_new/images/负1771994218/figure7-small.jpg\" width=\"850\" /><p><a href=\"#N102E2\" class=\"ibm-popup-link\" onclick=\"ibmweb.overlay.show('N102E2',this);return false;\">点击查看大图<\/a><\/p><div id=\"N102E2\" class=\"dw-sidefile-overlay ibm-common-overlay ibm-overlay-alt-two\"><div class=\"ibm-head\"><p><a href=\"#close\" class=\"ibm-common-overlay-close\">关闭 [x]<\/a><\/p><\/div><div class=\"ibm-body\"><div class=\"ibm-main\"><div class=\"ibm-title\"><h2>图 7. 客户尝试修改订单<\/h2><\/div><div class=\"ibm-container ibm-alternate\"><div class=\"ibm-container-body\"><img alt=\"显示在 Shopping Cart 页面上的错误，原因是客户试图修改目前由 CSR 锁定的订单\" src=\"/sunshine_new/images/负1771994218/figure7.jpg\" width=\"1500\" /><\/div><\/div><\/div><\/div><div class=\"ibm-footer\"><><\/div><\/div><\/li><li>当您在 Internet Explorer 中完成对订单的修改时，请单击 \n    <strong>Drop Customer Session<\/strong>，如 <a href=\"#fig8\">图 8<\/a> 所示。\n    \n<h5 id=\"fig8\">图 8. CSR 结束制定<\/h5><img alt=\"一个较小的 Madisons 截图，有一个箭头指出 'Drop Customer Session' 链接的位置\" src=\"/sunshine_new/images/负1771994218/figure8-small.jpg\" width=\"850\" /><p><a href=\"#N102FC\" class=\"ibm-popup-link\" onclick=\"ibmweb.overlay.show('N102FC',this);return false;\">点击查看大图<\/a><\/p><div id=\"N102FC\" class=\"dw-sidefile-overlay ibm-common-overlay ibm-overlay-alt-two\"><div class=\"ibm-head\"><p><a href=\"#close\" class=\"ibm-common-overlay-close\">关闭 [x]<\/a><\/p><\/div><div class=\"ibm-body\"><div class=\"ibm-main\"><div class=\"ibm-title\"><h2>图 8. CSR 结束制定<\/h2><\/div><div class=\"ibm-container ibm-alternate\"><div class=\"ibm-container-body\"><img alt=\"Madisons 截图，有一个箭头指出 'Drop Customer Session' 链接的位置\" src=\"/sunshine_new/images/负1771994218/figure8.jpg\" width=\"1500\" /><\/div><\/div><\/div><\/div><div class=\"ibm-footer\"><><\/div><\/div><p>制定被结束，会话恢复，如 <a href=\"#fig9\">图 9<\/a> 所示。<\/p><\/li><li>导航到以购物者身份登录的 Firefox 会话，并刷新购物车。您应该能够看到由 CSR 所做的修改。现在作为购物者尝试修改订单。您应该能够修改订单，并下订单。\n    \n<h5 id=\"fig9\">图 9. 客户修改订单<\/h5><img alt=\"较小的屏幕截图，显示来自购物者的 Mozilla Firefox 浏览器会话的购物车\" src=\"/sunshine_new/images/负1771994218/figure9-small.jpg\" width=\"850\" /><p><a href=\"#N10315\" class=\"ibm-popup-link\" onclick=\"ibmweb.overlay.show('N10315',this);return false;\">点击查看大图<\/a><\/p><div id=\"N10315\" class=\"dw-sidefile-overlay ibm-common-overlay ibm-overlay-alt-two\"><div class=\"ibm-head\"><p><a href=\"#close\" class=\"ibm-common-overlay-close\">关闭 [x]<\/a><\/p><\/div><div class=\"ibm-body\"><div class=\"ibm-main\"><div class=\"ibm-title\"><h2>图 9. 客户修改订单<\/h2><\/div><div class=\"ibm-container ibm-alternate\"><div class=\"ibm-container-body\"><img alt=\"屏幕截图显示来自购物者的 Mozilla Firefox 浏览器会话的购物车\" src=\"/sunshine_new/images/负1771994218/figure9.jpg\" width=\"1500\" /><\/div><\/div><\/div><\/div><div class=\"ibm-footer\"><><\/div><\/div><\/li><\/ol><h3 id=\"N1031A\">场景 2<\/h3><p>CSR 修改客户的个人资料信息。<\/p><ol><li>客户登录到商店，在系统中没有挂起订单。<\/li><li>CSR 登录并制定客户。要重点注意的是，因为不存在挂起订单，CSR 无法锁定订单。不过，CSR 可以执行其他活动，比如更新个人资料信息。<\/li><li>客户将物品添加到购物车中，并创建挂起订单。<\/li><li>CSR 刷新购物车，看到挂起订单。不过，CSR 目前不能修改订单，因为锁不是在制定过程中获得的。如果 CSR 试图对订单执行任何修改，则会显示错误，如 <a href=\"#fig10\">图 10<\/a> 所示。\n    \n<h5 id=\"fig10\">图 10. CSR 看到订单锁错误<\/h5><img alt=\"显示较小的挂起订单屏幕截图，其中显示了一个错误消息，指出订单不是被您锁定的，而是由 CSR 锁定的。\" src=\"/sunshine_new/images/负1771994218/figure10-small.jpg\" width=\"850\" /><p><a href=\"#N1033A\" class=\"ibm-popup-link\" onclick=\"ibmweb.overlay.show('N1033A',this);return false;\">点击查看大图<\/a><\/p><div id=\"N1033A\" class=\"dw-sidefile-overlay ibm-common-overlay ibm-overlay-alt-two\"><div class=\"ibm-head\"><p><a href=\"#close\" class=\"ibm-common-overlay-close\">关闭 [x]<\/a><\/p><\/div><div class=\"ibm-body\"><div class=\"ibm-main\"><div class=\"ibm-title\"><h2>图 10. CSR 看到订单锁错误<\/h2><\/div><div class=\"ibm-container ibm-alternate\"><div class=\"ibm-container-body\"><img alt=\"显示挂起订单屏幕截图，其中显示一个错误消息，指出订单不是被您锁定的，而是由 CSR 锁定的。\" src=\"/sunshine_new/images/负1771994218/figure10.jpg\" width=\"1500\" /><\/div><\/div><\/div><\/div><div class=\"ibm-footer\"><><\/div><\/div><\/li><li>为了获得在这个挂起订单上的锁，CSR 需要单击 <strong>Drop \n    Customer Session<\/strong> 并重新制定客户。<\/li><\/ol><h2 id=\"N10344\">安全性<\/h2><p>CSR 是特权用户，通常在内部网上执行业务操作；也就是说，在防火墙内，可通过访问开箱即用的业务用户工具来执行业务操作。本文中解释的特性授权 CSR 访问店面 URL，并在互联网上运行管理命令。虽然这种访问控制实践对于很多客户来说可能不是问题，但建议您在实现该特性之前先与您的安全团队对该特性进行评估和讨论。<\/p><h2 id=\"N1034C\">Aurora<\/h2><p>此特性也可能在 Aurora starter store 中推出。业务逻辑仍然相同。不过，在 JSP 中只需要执行极少量定制。<\/p><h2 id=\"N10354\">结束语<\/h2><p>本文解释了在 Madisons starter store 中的客户支持特性的开发。您还了解到如何在 CSR 和购物者试图同时编辑相同的订单时利用订单锁定特性。本文对于希望利用 WebSphere Commerce 店面 UI 来开展客户业务的企业很有用。<\/p><CMA ID: 970002><Site ID: 10><XSLT stylesheet used to transform this file: dw-document-html-7.0.xsl>\r\n<h2 id=\"download\">下载<\/h2><table class=\"ibm-data-table dw-download-table\" cellpadding=\"0\" cellspacing=\"0\" border=\"0\"><thead><tr><th scope=\"col\">描述<\/th><th scope=\"col\">名字<\/th><th scope=\"col\">大小<\/th><\/tr><\/thead><tbody><tr><th scope=\"row\" class=\"ibm-table-row\">客户制定的示例代码。<\/th><td nowrap=\"nowrap\"><a href=\"http://www.ibm.com/developerworks/apps/download/index.jsp?contentid=970002&amp;filename=CustEnactWC_samplecode.zip&amp;method=http&amp;locale=zh_CN\">CustEnactWC_samplecode.zip<\/a><\/td><td nowrap=\"nowrap\">47KB<\/td><\/tr><\/tbody><\/table>\r\n\r\n<\/div>\r\n<\/div>\r\n","createTime":"2014-04-29 00:00:00","deployTime":"2014-04-29 00:00:00","id":0,"intro":"IBM WebSphere Commerce 提供了一些 API，这些 API 是的管理员能够在系统中执行客户制定（customer enactment）。了解如何利用这些 API 在一个 Madisons 商店中实现客户制定（几乎不需要定制）。本文还介绍了订单锁定的概念，以及它在客户制定流程中的行为。","keyword":"","recommend":false,"source":"http://www.ibm.com/developerworks/cn/commerce/library/co-enact-apis-wcs/index.html","title":"通过 API 在 WebSphere Commerce 中执行客户制定","typeId":0,"updateTime":"2014-04-29 00:00:00"}
{"author":"","clickNumber":0,"content":"\r\n<div class=\"ibm-columns\">\r\n<div class=\"ibm-col-1-1\">\r\n\r\n<h2 id=\"1.简介 |outline\">简介<\/h2><p>\t随着互联网浪潮的逐渐兴起，各种基于互联网的云战略也不断涌现，各个公司对云平台的理解和实现不尽相同，而云+端的模式越来越多受到关注。其中的端可以理解为终端用户手中的各种终端，包括 PC、手机、平板等不一而足。\t而越来越多的用户愿意在自己的设备上使用轻量级的基于浏览器的应用。这类应用的安装部署可以是通过插件的方式安装，也有可能是直接以网页的形式访问而无需安装，相对于富客户端的下载安装，对用户来说更加简单方便，用户体验也更好。<\/p><p>\t这类应用对开发人员来说，需要一些互联网相关的技术，其中必不可少 HTML CSS 和 JavaScript 技术。而 JavaScript 作为一种客户端脚本语言，和传统编程语言 Cpp、Java 等相比，没有诸如 Eclipse、Visual Studio 等集成开发调试环境，其调试和测试是对开发人员都是一项挑战。<\/p><p>\t目前 JS 单元测试框架有丰富的选择，比如 Buster.js、TestSwarm、JsTestDriver 等。而 Jasmine 作为流行的 JavaScript 测试工具，很轻巧只有 20K 左右，而功能丰富，让我们可以容易的写出清晰简洁的针对项目的测试用例。对基于 JavaScript 开发的项目来说，是一款不错的测试框架选择。<\/p><h2 id=\"2.搭建环境 |outline\">搭建环境<\/h2><h3 id=\"N10066\">获取安装包<\/h3><p>\t可以在开源社区网站下载最新的 Jasmine 安装包, 目前的 Standalone 的最新版本是 1.3.0. 下载地址：\thttps://github.com/pivotal/jasmine/downloads<\/p><h3 id=\"N1006D\">配置安装<\/h3><p>下载后的.zip 文件包解压缩，如下的目录结构：<\/p><h5 id=\"N10075\">图 0.目录结构<\/h5><img alt=\"目录结构\" src=\"/sunshine_new/images/41840981/image003.jpg\" width=\"393\" /><p>其中 lib 文件夹中包含 Jasmine 的源代码。采用如下相对路径可以包含 Jasmine，进而开发基于 Jasmine 的测试用例。<\/p><div class=\"codesection\"><pre class=\"displaycode\">  &lt;link rel=\"shortcut icon\" type=\"image/png\" href=\"lib/jasmine-1.3.0/jasmine_favicon.png\"&gt;\n  &lt;link rel=\"stylesheet\" type=\"text/css\" href=\"lib/jasmine-1.3.0/jasmine.css\"&gt;\n  &lt;script type=\"text/javascript\" src=\"lib/jasmine-1.3.0/jasmine.js\"&gt;&lt;/script&gt;\n  &lt;script type=\"text/javascript\" src=\"lib/jasmine-1.3.0/jasmine-html.js\"&gt;&lt;/script&gt;<\/pre><\/div><p>\tspec 和 src 和 SpecRunner.html 是 Jasmine 的一个完整示例，用浏览器打开 SpecRunner.html，即可看到执行的结果。\t<\/p><h2 id=\"3.基本概念 |outline\">基本概念<\/h2><h3 id=\"N1008D\">describe<\/h3><p>\tdescribe 是 Jasmine 的全局函数，作为一个 Test Suite 的开始，它通常有 2 个参数：字符串和方法。字符串作为特定 Suite 的名字和标题。方法是包含实现 Suite 的代码。<\/p><h5 id=\"N10096\">清单 1.测试用例<\/h5><div class=\"codesection\"><pre class=\"displaycode\">describe(\"This is an exmaple suite\", function() {\n  it(\"contains spec with an expectation\", function() {\n    expect(true).toBe(true);\n    expect(false).toBe(false);\n    expect(false).not.toBe(true);\n  });\n});<\/pre><\/div><h3 id=\"N1009C\">Specs<\/h3><p>\tSpecs 通过调用 it 的全局函数来定义。和 describe 类似，it 也是有 2 个参数，字符串和方法。每个 Spec 包含一个或多个 expectations 来测试需要测试代码。<\/p><p>\tJasmine 中的每个 expectation 是一个断言，可以是 true 或者 false。当每个 Spec 中的所有 expectations 都是 true，则通过测试。有任何一个 expectation 是 false，则未通过测试。而方法的内容就是测试主体。<\/p><p>\tJavaScript 的作用域的规则适用，所以在 describe 定义的变量对 Suite 中的任何 it 代码块都是可见的。<\/p><h5 id=\"N100A9\">清单 2.测试用例<\/h5><div class=\"codesection\"><pre class=\"displaycode\">describe(\"Test suite is a function.\", function() {\n  var gVar;\n\n  it(\"Spec is a function.\", function() {\n    gVar = true;\n    expect(gVar).toBe(true);\n  });\n\n  it(\"Another spec is a function.\", function() {\n    gVar = false;\n    expect(gVar).toBe(false);\n  });\n\n});<\/pre><\/div><h3 id=\"N100AF\">Expectations<\/h3><p>\tExpectations 是由方法 expect 来定义，一个值代表实际值。另外的匹配的方法，代表期望值。<\/p><h5 id=\"N100B8\">清单 3.测试用例<\/h5><div class=\"codesection\"><pre class=\"displaycode\">describe(\"This is an exmaple suite\", function() {\n  it(\"contains spec with an expectation\", function() {\n    var num = 10;\n    expect(num).toEqual(10);\n  });\n});<\/pre><\/div><p>以上代码可以在附件中的 List.html 运行，结果见下图：<\/p><h5 id=\"N100C1\">图 1.测试用例结果<\/h5><img alt=\"测试用例结果\" src=\"/sunshine_new/images/41840981/image005.jpg\" width=\"331\" /><h3 id=\"N100CC\">总结<\/h3><p>\tdescribe 方法用来组织相关的 Spec 集合。string 参数作为 Spec 集合的名字，会和其中的 Spec 连接组成 Spec 的完整名字。这样在一个大的 suite 中可以更容易找到某个 Spec。如果给它们命名适当，Specs 读起来是一个典型的 BDD 样式的句子。<\/p><p>\tSpec 是作为测试主体，Suite 是一个或多个 Spec 的集合。<\/p><p>\tdescribe 和 it 代码块中都是方法，可以包含任何可执行的代码来实现测试。而方法的内容就是 Suites。<\/p><h2 id=\"4.常见用法 |outline\">常见用法<\/h2><h3 id=\"N100DC\">Matchers<\/h3><p>\t每个 Matchers 实现一个布尔值，在实际值和期望值之间比较。它负责通知 Jasmine，此 expectation 是真或者假。然后 Jasmine 会认为相应的 spec 是通过还是失败。<\/p><p>\t任何 Matcher 可以在调用此 Matcher 之前用 not 的 expect 调用，计算负值的判断。<\/p><h5 id=\"N100E7\">清单 4.测试用例<\/h5><div class=\"codesection\"><pre class=\"displaycode\">describe(\"The 'toBe' matcher compares with ===\", function() {\n  it(\"and has a positive case \", function() {\n    expect(true).toBe(true);\n  });\n  it(\"and can have a negative case\", function() {\n    expect(false).not.toBe(true);\n  });\n});<\/pre><\/div><h3 id=\"N100ED\">Included Matchers<\/h3><p>\tJasmine 有很多的 Matchers 集合。下面的例子中举例说明一些常用的 Matchers。另外当项目需要特定的判断，而没有包含在 Jasmine 的 Matchers 时，也可以通过写定制的 Matchers 来实现.<\/p><h5 id=\"N100F6\">清单 5.测试用例<\/h5><div class=\"codesection\"><pre class=\"displaycode\">describe(\"Included matchers:\", function() {\n\n  it(\"The 'toBe' Matcher\", function() {\n    var a = 3.6;\n    var b = a;\n\n    expect(a).toBe(b);\n    expect(a).not.toBe(null);\n  });\n\n  describe(\"The 'toEqual' matcher\", function() {\n\n    it(\"works for simple literals and variables\", function() {\n      var a = \"varA\";\n      expect(a).toEqual(\"varA\");\n    });\n\n    it(\"Work for objects\", function() {\n      var obj = {\n        a: 1,\n        b: 4\n      };\n      var obj2 = {\n        a: 1,\n        b: 4\n      };\n      expect(obj).toEqual(obj2);\n    });\n  });\n\n  it(\"The 'toBeDefined' matcher \", function() {\n    var obj = {\n      defined: 'defined'\n    };\n\n    expect(obj.defined).toBeDefined();\n    expect(obj.undefined).not.toBeDefined();\n  });\n\n});<\/pre><\/div><p>其他的 Matchers 还有：<\/p><div class=\"codesection\"><pre class=\"displaycode\">toBe()\ntoNotBe()\ntoBeDefined()\ntoBeUndefined()\ntoBeNull()\ntoBeTruthy()\ntoBeFalsy()\ntoBeLessThan()\ntoBeGreaterThan()\ntoEqual()\ntoNotEqual()\ntoContain()\ntoBeCloseTo()\ntoHaveBeenCalled()\ntoHaveBeenCalledWith()\ntoMatch()\ntoNotMatch()\ntoThrow()<\/pre><\/div><h3 id=\"N10102\">Setup and Teardown<\/h3><p>\t为了使某个测试用例干净的重复 setup 和 teardown 代码， Jasmine 提供了全局的 beforeEach 和 afterEach 方法。正像其名字一样，beforeEach 方法在 describe 中的<\/p><p>每个 Spec 执行之前运行，afterEach 在每个 Spec 调用后运行。<\/p><p>\t这里的在同一 Spec 集合中的例子有些不同。测试中的变量被定义为全局的 describe 代码块中，用来初始化的代码被挪到 beforeEach 方法中。afterEach 方法在继续前重置这些变量。<\/p><h5 id=\"N1010F\">清单 6.测试用例<\/h5><div class=\"codesection\"><pre class=\"displaycode\">describe(\"An example of setup and teardown)\", function() {\n  var gVar;\n\n  beforeEach(function() {\n    gVar = 3.6;\n    gVar += 1;\n  });\n\n  afterEach(function() {\n    gVar = 0;\n  });\n\n  it(\"after setup, gVar has new value.\", function() {\n    expect(gVar).toEqual(4.6);\n  });\n\n  it(\"A spec contains 2 expectations.\", function() {\n    gVar = 0;\n    expect(gVar).toEqual(0);\n    expect(true).toEqual(true);\n  });\n});<\/pre><\/div><h3 id=\"N10115\">嵌套代码块<\/h3><p>\tdescribe 可以嵌套， Specs 可以定义在任何一层。这样就可以让一个 suite 由一组树状的方法组成。在每个 spec 执行前，Jasmine 遍历树结构，按顺序执行每个 beforeEach 方法。Spec 执行后，Jasmine 同样执行相应的 afterEach。<\/p><h5 id=\"N1011E\">清单 7.测试用例<\/h5><div class=\"codesection\"><pre class=\"displaycode\">describe(\"A spec\", function() {\n  var gVar;\n\n  beforeEach(function() {\n    gVar = 3.6;\n    gVar += 1;\n  });\n\n  afterEach(function() {\n    gVar = 0;\n  });\n\n  it(\"after setup, gVar has new value.\", function() {\n    expect(gVar).toEqual(4.6);\n  });\n\n  it(\"A spec contains 2 expectations.\", function() {\n    gVar = 0;\n    expect(gVar).toEqual(0);\n    expect(true).toEqual(true);\n  });\n\n  describe(\"nested describe\", function() {\n    var tempVar;\n\n    beforeEach(function() {\n      tempVar = 4.6;\n    });\n\n    it(\"gVar is global scope, tempVar is this describe scope.\", function() {\n      expect(gVar).toEqual(tempVar);\n    });\n  });\n});<\/pre><\/div><h3 id=\"N10124\">跳过测试代码块<\/h3><p>      Suites 和 Specs 分别可以用 xdescribe 和 xit 方法来禁用。运行时，这些 Suites 和 Specs 会被跳过，也不会在结果中出现。这可以方便的在项目中可以根据需要来禁用隐藏某些测试用例。<\/p><h5 id=\"N1012D\">清单 8.测试用例<\/h5><div class=\"codesection\"><pre class=\"displaycode\">xdescribe(\"An example of xdescribe.\", function() {\n  var gVar;\n\n  beforeEach(function() {\n\tgVar = 3.6;\n\tgVar += 1;\n  });\n\n  xit(\" and xit\", function() {\n\texpect(gVar).toEqual(4.6);\n  });\n});<\/pre><\/div><p>\t以上代码可以在附件中的 List.html 运行，结果见下图：<\/p><h5 id=\"N10136\">图 2.测试用例结果<\/h5><img alt=\"测试用例结果\" src=\"/sunshine_new/images/41840981/image007.jpg\" width=\"424\" /><h2 id=\"5.与其他工具的集成 |outline\">与其他工具的集成<\/h2><h3 id=\"N10146\">Karma<\/h3><p>\t在 Java 中，用 JUnit 做单元测试, 用 Maven 进行自动化单元测试；<\/p><p>同样相对应的 JS 中，则可以用 Jasmine 做单元测试，用 Karma 自动化完成单元测试。<\/p><p>\tKarma 作为 JavaScript 测试执行过程管理工具，可用于测试所有主流 Web 浏览器。下面简单介绍一下 Karma 与 Jasmine 的集成。<\/p><p>\t首先，下载安装 Karma。<\/p><p>\t初始化 karma 配置文件 karma.conf.js。<\/p><p>\t安装集成包 karma-jasmine。<\/p><p> \t修改 karma.conf.js 配置文件。<\/p><p>\t需要修改：files 和 exclude 变量。其中 autoWatch 设置为 true，这样如果修改测试文件并保存后，Karma 会检测到然后自动执行。<\/p><div class=\"codesection\"><pre class=\"displaycode\">module.exports = function (config) {\n    config.set({\n        basePath: '',\n        frameworks: ['jasmine'],\n        files: ['*.js'],\n        exclude: ['karma.conf.js'],\n        reporters: ['progress'],\n        port: 9876,\n        colors: true,\n        logLevel: config.LOG_INFO,\n        autoWatch: true,\n        browsers: ['Chrome'],\n        captureTimeout: 60000,\n        singleRun: false\n    });\n};<\/pre><\/div><p>启动 karma，自动执行单元测试。<\/p><div class=\"codesection\"><pre class=\"displaycode\">\tF:\\Projects\\karma&gt;karma start karma.conf.js<\/pre><\/div><p>\t另外，Jasmine 也可以与持续集成工具 Jenkins 进行集成。<\/p><h2 id=\"6.一个 Jasmine 的完整例子 |outline\">一个 Jasmine 的完整例子<\/h2><p>    Jasmine 在 JavaScript 中编译，必须被包含在一个 JS 环境中，比如一个 web 网页，来运行。JavaScript 被包含，通过一个&lt;script&gt;标签，然后所有以上的 specs 可以通过 Jasmine 计算和记录。这样 Jasmine 可以运行所有这些 specs。此页面被认为是一个\"runner\"运行者。<\/p><p>    下面通过一个具体的例子来介绍通过 runner 怎样执行 Jasmine 的 suite。<\/p><p>    首先，创建 HTMLReporter，Jasmine 调用它，来提供每个 Spec 和 Suite 的结果。<\/p><p>    报告负责展现结果给用户。<\/p><p>    代理为报告过滤 specs。允许点击某个结果中的 suites 或者 specs 来只运行 suite 的子集合。<\/p><p>当页面完成加载时运行所有的测试-然后确认运行任何之前的 onload 句柄。<\/p><p>\t见下面清单 9，完整代码示例见附件。<\/p><h5 id=\"N1017C\">清单 9 .代码示例<\/h5><div class=\"codesection\"><pre class=\"displaycode\">  &lt;script type=\"text/javascript\"&gt;\t\n\tvar jasmineEnv = jasmine.getEnv();\n    \tvar htmlReporter = new jasmine.HtmlReporter();\n\t\t\n    \tjasmineEnv.addReporter(htmlReporter);\n\t  \n\tjasmineEnv.specFilter = function(spec) {\n\t\treturn htmlReporter.specFilter(spec);\n    \t};\t  \n\t\n\twindow.onload = function() {\n\t\tjasmineEnv.execute();\n    \t};\n  &lt;/script&gt;<\/pre><\/div><p>\t完整例子可以在附件中的 Reporter.html 运行，结果见下图：<\/p><h5 id=\"N10185\">图 3.测试用例结果<\/h5><img alt=\"测试用例结果\" src=\"/sunshine_new/images/41840981/image009.jpg\" width=\"404\" /><h2 id=\"7.结语 |outline\">结语<\/h2><p>\t通过本文的介绍，我们可以了解 Jasmine 的一些基本概念和用法，为组织项目的测试打下基础，为项目代码的可靠性和稳定性提供保证，并介绍了 Jasmine 和其他框架的集成。Jasmine 的一些相对高级的用法和技巧，会在后续的文章中进行介绍。<\/p><CMA ID: 969813><Site ID: 10><XSLT stylesheet used to transform this file: dw-document-html-7.0.xsl>\r\n<h2 id=\"download\">下载<\/h2><table class=\"ibm-data-table dw-download-table\" cellpadding=\"0\" cellspacing=\"0\" border=\"0\"><thead><tr><th scope=\"col\">描述<\/th><th scope=\"col\">名字<\/th><th scope=\"col\">大小<\/th><\/tr><\/thead><tbody><tr><th scope=\"row\" class=\"ibm-table-row\">示例代码<\/th><td nowrap=\"nowrap\"><a href=\"http://www.ibm.com/developerworks/apps/download/index.jsp?contentid=969813&amp;filename=example.zip&amp;method=http&amp;locale=zh_CN\">example.zip<\/a><\/td><td nowrap=\"nowrap\">26KB<\/td><\/tr><\/tbody><\/table>\r\n\r\n<\/div>\r\n<\/div>\r\n","createTime":"2014-04-29 00:00:00","deployTime":"2014-04-29 00:00:00","id":0,"intro":"Jasmine 是一款 JavaScript 测试框架，它不依赖于其他任何 JavaScript 组件。它有干净清晰的语法，让您可以很简单的写出测试代码。对基于 JavaScript 的开发来说，它是一款不错的测试框架选择。本文介绍了 Jasmine 的一些基本概念和用法，并给出简单易懂的示例，希望对感兴趣的开发人员有所裨益。","keyword":"","recommend":false,"source":"http://www.ibm.com/developerworks/cn/web/1404_changwz_jasmine/index.html","title":"JavaScript 单元测试框架：Jasmine 初探","typeId":0,"updateTime":"2014-04-29 00:00:00"}
{"author":"","clickNumber":0,"content":"\r\n<div class=\"ibm-columns\">\r\n<div class=\"ibm-col-1-1\">\r\n\r\n<p>测试的目的是为了识别一个产品中的问题和缺陷。而许多测试以能通过/通不过（pass/fail）所必须的度量数据的重要分析，来了解系统在测试时的情况。敏捷软件开发允许通过不断变更和动态的特性集合来完成特性的快速验证。当前的数据分析方法主要依赖于采用编译型或解析型编程语言（Perl、Python 等等）编写的静态脚本。虽然由于动态语言自身的快速开发周期，使用它们可以极大地促进分析过程，但与测试密切相关的个体人员在工作时往往无法得到进行必要修改所需的分析软件源代码或技能集合。<\/p><h2 id=\"staticanalysisinanagileworld\">敏捷世界中的静态分析<\/h2><p>测试团队通过对开发过程中的软件运行测试来识别问题。在传统瀑布式过程中，功能性需求会事先被知道，并按计划进行技术实现。敏捷开发则允许一个应用程序的功能可以随时变更来满足客户不断变更的需求。为了满足这些新的动态测试需求，新的测试方法学如雨后春笋般地涌现出来。测试及行为驱动开发方法学（Test and behavior-driven development methodologies）被发展出来支持这些短小的开发周期，并且使用新的动态和声明式环境配置工具，例如 Puppet 及 Chef 被用于快速部署和配置部署环境。<\/p><p>但关于非功能性需求的调查研究又怎样呢？功能性测试的天性就是“通过/失败”：特定的功能被正确实现了，或者没有被正确实现。<\/p><p>许多需求与生俱来就是非功能性的，成功或失败并不是简单地看是否能通得过一个功能性需求来判定的。加载和压力测试、性能测试及承载力判定是部分测试类型的示例，这些测试并不完全是二元性的，而是需要积极的调研和分析来确定一个应用程序是否满足非功能性需求。<\/p><p>当前的数据分析方法主要依赖于采用编译型或解析型编程语言编写的静态脚本（如 Perl、Python、Ruby，等等）。对于需要在大型静态系统或缓慢变化的代码基（codebase）上多次运行的分析来说，在开发分析工具和软件方面的投资是合理的，例如，因为这些工具会在很长一段时间里很有用，并可以帮助识别性能或稳定性问题的根本原因。然而对于一个快速的变更可能会同时发生在内容和容量上的代码基来说，花费在开发定制化分析工具上的时间通常会白白被浪费掉，因为测试团队在不断地追赶一个变动的目标。<\/p><p>虽然由于动态语言的快速开发周期，使得使用动态语言可以极大地促进分析过程，但当应用程序发生变更时，与测试密切相关的个体人员在工作时往往无法得到分析软件的源代码或所必需的技能集合。<\/p><p>在本文中，我描述了<em>敏捷数据分析（agile data analysis）<\/em>技术及工具，可以助力测试员及其他度量数据消费者采用适应性更强的方式解析结果。这些工具和技术使得数据分析更加具有交互性，并能最小化对持续脚本重写的需要。<\/p><h2 id=\"whyagiledataanalysis\">为什么需要敏捷数据分析？<\/h2><p>非功能性测试（Non-functional test）需要对被度量的系统有一个深入的理解，因为成功或失败这两种测试结果必须满足由系统操作特性所定义的条件才可以得到。缓慢的响应时间，服务器集群非线性的规模变动，过度的内存消耗（垃圾收集）或过度的网络通信量，等等例子都是在一个运行系统中可能被发现的不受欢迎的系统行为。要查找这些指示信号产生的最初始原因，需要对系统如何运作有一个更深入的理解。<\/p><p>我们执行数据分析来从运行系统中所获得的多个数据源头抽取信息，以便使这些不受欢迎的行为初始的触发原因得以被发现。对于已经建立，拥有固定需求集的产品，分析工具可以被编写为对多重数据来源进行关联，以使系统的健康状况得以被监控。但在敏捷开发中，由于代码基（codebase）要不断响应来自功能性需求或用户接口的变更，所以正在被开发的程序或系统在一次又一次的构建过程里也可能会发生动态的变更。这些用于解析所有数据来源的工具集同样需要变得敏捷。<\/p><div class=\"dw-sidebar ibm-inset\"><p>引用维基百科（wikipedia）条目<br />一个高度组合的系统，提供了可以被选择的可重组组件，并以多种组合方式进行组装，以便满足特定用户的需求。（\"A highly composable system provides recombinant components that can be selected and assembled in various combinations to satisfy specific user requirements.\"）<\/p><\/div><p>但这对于需要敏捷化的工具集来说，其含义是什么？敏捷工具集的经典例子是 UNIX/Linux 自带的工具及设施。每一个工具可以执行一个狭窄定义的任务，而且这些任务可以串联在一起运用，使得无论是通过命令行或是 shell 脚本都可以用来执行无限可能甚至无法复制的任务，即便每一个任务都要求一个专门的应用程序。只需要了解如何组合它们的功能来解决特定的问题即可。因此，对于敏捷数据分析来说，首要的需求就是<em>可组合能力（composability）<\/em>。<\/p><h2 id=\"agiledataformats\">敏捷数据格式<\/h2><p>可组合能力的例子包括 UNIX 自带工具，可以在这些不同的工具之间传递文本文件。Microsoft 的 PowerShell 工具也同样是可组合的，但它传递的是操作系统能识别的 PowerShell 对象实例。那么在敏捷数据分析系统不同的组件之间应当传递什么类型的数据格式呢？<\/p><p>从运行系统中获得的数据可能源自多个不同的出处，具有多种不同的格式。一些例子包括：<\/p><ul class=\"ibm-bullet-list\"><li>非结构化日志文件（Unstructured log files）<\/li><li>结构化日志文件（Structured log files）<\/li><li>系统环境数据（System environment data）<ul class=\"ibm-bullet-list\"><li>CPU 占用百分比（Percentage of CPU that is busy）<\/li><li>内存使用情况（ Memory consumed）<\/li><li>磁盘 I/O（Disk I/O）<\/li><\/ul><\/li><li>度量数据（Measured data）<ul class=\"ibm-bullet-list\"><li>数据表（Spreadsheets）<\/li><li>基于 HTML 的报告（HTML-based reports）<\/li><\/ul><\/li><\/ul><p>这些就是为了进行任意种类的数据分析，需要对数据来源进行语法分析和解析的例子。挑战是精简所有这些具有不同数据格式的数据，使之成为一个能在多种不同类型数据之间进行比较的形式。<\/p><p>举一个例子，假设一个加载测试（load test）要在一个服务器产品上进行，使用一个工具用于模拟多种不同浏览器用户。有多个开源和商业工具可以执行类似的加载度量。该工具为您提供每一个服务器访问申请的响应时间，而您想要了解何时服务器响应时间会超过一个特定的限定值。响应时间可以由于多种原因导致增加：并发用户的数量、过量内存消耗会导致的垃圾收集延迟、网络饱和，等等。<\/p><p>为了确定相应时间延迟的原因，检验以前面所提到的多种格式呈现的数据：来自操作系统、来自被测试的服务器，以及来自加载测试工具的数据。<\/p><p>可以尝试将数据格式进行标准化，例如采用 XML 或 JSON（通常用于产生自浏览器的数据）。XML 格式，由于高度格式化所以相对比较容易进行分析，但仍然需要明显的工作量来将文件中的数据都转化成为一个可以被其他工具进行解析的形式，或与其他非 XML 内容进行比较。可以被广泛支持的最简单的数据格式是矩阵表格；表格的每一行包含了一组关联唯一数据实例的属性。例如，对于加载度量，表格中每一行可以展现在测试过程中某一个特定时间点的相关数据。表格数据以例如逗号分隔值（comma separated value，CSV）磁盘格式直接输出到数据表和数据库。<\/p><h2 id=\"analystsorprogrammers\">分析师或程序员？<\/h2><p>当软件应用程序变得更大更复杂时，自动化测试也就成为必需的了。甚至对于那些精于构建目的用于确定特定软件系统质量和健壮性的自动化复杂场景的专家来说，他们对于被测试软件的内部其实很可能是毫无了解的。这种黑盒测试（black box testing）并不需要编程，但可能对测试场景进行定义是个例外。<\/p><p>非功能测试可以同时被某一自动化测试集（test suite）所驱动，但测试结果无法按黑盒测试的方式来处理。如果我们的数据分析需要变得敏捷，会很少需要解析自动化非功能性度量数据的结果，或者根本无需编程，而只需要一个工具来组合及关联多个数据来源。<\/p><p>与编程相比，数据分析是一个不同的技能集，需要对被测试程序的架构以及从程序的多个组件或部署环境获得的其他诊断信息有更深入的了解。取决于所获得的数据的多少以及其复杂性，数据挖掘和静态分析技术对于解析数据来判断非功能性缺陷的源头来说是必须的。<\/p><p>为了使毫无编程技能的测试员及分析师能对一个不断演进的软件应用程序所产生的自动化度量数据进行分析成为可能，我们的敏捷分析工具应当是需要越少的编程就越有用。<\/p><h2 id=\"summaryofrequirementsforagiledataanalysis\">对敏捷数据分析需求的小结<\/h2><p>总的来说，对于敏捷软件项目执行灵活的数据分析，工具应当满足以下三个主要条件：<\/p><ul class=\"ibm-bullet-list\"><li>功能应当可以使用已有的功能组件进行组合而成（Functionality must be composable using existing functional components）<\/li><li>在组件之间交换的数据应当以表格的形式展现给用户（Data exchange between components must appear to the user as a table）<\/li><li>组件的组合方式应当可以只需要尽可能少的编程便可以完成（Composition of components should be done with a minimum of programming required）<\/li><\/ul><p>已有的分析工具，例如数据挖掘和业务分析工具集，满足这些需求。这些工具集意味着可以对非程序员提供开箱即用的数据挖掘和分析能力。<\/p><div class=\"dw-sidebar ibm-inset\"><h2 id=\"N100BB\">了解 IBM SPSS Modeler<\/h2><p>IBM SPSS Modeler 是一个数据挖掘工作台（data mining workbench），可以帮助您快速直观地构建可预测模型，而且无须进行编程。使用它来深入您的数据，来获得洞察性、有益的答案。通过这些<a href=\"http://www.ibm.com/software/analytics/spss/products/modeler/downloads.html\">演示及视频<\/a>来进一步了解。<\/p><\/div><p>IBM SPSS Modeler 拥有非常理想的静态建模能力，可以用于分析大规模复杂数据集。在合适胜任执行软件应用程序数据分析的同时，它对于拥有复杂静态分析需求的大数据集来说也是有用的。<\/p><p>可用于更加适度分析任务的开源产品，可能更合适用于本文所描述的敏捷数据分析类型。一个更加流行的可获得的开源工具名叫 KNIME（查看参考资料中的链接）。<\/p><h3 id=\"0.1.KNIME(theKonstanzInformationMiner)|outline\">KNIME (the Konstanz Information Miner)<\/h3><div class=\"dw-sidebar ibm-inset\"><p>依据 KNIME 网站的描述，\n          <br />“KNIME，读作 [naim] 是一个适用于整个分析过程的用户友好的图形化工作台：包括了数据访问、数据转换、初始调查、强大的预测分析、可视化及报表等功能。这一开源集成平台提供了超过 1000 个模块（节点），包括那些来自 KNIME 社区和扩展合作伙伴网络的。\n          <br />（\"KNIME [naim] is a user-friendly graphical workbench\n          for the entire analysis process: data access, data transformation, initial investigation,\n          powerful predictive analytics, visualisation and reporting. The open integration platform\n          provides over 1000 modules (nodes), including those of the KNIME community and its\n          extensive partner network.\"<\/p><\/div><p>KNIME 是一个基于 Eclipse 框架，开发始于 2006 年，用于执行制药行业数据分析的工具。从那时起，它演进成为一个通用目的的数据分析、报表及集成平台。它是用于执行调查采用敏捷方法开发的软件非功能性能力最理想的基础数据分析平台。它满足前面所述的需求，通过使用图形化展示的工作流，使工作流的节点间以箭头彼此互相链接，来指示数据流向的方向。<\/p><p>通过连线这些节点在一起，您便可以实现数据分析任务，而只需要很少甚至完全不需要编程。所有分布在这些节点上的分析逻辑，可以用于消费来自外部的数据源（通过“reader”节点）；转换内在数据；或组合其他数据来源。在每一个节点上，所操控数据的当前状态可以以一个数据表样式的显示形式进行检视，因此您可以验证数据是否针对特定分析任务被正确转换了。<\/p><h5 id=\"fig1\">图1. KNIME 桌面版示例<\/h5><img alt=\"knime 桌面版显示的节点\" src=\"/sunshine_new/images/负1987748144/image001.jpg\" width=\"850\" /><h2 id=\"conclusion\">结论<\/h2><p>在本系列下一篇文章中，将会展示构建一个简单工作流所需的步骤，如何导入数据到工作流中，以及如何执行通常用于分析基于时间的数据所需的逻辑。<\/p><CMA ID: 969859><Site ID: 10><XSLT stylesheet used to transform this file: dw-document-html-7.0.xsl>\r\n\r\n\r\n<\/div>\r\n<\/div>\r\n","createTime":"2014-04-28 00:00:00","deployTime":"2014-04-28 00:00:00","id":0,"intro":"本文描述了用于助力测试员和其他度量数据消费者的工具和技术，采用适应性更强的方式解析结果，使得数据分析更加具有交互性。","keyword":"","recommend":false,"source":"http://www.ibm.com/developerworks/cn/rational/agile-data-analysis/index.html","title":"敏捷数据分析","typeId":0,"updateTime":"2014-04-28 00:00:00"}
{"author":"","clickNumber":0,"content":"\r\n<div class=\"ibm-columns\">\r\n<div class=\"ibm-col-1-1\">\r\n\r\n<h2 id=\"linux-ss-intro\">\n        Linux 系统启动过程概述\n      <\/h2><p>\n        您可以将 Linux 系统启动过程（从启动电源到让系统完全运行）看作两个概念性阶段：\n      <\/p><ol><li>\n          从设备引导，加载并初始化 Linux 内核\n        <\/li><li>\n          启动用户空间应用程序（包括服务器进程），挂载另外的文件系统，执行另外的内核配置与定制项，并提供对额外设备的访问权限\n        <\/li><\/ol><p>\n        第一阶段中的基本步骤已经在名为 “深入理解 Linux 的启动过程” 的 developerWorks 文章（参见<a href=\"#resources\">参考资料<\/a>）中讲述过了。这些步骤多年来变化不大，包括使用 GRand Unified Bootloader 2 (GRUB 2)，初始 RAM 磁盘的格式与使用方式的不同，以及对第一个启动的用户空间进程（通常是 <code>init<\/code> 进程）的改变。此阶段中的性能提升主要来自于硬件升级，比如速度更快的启动设备、更快的设备访问机制，以及速度更快的、更加强大的处理器。然而，第二阶段中的性能提升几乎完全是软件端的性能提升，可以继续使用大量不同的方法。\n      <\/p><p>\n        缩短阶段 2 系统启动时间有一种简便方法，即提高完成 Linux 启动过程第二阶段的机制性能。然而，改变启动次序本身就可以带来大幅性能提升。缩短阶段 2 系统启动时间的关键方面如下所示：\n\t  <\/p><ul class=\"ibm-bullet-list\"><li><strong>最小化<\/strong>：只启动最少的必要服务集合\n\t\t<\/li><li><strong>线性<\/strong>：找出一个服务需要的其他一个或多个服务（也称为<em>依赖性分析<\/em>），并将这些需要的服务纳入启动过程\n        <\/li><li><strong>平行<\/strong>：尽可能地同时启动独立服务（或相关服务链）\n        <\/li><\/ul><p>\n\t\t纵观其历史，Linux 曾使用过各种各样的启动和关闭机制，尽力平衡线性与平行的问题，同时不会完全向后兼容性。下一节讨论了最常用的一些机制，以及如何在系统上监控它们的行为与性能，从而找出可以优化的地方。\n\t  <\/p><h2 id=\"linux-sysvinit\">\n        了解和使用 SysVinit\n      <\/h2><p>\n\t\tLinux 系统上使用的传统系统启动与关闭机制叫作 SysVinit。顾名思义，SysVinit 机制的概念源自于 UNIX&#174; 的 Sys V 版本，它的更恰当的名称应该是 UNIX System V，版本 4 (SVR4)，发布于 1989 年。SysVinit init 程序将会读取 /etc/inittab 文件识别出系统到达默认状态（称为系统的默认<em>运行级别<\/em>）时可用的服务集合，以及为了到达该状态而应该执行的命令。使用 SysVinit 的系统通过 /etc/inittab 文件中的内容项定义这些信息，如 <a href=\"#list1\">清单 1<\/a> 中所示。\n      <\/p><h5 id=\"list1\">清单 1. \n          /etc/inittab 中传统的启动相关命令\n        <\/h5><div class=\"codesection\"><pre class=\"displaycode\">si::sysinit:/etc/init.d/rcS\nid:5:initdefault:\nl5:5:wait:/etc/init.d/rc 5<\/pre><\/div><p>\n        第一行确定初始化系统时系统应该执行的第一个脚本。第二行确定系统初始化后的默认运行级别。在这个例子中，默认的运行级别是 5，这通常意味着系统具有完整的网络与图形功能。第三行确定系统为了到达运行级别 5 而应该执行的命令。\n      <\/p><p>\n      \t在使用 SysVinit 时，/etc/init.d 目录包含用于启动和停止所有系统级进程的 shell 脚本。每种运行级别都有自己的目录，其中包含符号链接指向进入或离开相关运行级别时，应该启动或停止的、在 /etc/init.d 目录中选中的 shell 脚本。清单 1 中的第三行告诉 SysVinit 机制执行运行级别 5 相关目录中的脚本，根据您所运行的 Linux 版本，脚本通常为 /etc/rc5.d、/etc/init.d/rc5.d 或 /etc/rc.d/rc5.d。\n      <\/p><p>\n        运行级别目录中的符号链接以 <code>S<\/code> 或 <code>K<\/code> 字母开头，这表示它应该是在系统进入指定的运行级别时启动（<code>S<\/code>）相关系统进程，还是应该在系统离开该运行级别时终止（<code>K<\/code>）它。位于 <code>S<\/code> 或 <code>K<\/code> 之后的整数值定义了进入或离开运行级别时应该执行这些脚本的顺序。\n      <\/p><p>\n        在 /etc/init.d 目录中添加新脚本时，位于每个脚本开始部分的特定格式的注释会说明该脚本所依赖的其他所有脚本，同时说明与该脚本有关联的运行级别。这些脚本中应该出现的注释和其他信息被定义为 Linux Standard\n        Base (LSB) 规范的组成部分，该规范由多个 Linux 发行方共同开发，以确保 SysVinit 脚本在不同 Linux 版本上的兼容性。<a href=\"#list2\">清单 2<\/a> 摘自 init 脚本中注释的 LSB 讨论，它给出了一个这样的例子。\n      <\/p><h5 id=\"list2\">清单 2. \n          传统 SysVinit 脚本中的注释块\n        <\/h5><div class=\"codesection\"><pre class=\"displaycode\">### BEGIN INIT INFO\n# Provides: lsb-ourdb\n# Required-Start: $local_fs $network $remote_fs\n# Required-Stop: $local_fs $network $remote_fs\n# Default-Start:  2 3 4 5\n# Default-Stop: 0 1 6\n# Short-Description: start and stop OurDB\n# Description: OurDB is a very fast and reliable database\n# engine used for illustrating init scripts\n### END INIT INFO<\/pre><\/div><p><a href=\"#table1\">表 1<\/a> 对每一项的意义进行了说明。<\/p><h5 id=\"table1\">表 1. \n        SysVinit 脚本的 INIT INFO 区域中的注释\n      <\/h5><table border=\"0\" cellpadding=\"0\" cellspacing=\"0\" class=\"ibm-data-table\" summary=\"Table explaining comments in the INIT Info                       section of a  SysVinit script\"><thead xmlns:dw=\"http://www.ibm.com/developerWorks/\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"><tr><th scope=\"col\">关键字<\/th><th scope=\"col\">含义<\/th><\/tr><\/thead><tbody xmlns:dw=\"http://www.ibm.com/developerWorks/\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"><tr><td><code>Provides<\/code><\/td><td>\n            这个初始化脚本提供的服务的逻辑名称。\n          <\/td><\/tr><tr><td><code>Required-Start<\/code><\/td><td>\n            成功启动此初始化脚本中定义的服务而必须运行的任何其他服务的逻辑名称。\n          <\/td><\/tr><tr><td><code>Required-Stop<\/code><\/td><td>\n            成功停止此初始化脚本中定义的服务而必须运行的任何其他服务的逻辑名称。\n          <\/td><\/tr><tr><td><code>Default-Start<\/code><\/td><td>\n            为了启动此初始化脚本定义的服务，执行该初始化脚本所需的运行级别。\n          <\/td><\/tr><tr><td><code>Default-Stop<\/code><\/td><td>\n            为了停止此初始化脚本定义的服务，执行该初始化脚本所需的运行级别。\n          <\/td><\/tr><tr><td><code>Short-Description<\/code> 与 <code>Description<\/code><\/td><td>\n            为了给与初始化脚本中命令相关联的服务提供简要说明。很多查询和概括 SysVinit 初始化脚本的系统实用工具都使用了这些关键字。\n          <\/td><\/tr><\/tbody><\/table><p>\n        您可以使用 <code>/sbin/service<\/code> 命令来启动、停止与列出 SysVinit 脚本，也可以使用 <code>/sbin/chkconfig<\/code> 命令来列出或修改与脚本有关联的运行级别。\n      <\/p><p>\n        使用 shell 脚本启动系统可以很方便地给系统的启动过程增加新命令，或者修改启动或停止某项服务时发生的操作。也可以轻松在引导次序中的某个特定点增加新服务，只要创建到新服务的符号链接并在符号链接的名称中使用正确编号即可。\n      <\/p><p>\n        从性能的角度讲，SysVinit 按照指定的顺序执行多个 shell 脚本，从而到达指定的运行级别。执行 shell 脚本相对较慢，此外，因为无法利用可能的并行机制，这样的顺序启动机制原本需要的时间就很长。与目标运行级别相关联的每个 shell 脚本必须按顺序执行，而这种顺序是通过指向每个 shell 脚本的符号链接名称中的编号来指定的，其他服务只能等到当前服务完成后才能启动。因此，使用  SysVinit 的系统可以集成本文上一节（<a href=\"#linux-ss-monitor\">监控系统启动与脚本执行<\/a>）中讨论的启动监控与配置工具，从而确定每个启动脚本所花费的具体时长。\n\t  <\/p><p>\n        关于 SysVinit 机制更加详细的讨论，请参见 developerWorks 文章 “更快启动 Linux”（参见<a href=\"#resources\">参考资料<\/a>)。\n      <\/p><h2 id=\"linux-ed-intro\">\n        了解和使用事件驱动的启动机制\n      <\/h2><p>\n        尽管 SysVinit 易于使用和修改，因为它使用了 shell 脚本来启动与停止系统服务，但使用有序的 shell 脚本会让 SysVinit 变慢，并且不能并行启动不相关的服务。另一个问题是，启动与停止服务的脚本只在系统启动或关闭时才能执行，换句话说，系统运行级别的改变是它们惟一会响应的事件。很少有例外（比如由其他服务启动的服务），这意味着系统需要的所有服务必须一直运行，等待着可能永远不会来的请求。\n      <\/p><p>\n        无论从内存与处理器资源消耗方面，还是从首先启动它们所需的事件方面考虑，运行不使用的进程都是低效的。当今日益灵活的系统需要能够在各种环境中正确地、无缝地工作，比如网络连接从有线变为无线，从一个网络迁移到另一个网络，或者诸如增加和移除存储设备与其他外围设备这样的硬件变化。\n      <\/p><p>\n        事件驱动的机制正如其名所示，在系统发生特定事件时执行特定命令并启动相关服务。用于各种网络服务的 <code>inetd<\/code> 与 <code>xinetd<\/code> 守护进程对事件驱动的启动机制进行了很好地模拟，因为它们会等待某些事件发生（对它们所管理服务的网络连接请求），然后根据需要启动正确的服务。事件驱动的启动机制支持在响应事件时同时执行多个命令，并将同样的动态响应扩展到系统的运行时环境，从而最大程度地提高系统启动期间的并行化程度。事件实质上就是进程发送的字符串消息，用户可使用该消息作为对进程所监控状态出现变化的响应。一个进程发送一个事件消息。\n      <\/p><p>\n        最知名的事件驱动启动机制是 Upstart，它是很多 Linux 发行上使用的默认启动机制，包括 Ubuntu 9.10 及以上版本、RHEL6 及相关发行如 CentOS、Oracle Linux、Scientific Linux、Fedora 9-14 和其他众多 Linux 发行版本。Upstart 提供与 SysVinit 运行级别模型的向后兼容。\n      <\/p><p>\n        Upstart 使用任务配置（或 conf）文件来识别对事件的响应，比如启动、关闭、运行级别（运行级别变化）等。这些文件通常位于 /etc/init 目录中，但有些因为历史原因转移到了 /etc/event.d 目录中。您创建的任意新的系统级 conf 文件都应该位于 ./etc/init 目录中。Conf 文件的扩展名通常为 .conf。它们是文本文件，而且至少必须包含以下内容：\n      <\/p><ul class=\"ibm-bullet-list\"><li>\n          为了响应一个或多个事件，conf 文件应该执行某些操作。例如，<code>start on startup<\/code> 项说明在收到 <code>startup<\/code> 事件时应该执行一个任务文件，而 <code>stop on runlevel<\/code> 项说明在收到 <code>runlevel<\/code> 事件时应该停止一个任务文件，比如系统的运行级别改变时。\n        <\/li><li><p><code>task<\/code> 或 <code>respawn<\/code> 部分至少包含一个 <code>exec<\/code> 项，而 <code>script<\/code> 部分指定了响应触发此任务文件的事件时执行的命令。<code>exec<\/code> 项用于执行一个带有一组特定命令行参数的特定命令，通常为二进制命令。<code>script<\/code> 部分又叫作\n            <em>stanza<\/em>，它提供 shell 执行的命令，和其他 shell 脚本一样必须以 <code>end script<\/code> 语句结尾。Upstart\n            通过 <code>task<\/code> 和 <code>respawn<\/code> 关键字管理任务的两个概念性类：\n          <\/p><ul class=\"ibm-bullet-list\"><li>\n              任务必须完成，这意味着它们必须从停止状态转变为启动状态，然后在完成之后返回到停止状态。\n            <\/li><li>\n              服务必须始终运行，因此只要从停止状态转变为启动状态。<code>respawn<\/code> 部分说明了如何启动和重启一项服务。\n            <\/li><\/ul><\/li><\/ul><p>\n      \t您还可以在 Upstart conf 文件的 <code>task<\/code> 部分使用其他关键字来识别输出设备，在执行主要的 <code>exec<\/code> 或 <code>script<\/code> 部分之前运行脚本，在完成主要的 <code>exec<\/code> 或 <code>script<\/code> 部分之后运行脚本，诸如此类。<code>pre-start script<\/code> 部分提供了一些命令来初始化 <code>script<\/code> 或 <code>exec<\/code> 命令所需的环境，而 <code>post-stop script<\/code> 部分则提供了一些命令，在 <code>exec<\/code> 命令或 <code>script<\/code> stanza 完成后进行清理或执行后处理。任务文件中还有其他许多可用的 Upstart 命令（请参见<a href=\"#resources\">参考资料<\/a>）。\n      <\/p><p>\n      \t例如，<a href=\"#list3\">清单 3<\/a> 是一个 /etc/init/rcS.conf Upstart 任务文件，它模拟了 SysVinit 机制。它通过删除注释来提高代码可读性。\n      <\/p><h5 id=\"list3\">清单 3. \n          /etc/init/rcS.conf Upstart 任务文件\n        <\/h5><div class=\"codesection\"><pre class=\"displaycode\">start on runlevel [0123456]\n\nstop on runlevel [!$RUNLEVEL]\n\ntask\n\nexport RUNLEVEL\nconsole output\nexec /etc/rc.d/rc $RUNLEVEL<\/pre><\/div><p>\n        这个 conf 文件定义了一个任务，从与当前运行级别有关联的目录中运行所有现有的 SysVinit 脚本。\n      <\/p><p>\n        可以使用 <code>/sbin/initctl<\/code> 命令来启动、停止和列出 Upstart 任务。此命令可以显示当前正在运行的 Upstart 任务及其当前状态。在系统的初始化次序中添加一个新任务，只需要为该服务创建一个正确的 conf 文件，并在 /etc/init 目录中安装该文件。Upstart versions 1.3 及其更高版本甚至支持位于用户主目录的 .init 子目录中的用户特定的 conf 文件，但这个选项通常不受支持。\n      <\/p><h2 id=\"linux-sd-intro\">\n      \t了解和使用 <code>systemd<\/code><\/h2><p>\n\t\t当 Upstart 似乎注定要在 Linux 系统中全面替代 SysVinit 的时候，另一种前途更耀眼、更闪耀和更高效的启动机制出现了：<code>systemd<\/code> （系统守护进程），最初由 Leonard Poettering 编写。<code>systemd<\/code> 系统启动机制通过了解各种服务需要和使用的基本资源，大大提高了并行化系统启动的性能。<code>systemd<\/code> 还使用了自从 2.6 内核以后的版本中都支持的控制组 (cgroups) 机制，让跟踪和管理相关进程的资源变得更容易。\n\t  <\/p><p>\n\t\t大部分现代的 Linux 服务与相关客户端都使用了 UNIX 套接字来实现进程间通信，包括用于与一般硬件相关的、本地的应用间消息的 D-Bus 消息总线。当所需的套接字存在或 D-Bus 被激活时，就可以启动使用它们的任何服务，因此 <code>systemd<\/code> 首先创建与您想要在指定系统上启动的服务相关的所有套接字。使用这些资源的服务通常会受到阻塞，直到它们需要发送或接收消息为止，因此，要么并行地启动它们，要么根据传入的请求按需启动它们。\n      <\/p><p>\n        创建逻辑资源以启动可能并行使用这些资源的服务并不仅限于客户端与服务器。与随需文件系统访问机制（如 <code>autofs<\/code>）结合在一起之后，即使是系统启动过程中一般较慢的部分（比如文件系统一致性检查与挂载），也可以针对根文件系统（所有人都始终需要它）以外的文件系统使用这种模型。在结束文件系统挂载之后，就可以使用文件或文件系统更改事件来触发使用内核的 <code>fanotify<\/code> 与 <code>fsnotify<\/code> 机制的其他操作。\n\t  <\/p><p><code>systemd<\/code> 启动机制指的是作为<em>单元<\/em> 进行管理的所有内容。为了满足不同类型的初始化和启动需求，<code>systemd<\/code> 支持不同类型的单元，<a href=\"#table2\">表 2<\/a> 列出了其中最常用的一些单元。\n\t  <\/p><h5 id=\"table2\">表 2. <code>systemd<\/code> 的常用单元类型<\/h5><table border=\"0\" cellpadding=\"0\" cellspacing=\"0\" class=\"ibm-data-table\" summary=\"Common unit types for systemd\"><thead xmlns:dw=\"http://www.ibm.com/developerWorks/\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"><tr><th scope=\"col\">单元类型<\/th><th scope=\"col\">说明<\/th><\/tr><\/thead><tbody xmlns:dw=\"http://www.ibm.com/developerWorks/\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"><tr><td><code>automount<\/code><\/td><td>\n            确定随需文件系统访问机制（如 <code>autofs<\/code>）使用的文件系统挂载点。每个 <code>automount<\/code> 单元都有一个相匹配的 <code>mount<\/code> 单元。\n          <\/td><\/tr><tr><td><code>device<\/code><\/td><td>\n          \t代表 <code>udev<\/code> 规则针对的物理设备。\n          <\/td><\/tr><tr><td><code>mount<\/code><\/td><td>\n            确定一个标准的文件系统挂载点。\n          <\/td><\/tr><tr><td><code>service<\/code><\/td><td>\n            定义一个可被启动、停止、重新启动、重新加载等的守护进程。因为这些是由 SysVinit 启动机制完成的传统类型的工作，<code>systemd<\/code> 可以自动解析 SysVinit 启动脚本中的 LSB 注释（在 <a href=\"#linux-sysvinit\">了解和使用\n            SysVinit<\/a> 一节中讨论过这一点），并正确使用这些信息。\n          <\/td><\/tr><tr><td><code>socket<\/code><\/td><td>\n            代表一个标准类型的文件系统或网络套接字，比如 <code>AF_INET<\/code> 或 <code>AF_UNIX<\/code>，这样通向这些套接字的传入连接就可以触发启动相关服务\n          <\/td><\/tr><tr><td><code>target<\/code><\/td><td>\n            定义一个用于对概念相关的其他单元进行分组的逻辑单元。例如，<code>systemd<\/code> 使用 <code>graphical.target<\/code> 单元来收集在图形设备变为可用时，应该在带有图形化控制台的系统上启动的所有应用程序。\n          <\/td><\/tr><\/tbody><\/table><p>\n\t\t与 <code>systemd<\/code> 支持的单元类型有关联的服务配置文件通常位于 /etc/systemd 的子目录中。<a href=\"#list4\">清单 4<\/a> 就是 <code>systemd<\/code> 服务配置文件的一个例子。\n\t  <\/p><h5 id=\"list4\">清单 4. 一个样例 <code>systemd<\/code> 服务配置文件<\/h5><div class=\"codesection\"><pre class=\"displaycode\">[Unit]\nDescription=System Logging Service\n\n[Service]\nEnvironmentFile=-/etc/sysconfig/rsyslog\nExecStart=/sbin/rsyslogd -n $SYSLOGD_OPTIONS\nSockets=syslog.socket\nStandardOutput=null\n\n[Install]\nWantedBy=multi-user.target\nAlias=syslog.service<\/pre><\/div><p>\n        这个文件是 Fedora 17 <code>rsyslog.service<\/code> 系统中系统日志的单元定义，位于 /etc/systemd/system/multi-user.target.wants 目录中。可以看出，这个文件的多处均描述了与它相关联的单元，说明如何启动服务以及它使用哪些资源，并说明在何种情况下调用单元&#8212;在这个例子中，是当系统的启动目标为 <code>multi-user.target<\/code> 时。\n      <\/p><p><code>systemd<\/code> 启动机制使用 <code>systemctl<\/code> 命令，在命令行中启动、停止与检查各类单元的状态。<code>systemadm<\/code> 命令功能相同，但具有图形化的界面，默认不安装。要添加此命令，必须安装 <code>systemd-gtk<\/code> 包。\n      <\/p><p><code>systemd<\/code> 启动机制可以带来实质性的性能提升，但如果需要在启动次序中的一个具体的确定点上添加命令，则需要更高的技巧。尽管 <code>systemd<\/code> 很值得一试，看它在特定系统上是否能提高启动性能，但并非所有人都喜欢它，因为 <code>systemd<\/code> 与以前的 Linux 启动机制有很大的不同。请参见 <a href=\"#resources\">参考资料<\/a> 中关于 <code>systemd<\/code> 的反面观点的链接。新方法固然有趣，但可能很快就变得很平常。\n      <\/p><h2 id=\"linux-ss-monitor\">\n        监控系统启动和脚本执行\n      <\/h2><p>\n       如果要将系统变为可用的时间缩至最短，那么只是测量在按下电源后系统变为可用所花费的时间长短并不能提供很多有用的信息。您真正感兴趣的真实数据应该如下所示：\n      <\/p><ul class=\"ibm-bullet-list\"><li>\n\t\t  系统启动期间执行了哪些初始化命令或脚本？\n\t\t<\/li><li>\n\t\t  这些命令或脚本按照什么顺序执行？\n\t\t<\/li><li>\n\t\t  每个命令后脚本花费了多长时间？\n\t\t<\/li><\/ul><p>\n\t\t如果要在系统的启动过程中添加一个脚本，您应该一开始就关注它是否确实得到了执行，以及它在什么点上被执行。确定这些信息的一种简便途径是在脚本中调用 <code>/usr/bin/logger<\/code> 命令。<code>logger<\/code>\n\t\t命令使用指定的优先级将消息写入系统日志。例如，下面的命令使用与 <code>alert<\/code>  对应的数字优先级写入消息 <code>New script executed<\/code>，这种优先级的消息应该始终得到记录：\n\t  <\/p><div class=\"codesection\"><pre class=\"displaycode\">/usr/bin/logger -p 1 \"New script executed\"<\/pre><\/div><p>\n\t\t验证新命令的执行是一个好习惯，但与分析所有启动脚本的相对性能和每个脚本执行时间的长短等相比，用处没那么大。作为一种极其方便的实用工具，Bootchart 以图形化的格式提供这类信息。\n\t  <\/p><p>\n \t\tBootchart 原本是一个 shell 脚本，但最新版本 Bootchart 2 使用 C 编程语言重新编写了它，所以它可以提供更高性能，并减少应用程序本身对其所收集的数据的影响。使用 Bootchart 2 最新版本的方法是，获取当前版本的源代码，编译并安装应用程序，然后将它集成到用于引导系统的引导装载程序命令中。要编译和安装 Bootchart 2，必须在系统上安装以下内容：<code>git<\/code> 源代码控制系统、<code>make<\/code> 应用程序编译工具和 <code>gcc<\/code> C 编译器。然后可以完成以下步骤：\n\t  <\/p><ol><li><p>\n\t\t\t使用 <code>git<\/code> 命令克隆 Bootchart 2 的源代码库：\n\t\t  <\/p><div class=\"codesection\"><pre class=\"displaycode\">git clone https://github.com/mmeeks/bootchart<\/pre><\/div><\/li><li>\n\t\t  将目录更改为在前一步骤中创建的 bootchart 目录，并执行 <code>make<\/code> 命令编译 Bootchart 2 的各个部分。\n\t\t<\/li><li>\n\t\t  以 root 用户身份或通过 <code>sudo<\/code> 命令执行 <code>make install<\/code>\n\t\t  命令，在默认位置安装不同的 Bootchart 2 应用程序及其文档。\n        <\/li><li><p>\n\t\t\t在目前正在使用的 bootloader 配置文件中 kernel 项的末尾处添加如下片段：\n\t\t  <\/p><div class=\"codesection\"><pre class=\"displaycode\">initcall_debug printk.time=y quiet init=/sbin/bootchartd<\/pre><\/div><p>\n\t\t\t如果使用的是 GRUB bootloader，那么您很可能要在 /boot/grub/menu.lst 文件的 boot stanza 中添加前面的文本片段。如果使用的是 GRUB2 bootloader，那么您很可能要在 /boot/grub/grub.conf 文件的 boot stanza  中添加前面的文本片段。系统上的 GRUB 配置文件是使用命令自动生成的，比如 <code>grub-mkconfig<\/code> 或 <code>grub2-mkconfig<\/code>，您应该将前面的文本片段添加到 /etc/default/grub 文件中指定的默认内核引导选项，然后重新生成真正的 bootloader 配置文件。\n\t\t  <\/p><\/li><\/ol><p>\n\t\t下次重启系统时，Bootchart 2 会收集启动过程中每个阶段的相关数据，并采用 Portable Network Graphics\n\t\t(PNG) 格式，以图形化的方式对这些数据进行汇总。汇总数据保存在 /var/log/bootchart.tgz 文件中。这些数据的相关图形化表示保存在 /var/log/bootchart.png 文件中。<a href=\"#fig1\">图 1<\/a> 是对启动过程的图形化表示的摘要。\n\t  <\/p><h5 id=\"fig1\">图 1. \n          Bootchart 的图形化启动表示摘要\n        <\/h5><img alt=\"图形化启动表示\" src=\"/sunshine_new/images/32381988/linux-ss-bc-1.jpg\" width=\"530\" /><p>\n        在 Bootchart 2 的启动过程图形化视图上，顶部汇总了在系统上收集到的启动信息，包括启动过程所花费的总体时长。中部以图形化的方式展示所有启动进程（这里的 图 1 是一段摘要）。底部两个区域分别显示了进程的累计处理器使用情况和累计 I/O 使用情况。\n      <\/p><p>\n\t\t 每次重启系统时，所有以前叫这些名称的文件都将被覆盖。如果试验性地修改系统在启动期间执行各个脚本的顺序，或者尝试优化它们的内容，或者同时执行这两个操作，那么您很可能希望保留来自多次系统启动的摘要 Bootchart 2 数据。<\/p><p>Bootchart 2 在其配置文件（/etc/bootchartd.conf）中提供了 <code>CUSTOM_POST_CMD<\/code> 变量。这个变量的作用是在 Bootchart 2 创建了它的数据和相关图形文件后，指定到要执行的脚本或其他应用程序的完整路径。<a href=\"#list5\">清单 5<\/a> 是一个示例脚本，通过使用该脚本，可使用 YYYY-MM-DD-HH-MM-HOSTNAME 格式的名称重新命名输出文件，并将它们保存在 /var/log/bootchart 目录中。\n      <\/p><h5 id=\"list5\">清单 5. \n          对 Bootchart 输出文件进行惟一重命名的示例脚本\n        <\/h5><div class=\"codesection\"><pre class=\"displaycode\">#!/bin/bash\n\nsource /etc/bootchartd.conf\n\nHOST=$(hostname -s)\n\nif [ ! -d $(dirname $BOOTLOG_DEST)\"/bootchart\" ] ; then\n    mkdir $(dirname $BOOTLOG_DEST)\"/bootchart\"\nfi\n\nDATE=$(date +%Y-%m-%d-%H-%M)\n\nfilebase=\"$DATE-$HOST\"\n\nmv $BOOTLOG_DEST $(dirname $BOOTLOG_DEST)\"/bootchart/\"${filebase}\".tgz\"\n\nif [ \"x$AUTO_RENDER\" = \"xyes\" ] ; then\n    mv ${AUTO_RENDER_DIR}/bootchart.${AUTO_RENDER_FORMAT} \\\n       $(dirname $BOOTLOG_DEST)\"/bootchart/\"${filebase}\".\"${AUTO_RENDER_FORMAT}\nfi<\/pre><\/div><p>\n        Bootchart 2 适用于本文中提到的所有 Linux 系统启动机制，而且它可以非常直观地展示系统启动过程中每个步骤所花费的时间、处理器和 I/O。这有助于找出启动过程中能够进行优化的地方，从而最大程度地缩短系统启动时间。\n      <\/p><h2 id=\"linux-ss-summary\">\n        总结\n      <\/h2><p>\n        Linux 提供多种启动机制，其中一些很容易修改，而其他一些是可扩展的，但主要是针对速度而设计的。本文总结了三种最流行的 Linux\n        启动机制，重点讲述了它们在目标与实现方面的差异。不同的 Linux 发行版本可开箱即用地使用不同的启动机制，安装它们并进行试验并不难，您最终可以找到在性能、灵活性和可用性最能满足自己要求的启动机制。\n\t  <\/p><CMA ID: 969823><Site ID: 10><XSLT stylesheet used to transform this file: dw-document-html-7.0.xsl>\r\n\r\n\r\n<\/div>\r\n<\/div>\r\n","createTime":"2014-04-28 00:00:00","deployTime":"2014-04-28 00:00:00","id":0,"intro":"无论是打开您的家用电脑，还是重启给数以千计用户提供服务的服务器，将启动计算机系统所需的时间缩至最短都非常重要。本文讨论了不同 Linux 版本上使用的各种系统启动与关闭机制。本文说明了如何集成新服务，定制现有的启动配置，以及如何检查系统启动配置的行为与性能。","keyword":"","recommend":false,"source":"http://www.ibm.com/developerworks/cn/linux/l-customize-monitor-linux/index.html","title":"定制和监视 Linux 系统启动","typeId":0,"updateTime":"2014-04-28 00:00:00"}
{"author":"","clickNumber":0,"content":"\r\n<div class=\"ibm-columns\">\r\n<div class=\"ibm-col-1-1\">\r\n\r\n<p><em>CodeName:BlueMix 是一款 beta\n                    级产品，随着我们不断让功能更完善和更易用，它也将不断改进。我们将竭尽全力保持本文最新，但它并不总是完全跟上现状。感谢大家的理解。<\/em><\/p><p>消费者银行行业正在调整其业务模型的方向，从以产品为中心的孤岛转向以客户为中心的战略。银行系统必须成为高弹性平台，以便利用消费者通过多种渠道（包括移动设备）访问其帐户和执行交易的能力。金融机构在其旧的数据中心环境中难以保持和提高其弹性，为新的收入生成服务提供支持，尤其是那些为利用云计算、移动技术和企业\n                API 而不断演变的服务。用上这些技术后，银行可以发现其旧环境的低效性和局限性，开始仔细考虑通过现代化来利用新技术。<\/p><p>本文从一个高层次的角度上介绍了一个为消费者银行服务设计启用了私有云的解决方案的案例分析。我们的架构方法构建于以下成熟技术之上：识别弹性问题，建立弹性目标，使用成本受控的模式将传统\n                IT 环境转换为弹性的基于云的系统。该方法也适用于金融服务以外的行业。<\/p><h2 id=\"N1004D\">设计始终在线的架构的要求<\/h2><p>我们接触的金融机构希望其数字渠道服务持续可用（<em>始终在线<\/em>）。我们对由渠道访问服务和业务服务组成的应用程序和平台执行功能分析，这些应用程序和平台支持关键的客户服务功能（登录、查看帐户余额、查看最近交易、支付和购买服务）。图\n                1\n                是银行现有的数字服务领域的系统和相关系统组件的总体概述。我们观察到，应用程序是在一种垂直模型（孤岛）中进行开发、部署和管理的，而存储和网络组件是在企业范围内共享的资源。<\/p><h5 id=\"fig1\">图 1. 移动和在线银行系统<\/h5><img alt=\"该图显示了银行的数字服务的现有系统架构图\" src=\"/sunshine_new/images/952867506/Figure1.png\" width=\"572\" /><p>我们考虑的面向客户的应用程序分组包括：<\/p><ul class=\"ibm-bullet-list\"><li>一个运行在线银行服务的 Web 服务器场<\/li><li>运行移动服务的应用服务器<\/li><li>企业信息服务<\/li><li>具有单一登录功能的旧安全机制<\/li><li>企业集成服务<\/li><\/ul><p>这组相互依赖、互操作的应用程序还依赖于银行 IT 环境中和来自外部第三方服务提供商的其他服务。<\/p><p>现有系统的重要应用程序架构特征包括： <\/p><ul class=\"ibm-bullet-list\"><li>它是以一种分层方式和一种松散耦合的方法来构建的。<\/li><li>它使用了遵循组件架构模式的开放标准（Java&#8482; Enterprise Edition 和相关技术）。<\/li><li>它使用了行业标准的通信机制和协议（HTTP、JDBC [Java Database Connectivity，Java\n                    数据库连接]、SOAP [Simple Object Access Protocol，简单对象访问协议]，等等）。<\/li><li>它遵循基于标准的框架中的行业最佳实践，通过企业集成服务为主要子系统之间的集成和路由实现一种 SOA（面向服务的架构）的方法。<\/li><\/ul><p>图 2 是现有的银行解决方案的大体 IT 架构。<\/p><h5 id=\"fig2\">图 2. 支持当前的移动和在线银行系统的 IT 环境<\/h5><img alt=\"该图显示了现有银行解决方案的 IT 架构的概览图\" src=\"/sunshine_new/images/952867506/Figure2.png\" width=\"847\" /><p>这个传统的架构模型包含与零散的异构服务器场共享的网络和存储服务层，以及平台组件。该银行刚开始为系统环境定义一种通用的监视和管理系统。与银行当时最新的未简化的维护实践相结合，该环境具有很高的失败风险，因为系统的组件是相互依赖的：任何一个组件的弹性功能（或缺乏）都会影响所有依赖它的邻近组件。只有采用整体性的视图和方法才能得到高弹性系统。幸运的是，如果采用松散耦合、基于标准的框架的解决方案，那么可以利用在虚拟基础架构和平台上操作的云计算模型的优势。<\/p><h2 id=\"N1008B\">基于云架构的始终在线服务的方法<\/h2><p>云架构的基本原则包括<em>标准化<\/em>、<em>虚拟化<\/em>\n                和<em>自动化<\/em>。正确利用并相互集成时，这些原则对高弹性系统至关重要。基础架构组件（比如服务器、存储和网络）的虚拟化和平台组件（比如数据库、应用服务器和集成总线）的共享\n                &#8212; 与云服务管理方面（比如置备、监视和自动化）相结合 &#8212; 是为高弹性系统提供支持的基础。<\/p><p>标准化、虚拟化和自动化是银行通过一个或多个以下特征，向客户提供<em>始终在线<\/em> 的数字服务的愿景的中心：<\/p><ul class=\"ibm-bullet-list\"><li>高度可用的端到端系统，所有组件的设计都包含在发生故障时触发的故障转移机制<\/li><li>通过能确保客户交易已完成的弹性系统组件实现数据/信息的高完整性<\/li><li>任何系统或应用程序组件的维护没有计划的或计划外的宕机时间<\/li><\/ul><p><a href=\"http://www.ibm.com/cloud-computing/us/en/cloud-foundations.html\" target=\"new\">IBM 启用了云的数据中心<\/a> (CEDC) 方法通过多层架构构造来实现弹性：<\/p><ul class=\"ibm-bullet-list\"><li>基础架构即服务 (IaaS)<\/li><li>平台即服务 (PaaS)<\/li><li>软件即服务 (SaaS)<\/li><li>业务流程即服务 (BPaaS) <\/li><\/ul><p>图 3 是 CEDC 架构模型图。<\/p><h5 id=\"fig3\">图 3. 增强弹性的 CEDC 参考模型和重要组件<\/h5><img alt=\"该图显示了 CEDC 架构模型图\" src=\"/sunshine_new/images/952867506/Figure3.png\" width=\"834\" /><p>在图 3 中所示的模型中，IaaS 和 PaaS 层，以及<em>弹性<\/em> 构建块是高弹性解决方案的主要支撑。基础架构的虚拟化和 IaaS\n                支持更高的容量利用率和更高的可用性。弹性治理构建块帮助定义实现、管理、跟踪和监视云应用程序的策略和规程，以实现更高的弹性。<\/p><p>通用云管理平台 (CCMP) 的操作支持服务 (OSS) 和业务支持服务 (BSS) 层有助于实现自动化。带 BSS/OSS\n                的基础架构和平台元素的标准化，能够最大程度地提高平台资源利用率和减少部署错误，从而实现高可用性。带 OSS 的 CCMP\n                是自动化活动的重要组成部分。自动化（与集成的监视和虚拟化的基础架构相结合）有助于对计算资源执行动态调整和扩展。虚拟化的计算、存储和网络技术构建块的可动态扩展的、灵活的集合，这些已经足够消除孤岛。通过\n                OSS 和 BSS 实现自动化，将有助于将银行的传统 IT 环境转换为一个健全且高弹性的始终在线环境。<\/p><p>基于这个 CEDC 参考模型，我们为该银行开发了一个始终在线的解决方案。图 4 描绘了该解决方案的云架构。 <\/p><h5 id=\"fig4\">图 4. 移动和在线银行解决方案的基于云、始终在线的系统架构<\/h5><img alt=\"该图显示了移动和在线银行解决方案的基于云的架构图\" src=\"/sunshine_new/images/952867506/Figure4.png\" width=\"849\" /><h2 id=\"N100D9\">基础架构层的重要架构方面<\/h2><div class=\"dw-sidebar ibm-inset\"><h2 id=\"N100DF\">SoftLayer<\/h2><p>SoftLayer 提供了一个全球性的高性能云计算基础架构，它能够支持 Internet 级的应用程序。借助 SoftLayer\n                    全球云环境，您拥有所有一切：一个门户、一个 API，以及一个具有您可通过与 IBM 合作获得的稳定性、支持和信任的平台。 <\/p><\/div><p>该解决方案基本上由一个 <a href=\"http://www.ibm.com/cloud-computing/us/en/softlayer.html\" target=\"new\">IBM SoftLayer<\/a> IaaS\n                层来提供支持，该层包含在一些主要应用程序组间共享的计算、存储和网络组件 &#8212;\n                尤其是面向外部用户的静态支持系统、在线服务的路由功能，以及移动银行应用程序。金融服务业务需求的重要性质要求，解决方案架构基于 SoftLayer\n                所指定的，一个带单租户模型的高度安全环境中的裸机产品。以下是我们的解决方案架构中集成的计算、存储和网络 IaaS\n                的一些静默方面，这些方面旨在让始终在线的愿景成为现实。<\/p><h4 id=\"N100EE\">计算<\/h4><p>对于计算，我们选择使用 SoftLayer\n                裸机选项来提供高度可用的始终在线解决方案，它满足了机构对私有环境的需求。借助裸机解决方案，客户能够广泛使用计算服务器及网络和存储，可针对本地和全局弹性来配置这些资源。作为裸机的替代方案，我们考虑使用来自\n                SoftLayer 的虚拟服务器产品，通过多租户计算方法最大限度地节省运营开支\n                (OPEX)。但是，某些影响参与的业务职能部门的法规要求导致我们执行了一次架构权衡分析，排除了虚拟服务器选项。<\/p><h4 id=\"N100F5\">存储<\/h4><p>因为实现包含本地存储的始终在线解决方案需要全局分散的裸机配置中的冗余的本地存储，所以我们创建的存储配置是存储区域网络 (SAN)。SAN\n                架构提供了跨多个裸机实例的更有效管理和更高灵活性，因为它的设计支持 RAID 5 或更高的配置，所以能够轻松地同步数据。<\/p><p>我们考虑为数据敏感的应用程序（财务交易）采用同步数据更新，为对数据不那么敏感（比如静态客户支持信息）的解决方案或备份解决方案采用异步更新。在此上下文中，推荐采用\n                SAN 存储而不是本地存储，以便实现更高的完整性和性能。这种存储虚拟化支持随需应变的弹性带宽，以支持<em>自动缩放<\/em>\n                一个应用程序，通过扩展来响应更高的需求，并在需求降低时缩小。此解决方案满足了需要高度可用的、始终在线的私有环境的组织的需求，能够不断减少资本和运营开支。<\/p><h4 id=\"N10101\">网络和网络安全<\/h4><p>SoftLayer 网络架构（具有数据中心内高速连接和负载平衡）提供了具有严格的恢复时间目标 (RTO) 和恢复点目标 (RPO)\n                的用户想要的冗余性和灵活性。SoftLayer 为跨位于不同地区但集成的数据中心的分布式业务应用程序置备了资源的核心功能，以高达 99.999%\n                正常运行时间解决了高可用性需求。对于一些用户访问系统需要高性能的业务，SoftLayer 的 POP（point of\n                presence，入网点）网络特性提供了直接的或更短的连接，以实现更低的延迟。<\/p><p>为了帮助保护银行的业务关键型应用程序，SoftLayer 通过运营商级的防火墙和虚拟防火墙实现了边缘安全性。该架构的这种<em>网络中的网络<\/em>\n                特性可维护安全的环境。对于通过 Web 控制台执行的系统管理和云环境访问，我们的架构包括加密的 VPN\n                连接，以及带身份和访问管理的基于角色的安全性。<\/p><h4 id=\"N1010D\">监视和管理<\/h4><p>最初的系统的监视和管理方面，通过 BSS/OSS 支持功能和弹性构建块进行了自动化增强。这些组件，以及 IaaS API\n                层，可确保系统弹性，从而实现更高的恢复能力。<\/p><p>IaaS 层受 <a href=\"http://sldn.softlayer.com/reference/overview\" target=\"new\">SoftLayer API<\/a> 支持，有大约 2,000 个 API 来监视和管理系统的弹性。这种 API\n                架构是银行与其内部部署的监视系统集成所需的自动缩放功能的基础。对始终在线的基础架构的管理，通过 SoftLayer 的 API\n                管理模型在许多层级上提供了编程支持，该模型提供了可编程的接口。没有任何人类调节的应用程序运行管理，简化了服务器管理，并减少了始终在线的基础架构的\n                IT 操作成本。<\/p><h4 id=\"N1011B\">PureSystems<\/h4><p>除了基于 SoftLayer 的 IaaS 之外，IBM PureSystems&#174;\n                    也是始终在线的架构的一个关键组件。解决方案堆栈的一个关键功能是<em>企业集成服务<\/em>，它不仅支持银行的客户系统领域，还支持企业中的其他领域。将这个特定的业务智能模块迁移到外部的弊大于利。弊主要是因为需要将内部部署的系统与其他众多后端应用程序相集成，在高度关注安全性时还要与云集成。为始终在线的基础架构构建高度可用的内部部署私有云系统的快速、高效的方式，是将\n                PureSystems 包含在我们的架构中的重要考虑因素。PureSystems\n                将计算、存储、网络和管理软件集成到已针对具体工作负载和环境的需求而进行了优化的预配置平台中。<\/p><p>包含 PureSystems 的另一个原因是，它可配置一个 PaaS 组件，该组件是这个解决方案中的企业集成服务平台所必需的。带\n                PureSystems\n                的架构包含一个成熟的网络冗余性模型，解决了互联和全局负载平衡的需求，通过功能上独立的不同冗余资源来保持恢复能力。灵活的安全配置为身份、访问、加密、监视和审计提供了支持，能够满足合规性要求。PureSystems\n                随带的 SmartCloud Orchestration\n                管理功能可帮助用户创建镜像、置备环境，并将它部署在一个私有云上，而且它还为跨云集成提供了基础。<\/p><h2 id=\"N10129\">平台层<\/h2><div class=\"dw-sidebar ibm-inset\"><h2 id=\"N1012F\">使用 Codename: BlueMix 构建应用程序<\/h2><p>Codename:BlueMix 是 IBM\n                    用户开发和托管始终在线的应用程序的开放平台。您可以在一个综合环境中快速构建、部署和管理云应用程序，同时利用可用服务和运行时的不断扩大的生态系统。通过一个管理控制台或\n                    API 自动缩放、管理和监视应用程序的功能已内置于部署环境中；网络、服务器和存储对 BlueMix\n                    部署的业务应用程序而言是按需的、自动缩放的消耗性资源。要实现始终在线的云解决方案，除了在 BlueMix\n                    中构建和部署应用程序之外，用户需要做的工作很少。<\/p><p><a href=\"http://ibm.com/developerworks/cloud/apps/index.html\" target=\"new\">您可以查阅一些应用程序，了解它们是如何构建的，然后获取代码<\/a>。<\/p><p>报名参加 <a href=\"https://www.ibmdw.net/bluemix/\" target=\"new\">Codename:BlueMix 开放 beta 计划<\/a>。<\/p><\/div><p>我们推荐银行采用一种分阶段方法来实现分层和结构化的 CEDC 模型： <\/p><ul class=\"ibm-bullet-list\"><li>阶段 1：使用一个 CCMP/BSS/OSS 层为基础，实现 IaaS 以及一些启用了自动化的元素。<\/li><li>阶段 2：将平台组件与数据和集成平台元素相整合。<\/li><\/ul><p>在第 2 阶段中，解决方案架构也受一个 PaaS 层支持，该层中整合了一些核心平台组件。在平台层内：<\/p><ul class=\"ibm-bullet-list\"><li>数据层与一个数据平台相整合，该平台包含 <a href=\"http://www.ibm.com/software/data/infosphere/\" target=\"new\">InfoSphere&#174;<\/a> 和带 <a href=\"http://www.ibm.com/developerworks/cn/data/library/bd-streamsintro/\" target=\"new\">InfoSphere Streams<\/a> 的 <a href=\"http://www.ibm.com/software/data/db2/\" target=\"new\">DB2&#174;<\/a> 数据库软件。InfoSphere 多租户特性为多个应用程序共享数据平台提供了基础，InfoSphere\n                    Streams 特性解决了高事务量分析需求。<\/li><li>一个核心集成平台（基于 <a href=\"http://www.ibm.com/software/websphere/\" target=\"new\">WebSphere&#174;<\/a> 软件）支持将集成服务分离到应用程序中。<\/li><\/ul><h2 id=\"N10167\">结束语<\/h2><p>对始终在线的系统的需求不是银行业所独有的。任何与通过多个渠道提供的服务联系紧密的企业（以及希望维护较高的客户满意度的企业）都可利用云计算和 CEDC\n                模型来实现高弹性和高度可用的系统。实现 CEDC 模型的分阶段方法（首先实现 IaaS，然后通过启用 PaaS\n                来整合平台）是实现始终在线的系统的理想方式。<\/p><CMA ID: 969825><Site ID: 10><XSLT stylesheet used to transform this file: dw-document-html-7.0.xsl>\r\n\r\n\r\n<\/div>\r\n<\/div>\r\n","createTime":"2014-04-28 00:00:00","deployTime":"2014-04-28 00:00:00","id":0,"intro":"金融服务行业的一次案例分析，演示了 IBM 设计高弹性系统的启用了云的数据中心方法。本文面向那些拥有云计算背景的高级架构师，介绍了一种提供持续可用的数字渠道服务的系统性方法。","keyword":"","recommend":false,"source":"http://www.ibm.com/developerworks/cn/cloud/library/cl-bluemix-always-on/index.html","title":"设计基于云的始终在线系统的途径","typeId":0,"updateTime":"2014-04-28 00:00:00"}
{"author":"","clickNumber":0,"content":"\r\n<div class=\"ibm-columns\">\r\n<div class=\"ibm-col-1-1\">\r\n\r\n<h2 id=\"major1\">OpenPages 概述<\/h2><h3 id=\"minor1.1\">OpenPages 简介<\/h3><ul class=\"ibm-bullet-list\"><li>2001 年：OpenPages 公司开始开发帮助企业管理复杂风险和合规管理措施的平台。<\/li><li>2002 年：依据萨班斯 - 奥克斯利法案，着重开发财务控制管理功能。<\/li><li>2006 年：拓展风险和合规管理的其它新领域，包括操作风险管理、政策和合规管理、资讯科技管治、内部审计管理。<\/li><li>2010 年：IBM 完成对 OpenPages 公司的收购。IBM 与 OpenPages 的结合提供了一个全面一致的风险管理方法，帮助企业把风险管理和合规管理结合在一起，推动更好的企业决策。<\/li><\/ul><p>  IBM OpenPages 解决方案被 Gartner 和 Forrester 公认为企业治理、风险与合规性 (GRC, Governance、Risk Management、Compliance) 管理的领先平台，使金融服务、能源和公用事业、医疗保健和制造等行业中全球最大的企业可以识别和管理企业内的关键业务风险，从而提高业务性能。<\/p><h3 id=\"minor1.2\">OpenPages 产品架构<\/h3><p><strong>OpenPages 应用服务器<\/strong><\/p><p>  OpenPages 6.1 及之前版本的应用服务器在 Windows 系统中部署在 Weblogic 上，而 AIX 系统中则部署在 Websphere 上。而 6.2 及以后版本的应用服务器在 Windows 和 AIX 系统中均可部署在 Weblogic 或 Websphere 上。OpenPages 应用服务器负责定义和管理商业元数据、界面视图、用户配置信息以及用户授权权限，并允许终端用户创建、更新、浏览和过滤元数据。除此外，应用服务器也提供应用模块的运行时执行。<\/p><p><strong>Cognos 报表服务器 ( OpenPages CommandCenter )<\/strong><\/p><p>  OpenPages 主要通过 Cognos 报表、仪表盘和分析提供商业智能服务 , 也可通过 Cognos Mashup 服务在 OpenPages 界面中渲染、展现报表。其中 CommandCenter 为 OpenPages 和 Cognos 之间的交互提供了桥梁。<\/p><p><strong>工作流服务器（Workflow）<\/strong><\/p><p>  OpenPages 集成了 Interstage BPM。终端用户可使用 Interstage BPM studio 创建、修改工作流，定义工作流任务和逻辑，并发布到 OpenPages 应用服务器中。然后在 OpenPages 应用服务器中提交并执行这些工作流。<\/p><p><strong>OpenPages 数据库层<\/strong><\/p><p>  OpenPages 数据持久层管理、维护所有的数据：元数据、所有版本的应用数据 ( 记录每一次操作数据的行为 )、报表数据、用户 / 组以及其对应的访问权限。<\/p><h5 id=\"fig1\">图 1. OpenPages 产品架构图<\/h5><img alt=\"图 1. OpenPages 产品架构图\" src=\"/sunshine_new/images/负504245239/image001.JPG\" width=\"315\" /><h2 id=\"major2\">单机版 OpenPages 的优缺点<\/h2><h3 id=\"minor2.1\">单机版 OpenPages 的优点<\/h3><p>  OpenPages 提供了综合的治理、风险与合规性（GRC）解决方案，通过降低风险、以更低的成本管理风险计划和更合理地分配资源，改善业务绩效。综合的 GRC 解决方案综合了跨多个不同风险领域运行风险管理计划的功能，这些风险领域包括运营风险、财务控制管理、IT 治理、策略和法规遵从性管理、内部审计管理。这一切功能都整合在一个单一平台上。这样一个综合解决方案为高级管理人员提供了一个综合视图，显示跨不同风险管理领域的风险，使他们能够获得整个组织内风险的全面视图，并且使他们能够制定更好的业务决策。<\/p><p>IBM OpenPages GRC 平台使企业能够：<\/p><ul class=\"ibm-bullet-list\"><li>针对多重法规（其中包括财务报告法规、隐私法规和行业法规等）管理风险及合规性。<\/li><li>了解跨部门、业务单元与地理位置共享的流程、风险和控制手段之间的依赖关系。<\/li><li>实施一个统一且简化的方法来管理企业风险，以减少冗余，最大限度地降低复杂性，并最大限度地提高效率。<\/li><li>为生产线管理人员提供正确的信息，以优化风险与合规性流程。<\/li><li>使业务管理人员能够以特定方式探究风险数据，并根据最佳风险调整回报率来对这些机遇分配资金。<\/li><\/ul><p>  同时，IBM OpenPages GRC 平台是一个高度配置的解决方案，无需编写定制代码就能支持特定的风险管理方法，因此，它还可以带来更多优势：<\/p><ul class=\"ibm-bullet-list\"><li>没有改变您的方法――其他大多数公司要么迫使您改变风险管理流程，要么对他们的软件进行定制扩展。由于不灵活的技术解决方案而引起的方法变更将影响您把风险管理融入业务运营的能力。<\/li><li>降低成本――对初步实施而言，开发定制代码花费颇多，并且随着时间的推移，维护和扩展定制代码将会更加昂贵，而 OpenPage 完全可以规避这一巨大成本。<\/li><li>缩短部署时间―― OpenPages 专利元数据驱动型应用程序框架提供了无与伦比的配置，支持在极短时间内快速实施定制的开发方法。<\/li><li>面向未来―― OpenPages 独特的配置功能使您可以快速适应您的风险框架，以满足不断变化的需求，同时最大限度地减少对业务的影响。<\/li><li>专为集成而设计――作为一个充分集成的解决方案，OpenPages 支持跨风险管理域的常见流程，所以您最终不会遇到报告和问题孤岛。<\/li><\/ul><h3 id=\"minor2.2\">单机版 OpenPages 的缺点<\/h3><p>尽管我们看到了 OpenPages 的诸多优点。但是随着用户业务需求的增加和大数据时代的到来，很多大型企业在实际应用中遇到一系列业务瓶颈。<\/p><p>对于轻量级负载用户来说，部署一个简单的 OpenPages 环境既可满足他们的需求。比如：<\/p><h5 id=\"fig2\">图 2. 轻量或中量级用户负载部署方案<\/h5><img alt=\"图 2. 轻量或中量级用户负载部署方案\" src=\"/sunshine_new/images/负504245239/image002.JPG\" width=\"490\" /><p>我们知道 OpenPages 为企业提供应用解决方案，这些解决方案以模块的形式存在于 GRC 平台。这些模块拥有自己的工作流、元数据、报表展示功能。当不同权限的用户同时对自己相关的业务进行操作时，OpenPages 服务器的响应可能会产生延迟甚至中断。这种情况就属于服务器重负载运行。如果这种情况不能得到解决，我们 OpenPages 的产品优势将会被削弱。<\/p><p>为了应对这种多用户并行操作或大数据流传输时产生的应用瓶颈，OpenPages 集群环境将为企业用户带来精准应用解决方案和快速处理响应双重感受。<\/p><h2 id=\"major3\">OpenPages 集群环境架构<\/h2><p>为了解决重量级用户负载，我们可以通过配置扩展节点到 OpenPages 应用服务器。通过配置附加节点，来解决多用户并行操作和大数据流传输产生的瓶颈问题。OpenPages 集群环境，包括水平集群环境和垂直集群环境。无论水平或者垂直配置，都需要一个负载均衡器。负载均衡器负责分发到来的客户请求到各个不同的节点。<\/p><h3 id=\"minor3.1\">OpenPages 集群环境概述<\/h3><p>  OpenPages 集群环境，主要是通过水平或者垂直添加扩展节点到 OpenPages 环境中，从而提高用户并行操作时的响应时间。每个节点包括 OpenPages 应用服务器的实例和相应的 workflow 服务器的实例，每个节点都运行在不同的端口。<\/p><p>水平集群环境，通过添加额外的计算机到集群主机来增加服务器实例。<\/p><p>垂直集群环境，通过在一个现有的计算机集群环境中添加节点来增加服务器实例。  <\/p><p>下图为使用一个 Web 服务器作为负载均衡器，Web 服务器分发所有到来的客户请求到水平集群环境的示意图。<\/p><h5 id=\"fig3\">图 3. 重量级用户负载部署方案<\/h5><img alt=\"图 3. 重量级用户负载部署方案\" src=\"/sunshine_new/images/负504245239/image003.JPG\" width=\"528\" /><h3 id=\"minor3.2\">OpenPages 集群环境架构<\/h3><p>  在 OpenPages GRC 安装完成后，可以根据实际软硬件配置情况，合理部署集群环境。下面主要介绍负载均衡器为 WebSphere、OpenPages 垂直集群环境和水平集群环境的部署。<\/p><p><strong>WebSphere垂直集群环境部署 - OP &amp; IBPM<\/strong><\/p><h5 id=\"fig4\">图 4. 垂直集群环境<\/h5><img alt=\"图 4. 垂直集群环境\" src=\"/sunshine_new/images/负504245239/image004.JPG\" width=\"559\" /><p>垂直集群环境部署，添加一个新的节点到现有的 WebSphere 环境中。上图则为添加新节点 Aix1-OPNode1Server2 到一个现有的 OpenPages 环境中，则此节点 OpenPages 实例端口为 10128，IBPM 实例端口为 20128。经过垂直部署，用户则可以通过 http://Aix1:10128/openpages 访问 OpenPages 应用服务器，这样有效的缓减了重量型用户负载。<\/p><p><strong>WebSphere 水平集群环境部署 - OP &amp; IBPM<\/strong><\/p><h5 id=\"fig5\">图 5. 水平集群环境<\/h5><img alt=\"图 5. 水平集群环境\" src=\"/sunshine_new/images/负504245239/image005.JPG\" width=\"530\" /><p>水平集群环境部署，添加额外节点为现有 OpenPages 环境集群成员。上图为添加节点 Aix2 到 Aix1-OpenPages 环境中，此 OpenPages\n\t\t\t    实例端口仍为 10108，IBPM 实例端口仍为 20108。经过水平部署，则用户可以通过 “http://Aix2:10108/openpages” 访问 OpenPages 应用服务器，同样有效的缓减了重量型用户负载。<\/p><h2 id=\"major4\">如何创建企业级 OpenPages 集群环境<\/h2><p>  如果用户希望在一台服务器上部署 OpenPages 集群环境，可以选择垂直集群环境。如果用户希望在多台服务器上部署 OpenPages 集群环境，则可以选择水平集群环境。当然，用户也可以将两种集群环境混合使用。下面我们就分别针对这两种部署方案进行介绍。<\/p><h3 id=\"minor4.1\">部署垂直集群环境<\/h3><p>  部署垂直集群环境与部署单个 OpenPages 应用服务器，操作基本相似，不同之处在于垂直集群环境在部署时需根据需求指定节点个数，而单节点 OpenPages 应用服务器在部署时节点个数总为 1。下图为AIX 上部署垂直集群环境的差异界面。<\/p><h5 id=\"fig6\">图 6. AIX 部署垂直集群环境的界面<\/h5><img alt=\"图 6. AIX 部署垂直集群环境的界面\" src=\"/sunshine_new/images/负504245239/image006.JPG\" width=\"508\" /><p>  注：本文并不详细介绍 OpenPages 的详细安装细节，具体细节请参照 \n\t\t\t<a href=\"http://www.ibm.com/developerworks/cn/aix/library/1310_zhaoym_openpages/index.html#resources\">《在\n\t\t\t    AIX 系统上安装和配置 IBM OpenPages GRC 》<\/a>，\n\t\t\t或者 <a href=\"http://www-01.ibm.com/support/docview.wss?uid=swg27036766\">OpenPages 官方安装指南<\/a>。<\/p><p>  需要注意的是，Windows 上OpenPages 的 http 协议默认起始端口为 7009，https 协议默认起始端口为 7010，而其它 OpenPages 节点所对应端口每次累加 2。也就是说，如果有 3 个节点，那么 http 协议端口分别为 7009、7011、7013。Https 协议端口分别为 7010、7012、7014。AIX 上 OpenPages 的 http 协议默认起始端口为 10108，https 协议默认起始端口为 10111，而其它 OpenPages 节点所对应端口每次累加 20。也就是说，如果有 3 个节点，那么 http 协议端口分别为 10108、10128、10148。Https 协议端口分别为 10111、10121、10141。<\/p><h3 id=\"minor4.2\">部署水平集群环境<\/h3><p>  水平集群环境中，在不同的服务器上安装单个 OpenPages 节点。但仅有一个是集群的 admin 服务器，其它都属于 managed 服务器。<\/p><p>  需要注意的是，在 Windows 上部署水平集群环境，所有节点的 http 端口均为 7009，https 端口均为 7010。在 AIX 上部署水平集群环境，admin 服务器的 http 端口为 10108，https 端口为 10111，而其它服务器的端口号依次累加 20。<\/p><h3 id=\"minor4.3\">共享 OpenPages 存储目录<\/h3><p>  在集群环境中，所有的 OpenPages 应用节点共同使用一个目录存储 / 读取系统和用户上传的各种文件。因此，在安装完所有的 OpenPages 节点后，需要手动配置OpenPages 共享存储目录。下面假定所有的 OpenPages 应用节点都部署在 AIX 操作系统上，介绍如何将 Admin server 上的 OpenPages 存储目录共享给所有的 Managed server。<\/p><p>1. 以 root 用户登陆到 Admin server，创建 /etc/exports 文件，并将 OpenPages 存储目录的路径添加到 exports 文件中 ( 默认OpenPages 存储目录的路径为 /opt/OpenPages/openpages-storag)。<\/p><p>2. 修改 exports 文件的访问权限，使用如下命令：<\/p><div class=\"codesection\"><pre class=\"displaycode\">chmod 755 /etc/exports<\/pre><\/div><p>3. 执行如下命令发布 OpenPages 存储目录的路径，以便 Managed server 能够获得此路径信息并挂载在本地。<\/p><div class=\"codesection\"><pre class=\"displaycode\">exportfs -a \nstopsrc -g nfs \nstartsrc -g nfs<\/pre><\/div><p>4. 在多有的 Managed server 上执行步骤 1、2。<\/p><p>5. 在多有的 Managed server，以 root 用户执行如下命令挂载 OpenPages 共享存储目录到本地<\/p><div class=\"codesection\"><pre class=\"displaycode\">mount &lt;admin server hostname&gt;\n:/opt/OpenPages/openpages-storage   \n/opt/OpenPages/openpages-storage<\/pre><\/div><p>6. 从安装光盘拷贝 OP_6.2_Configuration/Database/ORACLE/INSTALL_SCRIPTS 到本地，并切换至\n    INSTALL_SCRIPTS 目录，执行如下命令更新数据库。<\/p><div class=\"codesection\"><pre class=\"displaycode\">sqlplus /nolog @sql-wrapper.sql update-storage \n&lt;log_file&gt; \n&lt;TNS_alias_name&gt; &lt;openpages_schema_owner&gt; \n&lt;openpages_schema_owner_password&gt; \nLFS &lt;storage_server_hostname&gt; \n&lt;admin_hostname&gt; \nUNIX &lt;share_folder&gt;<\/pre><\/div><h5 id=\"N10158\">表 1. 参数描述<\/h5><table border=\"0\" cellpadding=\"0\" cellspacing=\"0\" class=\"ibm-data-table\"><thead xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"><tr><th>参数<\/th><th>描述<\/th><\/tr><\/thead><tbody xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"><tr><td><em>log_file<\/em><\/td><td>记录 sql 脚本执行过程<\/td><\/tr><tr><td><em>TNS_alias_name<\/em><\/td><td>数据库实例名，默认为 OP <\/td><\/tr><tr><td><em>openpages_schema_owner<\/em><\/td><td>OpenPages 表空间的所有者，默认为 openpages <\/td><\/tr><tr><td><em>openpages_schema_owner_password<\/em><\/td><td>OpenPages 表空间的所有者的密码<\/td><\/tr><tr><td><em>storage_server_hostname<\/em><\/td><td>存储目录所在的主机名<\/td><\/tr><tr><td><em>admin_hostname<\/em><\/td><td>Admin server 的主机名<\/td><\/tr><tr><td><em>share_folder<\/em><\/td><td>存储目录所在的路径<\/td><\/tr><\/tbody><\/table><p>  至此，OpenPages 共享存储目录已经配置完成。现在用户访问任何一台 OpenPages server 都能查看到所有信息，并且在一台 server 上所做的修改，其它 server 也能看到。<\/p><p>  至于如何配置 Windows 的共享存储目录，请参照本文和 <a href=\"http://www-01.ibm.com/support/docview.wss?uid=swg27036766\">OpenPages 安装向导<\/a>，本文不做具体描述。<\/p><h3 id=\"minor4.4\">配置负载均衡<\/h3><p>  为了避免集群环境中某台 OpenPages 服务器负载过重，我们建议配置负载均衡。通常的方法是在集群环境的前端添加一个负载均衡器（针对 AIX + OpenPages cluster + WAS 的环境，我们通常使用的是 IBM HTTP server + plugin。针对 Windows + OpenPages cluster + WLG 的环境， 我们通常使用的是 Apache web server。 当然也可以使用其它软件或者硬件的负载均衡器）。负载均衡请根据实际网络拓扑，查阅相关软件或者硬件负载均衡器的指导文档 <sup>[2]<\/sup>，在此不做详细说明。<\/p><h2 id=\"major5\">结束语<\/h2><p>本文由浅入深，从 OpenPages 产品的诞生、架构、发展以及单机版 OpenPages 的优缺点深入到如何构建 OpenPages 集群环境。通过对 OpenPages 集群环境进行架构和部署的描述，让读者对 OpenPages 产品有了更进一步的认识。OpenPages 产品不仅能为企业提供风险管理解决方案，而且能为企业解决多用户并行操作和大数据流传输产生的瓶颈问题。<\/p><CMA ID: 969975><Site ID: 10><XSLT stylesheet used to transform this file: dw-document-html-7.0.xsl>\r\n\r\n\r\n<\/div>\r\n<\/div>\r\n","createTime":"2014-04-28 00:00:00","deployTime":"2014-04-28 00:00:00","id":0,"intro":"OpenPages 是一款商业智能分析软件，它能够帮助企业开发有关运营风险、财务控制管理、遵循和内部审计等领域的策略。但是对于大型企业而言，随着用户负载的不断增加，部署单机版的 OpenPages 环境对它们来说就会成为应用瓶颈。本文将着重介绍如何为大型企业创建 OpenPages 集群环境，帮助他们扩展应用规模，实现负载均衡，提高风险管理，增强安全控制。","keyword":"","recommend":false,"source":"http://www.ibm.com/developerworks/cn/data/library/bd-1404openpagescluster/index.html","title":"创建企业级 OpenPages 集群环境","typeId":0,"updateTime":"2014-04-28 00:00:00"}
{"author":"","clickNumber":0,"content":"\r\n<div class=\"ibm-columns\">\r\n<div class=\"ibm-col-1-1\">\r\n\r\n<h2 id=\"1.Scrum 和 RTC 简介 |outline\">Scrum 和 RTC 简介<\/h2><p>Scrum 是敏捷开发团队经常会采取的一种开发模式。以 Sprint 为周期，增量的来完成项目任务，非常灵活和高效，被越来越多的团队所采用。<\/p><p>RTC（IBM Rational Team Concert）是应用非常广泛的协同开发软件。是具有强大的项目管理功能的开发工具，帮助项目管理人员和开发人员进行开发和管理任务，并且可以提供种类繁多的报告表格。使项目进展和状态一目了然。<\/p><h2 id=\"2.应用 RTC 在 Scrum 团队中进行项目管理 |outline\">应用 RTC 在 Scrum 团队中进行项目管理<\/h2><h3 id=\"N10056\">项目计划（project plan）<\/h3><p>在项目伊始，项目管理人员、开发人员、Stackholder 需要对项目进行分析。<\/p><p>Project backlog：Project backlog 里面包含了整个项目需要完成的任务总和，并且包含每个任务的优先级，项目成员完成的所有任务都可以从 project backlog 里面找到。在 RTC 中创建任何种类的 item 时，在\"Planned For\"一栏选择对应的 project backlog，在浏览 plan 时候就可以看到 Project backlog，包含了整个项目需要完成的所有任务。如图 1 所示：<\/p><h5 id=\"N10060\">图 1.Project backlog<\/h5><img alt=\"Project backlog\" src=\"/sunshine_new/images/负572027816/image003.jpg\" width=\"582\" /><h3 id=\"N1006B\">Sprint 计划（sprint plan）<\/h3><p>Sprint 是指每一个迭代周期。项目组根据自己的情况制定，一般 sprint 周期在 2 周左右。<\/p><p>Sprint plan 指的是，在当前迭代周期内准备完成的任务总和。Sprint plan 的内容是 Project backlog 的一部分。整个项目的所有迭代周期完成，代表 project backlog 里面的任务都完成了。在 RTC 中创建任何种类的 item 时，在\"Planned For\"一栏选择对应的迭代周期，在浏览 sprint plan 时候就可以看到包含了整个迭代周期需要完成的所有任务。如图 2 所示：<\/p><h5 id=\"N10075\">图 2.Sprint plan<\/h5><img alt=\"Sprint plan\" src=\"/sunshine_new/images/负572027816/image005.jpg\" width=\"582\" /><p>Sprint plan 里面的每一个任务都会设置一个 Owner 来完成，从<strong>图 2<\/strong>中可以看到每个 Epic/User story/Task 的状态。<\/p><h3 id=\"N10085\">Task 状态跟踪（Task Track）<\/h3><p>一个项目经过多层 Epic、User story、Task 的拆分，最终会分解成为完成时间在 8 个小时内的 Task。<\/p><p>Epic 和 User story 打开后都有进度条可以直观的看到对应的完成状态。Task 打开后可以通过更新 Time Remaining 来显示 task 的进展情况。<\/p><p>Epic 的进度显示了其下面所有子 item 的进度总和，如图 3 所示：<\/p><h5 id=\"N10091\">图 3.Epic 进度显示<\/h5><img alt=\"Epic 进度显示\" src=\"/sunshine_new/images/负572027816/image007.jpg\" width=\"582\" /><p>User Story 的进度显示了其下面所有子 item 的进度总和，如图 4 所示：<\/p><h5 id=\"N1009F\">图 4.User story 进度显示<\/h5><img alt=\"User story 进度显示\" src=\"/sunshine_new/images/负572027816/image009.jpg\" width=\"582\" /><p>每个任务都可以选择 Owner 来负责完成，同时可以给任务设置优先级。值得注意的是下面几个时间，Estimate 时间，指的是完成任务预估的时间，Time Remaining 时间，指的是完成这个任务还需要多少个小时，Due Date 时间，指的是这个任务最终交付日期，如果该任务超过了 Due Date 那么任务标题会有提醒。如图 5 所示：<\/p><h5 id=\"N100AD\">图 5.Task due date warning<\/h5><img alt=\"Task due date warning\" src=\"/sunshine_new/images/负572027816/image011.jpg\" width=\"582\" /><h3 id=\"N100B9\">多种类报告视图项目状态浏览<\/h3><p>Sprint Burndown chart 可以清楚的看出整个迭代周期里面任务完成的状态，任务完成速度，以及未完成任务的状态。图中有理想状态下的曲线图作为参考，使项目管理者和开发人员都能很清楚直观的看到项目的进展状态。<\/p><p>可以看出随着时间的推移，未完成的任务量（蓝色点曲线）在逐渐下降。如图 6 所示：<\/p><h5 id=\"N100C3\">图 6.Sprint Burndown chart<\/h5><img alt=\"Sprint Burndown chart\" src=\"/sunshine_new/images/负572027816/image012.jpg\" width=\"419\" /><p>Development Burndown chart，可以清楚的看出整个项目各个迭代完成的任务综合的进展状态。如图 7 所示：<\/p><h5 id=\"N100D2\">图 7.Development Burndown chart<\/h5><img alt=\"Development Burndown chart\" src=\"/sunshine_new/images/负572027816/image013.jpg\" width=\"582\" /><h3 id=\"N100DE\">团队人员管理<\/h3><p>Scrum 团队的一个特点就是团队成员可以是来自不同地理位置，拥有不同时差的人员。RTC 中的团队人员信息查询功能，可以帮助项目管理者和团队成员了解其他人的一些情况，比如联系方式（email 等）、之前工作过的项目同时可以查看人员的照片(如果该成员已经上传过照片)。查看团队人员信息，如图 8 所示：<\/p><h5 id=\"N100E6\">图 8.查看团队人员信息<\/h5><img alt=\"查看团队人员信息\" src=\"/sunshine_new/images/负572027816/image015.jpg\" width=\"581\" /><p>Scrum 团队成员把自己的休假情况标记在 RTC 中，有助于项目管理者和其他团队成员通过 RTC 就可以清楚的了解到其他成员的工作状态，更加便于有效的沟通。如图 9 所示：<\/p><h5 id=\"N100F5\">图 9.团队人员休假情况<\/h5><img alt=\"团队人员休假情况\" src=\"/sunshine_new/images/负572027816/image017.jpg\" width=\"581\" /><h3 id=\"N10101\">不同颜色区分不同类型任务<\/h3><p>Scrum 团队中，在每天的 daily scrum 上一个主要的工作就是扫清所有的障碍，保证项目的顺利进行。如果有一些颜色可以清楚的标记出那些任务需要立即完成否则会影响项目的进展，无疑会提高项目管理者的工作效率，RTC 中可以根据一些关键字，设置显示的颜色，高亮显示更有益于清楚的找到关心的内容。如图 10 所示：<\/p><h5 id=\"N10109\">图 10.设置颜色<\/h5><img alt=\"设置颜色\" src=\"/sunshine_new/images/负572027816/image019.jpg\" width=\"581\" /><p>高亮显示后，可以更清晰的看到用户关心的内容。项目管理者可以通过这个方法，来把 Sprint plan 设置成为自己更容易查询状态的样子。如图 11 所示：<\/p><h5 id=\"N10118\">图 11.高亮显示出不同颜色<\/h5><img alt=\"高亮显示出不同颜色\" src=\"/sunshine_new/images/负572027816/image021.jpg\" width=\"789\" height=\"340\" /><p><a href=\"#N10120\" class=\"ibm-popup-link\" onclick=\"ibmweb.overlay.show('N10120',this);return false;\">点击查看大图<\/a><\/p><div id=\"N10120\" class=\"dw-sidefile-overlay ibm-common-overlay ibm-overlay-alt-two\"><div class=\"ibm-head\"><p><a href=\"#close\" class=\"ibm-common-overlay-close\">关闭 [x]<\/a><\/p><\/div><div class=\"ibm-body\"><div class=\"ibm-main\"><div class=\"ibm-title\"><h2>图 11.高亮显示出不同颜色<\/h2><\/div><div class=\"ibm-container ibm-alternate\"><div class=\"ibm-container-body\"><img alt=\"高亮显示出不同颜色\" src=\"/sunshine_new/images/负572027816/image021.jpg\" width=\"987\" /><\/div><\/div><\/div><\/div><div class=\"ibm-footer\"><><\/div><\/div><h3 id=\"N10125\">Query 的应用大大提高了项目管理效率<\/h3><p>RTC 的 Query 查询功能，通过用户的配置可以很快的查询出关注的任务，使状态一目了然。Scrum 团队在 Daily scrum 中，可以通过运行自定制或者 Shared Query，来快速的找出自己关心的内容，可以是已经完成的任务，即将开始的任务，当然也可以是工作中遇到的一些需要团队一起帮助解决的问题。<\/p><p>自定制 Query，通过配置查询条件来找到关注的内容，如图 12、13 所示：<\/p><h5 id=\"N1012F\">图 12.创建新的查询<\/h5><img alt=\"创建新的查询\" src=\"/sunshine_new/images/负572027816/image022.jpg\" width=\"729\" /><h5 id=\"N1013C\">图 13.工作项查询配置<\/h5><img alt=\"工作项查询配置\" src=\"/sunshine_new/images/负572027816/image024.jpg\" width=\"581\" /><p>Scrum 团队成员可以根据查询结果列表的内容来在 Daily scrum 上做状态描述。查询结果列表如图 14 所示：<\/p><h5 id=\"N1014B\">图 14.查询结果列表<\/h5><img alt=\"查询结果列表\" src=\"/sunshine_new/images/负572027816/image026.jpg\" width=\"582\" /><h2 id=\"3.结束语 |outline\">结束语<\/h2><p>RTC 在 Scrum 团队中是开发，项目管理的一把利器。特别适用于大型项目的开发，尤其是团队中成员来自不同的地理位置，RTC 是沟通交流的好工具，所有的开发，复查任务都可以完成。<\/p><p>RTC 提供的多种报告格式，以及项目进展统计都可以有效的帮助项目管理者了解项目状态、进展，在 Daily scrum 里借助 RTC 可以清楚的展现团队成员的工作状态，整个项目运行的状态，以便在需要的时候采取相应的行动。<\/p><CMA ID: 969857><Site ID: 10><XSLT stylesheet used to transform this file: dw-document-html-7.0.xsl>\r\n\r\n\r\n<\/div>\r\n<\/div>\r\n","createTime":"2014-04-28 00:00:00","deployTime":"2014-04-28 00:00:00","id":0,"intro":"本文将分享一些在 Scrum 敏捷开发团队中，借助 RTC 来实现的项目管理的一些实践。例如在 RTC 中进行项目规划、管理、进度的跟进，人员工作状态管理，以及各种项目绩效相关的报表生成。RTC 在 Scrum 中的应用大大提高了项目管理的灵活性和准确性。","keyword":"","recommend":false,"source":"http://www.ibm.com/developerworks/cn/rational/1404_yangyan_rtcscrum/index.html","title":"RTC 在 Scrum 团队中进行项目管理的一些实践","typeId":0,"updateTime":"2014-04-28 00:00:00"}
{"author":"","clickNumber":0,"content":"\r\n<div class=\"ibm-columns\">\r\n<div class=\"ibm-col-1-1\">\r\n\r\n<h2 id=\"1.前言 |outline\">前言<\/h2><p>作为一名 Web 前端工程师，我们的工作在大多数情况下，就是与各种浏览器打交道，开发以页面为主的 Web 应用程序。为此，非常的熟悉 HTML、CSS、JavaScript 以及各类主流的 JavaScript 工具库，比如 Dojo、jQuery、YUI 等。但是，浏览器的安全沙盒把我们限制在了一个小小的圈子里，我们不能用 JavaScript 访问操作系统的本地文件系统，不能发起一个 Socket 请求, 不能获取 CPU 和内存的使用情况, 也不能访问关系型数据库或者 NoSQL 数据库。<\/p><p>您是否一直在憧憬着，某一天，您使用着您最拿手的前端技能，来开发那些本来由 Java,、C++等语言所开发的桌面应用程序呢? 很幸运，答案是肯定的！Node-webkit 这个开源项目的出现，为 Web 前端开发人员提供了一个新的舞台；它更给我们带来了一个实际的价值，让我们现有的 Web 应用，可以更方便的移植到我们的桌面上来，加以本地功能的扩展，获取更大的用户体验度。<\/p><h2 id=\"2.Node-webkit 架构概述 |outline\">Node-webkit 架构概述<\/h2><p>Node-webkit 是项目托管网站 Github 上一个非常热门的开源项目，它基于著名的浏览器开源项目 Chromium 和服务器端 JavaScript 实现 Node.js 的一个应用程序运行时环境。假如您对它还没有任何头绪，不妨可以这样来想象一下这个运行时环境：它是一个支持 HTML5 特性的全功能 Web 浏览器, 并且它没有安全沙盒的限制, 我们可以用 JavaScript 来操作 HTML DOM 对象，也可以来调用操作系统的本地资源。<\/p><h5 id=\"N10067\">图 1. Node-webkit 概览<\/h5><img alt=\"Node-webkit 概览\" src=\"/sunshine_new/images/负262912514/image003.jpg\" width=\"471\" /><p>我们来通过一段最简单的代码，窥探一下 Node-webkit 的样子:<\/p><h5 id=\"N10076\">清单 1. 简单示例代码&lt;!DOCTYPE html&gt;<\/h5><div class=\"codesection\"><pre class=\"displaycode\">&lt;html&gt;\n  &lt;head&gt;\n    &lt;title&gt;Sample App&lt;/title&gt;\n  &lt;/head&gt;\n  &lt;body&gt;\n    &lt;h1&gt;Hello World!&lt;/h1&gt;\n    We are using node.js &lt;script&gt;document.write(process.version)&lt;/script&gt;.\n  &lt;/body&gt;\n&lt;/html&gt;<\/pre><\/div><h5 id=\"N1007D\">图 2. 清单 1 代码运行结果<\/h5><img alt=\"清单 1 代码运行结果\" src=\"/sunshine_new/images/负262912514/image005.jpg\" width=\"486\" /><p><strong>安装<\/strong><\/p><p>有两种方式可以实现 Node-webkit 的安装：第一种是从其项目主页面, 下载源代码，然后自行编译安装；或者, 我们为了方便起见, 可以直接下载它提供的编译好的二进制可执行文件, 目前支持三个操作系统平台：Windows、Linux 以及 Mac。<\/p><p>我们的教程在后文中都将主要以 Windows 为例，其他平台请具体参考 Node-webkit 的项目文档。以下是安装的具体步骤：<\/p><ol type=\"1\"><li>将下载的二进制文件放到一个文件夹下，例如 C:\\Program Files\\node-webki<\/li><li>在 Windows 的环境变量 PATH 中，添加路径 C:\\Program Files\\node-webki<\/li><\/ol><p>至此, Node-webkit 安装就算完成了。我们可以在命令行中运行 nw，如果您看到如下窗口出现, 则表示 Node-webkit 在您的计算机上已完全安装成功：<\/p><h5 id=\"N10098\">图 3. 成功运行 Node-Webkit 的界面<\/h5><img alt=\"成功运行 Node-Webkit 的界面\" src=\"/sunshine_new/images/负262912514/image007.jpg\" width=\"477\" /><p><strong>创建第一个 Node-webkit 应用<\/strong><\/p><p>复杂的应用从 Hello World 开始！让我们一步一步来建立我们第一个最简单易懂的 Node-webkit 应用程序。<\/p><p>首先，在您计算机上任意目录下，建立一个命名为 sample-app 的文件夹，它将被用来存放我们的示例应用程序代码和其他所有需要的资源文件；<\/p><p>然后在 sample-app 文件夹下，预建立一些空的子文件夹，用来合理的存放不同类型的文件；<\/p><p>最后，建立两个文件：index.html 和 package.json。至此，sample-app 文件夹中看起来应该是这样的一个结构：<\/p><h5 id=\"N100AF\">图 4. sample-app 包含的文件和目录<\/h5><img alt=\"sample-app 包含的文件和目录\" src=\"/sunshine_new/images/负262912514/image009.jpg\" width=\"166\" /><p>对这样一个目录结构，是不是觉得非常熟悉？没错，它就是一个标准的 Web 工程的目录结构，因为 Node-webkit 的开发继承了 Web 前端开发的一切，所以您所掌握的 Web 开发经验将使您更快速的掌握它。<\/p><p>下一步，我们来看一下 index.html 和 package.json 这两个重要文件中的内容：<\/p><h5 id=\"N100C0\">清单 2. index.html&lt;!DOCTYPE html&gt;<\/h5><div class=\"codesection\"><pre class=\"displaycode\">&lt;html&gt;\n  &lt;head&gt;\n    &lt;title&gt;Sample App&lt;/title&gt;\n  &lt;/head&gt;\n  &lt;body&gt;\n    &lt;h1&gt;Hello World!&lt;/h1&gt;\n  &lt;/body&gt;\n&lt;/html&gt;<\/pre><\/div><p>它将是我们这个应用程序的入口，现在它包含的仅仅是一段最简单的 HTML 文本，显示了一个\"Hello World!\"的问候，我们将在后文中一步步的充实它的内容。<\/p><h5 id=\"N100CA\">清单 3. package.json<\/h5><div class=\"codesection\"><pre class=\"displaycode\">{\n    \"main\": \"index.html\",\n    \"name\": \"sample-app\",\n    \"description\": \"demo app of node-webkit\",\n    \"version\": \"0.1.0\",\n    \"window\": {\n        \"toolbar\": false,\n        \"resizable\": false,\n        \"width\": 800,\n        \"height\": 500\n    }\n}<\/pre><\/div><p>该文件是 node-webkit 的应用描述文件，一个完整的 node-webkit 应用程序必须包含这样一个文件。它用于定义应用程序的基本信息以及运行相关的参数，比如名称、介绍、入口文件名称以及应用程序窗口的各项配置，如窗口的显示尺寸、显示位置、是否显示工具栏等等。您可以阅读 <a href=\"https://github.com/rogerwang/node-webkit/wiki/Manifest-format\">Node-webkit 描述文件格式<\/a>来获取更多相关信息。<\/p><p><strong>运行<\/strong><\/p><p>以上这些文件构成了一个最简单基本的 node-webkit 程序。我们非常清楚如何让一个 HTML 文件在浏览器中运行起来，但是，在 node-webkit 环境下，如何让它运行起来呢？<\/p><p>打开您的命令行工具，进入 sample-app 所在的目录，然后执行命令：nw sample-app<\/p><p>成功运行中的窗口界面如下所示：<\/p><h5 id=\"N100DF\">图 5. sample-app 运行结果<\/h5><img alt=\"sample-app 运行结果\" src=\"/sunshine_new/images/负262912514/image011.jpg\" width=\"435\" /><p><strong>基于 Dojo 来设计桌面应用<\/strong><\/p><p>好了，我们接下来要在前文的基础上，使用 Node-webkit 开发个稍微像样一点的东西。<\/p><p>开发一个专业的应用程序，界面的开发永远是一个重头，将耗费相当多的时间和精力。我们现代 Web 页面应用的开发中，通常会采用一些设计良好、功能强大、界面组件丰富的工具库，它们可以极大的加速我们的开发，减少我们的工作量，并且提高代码质量。例如 Dojo、jQuery 等就是一些我们经常采用的开源工具库，它们成熟、功能强、兼容性好，并且有强大的开发维护社区的支持。而 Dojo 是我个人比较喜欢的一个，它包含了丰富的基础 API 和界面组件（布局，表单，表格，图表等等），面向对象，高度模块化，可扩展性和可定制性非常强，所以非常适合开发各种不同规模的应用程序。在本教程中，我们将使用 Dojo 作为我们的开发辅助工具。<\/p><p>如今，基于 Web 技术的软件应用朝着单页化的方向发展，前端开发的复杂度已经远远超出我们的预期，如何让我们的软件设计层次清晰，又做到代码实现简单明了，即用最少的代码实现更多的功能，是我们的迫切需求。Dojo 为我们提供了非常有用的工具包 dojox.mvc，它是 Dojo 的一个对目前非常流行的前端 MVC 的思想的实现，主要关注前端的 View 和 Model 之间的数据绑定，能实时同步表单控件和 Model 数据，无论哪一方发生变化，另一方都会进行实时更新。其能够简化本来在 JavaScript 中处理表单的繁杂重复的代码。<\/p><p>我们下面要使用 Dojo 来构建我们整个应用程序的框架。这个应用程序将向您展示 2 个小示例，以此来阐明如何在 Node-webkit 环境下调用本地功能，以及如何访问外部数据资源。<\/p><p>我们的 index.html 现在看起来已经充实了很多，使用了 Dojo 组件来创建和布局整个应用的界面。下面是一部分关键代码：<\/p><h5 id=\"N100F9\">清单 4. index.html<\/h5><div class=\"codesection\"><pre class=\"displaycode\">&lt;script type=\"dojo/require\"&gt;at: \"dojox/mvc/at\"&lt;/script&gt;\n\n&lt;span id=\"ctrl\" data-dojo-type=\"dojox/mvc/EditModelRefController\" \n            data-dojo-props=\"sourceModel: models.sysinfo\"&gt;&lt;/span&gt;\n\n&lt;div id=\"appLayout\" data-dojo-type=\"dijit/layout/BorderContainer\" \ndata-dojo-props=\"design: 'headline'\"&gt;\n  &lt;div class=\"centerPanel\" data-dojo-type=\"dijit/layout/TabContainer\" \n           data-dojo-props=\"region: 'center', tabPosition: 'bottom'\"&gt;\n    &lt;!-- tab 1 --&gt;\n    &lt;div data-dojo-type=\"dijit/layout/ContentPane\" title=\"本地功能调用示例\"&gt;\n      &lt;div style=\"border:1px solid #cccccc\"&gt;\n        &lt;table&gt;\n          &lt;tr&gt;\n            &lt;td&gt;计算机名：&lt;/td&gt;\n            &lt;td&gt;&lt;span data-dojo-type=\"dojox/mvc/Output\" \n                data-dojo-props=\"value: at('widget:ctrl', 'hostname')\"&gt;&lt;/span&gt;&lt;/td&gt;\n          &lt;/tr&gt;\n          &lt;tr&gt;\n            &lt;td&gt;操作系统类型：&lt;/td&gt;\n            &lt;td&gt;\n              &lt;span data-dojo-type=\"dojox/mvc/Output\" \n              data-dojo-props=\"value: at('widget:ctrl', 'ostype')\"&gt;&lt;/span&gt;\n              &lt;span data-dojo-type=\"dojox/mvc/Output\" \n              data-dojo-props=\"value: at('widget:ctrl', 'platform')\"&gt;&lt;/span&gt;\n            &lt;/td&gt;\n          &lt;/tr&gt;\n          &lt;tr&gt;\n            &lt;td&gt;CPU 架构：&lt;/td&gt;\n            &lt;td&gt;&lt;span data-dojo-type=\"dojox/mvc/Output\" \n                data-dojo-props=\"value: at('widget:ctrl', 'arch')\"&gt;&lt;/span&gt;&lt;/td&gt;\n          &lt;/tr&gt;\n          &lt;tr&gt;\n            &lt;td&gt;CPU 核心数：&lt;/td&gt;\n            &lt;td&gt;&lt;span data-dojo-type=\"dojox/mvc/Output\" \n               data-dojo-props=\"value: at('widget:ctrl', 'cpus')\"&gt;&lt;/span&gt;&lt;/td&gt;\n          &lt;/tr&gt;\n        &lt;/table&gt;\n      &lt;/div&gt;\n\n      &lt;div style=\"margin-top:10px;padding: 8px;border:1px solid #cccccc\"&gt;\n        &lt;span&gt;内存使用情况:&lt;/span&gt;\n        &lt;div id=\"mem-pie-chart\" style=\"width:550px;height:280px;\"&gt;&lt;/div&gt;\n      &lt;/div&gt;\n    &lt;/div&gt;\n\n    &lt;!-- tab 2 --&gt;\n    &lt;div data-dojo-type=\"dijit/layout/ContentPane\" title=\"远程数据访问示例\"&gt;\n      &lt;div id=\"feed-toolbar\"&gt;&lt;/div&gt;\n      &lt;div id=\"feed-list\"&gt;&lt;/div&gt;\n    &lt;/div&gt;\n  &lt;/div&gt;\n&lt;/div&gt;<\/pre><\/div><p>下面是实际的运行效果图：<\/p><h5 id=\"N10101\">图 6. 本地功能调用示例运行界面<\/h5><img alt=\"本地功能调用示例运行界面\" src=\"/sunshine_new/images/负262912514/image013.jpg\" width=\"494\" /><p><strong>本地功能调用<\/strong><\/p><p>上面示例程序的第一个选项卡，展示的是一个调用并展示计算机系统信息的功能。由于 Node-webkit 内置了 Node.js，所以调用计算机本地功能和资源的工作主要都是通过它的 API 来完成。我们的应用使用了 Node.js 的 OS 模块，用以读取计算机的基本信息：<\/p><h5 id=\"N10113\">清单 5. 读取本地系统信息<\/h5><div class=\"codesection\"><pre class=\"displaycode\">// 加载 nodejs OS 模块\nvar os = global.require('os');\n\n//通过调用 nodejs api，获取本地计算机的内存使用信息\nvar getMemoryData = function() {\n    var fm = os.freemem();\n    var um = os.totalmem() - fm;\n    return [\n        { x: \"1\", y: fm, text: \"Free\" },\n        { x: \"1\", y: um, text: \"Used\" }\n    ];\n}\n\n//通过调用 nodejs api,获取本地计算机的基本信息\nvar getSystemInfo = function() {\n    return {\n        hostname: os.hostname(),\n        ostype: os.type(),\n        platform: os.platform(),\n        arch: os.arch(),\n        cpus: os.cpus().length\n    };\n}<\/pre><\/div><p>读写本地文件系统也是桌面应用程序经常会用到的功能，以下代码段展示如何完成此任务：<\/p><h5 id=\"N1011B\">清单 6. 读写本地文件<\/h5><div class=\"codesection\"><pre class=\"displaycode\">  var fs = global.require('fs');\n  \n  fs.readFile('/your/file.txt', function(err, data) {\n  if (err) throw err;\n  console.log(data);\n  });\n  \n  fs.writeFile('/your/file.txt', 'Hello World', function(err) {\n  if (err) throw err;\n  console.log('Saved!');\n  });<\/pre><\/div><p>注意：Dojo 和 Nodejs 都包含 require API，为了避免冲突，所以请使用 global.require()来限定作用域，以正确调用 Nodejs 的 require API。<\/p><p><strong>远程数据访问<\/strong><\/p><p>我们应用程序的第二个选项卡，展示如何访问远程数据。在 Web 开发中，Ajax，JSONP 等方式已经非常流行，这些技术在 Node-webkit 环境下仍然是可用的。在我们的程序中就使用了 Dojo 提供的 Ajax API 来获取 IBM DeveloperWorks 网站的 RSS 数据：<\/p><h5 id=\"N10128\">图 7. 远程数据访问示例运行界面<\/h5><img alt=\"远程数据访问示例运行界面\" src=\"/sunshine_new/images/负262912514/image015.jpg\" width=\"494\" /><h5 id=\"N10135\">清单 7. 读取远程 RSS<\/h5><div class=\"codesection\"><pre class=\"displaycode\">request('http://www.ibm.com/developerworks/cn/views/global/rss/libraryview.jsp', {\n    handleAs: 'xml'\n}).then(function(data){\n    var items = data.getElementsByTagName('item');\n\n    for (var i = 0; i &lt; items.length; i++) {\n        var item = items[i];\n        var children = item.children;\n\n        var title = children[0].textContent;\n        var description = children[1].textContent;\n        var link = children[2].textContent;\n        var pubdate = new Date(Date.parse(children[3].textContent));\n\n        var feed = domConstruct.toDom([\n            '&lt;div class=\"feed\"&gt;',\n                '&lt;h4&gt;&lt;a href=\"', link, '\" target=\"_blank\"&gt;', title, '&lt;/a&gt;&lt;/h4&gt;',\n                '&lt;p&gt;内容概要： ', description, '&lt;/p&gt;',\n                '&lt;div&gt;发布时间： ', locale.format(pubdate), '&lt;/div&gt;',\n            '&lt;/div&gt;'\n        ].join(''));\n\n        dom.byId('feed-list').appendChild(feed);\n    }\n});<\/pre><\/div><p>除了使用 Ajax，JSONP 等这些浏览器提供的远程数据访问方式，在 Node-webkit 中另外还可以使用 Nodejs 的 http，https 和 net 等模块 API 来发起系统原生的 HTTP 和 Socket 请求，与远程服务器进行数据交互。<\/p><h5 id=\"N1013E\">清单 8. 使用 Socket 与服务器交互<\/h5><div class=\"codesection\"><pre class=\"displaycode\">var net = require('net');\n\nvar client = net.connect({ port: 8088 }, function() {\n  console.log('client connected');\n  client.write('hello world!\\r\\n'); //向服务器端发送 hello world!\n});\n\nclient.on('data', function(data) {\n  console.log(data.toString());   //接受到服务器端发送来的数据\n  client.end();\n});\n\nclient.on('end', function() {\n  console.log('client disconnected');\n});<\/pre><\/div><p><strong>调试<\/strong><\/p><p>调试 Node-webkit 应用，我们一般借助它自带的开发者工具。要使用这个工具，首先我们要在 package.json 中，将 window 设置项中的 toolbar 设置为 true，之后在运行程序的窗口上会出现顶部的工具栏，在工具栏内点击右边如下图红框中的按钮，则会弹出开发者工具(Developer Tools)，点击\"Sources\"选项卡，出现的就是一个代码调试工具：<\/p><h5 id=\"N10149\">图 8. Node-webkit 调试工具界面<\/h5><img alt=\"Node-webkit 调试工具界面\" src=\"/sunshine_new/images/负262912514/image017.jpg\" width=\"566\" /><p>通过该调试工具，我们可以选择需要调试的代码文件，对代码行设置断点，设置要监视的变量等等，然后进行单步调试，并获取调试结果信息。<\/p><p><strong>打包与发布<\/strong><\/p><p>在一个应用程序开发完成后，将其打包成方便于发布的格式是我们必须做的事情。完成我们的 Node-webkit 应用程序的打包步骤如下：<\/p><p>步骤 1：将 sample-app 目录下的所有文件添加到一个 zip 格式的压缩文件 sample-app.zip 中，请确认 package.json 在这个 zip 文件中处于跟目录的位置；<\/p><p>步骤 2：将 sample-app.zip 重命名成 sample-app.nw；<\/p><p>步骤 3：在命令行中运行 nw sample-app.nw，确认能正确运行；<\/p><p>.nw 文件就是 Node-webkit 最基本的发布格式。如果您有需求需要将应用程序打包成.exe 或.app 等可执行文件的格式，您可以参阅<a href=\"https://github.com/rogerwang/node-webkit/wiki/How-to-package-and-distribute-your-apps\">Node-webkit 打包指南<\/a>了解更多打包相关的详细内容，以达到您的目标。<\/p><p><strong>结束语<\/strong><\/p><p>随着 HTML5 的日趋成熟和广泛应用，基于 Web 技术的软件开发已经不甘心局限于传统概念的网页开发，它们的触角已经快速伸向了各个软件开发领域，比如 PhoneGap 移动应用开发, Adobe Air 应用开发等等，让 HTML，CSS，JavaScript 这些技术拥有了跟多新的表现力以及更强的生命力。深度挖掘我们已经掌握的知识和技能，让我们的工作变得更有生产力和更有趣。<\/p><CMA ID: 969806><Site ID: 10><XSLT stylesheet used to transform this file: dw-document-html-7.0.xsl>\r\n<h2 id=\"download\">下载<\/h2><table class=\"ibm-data-table dw-download-table\" cellpadding=\"0\" cellspacing=\"0\" border=\"0\"><thead><tr><th scope=\"col\">描述<\/th><th scope=\"col\">名字<\/th><th scope=\"col\">大小<\/th><\/tr><\/thead><tbody><tr><th scope=\"row\" class=\"ibm-table-row\">示例代码<\/th><td nowrap=\"nowrap\"><a href=\"http://www.ibm.com/developerworks/apps/download/index.jsp?contentid=969806&amp;filename=sample-app.zip&amp;method=http&amp;locale=zh_CN\">sample-app.zip<\/a><\/td><td nowrap=\"nowrap\">5KB<\/td><\/tr><\/tbody><\/table>\r\n\r\n<\/div>\r\n<\/div>\r\n","createTime":"2014-04-28 00:00:00","deployTime":"2014-04-28 00:00:00","id":0,"intro":"本文主要介绍如何使用 Dojo 这个功能强大的工具库以及 Node-webkit 这个新奇有趣的开源技术来创建完全基于 JavaScript 的本地桌面应用程序，让作为前端工程师的开发人员充分利用自己已经掌握的一些技能，扩大自己技能的适用范围。","keyword":"","recommend":false,"source":"http://www.ibm.com/developerworks/cn/web/1404_zhangkai_nodewebkit/index.html","title":"使用 Dojo 和 node-webkit 开发跨平台桌面应用","typeId":0,"updateTime":"2014-04-28 00:00:00"}
