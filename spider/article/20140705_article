{"author":"","clickNumber":0,"content":"\r\n<div class=\"ibm-columns\">\r\n<div class=\"ibm-col-1-1\">\r\n\r\n<div class=\"dw-sidebar ibm-inset\"><h2 id=\"N10073\">虚拟化的四个维度<\/h2><p>CPU<br />内存<br />磁盘输入/输出（I/O）及存储<br />网络<\/p><\/div><p>这个由两部分组成的系列文章将通过具体示例探讨虚拟化的优缺点。在<a href=\"http://www.ibm.com/developerworks/cn/rational/smart-virtualization-1/\">第 1 部分<\/a>中，我们将从总体上解释虚拟化，尤其是它与 IBM Rational 软件的关系。我们将覆盖虚拟化的四个维度，CPU、内存、磁盘输入/输出（I/O）及存储、网络等应如何通过关联性（专用资源）被恰当地管理而不会过度承诺。我们所给出的例子展示了被恰当管理的虚拟化是如何彻底影响  IBM&#174; Rational&#174; 产品。尤其是我们所展示的两个案例分析，其中的 IBM&#174; Rational Team Concert&#8482; 及 IBM&#174; Rational&#174; ClearCase&#174; 托管在没有关联性配置的虚拟机中，虚拟环境配置欠佳，从而使之性能糟糕。<\/p><p>在第 2 部分中，我们将更加深入探究针对过度承诺的折中考虑。基于我们在 Rational 产品和曾服务客户身上测试得来的经验，我们将提供建议和技巧，故障排除和特定于供应商的示例来帮助您更好地管理您的虚拟化基础设施。所有提及的故障排除场景和建议都来自 <a href=\"https://jazz.net/wiki/bin/view/Deployment/VirtualizationTroubleshooting\">jazz.net Deployment wiki<\/a>。<\/p><h2 id=\"casestudyno3\">案例分析 3. 结合 ClearCase\n                探索过度承诺（overcommitment）<\/h2><p>案例分析 2 演示了当托管在没有专用资源的虚拟机（VM）上时，IBM Rational ClearCase 是如何糟糕。我们建议要为 IBM Rational 产品配置关联性和专用资源，来避免可能存在的过度承诺。然而，我们也认识到受管理的过度承诺对于虚拟化而言仍然具有显著的价值。案例分析 3 着眼于不同程度的过度承诺。<\/p><p>在我们其中之一的测试中，我们考察了一台拥有 4 个八核 CPU 及 64 GB内存的 Intel Westmere-EX 服务器。这台服务器启用了超线程，对于虚拟机管理程序（hypervisor）而言，这台拥有 32 个核心的服务器就如同拥有 64 个逻辑处理器（64 vCPU）。ClearCase CM 服务器安装在其中一个拥有 4 vCPU 和 8 GB RAM 的 VM 上，但没有专用资源或关联性。<\/p><p>在同一个虚拟机管理程序上我们还创建了 96 个拥有 4 vCPU 和 4 GB RAM 的 VM（64-位 RHEL 5.5）。这些 96 个镜像被用于产生背景负载。这 96 个镜像被组织成六组 16 VM 群组。每一个 16-VM 群组包括 64 vCPU 和 64 GB RAM，这与 Westmere-EX 自身的硬件维度是相符合的。因此每一个 16-VM 群组都 100%　体现了 Westmere-EX 服务器的硬件配给。<\/p><p>为了捕获基线平均响应时间数据（如表 1 a 行所示），我们仿真了 100 个用户的 UCM 负载并传递给 ClearCase CM 服务器。所有六组\n                VM 则处于挂起状态。<\/p><p>在下一个测试（表 1 中 b 行到 g 行），我们使用了六组 16 VM 的群组来创建背景负载。每一个 VM 都托管一个本机程序，运行多线程的平方根数学计算并分配了内存。这一“贪婪”程序确保每一个 VM 客户端将会 100% 消耗为它分配的处理器和内存。每一个测试以 16 个 VM 或 100% 相应的 Westmere-EX 服务器物理硬件为单位增加背景负载。<\/p><p>行 b 显示了 100 个用户 CC CM 服务器测试的平均响应时间数据，以及相应的 100% 的 Westmere-EX 负载（一组 16 VM 都运行“贪婪”程序）。行 c 到行 g 显示了 100 用户 CC CM 服务器测试随着逐步增加每一组 16 VM 的平均响应时间数据（每一步都逐步增加 100% 相应的 Westmere-EX 服务器负载）。<\/p><p>行 g 显示了在所有 96 个 VM 都在运行“贪婪”程序，即 600% 物理 Westmere-EX 服务器容量的情况下，我们的 100 个用户 CC CM 服务器测试的平均响应时间。响应时间非常糟糕。我们过度承诺的服务器无法在合理的响应时间内为 100 个用户 CC 负载提供服务。<\/p><p>让我们的服务器保证合理的性能的唯一办法是运行在一个具有专用资源的 VM 上。行 h 显示了与行 g 相同的测试，但 CC CM 服务器具有关联性和专用资源。在 600% 的负载下，CC CM 服务器以可接受的性能进行了响应。<\/p><h5 id=\"Table1\">表 1：使用 ClearCase 来展示关联性效果的性能测试<\/h5><table border=\"0\" cellpadding=\"0\" cellspacing=\"0\" class=\"ibm-data-table\" summary=\"9 column table with heading row and center-aligned content\"><thead xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"><tr><th>&#160;<\/th><th>a<br />物理机器<\/th><th>b<br />100% 无关联性的负载<\/th><th>c<br />200% 无关联性的负载<\/th><th>d<br />300% 无关联性的负载<\/th><th>e<br />400% 无关联性的负载<\/th><th>f<br />500% 无关联性的负载<\/th><th>g<br />600% 无关联性的负载<\/th><th>h<br />600% 有关联性的负载<\/th><\/tr><\/thead><tbody xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"><tr><td><strong>产生流<\/strong><\/td><td><strong>1.03<\/strong><\/td><td> 1.57 <\/td><td><strong>1.87<\/strong><\/td><td> 3.48 <\/td><td> 29.81 <\/td><td> 39.76 <\/td><td> 153.29 <\/td><td><strong>1.88<\/strong><\/td><\/tr><tr><td><strong>产生活动<\/strong><\/td><td><strong>0.33<\/strong><\/td><td> 0.50 <\/td><td><strong>0.55<\/strong><\/td><td> 1.64 <\/td><td> 24.84 <\/td><td> 44.35 <\/td><td> 176.21 <\/td><td><strong>0.61<\/strong><\/td><\/tr><tr><td><strong>集活动<\/strong><\/td><td><strong>0.59<\/strong><\/td><td> 0.92 <\/td><td><strong>1.04<\/strong><\/td><td> 3.59 <\/td><td> 68.55 <\/td><td> 69.45 <\/td><td> 159.14 <\/td><td><strong>0.99<\/strong><\/td><\/tr><tr><td><strong>产生目录<\/strong><\/td><td><strong>1.98<\/strong><\/td><td> 2.78 <\/td><td><strong>3.04<\/strong><\/td><td> 4.93 <\/td><td> 64.72 <\/td><td> 70.43 <\/td><td> 161.33 <\/td><td><strong>3.35<\/strong><\/td><\/tr><tr><td><strong>检出目录<\/strong><\/td><td><strong>0.72<\/strong><\/td><td> 0.91 <\/td><td><strong>0.97<\/strong><\/td><td> 2.08 <\/td><td> 30.82 <\/td><td> 38.17 <\/td><td> 125.30 <\/td><td><strong>1.12<\/strong><\/td><\/tr><tr><td><strong>检入目录<\/strong><\/td><td><strong>0.61<\/strong><\/td><td> 0.78 <\/td><td><strong>0.82<\/strong><\/td><td> 1.35 <\/td><td> 11.86 <\/td><td> 13.73 <\/td><td> 68.03 <\/td><td><strong>0.91<\/strong><\/td><\/tr><tr><td><strong>产生文件<\/strong><\/td><td><strong>1.40<\/strong><\/td><td> 1.78 <\/td><td><strong>1.93<\/strong><\/td><td> 3.23 <\/td><td> 33.10 <\/td><td> 37.54 <\/td><td> 95.58 <\/td><td><strong>2.28<\/strong><\/td><\/tr><tr><td><strong>检出文件<\/strong><\/td><td><strong>0.91<\/strong><\/td><td> 1.25 <\/td><td><strong>1.45<\/strong><\/td><td> 1.51 <\/td><td> 3.81 <\/td><td> 5.42 <\/td><td> 68.12 <\/td><td><strong>1.47<\/strong><\/td><\/tr><\/tbody><\/table><p>这个例子展示了多个情况。没有关联性，产品的性能会大幅度降低到不可用的程度。更进一步，仅仅拥有 CC CM 服务器访问权限的 ClearCase 管理员无法理解甚至无法猜测究竟发生了什么情况。这个背景负载也许过于极端，但非常清晰地演示了过度承诺的影响。<\/p><p>不过，虚拟化并不是一个无助的命题。比较表 1 中的 c 和 h 行，这两行显示了 CC CM 服务器在没有关联性而虚拟机管理程序承担 200% 负载时，以及 CC CM 服务器有关联性而虚拟机管理程序承担 200% 负载时的情形。两种情形相似的响应时间足以表明，如果不可能有专用资源时虚拟机管理程序的能力无法承担超过 200% 负载，而对于资源有关联性的配置则可以提供可接受的响应时间。这个事实表明，如果管理得当的话，过度承诺可以成为一个切实可行的选择。<\/p><h2 id=\"casestudyno4\">案例分析 4. 过度承诺或低于承诺：性能 vs. 能力<\/h2><p>案例分析 4 比较了两个不同 VM 配置在同一台 ESX 服务器，即一台 32 vCPU 及 32 GB RAM 的 Intel SandyBridge 服务器（E5-2680 @\n                2.70GHz）上时 ClearCase 的响应时间。配置 A 使用了 100% 的 VMware ESX 的能力，而配置 B 则使用了 150%。<\/p><p>在配置 A 中，ESX 服务器托管 VOB 服务器，一个 ClearCase Remote Client（CCRC）服务器以及两个 VM 运行案例 3 中描述的“贪婪”程序。每一个 ESX 服务器上的 VM 运行 RHEL 5.6，并分配了 8 vCPU 和 8 GB RAM。配置 A 拥有  100% 专用的 ESX 硬件资源。<\/p><p>配置 B 使用配置 A 相同的四个 VM；不过，额外的两个 VM 被增加到 ESX 服务器上。这两个额外的 VM 具有 8 vCPU 及 8 GB\n                RAM 来和其他四个 VM 对齐。当所有六个镜像都在使用时（48 vCPU 及 46 GB RAM），ESX 服务器被分配了 150% 的能力。两个额外的 VM 创建了一个二级 CC 区域，并执行在两个 CC 区域之间的活动来创建在 ESX 服务器上的负载。这些活动包括导入、mklabel 及构建操作，并在测试期间持续运行。<\/p><p>在本案例的背景负载中有两台其他的 ClearCase 虚拟机组成：一台 VOB 服务器及一台 ClearCase 客户端来作为视图（view）和构建服务器，也同样执行 mklabel 和导入操作。一个专用的 1 GB 网络连接着这些服务器和其他镜像。<\/p><p>这一 ClearCase 测试环境是实际 ClearCase 开发 VOB 的一个备份。100 VOB 被散布到两台服务器上。10 个最高容量的 VOB 被托管在 VM 镜像（VOB 服务器）上。剩余的 90 个 VOB 被托管在一个分离的物理服务器上，在此服务器上还有许可证服务器（license server）和注册服务器（registry server）。<\/p><p>这一用于比较的工作负载仿真了在一个 12 小时的时间段内大约 250 个并发用户。背景工作负载由以下方面组成：<\/p><ul class=\"ibm-bullet-list\"><li>200 个 CCRC 用户每小时执行 15 次事务<\/li><li>50 个动态视图用户用户每小时执行 15 次事务<\/li><li>38 个持续 clearmake 构建运行在 12 个不同的额外构建主机上（Unix 及 Windows）<\/li><li>1 台独立的 Unix 客户端运行集成任务<\/li><\/ul><h5 id=\"Table2\">表 2. 两个 ESX 服务器配置<\/h5><table border=\"0\" cellpadding=\"0\" cellspacing=\"0\" class=\"ibm-data-table\" summary=\"\"><thead xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"><tr><th>&#160;<\/th><th> 配置 A<br /> （运行 100% 能力的 ESX 服务器）<\/th><th> 配置 B<br /> （运行 150% 能力的 ESX 服务器）<\/th><\/tr><\/thead><tbody xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"><tr><td> ESX 服务器 <br />(32 vCPU，32 GB RAM) <\/td><td> 服务器托管 4 个镜像: <ul class=\"ibm-bullet-list\"><li>1 台 VOB 服务器<\/li><li>1 台 CCRC 服务器<\/li><li>2 台“贪婪”服务器<\/li><\/ul><\/td><td> 服务器托管 6 个镜像: <ul class=\"ibm-bullet-list\"><li>1 台 VOB 服务器<\/li><li>1 台 CCRC 服务器<\/li><li>2 台“贪婪”服务器<\/li><li>2 台 CC 服务器在分离的区域<\/li><\/ul><\/td><\/tr><\/tbody><\/table><p>图 1 比较了两个配置在超过 12 个小时的平均相应时间。相比配置 A，对于基本 ClearCase 操作配置 B 慢了 35%，UCM 操作慢了 25%。构建时间也慢了 22%。<\/p><h5 id=\"fig01\">图 1. 比较两种 ClearCase 环境<\/h5><img alt=\"当 ESX 服务器能力被分配在 150% 时 ClearCase 慢了\" src=\"/sunshine_new/images/1555978846/image001.jpg\" width=\"815\" /><p><strong>进一步探讨关联性和预订<\/strong><\/p><p>在第 1 部分，我们定义了关联性来作为在一台虚拟机上专用一个或更多资源的能力，这些资源来自虚拟机管理程序的相应资源。在一些虚拟机管理程序中，还有预订（reservation）的概念。预订在含义上与我们用来表达关联性的概念相一致。在这些系统中关联性标志着更多的是一个 VM 的 CPU 可以恰好指派给多少个物理核心。如果您指派您的专用 VM 到特定的 CPU，您也应同样分配您其余的 VM 到不同的 CPU 上。具有 CPU 关联性的 VM 或许性能更糟糕，因为他们也许无法被安排到多线程任务上。<\/p><p>我们建议 VM 拥有对虚拟机管理程序专用资源的访问。对于虚拟机管理程序是超线程，或者虚拟机管理程序被设计用于执行资源的自动化加载平衡的情形，还有一些额外的概念需要记住。<\/p><h3 id=\"2.1.CPUaffinityconsiderations|outline\">CPU 关联性注意事项<\/h3><p>如果使用 CPU 关联性，考虑以下问题：<\/p><ul class=\"ibm-bullet-list\"><li>如果您的虚拟机管理程序使用自动化加载平衡，CPU 关联性将会阻止虚拟机管理程序有效地工作。<\/li><li>在一个 VM 上的 CPU 关联性可能会阻止同一个虚拟机管理程序上的其他 VM 虚拟机管理程序。<\/li><li>在从一个虚拟机管理程序上将一个具有 CPU 关联性的 VM 移动到另外一个虚拟机管理程序上时，有可能会需要不同的处理器配置。<\/li><li>在多核或超线程机器上的 CPU 关联性将有可能阻止 VM 安排多线程任务，因为它对指定核心的请求是有限的。<\/li><\/ul><h2 id=\"summaryandconclusions\">总结和结论<\/h2><p>这一由两部分组成的系列文章探讨了虚拟化的优点和缺点，并使用了两个特定于 IBM Rational 产品的示例。<\/p><p>在第 1 部分中，我们覆盖了四个重要的维度，这些参数在使用虚拟化时必须被恰好判断：CPU、内存、磁盘 I/O 和存储，以及网络。我们强调了关联性（专用资源）的重要性，以及演示了当资源被过度承诺时有可能会发生的情况。<\/p><p>我们还提供了关于管理较差的虚拟化可能会大幅影响 IBM Rational 产品性能的示例。我们也展示了两个案例，其中的 IBM Rational Team Concert 和 IBM Rational ClearCase 当它们被托管在没有配置关联性，配置较差的虚拟环境上时性能很糟糕。<\/p><p>在第 2 部分中，我们更深入地了解了对过度承诺的权衡。<\/p><p>根据我们测试 IBM Rational 产品以及我们以往建议客户的经验，我们提供了建议和提示，故障排除策略和特定用户的示例，来帮助管理您的虚拟化基础设施。故障排除情形和建议可以从 <a href=\"https://jazz.net/wiki/bin/view/Deployment/VirtualizationTroubleshooting\">jazz.net Deployment wiki<\/a> 上看到。<\/p><h3 id=\"3.1.Virtualization’skeyadvantages|outline\">虚拟化的关键优势<\/h3><ul class=\"ibm-bullet-list\"><li>当前市场上所提供的硬件倾向于使它们自身更好地被分割和被虚拟机管理程序所使用，来托管多虚拟机。这些新机器节省空间和电力消耗，而且更加有效利用资源。<\/li><li>虚拟化基础设施可以增加部署新 VM 的速度（复制已有的 VM 或新的可立即使用的 VM）。<\/li><li>高可用（High-availability，HA）以及灾难恢复（Disaster Recovery，DR）解决方案可以与虚拟化一起集成，来获得更完整和有效成本的企业级配置。然而，需要注意的是，在一个单独的虚拟机管理程序上托管多个 VM 可能会导致一个单点失败。您可以了解这一特定领域，并使用 SAN 或 NAS 存储来为 VM 镜像和/或在一个备用的虚拟机管理程序上部署已准备要用的 VM。<\/li><li>VM 及它们的虚拟机管理程序可以从任何地点通过终端被管理（而不仅仅是在一个实验室中），从而可以优化和减少管理成本。<\/li><\/ul><p>了解完所给出关于较差管理的虚拟化可能出现的陷阱，您可能仍旧疑问这是否真的值得投资和劳神。但答案是非常值得！虚拟化是一个值得的投资，但我们也强调，虚拟化必须被恰当管理。在一些组织里，虚拟化是必然和永久的。消失的是专用的物理硬件、专用于托管一个单独应用的单台服务器。那些硬件厂商都在趋向于生产能增加更多处理器和内存的平台，切分新的硬件给虚拟机是最佳的方式来确保资源的有效性。<\/p><h3 id=\"3.2.Keyprinciplesdiscussedinthisseries|outline\">这一系列所讨论的关键原则<\/h3><ul class=\"ibm-bullet-list\"><li>尽可能分配 CPU、内存和网络作为专用资源。确保可以通过专用的 I/O 访问充足的共用存储。<\/li><li>只要可能，考虑 CPU 及内存关联性。在某些案例中，这将导致同一台主机上的其他 VM 性能变差。在某些案例中，虚拟机管理程序会作为集群的一部分，牵制资源可能会阻止整个家族的 VM 得以优化运行。这些是针对所有 VM 在 CPU 和内存资源无法被专用或预订时的一些性能权衡策略。<\/li><li>只要可能，通过监管资源消耗来管理您的虚拟化资源。了解有哪些其他的产品被托管在同一台 VM 上，以及那些被同一个虚拟机管理程序所托管的其它 VM 在做些什么。<\/li><li>只要可能，避免资源过度承诺。也就是说，任何 VM 或 VM 组合的资源永远不应超过虚拟机管理程序的物理资源。<\/li><li>如果您怀疑有与虚拟化相关的问题，收集关于 VM 配置、虚拟机管理程序和其他被同一个虚拟机管理程序托管的 VM 的特定数据。避免有偏见的信息，并使用脚本来收集特定，也许是定期的度量信息。<\/li><\/ul><h3 id=\"3.3.SpecialIBMRationalproductconsiderations|outline\">IBM Rational 产品应特别考虑的因素<\/h3><p>不同的软件产品的表现很不同。在某一个 VM 上的某一个产品上使用得很好虚拟化参数不一定对其他的产品有效。在这一系列文章中，我们检验了 Rational Team Concert 及 Rational ClearCase。其他 Rational 产品也许会表现得类似，也或许完全不同，这就是我们强调要理解虚拟化的各个关键维度的原因。<\/p><p>例如复杂多层应用程序，例如 Rational 协作化生命周期管理（Rational Collaborative Lifecycle Management）产品或 Rational ClearCase 要求就近访问专用资源。我们曾一起工作过的客户就曾遇到过由于并未强制执行上诉所列出的关键原则，而导致其在虚拟环境中的 Rational 产品性能很差的情形。<\/p><h2 id=\"creditsandacknowledgements\">致谢<\/h2><p>本文作者感谢我们的同事 Tim Lee、Chetna Warade、David Schlegel、Paul Weiss、Matthias Lee、Samir Shah、Harry Abadi 及 Poornima Seetharamaiah，我们在 Rational 支持和开发团队的同事，以及我们在 Intel、NetApp 和 VMware 的业务合作伙伴。<\/p><CMA ID: 974968><Site ID: 10><XSLT stylesheet used to transform this file: dw-document-html-7.0.xsl>\r\n\r\n\r\n<\/div>\r\n<\/div>\r\n","createTime":"2014-06-19 00:00:00","deployTime":"2014-06-19 00:00:00","id":0,"intro":"如果您目前正在 IBM Rational 软件上使用虚拟化方法，是否一切都像您预期的一样顺利？三位 IBM 专家将介绍 Rational 视角下的虚拟化，以及虚拟化环境从 Rational 应用程序中获取最优性能的关键要求。在第 2 部分，他们将展现更多的案例及和故障排除技巧。","keyword":"","recommend":false,"source":"http://www.ibm.com/developerworks/cn/rational/smart-virtualization-2/index.html","title":"利用虚拟化成就智慧: 第 2 部分 使用 IBM 软件的最佳实践","typeId":0,"updateTime":"2014-06-19 00:00:00"}
{"author":"","clickNumber":0,"content":"\r\n<div class=\"ibm-columns\">\r\n<div class=\"ibm-col-1-1\">\r\n\r\n<div class=\"dw-sidebar ibm-inset\"><h2 id=\"N10073\">虚拟化的四个维度<\/h2><p>CPU<br />内存<br />磁盘输入/输出（I/O）及存储<br />网络<\/p><\/div><p>这个由两部分组成的系列文章将通过具体示例探讨虚拟化的优缺点。在<a href=\"http://www.ibm.com/developerworks/cn/rational/smart-virtualization-1/\">第 1 部分<\/a>中，我们将从总体上解释虚拟化，尤其是它与 IBM Rational 软件的关系。我们将覆盖虚拟化的四个维度，CPU、内存、磁盘输入/输出（I/O）及存储、网络等应如何通过关联性（专用资源）被恰当地管理而不会过度承诺。我们所给出的例子展示了被恰当管理的虚拟化是如何彻底影响  IBM&#174; Rational&#174; 产品。尤其是我们所展示的两个案例分析，其中的 IBM&#174; Rational Team Concert&#8482; 及 IBM&#174; Rational&#174; ClearCase&#174; 托管在没有关联性配置的虚拟机中，虚拟环境配置欠佳，从而使之性能糟糕。<\/p><p>在第 2 部分中，我们将更加深入探究针对过度承诺的折中考虑。基于我们在 Rational 产品和曾服务客户身上测试得来的经验，我们将提供建议和技巧，故障排除和特定于供应商的示例来帮助您更好地管理您的虚拟化基础设施。所有提及的故障排除场景和建议都来自 <a href=\"https://jazz.net/wiki/bin/view/Deployment/VirtualizationTroubleshooting\">jazz.net Deployment wiki<\/a>。<\/p><h2 id=\"casestudyno3\">案例分析 3. 结合 ClearCase\n                探索过度承诺（overcommitment）<\/h2><p>案例分析 2 演示了当托管在没有专用资源的虚拟机（VM）上时，IBM Rational ClearCase 是如何糟糕。我们建议要为 IBM Rational 产品配置关联性和专用资源，来避免可能存在的过度承诺。然而，我们也认识到受管理的过度承诺对于虚拟化而言仍然具有显著的价值。案例分析 3 着眼于不同程度的过度承诺。<\/p><p>在我们其中之一的测试中，我们考察了一台拥有 4 个八核 CPU 及 64 GB内存的 Intel Westmere-EX 服务器。这台服务器启用了超线程，对于虚拟机管理程序（hypervisor）而言，这台拥有 32 个核心的服务器就如同拥有 64 个逻辑处理器（64 vCPU）。ClearCase CM 服务器安装在其中一个拥有 4 vCPU 和 8 GB RAM 的 VM 上，但没有专用资源或关联性。<\/p><p>在同一个虚拟机管理程序上我们还创建了 96 个拥有 4 vCPU 和 4 GB RAM 的 VM（64-位 RHEL 5.5）。这些 96 个镜像被用于产生背景负载。这 96 个镜像被组织成六组 16 VM 群组。每一个 16-VM 群组包括 64 vCPU 和 64 GB RAM，这与 Westmere-EX 自身的硬件维度是相符合的。因此每一个 16-VM 群组都 100%　体现了 Westmere-EX 服务器的硬件配给。<\/p><p>为了捕获基线平均响应时间数据（如表 1 a 行所示），我们仿真了 100 个用户的 UCM 负载并传递给 ClearCase CM 服务器。所有六组\n                VM 则处于挂起状态。<\/p><p>在下一个测试（表 1 中 b 行到 g 行），我们使用了六组 16 VM 的群组来创建背景负载。每一个 VM 都托管一个本机程序，运行多线程的平方根数学计算并分配了内存。这一“贪婪”程序确保每一个 VM 客户端将会 100% 消耗为它分配的处理器和内存。每一个测试以 16 个 VM 或 100% 相应的 Westmere-EX 服务器物理硬件为单位增加背景负载。<\/p><p>行 b 显示了 100 个用户 CC CM 服务器测试的平均响应时间数据，以及相应的 100% 的 Westmere-EX 负载（一组 16 VM 都运行“贪婪”程序）。行 c 到行 g 显示了 100 用户 CC CM 服务器测试随着逐步增加每一组 16 VM 的平均响应时间数据（每一步都逐步增加 100% 相应的 Westmere-EX 服务器负载）。<\/p><p>行 g 显示了在所有 96 个 VM 都在运行“贪婪”程序，即 600% 物理 Westmere-EX 服务器容量的情况下，我们的 100 个用户 CC CM 服务器测试的平均响应时间。响应时间非常糟糕。我们过度承诺的服务器无法在合理的响应时间内为 100 个用户 CC 负载提供服务。<\/p><p>让我们的服务器保证合理的性能的唯一办法是运行在一个具有专用资源的 VM 上。行 h 显示了与行 g 相同的测试，但 CC CM 服务器具有关联性和专用资源。在 600% 的负载下，CC CM 服务器以可接受的性能进行了响应。<\/p><h5 id=\"Table1\">表 1：使用 ClearCase 来展示关联性效果的性能测试<\/h5><table border=\"0\" cellpadding=\"0\" cellspacing=\"0\" class=\"ibm-data-table\" summary=\"9 column table with heading row and center-aligned content\"><thead xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"><tr><th>&#160;<\/th><th>a<br />物理机器<\/th><th>b<br />100% 无关联性的负载<\/th><th>c<br />200% 无关联性的负载<\/th><th>d<br />300% 无关联性的负载<\/th><th>e<br />400% 无关联性的负载<\/th><th>f<br />500% 无关联性的负载<\/th><th>g<br />600% 无关联性的负载<\/th><th>h<br />600% 有关联性的负载<\/th><\/tr><\/thead><tbody xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"><tr><td><strong>产生流<\/strong><\/td><td><strong>1.03<\/strong><\/td><td> 1.57 <\/td><td><strong>1.87<\/strong><\/td><td> 3.48 <\/td><td> 29.81 <\/td><td> 39.76 <\/td><td> 153.29 <\/td><td><strong>1.88<\/strong><\/td><\/tr><tr><td><strong>产生活动<\/strong><\/td><td><strong>0.33<\/strong><\/td><td> 0.50 <\/td><td><strong>0.55<\/strong><\/td><td> 1.64 <\/td><td> 24.84 <\/td><td> 44.35 <\/td><td> 176.21 <\/td><td><strong>0.61<\/strong><\/td><\/tr><tr><td><strong>集活动<\/strong><\/td><td><strong>0.59<\/strong><\/td><td> 0.92 <\/td><td><strong>1.04<\/strong><\/td><td> 3.59 <\/td><td> 68.55 <\/td><td> 69.45 <\/td><td> 159.14 <\/td><td><strong>0.99<\/strong><\/td><\/tr><tr><td><strong>产生目录<\/strong><\/td><td><strong>1.98<\/strong><\/td><td> 2.78 <\/td><td><strong>3.04<\/strong><\/td><td> 4.93 <\/td><td> 64.72 <\/td><td> 70.43 <\/td><td> 161.33 <\/td><td><strong>3.35<\/strong><\/td><\/tr><tr><td><strong>检出目录<\/strong><\/td><td><strong>0.72<\/strong><\/td><td> 0.91 <\/td><td><strong>0.97<\/strong><\/td><td> 2.08 <\/td><td> 30.82 <\/td><td> 38.17 <\/td><td> 125.30 <\/td><td><strong>1.12<\/strong><\/td><\/tr><tr><td><strong>检入目录<\/strong><\/td><td><strong>0.61<\/strong><\/td><td> 0.78 <\/td><td><strong>0.82<\/strong><\/td><td> 1.35 <\/td><td> 11.86 <\/td><td> 13.73 <\/td><td> 68.03 <\/td><td><strong>0.91<\/strong><\/td><\/tr><tr><td><strong>产生文件<\/strong><\/td><td><strong>1.40<\/strong><\/td><td> 1.78 <\/td><td><strong>1.93<\/strong><\/td><td> 3.23 <\/td><td> 33.10 <\/td><td> 37.54 <\/td><td> 95.58 <\/td><td><strong>2.28<\/strong><\/td><\/tr><tr><td><strong>检出文件<\/strong><\/td><td><strong>0.91<\/strong><\/td><td> 1.25 <\/td><td><strong>1.45<\/strong><\/td><td> 1.51 <\/td><td> 3.81 <\/td><td> 5.42 <\/td><td> 68.12 <\/td><td><strong>1.47<\/strong><\/td><\/tr><\/tbody><\/table><p>这个例子展示了多个情况。没有关联性，产品的性能会大幅度降低到不可用的程度。更进一步，仅仅拥有 CC CM 服务器访问权限的 ClearCase 管理员无法理解甚至无法猜测究竟发生了什么情况。这个背景负载也许过于极端，但非常清晰地演示了过度承诺的影响。<\/p><p>不过，虚拟化并不是一个无助的命题。比较表 1 中的 c 和 h 行，这两行显示了 CC CM 服务器在没有关联性而虚拟机管理程序承担 200% 负载时，以及 CC CM 服务器有关联性而虚拟机管理程序承担 200% 负载时的情形。两种情形相似的响应时间足以表明，如果不可能有专用资源时虚拟机管理程序的能力无法承担超过 200% 负载，而对于资源有关联性的配置则可以提供可接受的响应时间。这个事实表明，如果管理得当的话，过度承诺可以成为一个切实可行的选择。<\/p><h2 id=\"casestudyno4\">案例分析 4. 过度承诺或低于承诺：性能 vs. 能力<\/h2><p>案例分析 4 比较了两个不同 VM 配置在同一台 ESX 服务器，即一台 32 vCPU 及 32 GB RAM 的 Intel SandyBridge 服务器（E5-2680 @\n                2.70GHz）上时 ClearCase 的响应时间。配置 A 使用了 100% 的 VMware ESX 的能力，而配置 B 则使用了 150%。<\/p><p>在配置 A 中，ESX 服务器托管 VOB 服务器，一个 ClearCase Remote Client（CCRC）服务器以及两个 VM 运行案例 3 中描述的“贪婪”程序。每一个 ESX 服务器上的 VM 运行 RHEL 5.6，并分配了 8 vCPU 和 8 GB RAM。配置 A 拥有  100% 专用的 ESX 硬件资源。<\/p><p>配置 B 使用配置 A 相同的四个 VM；不过，额外的两个 VM 被增加到 ESX 服务器上。这两个额外的 VM 具有 8 vCPU 及 8 GB\n                RAM 来和其他四个 VM 对齐。当所有六个镜像都在使用时（48 vCPU 及 46 GB RAM），ESX 服务器被分配了 150% 的能力。两个额外的 VM 创建了一个二级 CC 区域，并执行在两个 CC 区域之间的活动来创建在 ESX 服务器上的负载。这些活动包括导入、mklabel 及构建操作，并在测试期间持续运行。<\/p><p>在本案例的背景负载中有两台其他的 ClearCase 虚拟机组成：一台 VOB 服务器及一台 ClearCase 客户端来作为视图（view）和构建服务器，也同样执行 mklabel 和导入操作。一个专用的 1 GB 网络连接着这些服务器和其他镜像。<\/p><p>这一 ClearCase 测试环境是实际 ClearCase 开发 VOB 的一个备份。100 VOB 被散布到两台服务器上。10 个最高容量的 VOB 被托管在 VM 镜像（VOB 服务器）上。剩余的 90 个 VOB 被托管在一个分离的物理服务器上，在此服务器上还有许可证服务器（license server）和注册服务器（registry server）。<\/p><p>这一用于比较的工作负载仿真了在一个 12 小时的时间段内大约 250 个并发用户。背景工作负载由以下方面组成：<\/p><ul class=\"ibm-bullet-list\"><li>200 个 CCRC 用户每小时执行 15 次事务<\/li><li>50 个动态视图用户用户每小时执行 15 次事务<\/li><li>38 个持续 clearmake 构建运行在 12 个不同的额外构建主机上（Unix 及 Windows）<\/li><li>1 台独立的 Unix 客户端运行集成任务<\/li><\/ul><h5 id=\"Table2\">表 2. 两个 ESX 服务器配置<\/h5><table border=\"0\" cellpadding=\"0\" cellspacing=\"0\" class=\"ibm-data-table\" summary=\"\"><thead xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"><tr><th>&#160;<\/th><th> 配置 A<br /> （运行 100% 能力的 ESX 服务器）<\/th><th> 配置 B<br /> （运行 150% 能力的 ESX 服务器）<\/th><\/tr><\/thead><tbody xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"><tr><td> ESX 服务器 <br />(32 vCPU，32 GB RAM) <\/td><td> 服务器托管 4 个镜像: <ul class=\"ibm-bullet-list\"><li>1 台 VOB 服务器<\/li><li>1 台 CCRC 服务器<\/li><li>2 台“贪婪”服务器<\/li><\/ul><\/td><td> 服务器托管 6 个镜像: <ul class=\"ibm-bullet-list\"><li>1 台 VOB 服务器<\/li><li>1 台 CCRC 服务器<\/li><li>2 台“贪婪”服务器<\/li><li>2 台 CC 服务器在分离的区域<\/li><\/ul><\/td><\/tr><\/tbody><\/table><p>图 1 比较了两个配置在超过 12 个小时的平均相应时间。相比配置 A，对于基本 ClearCase 操作配置 B 慢了 35%，UCM 操作慢了 25%。构建时间也慢了 22%。<\/p><h5 id=\"fig01\">图 1. 比较两种 ClearCase 环境<\/h5><img alt=\"当 ESX 服务器能力被分配在 150% 时 ClearCase 慢了\" src=\"/sunshine_new/images/1555978846/image001.jpg\" width=\"815\" /><p><strong>进一步探讨关联性和预订<\/strong><\/p><p>在第 1 部分，我们定义了关联性来作为在一台虚拟机上专用一个或更多资源的能力，这些资源来自虚拟机管理程序的相应资源。在一些虚拟机管理程序中，还有预订（reservation）的概念。预订在含义上与我们用来表达关联性的概念相一致。在这些系统中关联性标志着更多的是一个 VM 的 CPU 可以恰好指派给多少个物理核心。如果您指派您的专用 VM 到特定的 CPU，您也应同样分配您其余的 VM 到不同的 CPU 上。具有 CPU 关联性的 VM 或许性能更糟糕，因为他们也许无法被安排到多线程任务上。<\/p><p>我们建议 VM 拥有对虚拟机管理程序专用资源的访问。对于虚拟机管理程序是超线程，或者虚拟机管理程序被设计用于执行资源的自动化加载平衡的情形，还有一些额外的概念需要记住。<\/p><h3 id=\"2.1.CPUaffinityconsiderations|outline\">CPU 关联性注意事项<\/h3><p>如果使用 CPU 关联性，考虑以下问题：<\/p><ul class=\"ibm-bullet-list\"><li>如果您的虚拟机管理程序使用自动化加载平衡，CPU 关联性将会阻止虚拟机管理程序有效地工作。<\/li><li>在一个 VM 上的 CPU 关联性可能会阻止同一个虚拟机管理程序上的其他 VM 虚拟机管理程序。<\/li><li>在从一个虚拟机管理程序上将一个具有 CPU 关联性的 VM 移动到另外一个虚拟机管理程序上时，有可能会需要不同的处理器配置。<\/li><li>在多核或超线程机器上的 CPU 关联性将有可能阻止 VM 安排多线程任务，因为它对指定核心的请求是有限的。<\/li><\/ul><h2 id=\"summaryandconclusions\">总结和结论<\/h2><p>这一由两部分组成的系列文章探讨了虚拟化的优点和缺点，并使用了两个特定于 IBM Rational 产品的示例。<\/p><p>在第 1 部分中，我们覆盖了四个重要的维度，这些参数在使用虚拟化时必须被恰好判断：CPU、内存、磁盘 I/O 和存储，以及网络。我们强调了关联性（专用资源）的重要性，以及演示了当资源被过度承诺时有可能会发生的情况。<\/p><p>我们还提供了关于管理较差的虚拟化可能会大幅影响 IBM Rational 产品性能的示例。我们也展示了两个案例，其中的 IBM Rational Team Concert 和 IBM Rational ClearCase 当它们被托管在没有配置关联性，配置较差的虚拟环境上时性能很糟糕。<\/p><p>在第 2 部分中，我们更深入地了解了对过度承诺的权衡。<\/p><p>根据我们测试 IBM Rational 产品以及我们以往建议客户的经验，我们提供了建议和提示，故障排除策略和特定用户的示例，来帮助管理您的虚拟化基础设施。故障排除情形和建议可以从 <a href=\"https://jazz.net/wiki/bin/view/Deployment/VirtualizationTroubleshooting\">jazz.net Deployment wiki<\/a> 上看到。<\/p><h3 id=\"3.1.Virtualization’skeyadvantages|outline\">虚拟化的关键优势<\/h3><ul class=\"ibm-bullet-list\"><li>当前市场上所提供的硬件倾向于使它们自身更好地被分割和被虚拟机管理程序所使用，来托管多虚拟机。这些新机器节省空间和电力消耗，而且更加有效利用资源。<\/li><li>虚拟化基础设施可以增加部署新 VM 的速度（复制已有的 VM 或新的可立即使用的 VM）。<\/li><li>高可用（High-availability，HA）以及灾难恢复（Disaster Recovery，DR）解决方案可以与虚拟化一起集成，来获得更完整和有效成本的企业级配置。然而，需要注意的是，在一个单独的虚拟机管理程序上托管多个 VM 可能会导致一个单点失败。您可以了解这一特定领域，并使用 SAN 或 NAS 存储来为 VM 镜像和/或在一个备用的虚拟机管理程序上部署已准备要用的 VM。<\/li><li>VM 及它们的虚拟机管理程序可以从任何地点通过终端被管理（而不仅仅是在一个实验室中），从而可以优化和减少管理成本。<\/li><\/ul><p>了解完所给出关于较差管理的虚拟化可能出现的陷阱，您可能仍旧疑问这是否真的值得投资和劳神。但答案是非常值得！虚拟化是一个值得的投资，但我们也强调，虚拟化必须被恰当管理。在一些组织里，虚拟化是必然和永久的。消失的是专用的物理硬件、专用于托管一个单独应用的单台服务器。那些硬件厂商都在趋向于生产能增加更多处理器和内存的平台，切分新的硬件给虚拟机是最佳的方式来确保资源的有效性。<\/p><h3 id=\"3.2.Keyprinciplesdiscussedinthisseries|outline\">这一系列所讨论的关键原则<\/h3><ul class=\"ibm-bullet-list\"><li>尽可能分配 CPU、内存和网络作为专用资源。确保可以通过专用的 I/O 访问充足的共用存储。<\/li><li>只要可能，考虑 CPU 及内存关联性。在某些案例中，这将导致同一台主机上的其他 VM 性能变差。在某些案例中，虚拟机管理程序会作为集群的一部分，牵制资源可能会阻止整个家族的 VM 得以优化运行。这些是针对所有 VM 在 CPU 和内存资源无法被专用或预订时的一些性能权衡策略。<\/li><li>只要可能，通过监管资源消耗来管理您的虚拟化资源。了解有哪些其他的产品被托管在同一台 VM 上，以及那些被同一个虚拟机管理程序所托管的其它 VM 在做些什么。<\/li><li>只要可能，避免资源过度承诺。也就是说，任何 VM 或 VM 组合的资源永远不应超过虚拟机管理程序的物理资源。<\/li><li>如果您怀疑有与虚拟化相关的问题，收集关于 VM 配置、虚拟机管理程序和其他被同一个虚拟机管理程序托管的 VM 的特定数据。避免有偏见的信息，并使用脚本来收集特定，也许是定期的度量信息。<\/li><\/ul><h3 id=\"3.3.SpecialIBMRationalproductconsiderations|outline\">IBM Rational 产品应特别考虑的因素<\/h3><p>不同的软件产品的表现很不同。在某一个 VM 上的某一个产品上使用得很好虚拟化参数不一定对其他的产品有效。在这一系列文章中，我们检验了 Rational Team Concert 及 Rational ClearCase。其他 Rational 产品也许会表现得类似，也或许完全不同，这就是我们强调要理解虚拟化的各个关键维度的原因。<\/p><p>例如复杂多层应用程序，例如 Rational 协作化生命周期管理（Rational Collaborative Lifecycle Management）产品或 Rational ClearCase 要求就近访问专用资源。我们曾一起工作过的客户就曾遇到过由于并未强制执行上诉所列出的关键原则，而导致其在虚拟环境中的 Rational 产品性能很差的情形。<\/p><h2 id=\"creditsandacknowledgements\">致谢<\/h2><p>本文作者感谢我们的同事 Tim Lee、Chetna Warade、David Schlegel、Paul Weiss、Matthias Lee、Samir Shah、Harry Abadi 及 Poornima Seetharamaiah，我们在 Rational 支持和开发团队的同事，以及我们在 Intel、NetApp 和 VMware 的业务合作伙伴。<\/p><CMA ID: 974968><Site ID: 10><XSLT stylesheet used to transform this file: dw-document-html-7.0.xsl>\r\n\r\n\r\n<\/div>\r\n<\/div>\r\n","createTime":"2014-06-19 00:00:00","deployTime":"2014-06-19 00:00:00","id":0,"intro":"如果您目前正在 IBM Rational 软件上使用虚拟化方法，是否一切都像您预期的一样顺利？三位 IBM 专家将介绍 Rational 视角下的虚拟化，以及虚拟化环境从 Rational 应用程序中获取最优性能的关键要求。在第 2 部分，他们将展现更多的案例及和故障排除技巧。","keyword":"","recommend":false,"source":"http://www.ibm.com/developerworks/cn/rational/smart-virtualization-2/index.html","title":"利用虚拟化成就智慧: 第 2 部分 使用 IBM 软件的最佳实践","typeId":0,"updateTime":"2014-06-19 00:00:00"}
{"author":"","clickNumber":0,"content":"\r\n<div class=\"ibm-columns\">\r\n<div class=\"ibm-col-1-1\">\r\n\r\n<p>我习惯于使用 Windows 桌面应用程序跟踪待办事项列表。每次记起一些重要的东西时，我都会打开它，键入一个简短标签，分配一个截止日期，然后保存它。我每次登录到系统中时，该应用程序都会启动，所以我能立刻了解需要注意的事项和完成时间。<\/p><p>这个 Windows 应用程序很好用，但有两个不足之处：在离开计算机后，我不能检查待办事项列表或添加任务。<\/p><div class=\"ibm-pull-quote ibm-inset\"><blockquote><p><em><span class=\"ibm-pullquote-open\">“<\/span>然后我发现了 Google Tasks。它支持在路途中检查我的任务和添加新任务。<span class=\"ibm-pullquote-close\">”<\/span><\/em><\/p><\/blockquote><p class=\"ibm-pullquote-source\"/><\/div><p>\n                Google Tasks 与 Gmail 集成在了一起（但知道这一点的人并不多），而且它支持在线创建和管理待办事项列表。因为可以通过浏览器访问任务列表，所以您可以很容易添加、查看和关闭任务，甚至在路途中也是如此。\n\n                <\/p><p class=\"ibm-button-link-alternate\"><a href=\"https://hub.jazz.net/project/vvaswani/tasks?utm_source=developerWorks&amp;utm_medium=article&amp;utm_content=mo-php-todolist-app&amp;utm_campaign=dW%20CloudOE%20content\">获取代码<\/a><\/p><h2 id=\"N10077\">构建待办事项列表应用程序需要做的准备工作<\/h2><ul class=\"ibm-bullet-list\"><li>一个 Apache/PHP 开发环境<\/li><li>一个用于测试用途的 Google 帐户<\/li><li><a href=\"http://www.slimframework.com/\">Slim<\/a><p>这个 PHP 微型框架将向您的 PHP 代码添加结构。<\/p><\/li><li><a href=\"http://code.google.com/p/google-api-php-client/\">Google APIs Client Library for PHP<\/a><p>这个库提供了一种健全的 OAuth 实现和包装器对象，简化了对所有 Google API 的访问。 \n                        <\/p><\/li><li><a href=\"http://jquerymobile.com\">jQuery Mobile<\/a><p>这个框架能迅速让您应用程序的用户界面投入正常使用，平台和浏览器兼容性问题很少。<\/p><\/li><\/ul><p class=\"dw-article-ps-see-blk\"><span class=\"dw-article-ps-see-head\">阅读：<\/span><a class=\"dw-article-ps-see\" href=\"https://developers.google.com/accounts/docs/OAuth2\">OAuth 2.0 身份验证<\/a><\/p><h2 id=\"N100A3\">您将需要知道的事项<\/h2><p>像其他许多 Google 产品一样，Google Tasks 公开了一个 <a href=\"https://developers.google.com/google-apps/tasks/v1/reference\">Tasks API<\/a>，它允许第三方应用程序连接到它，并围绕它的数据构建自定义应用程序。这个 API（遵循 REST 模型）可通过任何具有 REST 功能的开发工具包进行访问，而且已经拥有针对许多常见编程语言的客户端库，包括我最喜爱的 PHP。<\/p><p>要理解这里给出的 PHP 示例代码，您应当对 PHP 中的类和对象的基本知识有一定的了解，而且习惯使用 REST。您还应当熟悉 HTML、CSS 和 jQuery。<\/p><p>让我们开始吧！<\/p><h2 id=\"N100B5\">配置依赖性库和组件<\/h2><p> 首先设置 Slim。<\/p><p>如果不熟悉 Slim，它是一个用于快速开发 Web 应用程序和 API 的 PHP 微型框架。不要被它的名称所误导：Slim 包含一个复杂的 URL 路由器，而且支持页面模板、flash 消息、加密 cookie 和中间件。它非常容易理解和使用，而且具有优秀的文档和一个热心开发人员社区。<\/p><h3 id=\"N100C2\">第 1 步. 使用 Slim 和 Google OAuth 库创建应用程序目录<\/h3><p>更改到 Web 服务器的文档根目录（通常在 Linux 上为 <code>/usr/local/apache/htdocs<\/code>，在 Windows 上为 <code>C:\\Program Files\\Apache\\htdocs<\/code>），然后为应用程序创建一个新的子目录。将此目录命名为 <code>tasks<\/code>。<\/p><div class=\"codesection\"><pre class=\"displaycode\">shell&gt; cd /usr/local/apache/htdocs\nshell&gt; mkdir tasks<\/pre><\/div><p>此目录在本文中被称为 <code>$APP_ROOT<\/code>。<\/p><p>假设您已经下载了上一节中介绍的 Slim 框架和 Google OAuth 库，并将这些库提取到 <code>$APP_ROOT/vendor<\/code> 中。另外，您已经将 <code>index.php<\/code> 和 <code>.htaccess<\/code> 文件从 Slim 下载压缩文件传输到您的 <code>$APP_ROOT<\/code> 目录，编辑 <code>index.php<\/code> 文件，以便反映 <code>Slim.php<\/code> 文件的正确路径。<\/p><p>您的目录结构现在应类似于：<\/p><img alt=\"项目目录结构\" src=\"/sunshine_new/images/负1526964253/image1.jpg\" width=\"217\" /><h3 id=\"N100F8\">第 2 步. 定义一个虚拟主机<\/h3><p>为了使得应用程序更易于访问，一个不错的想法是定义一个新虚拟主机并将它设置为工作目录。为此，需要编辑 Apache 配置文件（<code>httpd.conf<\/code> 或 <code>httpd-vhosts.conf<\/code>），向其中添加以下行：<\/p><div class=\"codesection\"><pre class=\"displaycode\">NameVirtualHost 127.0.0.1\n&lt;VirtualHost 127.0.0.1&gt;\n    DocumentRoot \"/usr/local/apache/htdocs/tasks\"\n    ServerName tasks.melonfire.com\n&lt;/VirtualHost&gt;<\/pre><\/div><p>这些行定义了一个新虚拟主机，该主机的文档根目录对应于 <code>$APP_ROOT<\/code>。在上面的清单中，此主机的名称为 <code>tasks.melonfire.com<\/code>。请记住，您需要将此名称更改为 <code>localhost<\/code> 或在您控制之下的另一个域。<\/p><p>重新启动 Web 服务器，以便激活这些新设置。请注意，可能有必要更新您网络的本地 DNS 服务器，让它也知道这个新主机。<\/p><p>完成这些操作之后，在浏览器中打开您的新主机。您会看到 Slim 框架欢迎页面：<\/p><img alt=\"Slim 默认欢迎页面\" src=\"/sunshine_new/images/负1526964253/image2.jpg\" width=\"599\" /><h3 id=\"N1011E\">第 3 步. 向 Google Apps Platform 注册您的应用程序<\/h3><p>使用 Google Tasks API 之前，需要向 Google 注册您的 Web 应用程序。为此，需要使用您的 Google Account 凭据登录到 Google 并访问 <a href=\"https://cloud.google.com/console\">Google Cloud Console<\/a>。创建一个新项目，为它分配一个名称，然后开启对 Google Tasks API 的访问权。您的项目在 Google Cloud Console 看起来应类似于：<\/p><img alt=\"Google Cloud Console 中的 API 访问\" src=\"/sunshine_new/images/负1526964253/image3.jpg\" width=\"664\" /><p>接下来，注册您的 Web 应用程序，以获得 OAuth 2.0 客户端 ID 和密钥。记下这些值，Google PHP OAuth 客户端需要使用它们。<\/p><img alt=\"Google Cloud Console 中的 OAuth 凭据\" src=\"/sunshine_new/images/负1526964253/image4.jpg\" width=\"502\" /><p>请记住，您还要在这里设置应用程序重定向 URL。在完成 OAuth 身份验证流程后，Google 会将客户端浏览器重定向到这个 URL。在根示例中，此 URL 被设置为 <code>http://tasks.melonfire.com/login<\/code>：<\/p><img alt=\"Google Cloud Console 中的重定向 URL 设置\" src=\"/sunshine_new/images/负1526964253/image5.jpg\" width=\"467\" /><p>登录后，您还应当访问 Gmail，其中包含一个 <a href=\"https://support.google.com/mail/answer/106237?hl=en\">集成的 Google Tasks 界面<\/a>，向它添加一些示例任务列表和任务。这对检查 PHP 应用程序能否正常工作很有用。Gmail 中的 Google Tasks 界面类似于：\n                <\/p><img alt=\"Gmail 中的 Google Tasks 界面\" src=\"/sunshine_new/images/负1526964253/image6.jpg\" width=\"542\" /><p>看起来像是要完成许多挂钩，好消息是您只需完成一次即可。<\/p><h2 id=\"N10156\">了解 Tasks API<\/h2><p>Google Tasks API 接受对在资源上执行操作的 REST 请求，使用请求的信息作为响应。<em>资源<\/em> 只是一个 URL，引用可对其执行操作的对象或实体，比如 <code>/lists<\/code> 或 <code>/users<\/code>。<em>操作<\/em> 是 4 个 HTTP “动词” 之一，比如 GET（检索）、POST（创建）、PUT（更新）和 DELETE（删除）。<\/p><p>Google Tasks API 包含两种主要资源：任务和任务列表。用户可拥有多个任务列表，每个列表可拥有多个任务。任务始终存在于任务列表中。Google Tasks API 会将用户创建的第一个任务列表视为他或她的 “默认” 任务列表。<\/p><p>Google Tasks API 使用 JSON 格式编码响应。以下是一个 API 响应示例，它向 <code>https://www.googleapis.com/tasks/v1/lists/@default/tasks<\/code> 发出一个经过验证的 GET 请求，这是检索用户的默认任务列表的 API 端点。<\/p><h5 id=\"c1\">清单 1. Google Tasks API 响应示例<\/h5><div class=\"codesection\"><pre class=\"displaycode\">{\n \"kind\": \"tasks#tasks\",\n \"etag\": \"\\\"zhaMOBt\\\"\",\n \"items\": [\n  {\n   \"kind\": \"tasks#task\",\n   \"id\": \"MTc3Mz\",\n   \"etag\": \"\\\"zhaMOBt\\\"\",\n   \"title\": \"Milk\",\n   \"updated\": \"2013-11-11T07:46:09.000Z\",\n   \"selfLink\": \"https://www.googleapis.com/tasks/v1/lists/MTc3Mz/tasks/MTc3MzQ1\",\n   \"position\": \"00000000000637427684\",\n   \"status\": \"needsAction\"\n  },\n  {\n   \"kind\": \"tasks#task\",\n   \"id\": \"MTc3Mz\",\n   \"etag\": \"\\\"zhaMOBt\\\"\",\n   \"title\": \"Bread\",\n   \"updated\": \"2013-11-11T07:46:11.000Z\",\n   \"selfLink\": \"https://www.googleapis.com/tasks/v1/lists/MTc3Mz/tasks/MTc3MzQ6\",\n   \"position\": \"00000000000717532232\",\n   \"status\": \"needsAction\"\n  },\n  {\n       ...\n  }\n ]\n}<\/pre><\/div><p>如清单 1 所示，Tasks API 生成一个 JSON 编码的响应，其中包含一个任务列表。每个任务条目包含一些有用的元数据，比如任务标题、截止日期、自己的 URL 和状态。现在编码此 JSON 并将它转换为适合在 Web 浏览器中显示的 HTML 表示会非常简单。但是，在大部分时间，您都不会向 Tasks API 发出原始的 GET 和 POST 请求。Google PHP OAuth 客户端和它的服务对象围绕这些请求提供了一个便捷的包装器，将所有相关功能封装到 PHP 对象和方法中。<\/p><h2 id=\"N1017A\">列出任务<\/h2><p>清单 2 结合使用了 Google OAuth 库和 Slim 框架来连接、验证任务列表和任务，并显示了它们的摘要。<\/p><h5 id=\"c2\">清单 2. OAuth 身份验证流和任务列表检索<\/h5><div class=\"codesection\"><pre class=\"displaycode\">&lt;?php\nsession_start();\nrequire_once 'vendor/Slim/Slim.php';\nrequire_once 'vendor/google-api-php-client/src/Google_Client.php';\nrequire_once 'vendor/google-api-php-client/src/contrib/Google_TasksService.php';\n\n\\Slim\\Slim::registerAutoloader();\n$app = new \\Slim\\Slim();\n$app-&gt;config(array(\n  'debug' =&gt; true,\n  'templates.path' =&gt; './templates'\n));\n$client = new Google_Client();\n$client-&gt;setApplicationName('Project X');\n$client-&gt;setClientId('YOUR-CLIENT-ID');\n$client-&gt;setClientSecret('YOUR-CLIENT-SECRET');\n$client-&gt;setRedirectUri('http://tasks.melonfire.com/login');\n$client-&gt;setScopes(array(\n  'https://www.googleapis.com/auth/tasks'\n));\n$app-&gt;client = $client;\n$app-&gt;tasksService = new Google_TasksService($app-&gt;client);\n\n\n$app-&gt;get('/login', function () use ($app) {\n  \n    if (isset($_GET['code'])) {\n      $app-&gt;client-&gt;authenticate();\n      $_SESSION['access_token'] = $app-&gt;client-&gt;getAccessToken();\n      $app-&gt;redirect('/index');\n      exit;\n    }  \n\n    // if token available in session, set token in client\n    if (isset($_SESSION['access_token'])) {\n      $app-&gt;client-&gt;setAccessToken($_SESSION['access_token']);\n    }\n\n    if ($app-&gt;client-&gt;getAccessToken()) {\n      if (isset($_SESSION['target'])) {\n        $app-&gt;redirect($_SESSION['target']);\n      } else {\n        $app-&gt;redirect('/index');\n      }\n    } else {\n      $authUrl = $app-&gt;client-&gt;createAuthUrl();\n      $app-&gt;redirect($authUrl);\n    }\n  \n});\n\n$app-&gt;get('/index', 'authenticate', function () use ($app) {\n  $lists = $app-&gt;tasksService-&gt;tasklists-&gt;listTasklists();\n  foreach ($lists['items'] as $list) {\n    $id = $list['id'];\n    $tasks[$id] = $app-&gt;tasksService-&gt;tasks-&gt;listTasks($id);\n  }\n  $app-&gt;render('index.php', array('lists' =&gt; $lists, 'tasks' =&gt; $tasks));\n});\n\n\n$app-&gt;get('/logout', function () use ($app) {\n  unset($_SESSION['access_token']);    \n  $app-&gt;client-&gt;revokeToken();\n});\n\n$app-&gt;run();\n\nfunction authenticate () {\n  $app = \\Slim\\Slim::getInstance();\n  $_SESSION['target'] = $app-&gt;request()-&gt;getPathInfo();\n  if (isset($_SESSION['access_token'])) {\n    $app-&gt;client-&gt;setAccessToken($_SESSION['access_token']);\n  }\n  if (!$app-&gt;client-&gt;getAccessToken()) {\n    $app-&gt;redirect('/login');\n  }\n}<\/pre><\/div><p>清单 2（应保存为 <code>$APP_ROOT/index.php<\/code>）首先加载 Slim 和 Google OAuth 客户端库，以及 Google Tasks 服务对象。它初始化一个新的 Slim 应用程序对象和一个新的 <code>Google_Client<\/code> 对象。不用说，<code>Google_Client<\/code> 对象必须配置之前在 Google Cloud Console 中定义的相同的客户端 ID、客户端密钥和重定向 URL。还会初始化一个 <code>Google_TasksService<\/code> 服务对象，该对象用作通过 PHP 与 Google Tasks API 交互的主要控制点。<\/p><p>Slim 定义 HTTP 方法和端点的路由器回调。完成方式是调用相应的方法（<code>get()<\/code> 用于 GET 请求、<code>post()<\/code> 用于 POST 请求等），并传递 URL 路由，以便匹配为该方法的第一个参数。该方法的第二个参数是一个函数，它指定了在路由与一个传入的请求匹配时应采取的操作。清单 2 设置了 3 个这样的路由器回调：<code>/index<\/code>、<code>/login<\/code> 和 <code>/logout<\/code>。我们将依次看看每个回调：<\/p><ul class=\"ibm-bullet-list\"><li><code>/login<\/code> 回调处理了 OAuth 身份验证流。有关这个流的完整讨论不属于本文的讨论范围，但您可通过 Google API 文档获取有关的详尽细节\n                    。简言之，此回调使用了 <code>Google_Client<\/code> 对象的 <code>createAuthUrl()<\/code> 方法生成 Google 身份验证页面的 URL（参见下图），然后将客户端浏览器重定向到这个 URL。在用户验证应用程序并确认它能够访问的数据后，Google 将客户端重定向回 <code>/login<\/code> URL，此 URL 将会获取一个访问令牌并将该令牌存储在会话中。这个访问令牌为客户端提供了访问 Google Tasks API 的能力。<\/li><li>成功的 OAuth 身份验证会将客户端重定向到应用程序的索引页面，位于 <code>/index<\/code>。此回调使用已配置好的 <code>Google_TasksService<\/code> 对象和它的 <code>listTasklists()<\/code> 方法来获取经过验证的用户的一组任务列。该代码然后迭代这个任务列表集合，对于每个列表，该代码都会调用服务对象的 <code>listTasks()<\/code> 方法来获取该列表中的各个任务。然后将此信息传输给视图，视图负责向用户呈现它。下文将给出视图脚本。<\/li><li><code>/logout<\/code> 方法会销毁会话，进而清空其中存储的访问令牌。为了提高安全性，它还调用了客户端对象的 <code>revokeToken()<\/code> 方法，这也会让 Google 服务器上的令牌失效。<\/li><\/ul><img alt=\"Google API 授权\" src=\"/sunshine_new/images/负1526964253/image7.jpg\" width=\"449\" /><p>您已经看到，<code>/index<\/code> 回调负责获取用户的任务列表和每个列表的任务。此信息存储在 PHP 变量中，并被传输给视图，后者负责将它格式化为容易阅读的列表。视图脚本应位于 <code>$APP_ROOT/templates/index.php<\/code>，它应类似于：<\/p><h5 id=\"c3\">清单 3. 索引页面<\/h5><div class=\"codesection\"><pre class=\"displaycode\">&lt;!DOCTYPE html&gt; \n&lt;html&gt; \n&lt;head&gt; \n  &lt;meta name=\"viewport\" content=\"width=device-width, initial-scale=1\"&gt; \n  &lt;link rel=\"stylesheet\" href=\"http://code.jquery.com/\n    mobile/1.3.2/jquery.mobile-1.3.2.min.css\" /&gt;\n  &lt;script src=\"http://code.jquery.com/jquery-1.9.1.min.js\"&gt;&lt;/script&gt;\n  &lt;script src=\"http://code.jquery.com/mobile/1.3.2/\n    jquery.mobile-1.3.2.min.js\"&gt;&lt;/script&gt;\n&lt;/head&gt; \n&lt;body&gt; \n    &lt;div data-role=\"page\"&gt;\n      &lt;div data-role=\"header\"&gt;\n      Tasks\n      &lt;/div&gt;\n      &lt;div data-role=\"content\"&gt;\n      &lt;div data-role=\"collapsible-set\" data-inset=\"false\"&gt;\n        &lt;?php foreach ($lists['items'] as $list): ?&gt;\n          &lt;?php $id = $list['id']; ?&gt;\n          &lt;div data-role=\"collapsible\"&gt;\n            &lt;h2&gt;&lt;?php echo $list['title']; ?&gt;&lt;/h2&gt;\n            &lt;ul data-role=\"listview\"&gt;\n              &lt;?php if (isset($tasks[$id]['items'])): ?&gt;\n                &lt;?php foreach ($tasks[$id]['items'] as $task): ?&gt;\n                &lt;li&gt;                \n                  &lt;h3&gt;&lt;?php echo $task['title']; ?&gt;&lt;/h3&gt; \n                &lt;/li&gt;\n                &lt;?php endforeach; ?&gt;\n              &lt;?php endif; ?&gt;\n            &lt;/ul&gt; \n          &lt;/div&gt;\n        &lt;?php endforeach; ?&gt;\n        &lt;/div&gt;\n      &lt;/div&gt;\n    &lt;/div&gt;        \n&lt;/body&gt;\n&lt;/html&gt;<\/pre><\/div><p>清单 3 设置了一个依据标准 jQuery Mobile 约定而格式化的列表视图页面。主要页面元素是一个 <code>&lt;div&gt;<\/code> 元素，它有一个 <code>data-role=\"page\"<\/code> 属性。该属性中包含针对页面页眉、页脚和内容的不同 <code>&lt;div&gt;<\/code> 元素。页面内容包含一系列可折叠的 <code>&lt;div&gt;<\/code> 元素，每个元素表示用户的一个任务列表。单击一个列表的标题会展开它的任务。<\/p><p>要查看此功能是如何实现的，您可以在浏览器中访问 <code>http://tasks.melonfire.com/index<\/code>（将该 URL 替换为您自己的虚拟主机的 URL）。您应该看到一个与以下列表类似的任务列表：<\/p><img alt=\"任务列表\" src=\"/sunshine_new/images/负1526964253/image8.jpg\" width=\"320\" /><h2 id=\"N101FD\">创建和删除任务列表<\/h2><p>当然，显示任务只是第一步；您还希望用户能够添加新任务和任务列表。那么让我们在 <code>$APP_ROOT/index.php<\/code> 中定义一个新路由：<\/p><div class=\"codesection\"><pre class=\"displaycode\">&lt;?php\n\n// ... other routes \n\n$app-&gt;get('/add-list', 'authenticate', function () use ($app) {\n  $app-&gt;render('add-list.php');    \n});<\/pre><\/div><p>借助此路由，对 <code>/add-list<\/code> 的请求将生成一个要向用户呈现的 <code>$APP_ROOT/templates/add-list.php<\/code> 模板。下一个清单显示了此模板的内容。<code>authenticate()<\/code> 函数是一个自定义函数，在执行路由回调之前执行；查看 <a href=\"#c2\">清单 2<\/a>，您会看到它检查了一个访问令牌，如果没有找到该令牌，它会将客户端重定向到登录页面，提示重新登录。 <\/p><h5 id=\"c5\">清单 4. 任务列表创建表单<\/h5><div class=\"codesection\"><pre class=\"displaycode\">&lt;!DOCTYPE html&gt; \n&lt;html&gt; \n&lt;head&gt; \n  &lt;meta name=\"viewport\" content=\"width=device-width, initial-scale=1\"&gt; \n  &lt;link rel=\"stylesheet\" href=\"http://code.jquery.com/mobile/1.3.2/\n    jquery.mobile-1.3.2.min.css\" /&gt;\n  &lt;script src=\"http://code.jquery.com/jquery-1.9.1.min.js\"&gt;&lt;/script&gt;\n  &lt;script src=\"http://code.jquery.com/mobile/1.3.2/\n    jquery.mobile-1.3.2.min.js\"&gt;&lt;/script&gt;\n&lt;/head&gt; \n&lt;body&gt; \n    &lt;div data-role=\"page\"&gt;\n      &lt;div data-role=\"header\"&gt;\n      Add List\n      &lt;/div&gt;\n      &lt;div data-role=\"content\"&gt;\n        &lt;div data-role=\"collapsible-set\"&gt;\n          &lt;form method=\"post\" action=\"/add-list\"&gt;\n            &lt;label for=\"title\"&gt;Title:&lt;/label&gt;\n            &lt;input name=\"title\" id=\"title\" data-clear-btn=\"true\" type=\"text\"/&gt;\n            &lt;input name=\"submit\" value=\"Save\" type=\"submit\" \n              data-icon=\"check\" data-inline=\"true\" data-theme=\"a\" /&gt;\n            &lt;a href=\"/index\" data-role=\"button\" data-inline=\"true\" \n              data-icon=\"back\" data-theme=\"a\"&gt;Back&lt;/a&gt;\n          &lt;/form&gt;\n      &lt;/div&gt;\n    &lt;/div&gt;\n&lt;/body&gt;\n&lt;/html&gt;<\/pre><\/div><p>清单 4 包含一个表单，其中只有一个字段，表示新任务列表的标题。提交时，表单数据将 POST 回 <code>/add-list<\/code> 路由，后者现在需要扩展来处理表单输入。以下是额外的代码：<\/p><h5 id=\"c6\">清单 5. 任务列表创建<\/h5><div class=\"codesection\"><pre class=\"displaycode\">&lt;?php\n\n// ... other routes \n\n$app-&gt;post('/add-list', 'authenticate', function () use ($app) {\n  if (isset($_POST['submit'])) {\n    $title = trim(htmlentities($_POST['title']));\n    if (empty($title)) {\n      $title = 'Untitled List';\n    }\n    $tasklist = new Google_TaskList();\n    $tasklist-&gt;setTitle($title);\n    $result = $app-&gt;tasksService-&gt;tasklists-&gt;insert($tasklist);\n    $app-&gt;redirect('/index');\n  } \n});<\/pre><\/div><p>清单 5 清除了通过表单提交的标题，然后创建一个新的 <code>Google_TaskList<\/code> 对象。此对象表示 Google Tasks API 中的一个任务列表资源。该对象的 <code>setTitle()<\/code> 方法用于分配一个标题，然后，该服务对象的 <code>insert()<\/code> 方法将新任务列表保存到 Google Tasks 中。<\/p><p>以下是这个表单，以及提交它的结果：<\/p><img alt=\"任务列表创建\" src=\"/sunshine_new/images/负1526964253/image9.jpg\" width=\"400\" /><p>如果现在检查 Gmail 中的 Google Tasks 界面，您也应该在这里看到新添加的任务列表。您可亲自尝试！<\/p><p>如果已允许用户添加列表，那么您还需要为他们提供一种删除列表的方式。服务对象的 <code>insert()<\/code> 方法的反向方法是 <code>delete()<\/code> 方法，它接受一个任务列表标识符并从 Google Tasks 删除相应的列表。以下是路由定义：<\/p><h5 id=\"c7\">清单 6. 任务列表删除<\/h5><div class=\"codesection\"><pre class=\"displaycode\">&lt;?php\n\n// ... other routes \n\n$app-&gt;get('/delete-list/:lid', 'authenticate', function ($lid) use ($app) {\n  $app-&gt;tasksService-&gt;tasklists-&gt;delete($lid);\n  $app-&gt;redirect('/index');\n});<\/pre><\/div><p>清单 6 设置一个新路由 <code>/delete-list<\/code>，它接受一个列表标识符，使用该标识符作为请求 URL 的一部分。Slim 的路由框架随后会解析这个请求 URL，提取列表标识符，使用服务对象的 <code>delete()<\/code> 方法从 Google Tasks 删除相应的列表。<\/p><p>现在所剩只有更新索引页面列清单，增添添加和删除列表的按钮。以下是修订的索引页面的代码：<\/p><h5 id=\"c8\">清单 7. 索引页面<\/h5><div class=\"codesection\"><pre class=\"displaycode\">&lt;!DOCTYPE html&gt; \n&lt;html&gt; \n&lt;head&gt; \n  &lt;meta name=\"viewport\" content=\"width=device-width, initial-scale=1\"&gt; \n  &lt;link rel=\"stylesheet\" href=\"http://code.jquery.com/mobile/1.3.2/\n    jquery.mobile-1.3.2.min.css\" /&gt;\n  &lt;script src=\"http://code.jquery.com/jquery-1.9.1.min.js\"&gt;&lt;/script&gt;\n  &lt;script src=\"http://code.jquery.com/mobile/1.3.2/\n    jquery.mobile-1.3.2.min.js\"&gt;&lt;/script&gt;\n&lt;/head&gt; \n&lt;body&gt; \n    &lt;div data-role=\"page\"&gt;\n      &lt;div data-role=\"header\"&gt;\n      Tasks\n      &lt;/div&gt;\n      &lt;div data-role=\"content\"&gt;\n      &lt;div data-role=\"collapsible-set\" data-inset=\"false\"&gt;\n        &lt;?php foreach ($lists['items'] as $list): ?&gt;\n          &lt;?php $id = $list['id']; ?&gt;\n          &lt;div data-role=\"collapsible\"&gt;\n            &lt;h2&gt;&lt;?php echo $list['title']; ?&gt;&lt;/h2&gt;\n            &lt;ul data-role=\"listview\"&gt;\n              &lt;?php if (isset($tasks[$id]['items'])): ?&gt;\n                &lt;?php foreach ($tasks[$id]['items'] as $task): ?&gt;\n                &lt;li&gt;                \n                  &lt;?php if ($task['status'] == 'needsAction'): ?&gt;\n                  &lt;h3&gt;&lt;?php echo $task['title']; ?&gt;&lt;/h3&gt; \n                  &lt;?php else: ?&gt;\n                  &lt;h3 style=\"text-decoration:line-through\"\n                    &gt;&lt;?php echo $task['title']; ?&gt;&lt;/h3&gt; \n                  &lt;?php endif; ?&gt;\n                  &lt;?php if (isset($task['due']) &amp;&amp; \n                    ($task['status'] == 'needsAction')): ?&gt;\n                  &lt;p&gt;Due on &lt;?php echo date('d M Y', \n                    strtotime($task['due'])); ?&gt;&lt;/p&gt; \n                  &lt;?php endif; ?&gt;                    \n                  &lt;?php if (isset($task['completed']) \n                    &amp;&amp; ($task['status'] == 'completed')): ?&gt;\n                  &lt;p&gt;Completed on &lt;?php echo \n                    date('d M Y', strtotime($task['completed'])); ?&gt;&lt;/p&gt; \n                  &lt;?php endif; ?&gt;                    \n                &lt;/li&gt;\n                &lt;?php endforeach; ?&gt;\n              &lt;?php endif; ?&gt;\n            &lt;/ul&gt; \n            &lt;a href=\"/delete-list/&lt;?php echo $id; ?&gt;\" \n              data-inline=\"true\" data-role=\"button\" data-icon=\"delete\" \n              data-theme=\"a\"&gt;Remove list&lt;/a&gt;\n          &lt;/div&gt;\n        &lt;?php endforeach; ?&gt;\n        &lt;/div&gt;\n      &lt;/div&gt;\n      &lt;a href=\"/add-list\" data-inline=\"true\" data-role=\"button\" \n        data-icon=\"plus\" data-theme=\"b\"&gt;Add new list&lt;/a&gt; \n    &lt;/div&gt;        \n&lt;/body&gt;\n&lt;/html&gt;<\/pre><\/div><p>除了添加和删除列表的新按钮之外，这个视图脚本版本还添加了一些额外的增强。此时我们显示了任务的截止日期，已完成的任务有一条划过它们的删除线，而仍为完成的任务 (<code>status=\"needsAction\"<\/code>) 则没有删除线。以下是该页面的显示效果。<\/p><img alt=\"任务列表\" src=\"/sunshine_new/images/负1526964253/image10.jpg\" width=\"368\" /><h2 id=\"N1026E\">创建和删除任务<\/h2><p>就像可以添加和删除任务列表一样，也可在列表中添加和删除任务。以下是用于此用途的新 <code>/add-item<\/code> 和 <code>/delete-item<\/code> 路由：<\/p><h5 id=\"c9\">清单 8. 任务添加和删除<\/h5><div class=\"codesection\"><pre class=\"displaycode\">&lt;?php\n\n// ... other routes \n\n$app-&gt;get('/add-task/:tid', 'authenticate', function ($tid) use ($app) {\n  $app-&gt;render('add-task.php', array('id' =&gt; $tid));    \n});\n\n$app-&gt;post('/add-task', 'authenticate', function () use ($app) {\n  if (isset($_POST['submit'])) {\n    $title = trim(htmlentities($_POST['title']));\n    $due = trim(htmlentities($_POST['due']));\n    $id = trim(htmlentities($_POST['id']));\n    if (empty($title)) {\n      $title = 'Untitled Task';\n    }\n    if (empty($due)) {\n      $due = 'tomorrow';\n    }\n    $task = new Google_Task();\n    $task-&gt;setTitle($title);\n    $task-&gt;setDue(date(DATE_RFC3339, strtotime($due)));\n    $result = $app-&gt;tasksService-&gt;tasks-&gt;insert($id, $task);\n    $app-&gt;redirect('/index');\n  } \n});\n\n$app-&gt;get('/delete-task/:lid/:tid', 'authenticate', function ($lid, $tid) use ($app) {\n  $app-&gt;tasksService-&gt;tasks-&gt;delete($lid, $tid);\n  $app-&gt;redirect('/index');\n});<\/pre><\/div><p>每个任务都必须与一个任务列表相关联，所以 <code>/add-task<\/code> 路由回调被设置为接收一个任务列表标识符作为 GET 请求参数。然后，它会呈现 <code>$APP_ROOT/templates/add-task.php<\/code> 模板，其中包含一个添加新任务的表单，该模板如此清单中所述：<\/p><h5 id=\"c10\">清单 9. 任务创建表单<\/h5><div class=\"codesection\"><pre class=\"displaycode\">&lt;!DOCTYPE html&gt; \n&lt;html&gt; \n&lt;head&gt; \n  &lt;meta name=\"viewport\" content=\"width=device-width, initial-scale=1\"&gt; \n  &lt;link rel=\"stylesheet\" href=\"http://code.jquery.com/mobile/1.3.2/\n    jquery.mobile-1.3.2.min.css\" /&gt;\n  &lt;link rel=\"stylesheet\" type=\"text/css\" href=\"http://dev.jtsage.com/cdn/\n    datebox/latest/jqm-datebox.min.css\" /&gt; \n  &lt;script src=\"http://code.jquery.com/jquery-1.9.1.min.js\"&gt;&lt;/script&gt;\n  &lt;script src=\"http://code.jquery.com/mobile/1.3.2/\n    jquery.mobile-1.3.2.min.js\"&gt;&lt;/script&gt;\n  &lt;script src=\"http://dev.jtsage.com/cdn/datebox/latest/\n    jqm-datebox.core.min.js\"&gt;&lt;/script&gt;\n  &lt;script src=\"http://dev.jtsage.com/cdn/datebox/latest/\n    jqm-datebox.mode.calbox.min.js\"&gt;&lt;/script&gt;\n  &lt;script src=\"http://dev.jtsage.com/cdn/datebox/i18n\n    /jquery.mobile.datebox.i18n.en_US.utf8.js\"&gt;&lt;/script&gt;\n&lt;/head&gt; \n&lt;body&gt; \n    &lt;div data-role=\"page\"&gt;\n      &lt;div data-role=\"header\"&gt;\n      Add Task\n      &lt;/div&gt;\n      &lt;div data-role=\"content\"&gt;\n        &lt;div data-role=\"collapsible-set\"&gt;\n          &lt;form method=\"post\" action=\"/add-task\"&gt;\n            &lt;input name=\"id\" type=\"hidden\" value=\"&lt;?php echo $id; ?&gt;\" /&gt;\n            &lt;label for=\"title\"&gt;Title:&lt;/label&gt;\n            &lt;input name=\"title\" id=\"title\" data-clear-btn=\"true\" type=\"text\"/&gt;\n            &lt;label for=\"due\"&gt;Due:&lt;/label&gt;\n            &lt;input name=\"due\" id=\"due\" type=\"date\" data-role=\"datebox\" \n              data-options='{\"mode\": \"calbox\", \"useFocus\": true, \n              \"themeDateToday\": \"e\"}' /&gt;\n            &lt;input name=\"submit\" value=\"Save\" type=\"submit\" \n              data-icon=\"check\" data-inline=\"true\" data-theme=\"a\" /&gt;\n            &lt;a href=\"/index\" data-role=\"button\" data-inline=\"true\" \n              data-icon=\"back\" data-theme=\"a\"&gt;Back&lt;/a&gt;\n          &lt;/form&gt;\n      &lt;/div&gt;\n    &lt;/div&gt;\n&lt;/body&gt;\n&lt;/html&gt;<\/pre><\/div><p>清单 9 包含一个具有两个可见字段的表单，一个字段用于任务标题，另一个字段用于任务截止日期。为了简化日期输入，日期输入字段被配置为使用 <a href=\"http://dev.jtsage.com/jQM-DateBox2/\">jQuery Mobile DateBox<\/a> 插件，该插件显示一个图形化的日期选取器，以便通过单击来输入日期\n                。因为任务必须与一个任务列表有关联，所以作为 GET 参数而收到的任务列表标识符也在表单中被指定为一个隐藏字段。<\/p><p>提交表单后，输入其中的数据就会被清除，并用于初始化一个 <code>Google_Task<\/code> 对象。然后这个对象与隐藏的任务列表标识符一起传递给服务对象的 <code>insert()<\/code> 方法，该方法负责通过 GEST 调用将它添加到 Google Tasks 系统中。最后，像 <code>/add-task<\/code> 回调一样，<code>/delete-task<\/code> 路由回调被配置为同时接收任务列表标识符和任务标识符。然后，它使用服务对象的 <code>delete()<\/code> 方法来从指定的任务列表中删除指定的任务。<\/p><p>在设置了路由和业务登录后，剩下的任务就是更新索引页面、添加任务添加和删除按钮。因为我很快就会介绍如何更新任务的状态，所以现在正好为此功能添加一个按钮。以下是修订后的模板：<\/p><h5 id=\"c11\">清单 10. 索引页面<\/h5><div class=\"codesection\"><pre class=\"displaycode\">&lt;!DOCTYPE html&gt; \n&lt;html&gt; \n&lt;head&gt; \n  &lt;meta name=\"viewport\" content=\"width=device-width, initial-scale=1\"&gt; \n  &lt;link rel=\"stylesheet\" href=\"http://code.jquery.com/mobile/1.3.2/\n    jquery.mobile-1.3.2.min.css\" /&gt;\n  &lt;link rel=\"stylesheet\" type=\"text/css\" \n    href=\"http://dev.jtsage.com/cdn/datebox/latest/jqm-datebox.min.css\" /&gt; \n  &lt;script src=\"http://code.jquery.com/jquery-1.9.1.min.js\"&gt;&lt;/script&gt;\n  &lt;script src=\"http://code.jquery.com/mobile/1.3.2/\n    jquery.mobile-1.3.2.min.js\"&gt;&lt;/script&gt;\n  &lt;script src=\"http://dev.jtsage.com/cdn/datebox/latest/\n    jqm-datebox.core.min.js\"&gt;&lt;/script&gt;\n  &lt;script src=\"http://dev.jtsage.com/cdn/datebox/latest/\n    jqm-datebox.mode.calbox.min.js\"&gt;&lt;/script&gt;\n  &lt;script src=\"http://dev.jtsage.com/cdn/datebox/i18n/\n    jquery.mobile.datebox.i18n.en_US.utf8.js\"&gt;&lt;/script&gt;\n&lt;/head&gt; \n&lt;body&gt; \n    &lt;div data-role=\"page\"&gt;\n      &lt;div data-role=\"header\"&gt;\n      Tasks\n      &lt;/div&gt;\n      &lt;div data-role=\"content\"&gt;\n      &lt;div data-role=\"collapsible-set\" data-inset=\"false\"&gt;\n        &lt;?php foreach ($lists['items'] as $list): ?&gt;\n          &lt;?php $id = $list['id']; ?&gt;\n          &lt;div data-role=\"collapsible\"&gt;\n            &lt;h2&gt;&lt;?php echo $list['title']; ?&gt;&lt;/h2&gt;\n            &lt;ul data-role=\"listview\"&gt;\n              &lt;?php if (isset($tasks[$id]['items'])): ?&gt;\n                &lt;?php foreach ($tasks[$id]['items'] as $task): ?&gt;\n                &lt;li&gt;                \n                  &lt;div class=\"ui-grid-b\"&gt;\n                    &lt;div class=\"ui-block-a\"&gt;\n                      &lt;?php if ($task['status'] == 'needsAction'): ?&gt;\n                      &lt;h3&gt;&lt;?php echo $task['title']; ?&gt;&lt;/h3&gt; \n                      &lt;?php else: ?&gt;\n                      &lt;h3 style=\"text-decoration:line-through\"&gt;\n                        &lt;?php echo $task['title']; ?&gt;&lt;/h3&gt; \n                      &lt;?php endif; ?&gt;\n                      &lt;?php if (isset($task['due']) &amp;&amp; \n                        ($task['status'] == 'needsAction')): ?&gt;\n                      &lt;p&gt;Due on &lt;?php echo date('d M Y', \n                        strtotime($task['due'])); ?&gt;&lt;/p&gt; \n                      &lt;?php endif; ?&gt;                    \n                      &lt;?php if (isset($task['completed']) &amp;&amp;\n                        ($task['status'] == 'completed')): ?&gt;\n                      &lt;p&gt;Completed on &lt;?php echo \n                        date('d M Y', strtotime($task['completed'])); ?&gt;&lt;/p&gt; \n                      &lt;?php endif; ?&gt;                    \n                    &lt;/div&gt;                    \n                    &lt;div class=\"ui-block-b\"&gt;&lt;/div&gt;                    \n                    &lt;div class=\"ui-block-c\"&gt;\n                      &lt;?php if ($task['status'] == 'needsAction'): ?&gt;\n                      &lt;a href=\"/update-task/&lt;?php echo $id; ?&gt;/\n                        &lt;?php echo $task['id']; ?&gt;\" data-inline=\"true\" \n                        data-role=\"button\" data-icon=\"check\" \n                        data-theme=\"a\"&gt;Done!&lt;/a&gt;\n                      &lt;?php endif; ?&gt;\n                      &lt;a href=\"/delete-task/\n                        &lt;?php echo $id; ?&gt;/&lt;?php echo $task['id']; ?&gt;\" \n                        data-inline=\"true\" data-role=\"button\" data-icon=\"delete\" \n                        data-theme=\"a\"&gt;Remove task&lt;/a&gt;\n                    &lt;/div&gt;\n                  &lt;/div&gt;\n                &lt;/li&gt;\n                &lt;?php endforeach; ?&gt;\n              &lt;?php endif; ?&gt;\n            &lt;/ul&gt; &lt;br/&gt;\n            &lt;a href=\"/add-task/&lt;?php echo $id; ?&gt;\" \n              data-inline=\"true\" data-role=\"button\" data-icon=\"plus\" \n              data-theme=\"a\"&gt;Add new task&lt;/a&gt;\n            &lt;a href=\"/delete-list/&lt;?php echo $id; ?&gt;\" \n              data-inline=\"true\" data-role=\"button\" data-icon=\"delete\" \n              data-theme=\"a\"&gt;Remove list&lt;/a&gt;\n          &lt;/div&gt;\n        &lt;?php endforeach; ?&gt;\n        &lt;/div&gt;\n        &lt;a href=\"/add-list\" data-inline=\"true\" data-role=\"button\" \n          data-icon=\"plus\" data-theme=\"b\"&gt;Add new list&lt;/a&gt; \n      &lt;/div&gt;\n    &lt;/div&gt;\n&lt;/body&gt;\n&lt;/html&gt;<\/pre><\/div><p>如清单 10 所示，每个任务列表的标记都已更新，将每个列表转换为一个两列网格。左侧列包含任务标题和截止日期。右侧列包含可为该任务执行的操作，比如更新它还是删除它。最后还有一个新按钮，该按钮支持使用新任务更新此列表。<\/p><p>向任务列表添加新任务的过程类似于：<\/p><img alt=\"任务创建\" src=\"/sunshine_new/images/负1526964253/image11.jpg\" width=\"500\" /><h2 id=\"N102BD\">更新任务状态<\/h2><p>所以，您的应用程序现在支持添加和删除任务和任务列表。您需要添加的最后一项功能是将任务标记为已完成。<a href=\"#c10\">清单 10<\/a> 已包含此功能的按钮，它被链接到 <code>/update-task<\/code> 路由。清单 11 完成了最后的工作，指定了此路由的业务逻辑。<\/p><h5 id=\"c12\">清单 11. 任务更新<\/h5><div class=\"codesection\"><pre class=\"displaycode\">&lt;?php\n\n// ... other routes \n\n$app-&gt;get('/update-task/:lid/:tid', 'authenticate', \n  function ($lid, $tid) use ($app) {\n    $task = new Google_Task($app-&gt;tasksService-&gt;tasks-&gt;get($lid, $tid));\n    $task-&gt;setStatus('completed');\n    $result = $app-&gt;tasksService-&gt;tasks-&gt;update($lid, $task-&gt;getId(), $task);\n    $app-&gt;redirect('/index');\n});<\/pre><\/div><p><code>/update-task<\/code> 路由回调同时接收列表和任务标识符，使用此信息从 Google Tasks API 获取任务信息。然后，使用此信息来填充一个新的 <code>Google_Tasks<\/code> 对象，该对象的 <code>setStatus()<\/code> 方法用于将任务的状态更改为 “completed”。服务对象的 <code>update()<\/code> 方法用于将新任务条目推送到 Google 的服务器。<\/p><p>将任务标记为已完成的过程类似于下图。<\/p><img alt=\"任务状态更新\" src=\"/sunshine_new/images/负1526964253/image12.jpg\" width=\"500\" /><h2 id=\"N102E8\">结束语<\/h2><p>大功告成！您参加了一堂速成课，了解了如何结合使用 jQuery Mobile、Google PHP OAuth 库和 Slim PHP 微型框架，将来自 Google Tasks API 的数据与 PHP 应用程序相集成。本文中的示例介绍了 Google Tasks JSON 格式，展示了如何获取任务列表；添加、修改和删除任务；以及为用户的 Google Account 中的任务列表构建一个自定义界面。<\/p><p>正如这些示例所演示的，在您希望构建新的富有创意的任务管理应用程序时，Google Tasks API 是一个强大且又灵活的工具。使用它一段时间，看看您能想到什么！<\/p><div class=\"ibm-rule dw-article-ps-topic-rule\"><hr/><\/div><p><span class=\"dw-article-ps-topic-head\">相关主题：<\/span><a class=\"dw-article-ps-topic\" href=\"http://www.ibm.com/developerworks/topics/php/\">PHP<\/a><a class=\"dw-article-ps-topic\" href=\"http://www.ibm.com/developerworks/topics/jquery mobile/\">jQuery Mobile<\/a><a class=\"dw-article-ps-topic\" href=\"http://www.ibm.com/developerworks/topics/google tasks/\">Google Tasks<\/a><\/p><CMA ID: 976430><Site ID: 10><XSLT stylesheet used to transform this file: dw-document-html-7.0.xsl>\r\n\r\n\r\n<\/div>\r\n<\/div>\r\n","createTime":"2014-07-03 00:00:00","deployTime":"2014-07-03 00:00:00","id":0,"intro":"想要构建一个简单的移动应用程序，以便创建和管理您的待办事项列表？使用 Slim PHP 微型框架、jQuery Mobile 和 Google Tasks API 很容易完成这项任务。我将展示我是怎么做的。","keyword":"","recommend":false,"source":"http://www.ibm.com/developerworks/cn/mobile/mo-php-todolist-app/index.html","title":"使用 PHP、jQuery Mobile 和 Google Tasks 创建一个移动友好的待办事项列表应用程序","typeId":0,"updateTime":"2014-07-03 00:00:00"}
{"author":"","clickNumber":0,"content":"\r\n<div class=\"ibm-columns\">\r\n<div class=\"ibm-col-1-1\">\r\n\r\n<h2 id=\"major1\">简介<\/h2><p>IBM WebSphere Lombardi Edition(简称 WLE) 是 IBM Business Process Manager(简称 BPM) 产品的前身，WLE 产品的用户为了获得 IBM BPM 的最新功能、服务与支持，需要将 WLE 迁移到 BPM 的最新版本 V8.5，同时迁移源环境的所有用户数据。<\/p><p>从 BPM V8.5 开始，产品配置和迁移的方法较之以前的版本有了较大的变化，本文将以 WLE V7.2 到 BPM V8.5 升级版的迁移为实例，详细介绍从 WLE 到 BPM V8.5 的迁移方法。<\/p><h2 id=\"major2\">源环境版本与拓扑结构<\/h2><p>在本例中，源环境 WLE V7.2 使用的操作系统为 Red Hat Linux 5.5 x86_64，数据库为 Oracle，产品版本信息见表 1。<\/p><h5 id=\"table1\">表 1 源环境产品版本信息<\/h5><table border=\"0\" cellpadding=\"0\" cellspacing=\"0\" class=\"ibm-data-table\"><thead xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"><tr><th><strong>Product/Component<\/strong><\/th><th><strong>Version<\/strong><\/th><\/tr><\/thead><tbody xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"><tr><td>\nIBM WebSphere Lombardi \n<\/td><td>\n7.2.0.4\n<\/td><\/tr><tr><td>\nIBM WebSphere Application Server Network Deployment\n<\/td><td>\n7.0.0.7\n<\/td><\/tr><tr><td>\nOracle database\n<\/td><td>\n11.2.0.2.0\n<\/td><\/tr><\/tbody><\/table><p>WLE V7.2 包括 Process Center（简称 PC）单机环境和 Process Server（简称 PS）网络集群环境。其中 PC 是开发环境，用户使用其部署和测试商业流程应用。PS 是运行环境，在 PC 上测试好的应用可以直接安装到 PS 上以用于实际的工作流程。<\/p><p>具体的产品拓扑结构如图 1 所示。<\/p><h5 id=\"img001\">图 1 WLE V7.2 拓扑结构图<\/h5><img alt=\"图 1 WLE V7.2 拓扑结构图\" src=\"/sunshine_new/images/1778502604/img001.jpg\" width=\"480\" /><h2 id=\"major3\">目标环境版本与拓扑结构<\/h2><p>本例中，目标环境 BPM V8.5 与源环境处于不同的机器上，目标环境使用的操作系统为 Red Hat Linux 6.1 x86_64，数据库为 Oracle，产品版本信息见表 2。<\/p><h5 id=\"table2\">表 2 目标环境产品版本信息<\/h5><table border=\"0\" cellpadding=\"0\" cellspacing=\"0\" class=\"ibm-data-table\"><thead xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"><tr><th><strong>Product/Component<\/strong><\/th><th><strong>Version<\/strong><\/th><\/tr><\/thead><tbody xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"><tr><td>\nIBM Business Process Manager Advanced\n<\/td><td>\n8.5.0.0\n<\/td><\/tr><tr><td>\nIBM WebSphere Application Server Network Deployment\n<\/td><td>\n8.5.0.2\n<\/td><\/tr><tr><td>\nOracle database\n<\/td><td>\n11.2.0.2.0\n<\/td><\/tr><\/tbody><\/table><p>BPM V8.5 包括 Process Center（简称 PC）和 Process Server（简称 PS），都为网络集群环境经典拓扑结构，包含一个 Deployment Manager（简称 Dmgr）和两个 Custom Node，三个 Cluster：AppTarget Cluster, Messaging Cluster 和 Support Cluster 分布在两个 Custom Node 上。<\/p><p>其中 PC 为开发环境，PS 为运行环境，与在 WLE 中的 PC 和 PS 作用相同。<\/p><p>拓扑结构如图 2 所示。<\/p><h5 id=\"img002\">图 2 BPM V8.5 拓扑结构图<\/h5><img alt=\"图 2 BPM V8.5 拓扑结构图\" src=\"/sunshine_new/images/1778502604/img002.jpg\" width=\"447\" /><h2 id=\"major4\">迁移前的准备<\/h2><p>首先，确认源环境是否准备好迁移<\/p><ol type=\"1\"><li>\n源环境可以正确启动，所有应用可以正常运行<\/li><li>\n源环境上有足够的存储空间用户做产品快照<\/li><\/ol><p>其次，确认目标环境是否支持迁移<\/p><ol type=\"1\"><li>\n 目标环境支持 BPM V8.5 安装，包括操作系统，硬件，数据库等<\/li><\/ol><p><a href=\"http://www.ibm.com/software/integration/business-process-manager/advanced/sysreqs/\">IBM Business Process Manager Advanced system requirements<\/a><\/p><ol type=\"1\"><li>\n用户对于目标环境有管理员权限<\/li><li>\n目标环境有足够的存储空间安装 BPM V8.5<\/li><li>\n将要用到的机器 IP 和 Hostname 已经互相加到了 Hosts 文件中<\/li><\/ol><p>最后，确认源环境 WLE V7.2 的产品安装和数据库都已经备份好，以备意外时恢复之用。<\/p><p>对于 WLE V7.2 需要备份其安装目录。<\/p><p>例如： tar -cvf lombardi7204.tar lombardi7204<\/p><p>恢复时 tar -xvf lombardi7204.tar<\/p><p>其中 lombardi7204 为 WLE 的安装目录<\/p><p>对于数据库需要备份使用的相应数据库。<\/p><p>例如：Exp <a href=\"mailto:PC106PS/pwd4insadmin@BPMSCAN1.cn.ibm.com:1521/BPMDB\">PC106PS/pwd4insadmin@BPMSCAN1.cn.ibm.com:1521/BPMDB<\/a> owner=PC106PS file=G:\\Oracle-Database-Backup\\7204back\\PC106PS.dmp<\/p><p>恢复时 imp PC106PS/pwd4insadmin@BPMSCAN1.cn.ibm.com:1521/BPMDB full=y <\/p><p>file=G:\\Oracle-Database-Backup\\7204back\\PC106PS.dmp<\/p><p>其中 BPMDB 为数据库名，PC106PS 为 Process Server 的数据所使用的用户名。<\/p><h2 id=\"major5\">迁移过程<\/h2><p>源环境 WLE V7.2 的 PC 和 PS 需要分别迁移到目标环境 BPM V8.5 中，对于这两个过程，迁移的方法是相同的，所以本章以 PC 为例介绍迁移过程。<\/p><h3 id=\"major6\">安装 BPM V8.5<\/h3><p>在目标环境 PC 所用的每个机器上（包括 Dmgr 和 Node 所在机器）安装 BPM V 8.5 升级版, 可以使用图形界面、命令行或者其他支持的工具来进行 BPM V8.5 安装，在本文中安装不作为的重点介绍，请参考<a href=\"http://bidoc.torolab.ibm.com/review/8500/topic/com.ibm.wbpm.imuc.ebpm.doc/topics/inst_lin.html\">Installing IBM Business Process Manager Advanced on Linux<\/a><\/p><p>在本例中，使用了自动化安装工具（仅用于测试中）进行 BPM V8.5 的安装，自动化所做操作包括：清理目标环境、下载安装文件和安装 BPM V8.5 升级版的产品。<\/p><p>当安装结束后，检查安装是否成功并在 install_root/bin 目录下运行 versionInfo 命令检验产品版本信息是否正确。<\/p><h3 id=\"major7\">生成迁移工具并拷贝到源环境<\/h3><p>由于目标环境与源环境不在同一台机器，迁移为远程迁移，需要生成 BPM V8.5 的迁移工具，并拷贝到源环境中，这个迁移工具用于生成源环境的快照。<\/p><p>在 target_install_root/bin 目录下运行 BPMCreateRemoteMigrationUtilities.sh remoteMigrationUtilities.zip，如图 3 所示。<\/p><h5 id=\"img003\">图 3 运行 BPMCreateRemoteMigrationUtilities 命令<\/h5><img alt=\"图 3 运行 BPMCreateRemoteMigrationUtilities 命令\" src=\"/sunshine_new/images/1778502604/img003.jpg\" width=\"553\" /><p>remoteMigrationUtilities.zip 文件生成在 BPM_home/util/migration/scripts 目录下，在命令行执行结果中显示了这个文件路径。<\/p><p>用 ftp 等工具从目标环境中复制 remoteMigrationUtilities.zip 文件到源环境，然后解压到源环境，并修改解压后的文件夹的权限为可读写。<\/p><p>例如：unzip .remoteMigrationUtilities.zip -d /opt/remoteMigrationUtilities<\/p><p> chmod 755 -R remoteMigrationUtilities<\/p><h3 id=\"major8\">提取源环境的数据库信息<\/h3><p>这部分在迁移过程中是可选择执行的，提取出的源环境数据库信息可以帮助用户生成用于目标环境搭建时的配置文件。<\/p><p>首先需启动源环境 PC 单机环境中的 server1，然后按照源环境的实际信息更新<\/p><p>remote_migration_utility/util/migration/resources/路径下的文件 migration.properties<\/p><p>更新内容包括：admin 用户和密码、WLE 的安装路径和 profile 名称。<\/p><p>在 remote_migration_utility/bin 目录下执行 BPMExtractDBConfiguration.sh -output output_properties_file -propertiesFile migration_properties_file，如图 4 所示。<\/p><h5 id=\"img004\">图 4 运行 BPMExtractDBConfiguration 命令<\/h5><img alt=\"图 4 运行 BPMExtractDBConfiguration 命令\" src=\"/sunshine_new/images/1778502604/img004.jpg\" width=\"554\" /><p>运行命令后，在指定目录查看生成的数据库信息文件，在 remote_migration_utility/logs/migration 目录下查看执行命令的日志文件。<\/p><h3 id=\"major9\">创建并配置 BPM V8.5 网络集群环境<\/h3><p>安装好 BPM V8.5 之后，需要按照参数文件，运行命令 BPMConfig 来创建和配置网络集群环境。<\/p><p>对于要搭建的 BPM V8.5 版本、拓扑环境和数据库的不同，参数文件也各不相同，在 BPM_home/BPM/samples/config/migration/ 目录下存储了针对不同情况的参数文件范例。<\/p><p>需要拷贝相应的参数文件到用户指定目录下，并按照具体情况进行修改。<\/p><p>本例使用的参数文件为 Advanced-PC-ThreeClusters-Oracle.properties<\/p><p>修改内容包括：deadmin、celladmin 用户名密码；数据库 hostname、数据库名称、数据库用户名和密码；Dmgr 和 Custom Node 要安装机器的 hostname 和路径。其他的参数保持默认。<\/p><p>Oracle 对于不同的数据要用不同的用户和 schema，包括 Process Server 数据、Performance data warehouse 数据、common 数据、cell 数据，其中 Process Server 数据和 Performance data warehouse 数据在 WLE V7.2 中存在，所以使用 WLE V7.2 的用户和 schema，common 数据和 cell 数据在 WLE V7.2 中不存在，需创建新的用户和 schema。<\/p><p>修改好参数文件后，在 Dmgr 所在机器 BPM_home/bin 目录下运行 BPMConfig -create -de my_environment.properties 其中 my_environment.properties 为上面修改的参数文件的完整路径。<\/p><p>如图 5 所示 BPMConfig 命令的执行开始，执行结果未在本图显示，需等待命令行输出 BPMConfig completed successfully，表示命令执行成功。<\/p><h5 id=\"img005\">图 5 运行 BPMConfig 命令<\/h5><img alt=\"图 5 运行 BPMConfig 命令\" src=\"/sunshine_new/images/1778502604/img005.jpg\" width=\"553\" /><p>在 Dmgr 所在机器成功执行 BPMConfig 之后，启动 Dmgr，然后拷贝配置文件到与 Dmgr 不在同一台机器的 Custom Node 所在机器，并在这台机器的 BPM_home/bin 目录下再运行 BPMConfig -create -de my_environment.properties，等待命令成功完成，停止 Dmgr。至此 BPM V8.5 的网络集群环境就搭建好了。<\/p><p>在 BPM_home/logs/config 目录下查看 BPMConfig 执行的日志文件。<\/p><h3 id=\"major10\">生成源环境的产品快照<\/h3><p>提取源环境的产品配置和用户定义等信息来生成源环境的产品快照，产品快照将用于接下来的迁移步骤中。<\/p><p>首先需启动源环境 WLE 所有 server，包括 server1、process server、performance server。<\/p><p>使用在提取源环境数据库部分中所更新的 migration.properties 文件。<\/p><p>在 remote_migration_utility/bin 目录下运行 BPMExtractSourceInformation.sh -backupFolder snapshot_folder -propertiesFile migration_properties_file，如图 6 所示。<\/p><h5 id=\"img006\">图 6 运行 BPMExtractSourceInformation 命令<\/h5><img alt=\"图 6 运行 BPMExtractSourceInformation 命令\" src=\"/sunshine_new/images/1778502604/img006.jpg\" width=\"554\" /><p>运行命令后，在指定目录查看生成的产品快照文件夹，并在这个文件夹下查看执行命令的日志文件。执行结果中显示了日志文件的路径。<\/p><p>把产品快照打包，拷贝到目标环境上（BPM V8.5 Dmgr 所在机器），并在目标环境上解压。<\/p><p>生成产品快照后，停止源环境，并继续在目标环境上（BPM V8.5 Dmgr 所在机器）做迁移步骤。<\/p><h3 id=\"major11\">生成数据库升级脚本和配置新数据库<\/h3><p>在这个步骤中，生成用于更新 WLE 原有数据库的脚本，和对新数据库进行配置。<\/p><p>在 BPM_home/util/migration/resources/目录下找到 migration properties 文件，按照实际信息更新文件，包括：admin 用户和密码、BPM V8.5 的安装路径、Dmgr profile 名称、用于 BPMConfig 的配置文件完整路径、原产品 WLE 的版本（例如 7.2.0.4）。<\/p><p>然后在 BPM_home/bin 目录下运行 BPMGenerateUpgradeSchemaScripts.sh -propertiesFile migration_properties_file，如图 7 所示。<\/p><h5 id=\"img007\">图 7 运行 BPMExtractSourceInformation 命令<\/h5><img alt=\"图 7 运行 BPMExtractSourceInformation 命令\" src=\"/sunshine_new/images/1778502604/img007.jpg\" width=\"553\" /><p>查看生成的用于数据库升级的脚本位于 target_deployment_manager_profile/dbscripts/Upgrade 目录下，日志信息位于 target_deployment_manager_profile/logs 目录下。<\/p><p>对于在配置文件中设置的新的数据库，需要对其进行配置和初始化。拷贝 target_deployment_manager_profile/dbscripts/Upgrade 文件夹到数据库服务器上，并执行这个文件夹下每个组件所对应子文件夹下的 create 脚本，包括：<\/p><p>createTable_BusinessSpace.sql<\/p><p>createSchema_CommonDB.sql<\/p><p>createSchema_CommonDBCellOnlyDB.sql<\/p><p>createSchema_ProcessChoreographer.sql<\/p><p>createSchema_Monitor.sql<\/p><p>createSchema_Messaging.sql<\/p><h3 id=\"major12\">升级源环境数据库<\/h3><p>这个步骤升级原 WLE V7.2 所用的数据库，以支持新 BPM V8.5 版本。<\/p><p>需要用到在上一步骤修改过的 BPM_home/util/migration/resources/migration properties 文件和生成的源环境产品快照解压的文件夹。<\/p><p>在 BPM_home/bin 目录下运行 DBUpgrade.sh -propertiesFile migration_properties_file -backupFolder snapshot_folder<\/p><p>如图 8 所示 DBUpgrade 命令的执行开始，执行结果未在本图显示，需等待命令行输出 All upgrade steps have been completed successfully，表示命令执行成功。<\/p><h5 id=\"img008\">图 8 运行 DBUpgrade 命令<\/h5><img alt=\"图 8 运行 DBUpgrade 命令\" src=\"/sunshine_new/images/1778502604/img008.gif\" width=\"658\" /><p>在 target_deployment_manager_profile/logs 目录下查看 BPMConfig 执行的日志文件。<\/p><h3 id=\"major13\">引入源环境产品快照<\/h3><p>这个步骤将源环境产品快照引入到目标环境中。<\/p><p>在做产品快照迁移前需要启动 BPM V8.5 环境，包括 Dmgr、Node angent 和所有的 Cluster，确认环境成功启动。<\/p><p>需要用到之前步骤修改过的 BPM_home/util/migration/resources/migration properties 文件和生成的源环境产品快照解压的文件夹。<\/p><p>在 BPM_home/bin 目录下运行 BPMMigrate.sh -backupFolder snapshot_folder -propertiesFile migration_properties_file<\/p><p>如图 9 所示 BPMMigrate 命令的执行开始，执行结果未在本图显示，需等待命令行输出 All steps of the migration completed successfully，表示命令执行成功。<\/p><h5 id=\"img009\">图 9 运行 BPMMigrate 命令<\/h5><img alt=\"图 9 运行 BPMMigrate 命令\" src=\"/sunshine_new/images/1778502604/img009.jpg\" width=\"553\" /><p>在 snapshot/logs 目录下查看 BPMMigrate 执行的日志文件。<\/p><h3 id=\"major14\">迁移用户配置到目标环境<\/h3><p>如果用户想继续使用源环境的性能优化参数，需手工在目标环境中进行配置。<\/p><p>如果用户修改过源环境的 100Custom.xml 等配置文件，在生成源环境产品快照时，自动把用户配置文件合并成 101CustomMigrated.xml，并在引入源环境产品快照时，引入到了目标环境中，检验<\/p><p>BPM_Home/profiles/deployment_manager_profile/config/cells/cell_name/nodes/node_name/servers/application_cluster_name/process-center/config 目录下的 101CustomMigrated.xml 文件是否生成，其中参数值是否和源环境设置的相同。<\/p><p>在 BPM V8.5 里，有些参数进入到了 WebSphere Common Configuration Model (简称 WCCM) 里，并在 WCCM 生效，所以需要手工将 101CustomMigrated.xml 相应的参数移到 WCCM 中，需要移动的参数请参考<a href=\"http://bidoc.torolab.ibm.com/review/8500/topic/com.ibm.wbpm.admin.doc/topics/csec_config_properties.html\">Security configuration properties<\/a>。<\/p><h3 id=\"major15\">重新启动目标环境 BPM V8.5<\/h3><p>在成功迁移源环境 WLE V7.2 到目标环境 BPM V8.5 之后，重新启动 BPM V8.5，步骤包括：<\/p><p>停止所有 Cluster，停止所有 Node Agent，停止 Dmgr；<\/p><p>启动 Dmgr，启动所有 Node Agent，启动所有 Cluster。<\/p><p>查看 Dmgr、所有 Node Agent 和所有 Cluster 的日志文件 SystemOut.log，检查在这个过程中是否有错误产生。<\/p><h2 id=\"major16\">迁移后的检验<\/h2><p>查看 Process Center console 是否可以显示连接的 Process Server（PS 的迁移需另外执行，步骤与 PC 迁移相同），确认源环境的用户流程应用可以正确显示。<\/p><p>例如：<a href=\"http://9.115.198.203:9080/ProcessCenter\">http://9.115.198.203:9080/ProcessCenter<\/a><\/p><p>查看 Process Portal 是否可以显示在源环境中启动的所有执行中的任务，和执行完成的任务。<\/p><p>例如：<a href=\"http://9.115.198.203:9080/ProcessPortal\">http://9.115.198.203:9080/ProcessPortal<\/a><\/p><p>在 Process Center console 上下载 Process Designer，安装并连接 BPM V8.5 可以查看和编辑 ProcessCenter 中的用户流程应用。<\/p><h2 id=\"major17\">结束语<\/h2><p>本文详细介绍了从 WLE V7.2 到 BPM V8.5 的迁移过程以及注意事项，用户可以参照本文，成功实现从 WLE 各版本到 BPM V8.5 的迁移。<\/p><CMA ID: 976447><Site ID: 10><XSLT stylesheet used to transform this file: dw-document-html-7.0.xsl>\r\n\r\n\r\n<\/div>\r\n<\/div>\r\n","createTime":"2014-07-03 00:00:00","deployTime":"2014-07-03 00:00:00","id":0,"intro":"IBM WebSphere Lombardi Edition(简称 WLE) 是 IBM Business Process Manager(简称 BPM) 产品的前身，WLE 产品的用户为了获得 IBM BPM 的最新功能、服务与支持，需要将 WLE 迁移到 BPM 的最新版本 V8.5，同时迁移源环境的所有用户数据。 从 BPM V8.5 开始，产品配置和迁移的方法较之以前的版本有了较大的变化，本文将以 WLE V7.2 到 BPM V8.5 升级版的迁移为实例，详细介绍从 WLE 到 BPM V8.5 的迁移方法。","keyword":"","recommend":false,"source":"http://www.ibm.com/developerworks/cn/websphere/library/techarticles/1407_wangxh_wlemigration/1407_wangxh_wlemigration.html","title":"WebShpere Lombardi Edition V7.2 到 IBM Business Process Manager V8.5 迁移实例","typeId":0,"updateTime":"2014-07-03 00:00:00"}
{"author":"","clickNumber":0,"content":"\r\n<div class=\"ibm-columns\">\r\n<div class=\"ibm-col-1-1\">\r\n\r\n<h2 id=\"introduction\"> 简介 <\/h2><p> InfoSphere DataStage 提供了一些强大功能，从来源系统提取数据，转换这些数据，并将它加载到目标系统中。许多 DataStage 用户需要获得能够保障数据从来源系统转移到目标系统并且绝不会丢失数据的解决方案。本文将详细介绍您可以在 InfoSphere DataStage 中用于保障数据从来源到目标的传送的各种方法。文中将介绍如何使用 Distributed Transaction Stage (DTS) 和一个事务管理器来处理分布式 XA 事务，并且不使用事务管理器来处理本地数据库事务。文本还将介绍如何使用多个输入链接和一个数据库连接器在一个本地事务内执行多个数据库操作，以及如何在将数据从 InfoSphere Data Replication 移动到 DataStage 时，使用 Change Data Capture Transaction 阶段完成有保障的传送。最后，还将介绍结合使用消息极端和数据库阶段来提供可靠的数据处理和转换服务的最佳实践。 <\/p><h2 id=\"gtwtdts\">全局事务与 DTS<\/h2><p> 本节大体介绍了 XA 2 阶段提交架构，展示了 DTS 如何通过与 WebSphere&#174; MQ 和数据库资源交互来完成全局事务。 <\/p><p> X/Open Group 标准 <em>eXtended Architecture<\/em> (XA) 定义了一个协议，在单个事务内更新多个资源。资源可以是数据库，也可以是消息系统，比如 WebSphere MQ。通过不可靠的网络连接跨多种资源实现原子性、一致性、隔离性和耐久性 (ACID)，这是一个亟待解决的困难问题。XA 使用一种 2 阶段提交 (2PC) 协议来实现此目的。事务管理器管理该协议，与多个管理数据库或消息资源事务的资源管理器进行通信。2PC 协议的两个阶段是： <\/p><ul class=\"ibm-bullet-list\"><li><strong>提交请求<\/strong>：在此阶段中，事务管理器将请求消息发送到每个资源。这些资源将事务准备到提交点，而不实际提交事务。例如，一个资源可将数据写入数据库，但将每个记录标记为未提交。然后，该资源向事务管理器发送回一条状态消息，表明是成功了还是失败了。<\/li><li><strong>提交<\/strong>：如果所有资源在第一阶段中都被报告成功，那么资源管理器会向每个资源都发送一条提交消息。这些资源会完成事务，然后向资源管理器报告它们的最终状态。如果资源管理器从任何资源收到任何失败消息，它会向所有资源发送一条中止消息，该消息会回滚它们未提交的事务。<\/li><\/ul><p> 2PC 之所以有效，是因为如果一个资源在第一阶段报告成功，那么它就为它将要提交数据做出了保证。支撑该协议的是一组握手消息，这些消息可以处理各种不同的清理条件，比如网络故障或事务中涉及的任何组件的故障。 <\/p><p> DTS 使用 WebSphere MQ 事务管理器（WebSphere MQ Server 中的一个标准功能）来协调事务与资源管理器，从而利用 2PC，如 <a href=\"#fig1\">图 1<\/a> 中所示： <\/p><h5 id=\"fig1\">图 1. DTS、MQ 和资源管理器之间的关系<\/h5><img alt=\"该图显示了 DTS、WebSphere MQ 和资源管理器之间的关系\" src=\"/sunshine_new/images/负1308183492/Figure1.png\" width=\"408\" /><p> DTS 首先连接到 WebSphere MQ，告诉事务管理器启动 XA 事务。事务管理器与资源管理器进行通信，以启动事务。DTS 然后利用 DB2、Oracle 或 WebSphere MQ 连接器向资源执行写入操作。最后，DTS 告诉事务管理器提交或回滚 XA 事务。 <\/p><p> DTS 作业通常使用 WebSphere MQ 作为数据源，使用数据库作为目标。通过使用 DTS，从来源队列到目标数据据库的传送就得到了保障：如果事务被成功提交，则会从来源队列中删除来源消息，数据会写入到目标数据库。如果该作业失败，则不会向目标数据库写入任何数据，该消息也会保留在来源队列上。这就提供了保障，因为来源消息的删除是在与目标数据库的更新相同的 XA 事务内执行的，因此两种操作要么都会执行，要么都不执行。 <\/p><p> DTS 作业通常使用<em>工作队列<\/em> 将工作分区为并行管道。工作文件的使用最好借助图表来解释，如图 2 所示： <\/p><h5 id=\"fig2\">图 2. DTS 对工作队列的使用<\/h5><img alt=\"该图显示了 Distributed Transaction DTS 对工作队列的使用\" src=\"/sunshine_new/images/负1308183492/Figure2.png\" width=\"436\" /><p> 这个作业与 WebSphere MQ 一起通过以下方式保障数据的传送： <\/p><ol><li>在本地同步点控制下，MQ Connector 从来源队列读取一条消息，以执行一次破坏性读取（也就是说，它将从队列中删除消息）。<\/li><li>MQ Connector 将该消息写入工作队列。如果并行运行，则会存在多个工作队列，每个并行管道一个工作队列。MQ Connector 随后会提交本地事务。请注意，这里使用的本地事务表明，从来源队列到工作队列移动的消息是<em>受保障的<\/em>。如果移动失败，那么删除操作将会回滚，该消息会还原到来源队列上，该作业也会中止。<\/li><li>DTS 阶段将更新写入目标数据库。<\/li><li>DTS 阶段从工作队列中删除此消息。<\/li><\/ol><p> 通过使用工作队列，MQ 来源连接器能够并行运行。这个阶段的每个实例都从来源队列读取不同的消息，因为它以一种破坏性方式读取数据，而且 WebSphere MQ 可确保多个读取器中只有一个读取器能读取任何特定的来源消息。 <\/p><p> 在提交该事务时，如果一切正常，那么工作队列和数据库更新就会被提交，这些全部在单个 XA 事务中完成。如果出现任何故障，比如数据库写入错误，该 XA 事务将会回滚，这会撤销对目标数据库的任何更改，将 MQ 消息还原到工作队列。如果该作业随后重新启动，MQConnector 首先从工作队列读取消息，并将它们提供给该作业，然后继续从来源队列中读取数据。这意味着在发生故障时，重新启动作业即可继续从上次的位置开始处理消息。 <\/p><h2 id=\"ltwtdts\"> 本地事务与 DTS<\/h2><p> 除了处理符合 XA 的资源（比如 DB2 和 Oracle）之外，DTS 还会处理不符合 XA 的资源。这包括 ODBC 和 Teradata 目标。本节将介绍如何在 DataStage 作业中利用不支持 XA 架构的资源，以及如何仍然实现有保障的传送。还将介绍这种设计模式的缺陷和优势。 <\/p><p> DTS 处理非 XA 资源的方式是，除了 XA 事务之外，创建一个或多个 “本地” 事务。在此上下文中，一个资源由连接属性惟一地定义，比如数据库和用于访问该数据库的用户名。如果有多个访问同一个资源（也就是同一个数据库，使用相同的用户凭据）的链接，那么可以跨这些链接使用单个事务。在提交时，本地事务会在 XA 事务之前提交。这次本地提交可能获得成功，这是最可能发生的情形，也可能会失败，这会导致资源回滚该事务。在提交或回滚本地事务后，就会提交或回滚 XA 事务。在结合使用本地事务和 XA 事务时，可能的提交或回滚场景包括： <\/p><ul class=\"ibm-bullet-list\"><li>本地提交成功，然后 XA 提交成功（正常的情况）。<\/li><li>本地提交成功，但 XA 提交失败（极少发生）。<\/li><li>本地提交失败。在发生这种情况时，DTS 会回滚 XA 事务。如果在回滚 XA 事务之前，DTS 发生崩溃或发生了其他某种系统故障，MQ 事务管理器会自动回滚它。<\/li><\/ul><p>对于回滚：<\/p><ul class=\"ibm-bullet-list\"><li>本地回滚成功，然后发生 XA 回滚。<\/li><li>本地回滚失败。此场景不会实际发生；资源会假设一个回滚位置，除非系统要求提交它们，并且可以成功完成该提交请求。<\/li><\/ul><p> 在这些场景中，惟一要担忧的是第二种场景，也就是本地事务提交成功，但后续 XA 提交失败。在这种情况下，最糟的情形是数据在本地事务下被写入到目标数据库，但消息队列在来源队列上。如果出现这种情形，只要该作业是幂等的，就可以再次运行它。在前面描述的所有可能场景中，都不会丢失数据。下一节将介绍如何创建可在作业失败时重新启动的幂等作业。 <\/p><h2 id=\"iadsj\">幂等性和 DataStage 作业 <\/h2><p> 本节将介绍如何编写作业，以便它们提供幂等的行为；也就是说，它们可在失败时重新启动，而且不会丢失数据。这些作业需要能够接受它们可能已处理的数据，要么再次处理它，要么忽略它。为了帮助解释此概念，可考虑一个非幂等的作业。考虑一个简单的文件到 Oracle 连接器作业，如图 3 所示： <\/p><h5 id=\"fig3\">图 3.  一个简单的文件到 Oracle 连接器作业 <\/h5><img alt=\"该图显示了一个简单的文件到 Oracle 连接器作业\" src=\"/sunshine_new/images/负1308183492/Figure3.jpg\" width=\"301\" /><p> 包含图 4 中指定的 Oracle 连接器的属性： <\/p><h5 id=\"fig4\">图 4.  Oracle 连接器属性 <\/h5><img alt=\"该图显示了 Oracle 连接器阶段的属性\" src=\"/sunshine_new/images/负1308183492/Figure4.jpg\" width=\"442\" /><p> 假设表 TABLE_WITH_PK 拥有一个惟一约束，也就是说，它无法拥有两个具有相同键值的行。可以明显地看到，如果第二次运行此作业，它会失败，因为相同的数据将 “重放” 到 Oracle 连接器，这将导致重复键行错误。可通过多种可能方式克服此问题： <\/p><ul class=\"ibm-bullet-list\"><li>将 Write mode 属性更改为 Insert new rows only、Insert then update 或 Update then insert。第一个选项忽略数据库中已存在的行，第二个选项在该行上执行一次插入操作，如果返回结果表明已存在该行，则会使用相同数据执行一个更新语句。最后一个选项与此类似，但按照相反顺序执行该语句。 <\/li><li>向目标阶段添加一个拒绝链接并配置它，以便导致行错误的记录被发送到该拒绝链接。<\/li><li>使用一个稀疏查找阶段查看一条记录是否已存在于目标中。查找的结果可用于确定是将记录发送到目标阶段、忽略它们，还是将现有记录转移到一个日志文件或其他目标。<\/li><\/ul><p> 具体使用哪种方法取决于特定的用例，以及是否需要对源数据进行处理。如果需要对源数据执行转换或使用其他功能，那么可以在作业中尽早使用一个稀疏查找阶段，以确定某条记录是否已存在，这样做会更有效，可以跳过转换。如果大部分源数据已通过少量中间阶段直接传递到目标，可能允许数据到达目标连接器，并让该连接器拒绝或忽略该数据会更有效。 <\/p><p> 通过使用额外的目标表来存储事务状态，可完成实现幂等性的其他方式。为此，会要求一个目标阶段可在单个事务中写入多个目标表。数据库连接器拥有这样一项功能，此功能将在下一节中介绍。 <\/p><h2 id=\"ltwdc\"> 本地事务与数据库连接器 <\/h2><p> 从 Information Server 8.5 开始，数据库连接器就已提供了支持多个输入链接的能力，每个链接以一个特定的数据库表为目标，拥有自己的一组属性（比如写入模式）。这些链接都在同一个数据库事务中执行，所以需要使用 ACID 功能来提供有保障的传送：要么写入所有表更新，要么全都不写入。 <\/p><p> 该功能有许多用例，包括： <\/p><ul class=\"ibm-bullet-list\"><li>写入相关的记录，比如在一个事务中保持父子关系。<\/li><li>对每个链接使用不同的写入模式，其中每个链接被配置为更新同一个表。例如，链接 1 可能从一个表执行删除，而链接 2 对同一个表执行更新。<\/li><li>存储一个事务标记来保存事务的状态。<\/li><\/ul><p> 后一种方法常常用在<em>检查点重新启动<\/em> 场景中，以避免在一个作业由于某个失败条件而需要重启系统时，将相同的数据再次发送到目标数据库。实现此目的的一种做法是，利用一个目标表来存储最后处理的行的编号。因为这是在与目标更新相同的事务中提交的，所以可保证准确地反映了<em>最后处理的<\/em> 行计数。在同一个作业的早期阶段，一个查找阶段会读取这个<em>最后处理的<\/em> 值，将它传递给一个转换器阶段，该阶段包含一个约束表达式，用于对比该行号与该计数。此阶段将会丢弃任何行计数小于<em>最后处理的<\/em> 值的行，因为这些行已由目标阶段处理。结果是，只有还未被目标阶段处理的记录被传送到该阶段。 <\/p><p> 还需要一个阶段，即 Wave Generator 阶段。在配置了多个输入链接时，数据库连接器仅在每个批行结束时提交该事务。Wave Generator 提供了多种不同方法来确定何时发出一个批次标记。对于本例，一个绝对行计数就足够用了，这样目标连接器就会每隔 N 行提交该事务一次。 <\/p><p> 完整的作业类似于图 5： <\/p><h5 id=\"fig5\">图 5.  检查点重新启动作业 <\/h5><img alt=\"该图显示了一个检查点重新启动作业\" src=\"/sunshine_new/images/负1308183492/Figure5.jpg\" width=\"568\" /><p> 像 <a href=\"#fig5\">图 5<\/a> 中这样的作业可用作幂等性问题的解决方案，而且可确保将数据从来源传送到目标。 <\/p><h2 id=\"odp\">其他设计模式 <\/h2><p> 本节将介绍可对其他资源实现有保障传送的其他一些模式。 <\/p><h3 id=\"N1010B\">使用 InfoSphere Data Replication 执行有保障的传送 <\/h3><p> 将 Change Data Capture Transactional 阶段 (CDCTS) 与 InfoSphere Data Replication (DR) 结合使用，可实时复制和处理任务关键型数据事件。DR 使用一种基于日志的捕获方法来检测对各种数据库系统的更新，然后将这些更新复制到另一个数据库系统，或者将这些更新传送到文件、WebSphere MQ 消息或 CDCTS。CDCTS 通过 TCP/IP 与 DR 进行通信，以接收这些对来源数据库的更新，并传递状态消息。 <\/p><p>图 6 显示了一个简单的 DR DataStage 作业： <\/p><h5 id=\"fig6\">图 6.  数据复制作业 <\/h5><img alt=\"该图显示了一个数据复制作业\" src=\"/sunshine_new/images/负1308183492/Figure6.jpg\" width=\"496\" /><p> 该 CDC 阶段配置了 DR 订阅的名称，必须拥有至少两个输出链接：其中一个或多个链接承载了数据库更新，而只有一个链接负责传递<em>书签<\/em>。书签类似于上一节中介绍的<em>最后处理的<\/em> 计数。它用于识别当前事务的最后提交点。一个 CDCTS 作业使用一个目标数据库连接器，该连接器拥有至少两个输入链接。一个链接承载书签值，它的目标是一个简单表，也就是为了存储书签值而创建的书签表。与前一个例子一样，目标数据库连接器在事务批次结束时提交该事务。这些事务批次的边界由 DR 确定。DR 将提交消息发送到 CDCTS，这些消息与来源数据库的更新事务边界保持一致。在 CDCTS 收到这些提交消息后，它将事务批次标记发送到其输出链接。在目标数据库阶段收到每个链接上的批次标记时，它会提交该事务。因为一个事务同时包含书签表和数据库更新，所以存储的书签值可保证与数据库更新保持同步。 <\/p><p> 在作业运行时，DR 定期要求 CDCTS 报告最后提交的书签值。CDCTS 通过一个 ODBC 连接查询书签值，并向 DR 报告该书签。DR 使用该值清理日志，因为它可以确定一个特定的事务已成功写入到目标表。 <\/p><p> 在作业、网络或系统发生故障时，该作业会保留为不完整状态。在作业重新启动时，CDCTS 向 DR 报告最后提交的书签值，DR 随后使用该信息确定从哪条记录开始。 <\/p><p> 从 DR 到目标数据库的传送再一次受到了保护，而且通过使用书签机制，绝不会有重复的记录发送到目标数据库。 <\/p><h3 id=\"N1012C\"> 使用管道阶段执行有保障的传送 <\/h3><p> 作业还可通过其他有创意的方式写入，以保证有保障的传送。大多数方式都依靠事务批次标记的使用，如前面的示例中所示。这类使用的另一个示例是，数据必须从一个来源队列移动到目标数据库，但消息系统不是 WebSphere MQ。DTS 仅支持 WebSphere MQ，所以要使用其他消息系统（比如 Java Messaging System (JMS)）实现类似功能，还需要使用一个类似图 7 中所示的作业： <\/p><h5 id=\"fig7\">图 7.  管道作业 <\/h5><img alt=\"该图显示了一个使用管道保障传送的作业\" src=\"/sunshine_new/images/负1308183492/Figure7.jpg\" width=\"569\" /><p> SourceMessage 和 DeleteMessage 阶段使用了一个在 Java Integration Stage 基础上编码的 JMS 解决方案。这个 JMS 阶段也定期输出批次标记。该解决方案之所以有效，是因为 Teradata 连接器提供了将成功的记录发送到它的拒绝链接（如图 8 所示）的能力（只要在拒绝链接属性中被配置为这么做）： <\/p><h5 id=\"fig8\">图 8. Teradata 连接器拒绝属性 <\/h5><img alt=\"该图显示了Teradata 连接器的拒绝属性\" src=\"/sunshine_new/images/负1308183492/Figure8.jpg\" width=\"278\" /><p> 该作业执行过程中的事件顺序是： <\/p><ol><li>JMS 阶段读取来源消息，但将它留在来源队列上。这个阶段还按规定的间隔发出批次结束标记。 <\/li><li>来自 JMS 的数据由 Teradata 连接器写入到 Teradata 数据库中。如果写入成功，那么连接器会将该数据转发到它的拒绝链接，该链接被配置为仅转发成功的记录。<\/li><li>在 Teradata 连接器从 JMS 来源阶段收到批次结束标记时，它会提交事务，并将批次结束标记转发给它的输出链接。<\/li><li>当 Remove Duplicates 阶段收到批次结束标记时，它会删除重复数据并将结果（包含一个批次结束标记）发送给它的输出链接。<\/li><li>最后的 JMS 阶段在收到一个批次结束标记时删除来源消息。<\/li><\/ol><p> 请注意，如果没有批次结束标记，前面的解决方案将无法正确工作，因为 Teradata 在数据写入后而不是在提交后将记录发送到它的输出链接。但是，通过使用批次标记并包含 Remove Duplicates 阶段，该顺序得到了保障。 <\/p><p> 在数据库事务提交后，作业可能会失败。在这种情况下，不会执行来源消息的最终删除，该消息会保留在来源队列上。没有数据会丢失，但这种失败可能意味着如果改作业重新启动，Teradata 连接器会看到它已处理的相同数据。出于这个原因，与使用本地事务和 DTS 一样，作业设计需要是幂等的。使用正确构建的幂等性作业，如果作业因为任何原因而被中止，那么可以重新启动它，从离开的位置继续处理。 <\/p><h2 id=\"conclusion\"> 结束语 <\/h2><p> 本文介绍了一些可用来为通过 DataStage 作业将数据从来源系统传送到目标系统提供保障的方法。由于所访问的资源具有不同的性质，一种解决方案可能无法完美地应对所有情形，所以需要结合使用多种技术。确定使用何种方法的因素包括：该资源是否支持 XA 事务、事务数据的大小、延迟需求，以及可重新启动性需求。 <\/p><h2 id=\"acknowledgements\">\n            致谢 <\/h2><p> 衷心感谢同事 Tony Curcio 和 Ernie Ostic 审阅本文，并提供对完善本文大有帮助的宝贵反馈。 <\/p><CMA ID: 976484><Site ID: 10><XSLT stylesheet used to transform this file: dw-document-html-7.0.xsl>\r\n\r\n\r\n<\/div>\r\n<\/div>\r\n","createTime":"2014-07-03 00:00:00","deployTime":"2014-07-03 00:00:00","id":0,"intro":"本文将介绍如何使用 InfoSphere DataStage Distributed Transaction Stage 保障数据的传送。文中还将介绍如何使用 DataStage 数据库阶段中的本地事务。最后将介绍 Change Data Capture Transaction 阶段如何与 InfoSphere Data Replication 结合来保障更改向目标数据库的传送。","keyword":"","recommend":false,"source":"http://www.ibm.com/developerworks/cn/data/library/techarticle/dm-1310datastage/index.html","title":"使用 InfoSphere DataStage 执行有保障的传送","typeId":0,"updateTime":"2014-07-03 00:00:00"}
{"author":"","clickNumber":0,"content":"\r\n<div class=\"ibm-columns\">\r\n<div class=\"ibm-col-1-1\">\r\n\r\n<h2 id=\"major1\">背景介绍<\/h2><h3 id=\"major2\">现状和意义<\/h3><p>\n                越来越多的企业，开始关注其广域网带宽的使用状况。对广域网带宽的使用分析，不仅可以确保企业关键业务得到充分的带宽保障，而且也可以发现带宽使用中最大的威胁来自哪里。由于大部分的企业都已经部署了基于\n                SNMP 或者 Netflow\n                的网管平台，因此对企业而言，带宽当前的使用状况是了解的。然而，为了解决业务发展对带宽增长的需求，就需要及时预测未来带宽的需求状况，从而为升级带宽提供依据。<\/p><p>\n                由于广域网带宽非常昂贵，因此，当企业决定升级广域网带宽时，对升级后的带宽会有严格的要求。既要保证企业业务对带宽增长的需求，又不能升级过多，出现投资浪费的情况。<\/p><h3 id=\"major3\">问题描述<\/h3><p>\n                目前，对带宽的预测主要有以下几种方法。第一种方法，通过计算得到。该方法通过累加关键业务所占用带宽，然后乘以同时在线的概率。第二种方法，通过企业现有网管数据做简单推演。第三种方法，通过企业现有网管数据建立数学模型，从而预测未来带宽需求。<\/p><p>\n                上述前两种方法误差较大，无法满足企业升级带宽时，对准确性的要求。而本文所要讨论的，正是从企业网管数据着手建立数学模型，准确地预测未来带宽需求。<\/p><h2 id=\"major4\">带宽分析方法<\/h2><h3 id=\"major5\">数据生成方法<\/h3><p><strong>企业网管工具介绍<\/strong><\/p><p> 目前，面向大中型企业的网管产品主要是基于 SNMP 协议或者思科的 Netflow 技术。基于 SNMP\n                协议的网管产品，优势在于捕获链路的利用率，用来生成利用率基线以及捕获网络设备的性能参数，比如 CUP、MEM 等。非常著名的 Orion NPM\n                就是这类网管产品；另外一类是基于 Netflow 的网管产品。它的优势在于对 IP 地址和流量协议的分析，如 Orion\n                NTA。近年来，网管产品也出现对两种技术融合的趋势。<\/p><p><strong>实例：AT&amp;T 工具获取数据<\/strong><\/p><p> 本文所使用的网管平台，来自基于 Netflow 的网管产品 Application Traffic Analyzer，如下图 1\n                所示。生成报表时，可以定义的主要字段主要有：<\/p><p>Function：该字段用来定义报表的功能，比如，可以生成以协议、会话、目的 IP、服务分类为主要内容的报表；<\/p><p>Report Type：该字段用来定义生成报表的类型，比如图表、柱状图、饼状图等；<\/p><p>Granularity：该字段用来定义生成报表的颗粒度，比如 5 分钟、10 分钟、1 小时、1 天、1 星期等；<\/p><p>Traffic Direction：该字段定义流量的方向，是入流量还是出流量；<\/p><p>Statistic：该字段定义了统计方法，比如：求和、求平均值、求最大值、求 95% 等；<\/p><p>Scaling：该字段定义了流量单位，比如：Mbps、Megabytes、Kilobytes 等。<\/p><h5 id=\"img001\">图 1. Application Traffic\n                    Analyzer<\/h5><img alt=\"图 1. Application Traffic Analyzer\" src=\"/sunshine_new/images/负466927517/img001.png\" width=\"477\" /><p> 本文所使用的报表，以 5 分钟为采样单位，每天生成一张单独的报表。定义的主要字段如下：<\/p><p>Time range：9:00 am C 19:00 pm<\/p><p>Scaling：Mbps<\/p><p>Statistic：Sum<\/p><p>Traffic direction：inbound（由于 Inbound 流量远大于 Outbound\n                流量，所以在这里我们选取较大方向的流量）<\/p><p>Function：destinations（在这里，我们以目的地 IP 来排序所有的 inbound 流量）<\/p><h3 id=\"major6\">数据预处理<\/h3><p>\n                并不是所有的原始数据都能直接用来构建预测模型。通过对待解决的问题进行一个明确清晰的定义，来确定原始数据是否能直接支持解决方案的构建。如果不能，则需要对一些字段进行处理，生成间接数据建模。这样既可以提供足够的信息支持，也能保证预测结果是可衡量、可理解的，从而便于评估解决方案的结果。<\/p><p><strong>数据分析和定义<\/strong><\/p><p> 从 IT 部门拿到的原始数据，在预处理前首先要进行数据分析。根据解决方案的目标定义表之间的关系、表的结构（目标变量和因变量）。<\/p><p>本文中，IT 部门提供了从 2012 年 11 月到 2013 年 1 月的网络流量数据。这些数据按照每天的网络流量独立制表，半年共计 92\n                张表（EXCEL 格式），每张表格式统一。现在以 2012 年 11 月 17 日为例，介绍原始表的结构。<\/p><h5 id=\"img002\">图 2. 原始表结构<\/h5><img alt=\"图 2. 原始表结构\" src=\"/sunshine_new/images/负466927517/img002.png\" width=\"580\" /><p> 如图 2 所示：原始表的行变量是日网络流量进入前 100 名的 IP 集合，其中包括网络环境下的服务器（Server）和 PC\n                终端机器（Client）。表的列变量是每个 IP 每隔 5 分钟（时间点）记录的网络流量值。从早 9 点到晚 7 点共计 119 列。<\/p><p>本文的目标是要找到影响某企业网络总流量的因素。原始数据提供的信息有记录时间、Server 流量和 Client\n                流量。根据数据分析结果，我们定义了用于建模的终表结构，如图 3 所示。<\/p><h5 id=\"img003\">图 3. 终表结构<\/h5><img alt=\"图 3. 终表结构\" src=\"/sunshine_new/images/负466927517/img003.png\" width=\"680\" /><p> 我们定义的目标变量是网络总流量 COS_Total，因变量有记录日期 Date，前 10~70 个服务器网络流量总和从\n                Top10Server_sum 到 Top70Server_sum，前 10~70 个终端机器网络流量总和从 Top10Client_sum 到\n                Top70Client_sum。每一张原始表的信息作为终表的一个行记录存在。<\/p><p><strong>Python 编程接口，数据预处理自动化<\/strong><\/p><p> 从终表和原始表的结构可以看出，原始表的变量不能直接作为终表的变量。这就需要把每张原始表的时间点流量信息转换为日流量信息。我们认为能够满\n                95%用户网络流量需求的流量值可以作为企业当天的网络流量总和值。<\/p><p> 转换的思路是：1）每个 IP 每天的网络流量值 total_per_IP，等于升序排列该 IP 当天所有时间点网络流量值后，取第 95%的值。根据\n                total_per_IP 值选取排名前 10~70 的服务器和终端。2）每天前 10~70 个服务器/终端产生的网络总流量\n                topNClient/Server_sum，取前 10~70 个服务器/终端产生的网络流量均值。3）网络总流量值 COS_Total，等于将所有\n                IP 在每个时间点产生的网络流量总和升序排列后，取第 95%的值。定义如下：<\/p><p>total_per_IP=Percentage(Sort(Time1,Time2,Time3,…,Time119)ascending)95%<\/p><p>topNClient/Server_sum=Mean(SumTime1,SumTime2,SumTime3,…,SumTime119)<\/p><p>COS_Total=\n                Percentage(Sort(SumTime1,SumTime2,SumTime3,…,SumTime119)ascending)95%<\/p><p> 统计分析软件 IBM SPSS Statistics\n                在拥有的强大的数据处理能力的同时，也提供了丰富的编程接口（Python、R、.Net）。本文运用 Statistics 的\n                Compute、Aggregate、Transpose、OMS、Merge 等功能对原始数据进行操作并整合，最后通过编写 Python\n                脚本批处理大量数据表，实现数据预处理自动化。关于如何在 Statistics 中运行 Python 脚本，请参见 Statistics\n                产品帮助文档。<\/p><p>这里需要提到的是，原始表中的没有区分服务器和 PC 终端的 IP 地址，Python 封装的 Netaddr 包能够根据客户设定的规则对 IP\n                分类。处理过程如下图 4 所示。<\/p><h5 id=\"img004\">图 4. IP 分类脚本<\/h5><img alt=\"图 4. IP 分类脚本\" src=\"/sunshine_new/images/负466927517/img004.png\" width=\"580\" /><h2 id=\"major7\">建模及分析<\/h2><h3 id=\"major8\">线性模型的建立<\/h3><p>通过 IBM SPSS Statistics 提供的线性回归分析模块，设置界面如下图 5 所示，可以针对 3 个月的数据，寻找 COS_Total\n                与各个输入变量之间的关系。<\/p><h5 id=\"img005\">图 5. 线性回归分析<\/h5><img alt=\"图 5. 线性回归分析\" src=\"/sunshine_new/images/负466927517/img005.png\" width=\"343\" /><p> 通过表 1 和表 2 可以看出可以利用 Top40Server_sum、Top50Client_sum 建立线性模型来预测\n                COS_Total，预测准确度达到 86.2%，说明 COS_Total 与 Top40Server_sum、Top50Client_sum\n                的关系最为紧密，并可以建立线性模型的方程来预测 COS_Total。<\/p><p>COS_Total = 2.264+ 2.774 * Top40Server_sum + 2.976 * Top50Client_sum<\/p><h5 id=\"img006\">表 1. 模型概要<\/h5><img alt=\"表 1. 模型概要\" src=\"/sunshine_new/images/负466927517/img006.png\" width=\"400\" /><h5 id=\"img007\">表 2. 系数<\/h5><img alt=\"表 2. 系数\" src=\"/sunshine_new/images/负466927517/img007.png\" width=\"401\" /><h3 id=\"major9\">蒙特卡洛仿真分析<\/h3><p> 蒙特卡洛仿真分析是 IBM SPSS Statistics 21\n                版本后新增加的功能，其原理是当问题或对象本身具有概率特征时，可以用计算机模拟的方法产生抽样结果，根据抽样计算统计量或者参数的值。随着模拟次数的增多，可以通过对各次统计量或参数的估计值求平均的方法得到稳定结论，蒙特卡洛分析在金融、医药等多个行业有着广泛的应用。<\/p><p> 因为在这里只有 3 个月的网络流量数据，并且有预测 COS_Total\n                线性模型方程，因此我们可以根据三个个月数据的分布特征，用模拟功能生成大量模拟数据，并根据模拟数据分析出 COS_Total\n                的分布特征，从而对公司的合理带宽使用提供依据。<\/p><p> 在 IBM SPSS Statistics 22 中选择分析菜单下的模拟模块，打开如下图 6 界面，选择“输入方程”。<\/p><h5 id=\"img008\">图 6. 模拟模块<\/h5><img alt=\"图 6. 模拟模块\" src=\"/sunshine_new/images/负466927517/img008.png\" width=\"383\" /><p>在“方程编辑器”对话框中（图 7），将前面用来预测 COS_Total 的线性方程输入到下面的“数字表达式”中，单击“继续”按钮确认。<\/p><h5 id=\"img009\">图 7. 方程编辑器<\/h5><img alt=\"图 7. 方程编辑器\" src=\"/sunshine_new/images/负466927517/img009.png\" width=\"556\" /><p>在“模拟”页面，单击“拟合全部”按钮，Statistics 软件就会根据已有的 3 个月数据中的 Top40Server_sum 和\n                Top50Client_sum 变量自动的计算其相应的分布，可以发现 Top40Server_sum 符合 Weibull 分布，而\n                Top50Client_sum 符合正态分布。单击“运行”按钮，就会根据这个两个变量的分布和已有的线性方程，对 COS_Total\n                的概率分布进行仿真计算。<\/p><h5 id=\"img010\">图 8. 模拟构建器<\/h5><img alt=\"图 8. 模拟构建器\" src=\"/sunshine_new/images/负466927517/img010.png\" width=\"567\" /><p>蒙特卡洛仿真分析得到的 COS_Total 的概率分布如下图 9 所示。图中的横轴表示 COS_Total 的取值范围从-100M 到\n                500M，纵轴表示了在每一个 COS_Total 值上的概率密度，相应的表中分别给出了覆盖 5% 的 COS_Total 值，5%-95% 的\n                COS_Total 值和 95% 的 COS_Total 值。因此说明，公司采购带宽如果设定为 332.95M 时，可以满足\n                95% 的情况下的使用，如果采购带宽设定为 54.52%，则只能满足 5% 的情况使用。<\/p><h5 id=\"img011\">图 9. 概率密度<\/h5><img alt=\"图 9. 概率密度\" src=\"/sunshine_new/images/负466927517/img011.png\" width=\"447\" /><h2 id=\"major10\">业务决策<\/h2><h3 id=\"major11\">企业带宽现状评估<\/h3><h5 id=\"img012\">图 10. 网管报告<\/h5><img alt=\"图 10. 网管报告\" src=\"/sunshine_new/images/负466927517/img012.png\" width=\"303\" /><p> 从上述网管报告（图 10）可以看到，企业带宽的实际使用情况已用不同颜色区分。绿色表示链路占用率小于\n                50%，说明链路处于健康状态。黄色表示链路占用率处于\n                50%-70%，当处于这种状态时，说明网络处于拥塞状态，丢包时有发生，需要做带宽的升级准备了。红色表示链路占用率大于\n                70%，当处于这种状态时，业务性能会严重下降，无法保障业务的正常使用。我们可以得出结论，企业需要尽快升级带宽了。那么，升级到多少合适呢？<\/p><h3 id=\"major12\">企业带宽升级决策<\/h3><p> 根据我们前面预测分析的结果，在 95%的情况下，企业带宽位于 332.95Mbps\n                以内，这和网管报告中的带宽实际使用情况是一致的。合理的带宽升级方式，是既要保证良好的用户体验（带宽使用率&lt;70%），又能够尽量节省成本。因此我们建议带宽升级的升级范围是\n                475.6Mbps（332.95/0.7）~665.9Mbps（332.95/0.5）。将带宽升级到 475.6Mbps\n                是一个合理的方案，它可以满足企业绝大多数情况下对网络的使用要求（绿色），即使全网资源被占用也不会出现性能严重下降（红色）的问题。当然，如果企业对网络性能要求很高并且愿意投入成本，选择升级到\n                665.9Mbps 后，企业的网络处于会长期处于健康状态（绿色），从而对关键业务性能有更可靠的保证。<\/p><h2 id=\"major13\">结束语<\/h2><p> 本文通过 IBM SPSS Statistics 中的 Python 编程模块对原始 AT&amp;T\n                网络数据进行预处理，然后结合线性模型和蒙特卡洛仿真分析，可以在原始少量数据的基础上大量仿真模拟企业的真实网络带宽使用情况，从而为企业的带宽升级决策提供量化的结果，为企业\n                IT 决策部门提供分析智慧的洞察能力。<\/p><CMA ID: 976114><Site ID: 10><XSLT stylesheet used to transform this file: dw-document-html-7.0.xsl>\r\n\r\n\r\n<\/div>\r\n<\/div>\r\n","createTime":"2014-07-03 00:00:00","deployTime":"2014-07-03 00:00:00","id":0,"intro":"本文为读者提供了一种 IT 部门网络带宽分析方法。使读者能借助统计分析软件 IBM SPSS Statistics 提供的 python 编程接口, 线性模型和蒙特卡洛仿真分析方法，评估企业带宽使用现状并为企业的带宽升级决策提供量化的结果，从而为企业 IT 决策部门提供分析洞察能力。","keyword":"","recommend":false,"source":"http://www.ibm.com/developerworks/cn/data/library/bd-1407-spss-statistics-insightsbroadband/index.html","title":"IBM SPSS Statistics 仿真分析获得洞察--为企业 IT 部门评估合理的带宽宽度","typeId":0,"updateTime":"2014-07-03 00:00:00"}
{"author":"","clickNumber":0,"content":"\r\n<div class=\"ibm-columns\">\r\n<div class=\"ibm-col-1-1\">\r\n\r\n<p> 我们如何使用不同场景中的不同安全测试概念，将平台即服务 (PaaS)\n                用作一个漏洞测试平台。在本文中，我将介绍如何评估、集成和定义任何安全测试概念，然后通过将概念与场景建立链接来进一步解释这些概念。<\/p><p>但开始了解难懂的概念之前，让我们看看一种<em>用户 PaaS 模型结构<\/em>，以熟悉这一主题。 <\/p><h2 id=\"N1003E\">用户 PaaS 模型结构<\/h2><p> 用户 PaaS 模型结构分为 3 种类型： <\/p><ul class=\"ibm-bullet-list\"><li><em>应用程序开发生命周期<\/em> 流程跟踪 PaaS 上的应用程序，从需求到设计、编码和安全测试，再到部署阶段。<\/li><li><em>风险管理生命周期<\/em>\n                    跟踪缓解风险的过程，从识别资产到实施富有成本效益的保护措施。风险是威胁作用物将利用一个或多个漏洞的可能性。<\/li><li><em>业务流程生命周期<\/em> 允许开发人员在每个 PaaS\n                    阶段控制和保护应用程序。开发人员在此周期中会使用电子表格、文字处理器、结算和其他业务工具。 <\/li><\/ul><p> 我们简单看看，这些生命周期如何在安全测试中彼此关联： <\/p><ul class=\"ibm-bullet-list\"><li>在风险管理生命周期中，PaaS 测试人员识别应用程序开发风险，然后创建基于风险的安全测试方法。<\/li><li>在应用程序开发生命周期中，测试人员应用该基于风险的方法。<\/li><li>在业务流程生命周期中，测试人员使用电子表格和文档来记录基于风险的安全测试的结果，包括漏洞评估。<\/li><\/ul><p>下面我们看看一种通用的安全测试模型。 <\/p><h2 id=\"N1005D\">安全测试模型<\/h2><p> 识别最脆弱的链接，执行渗透测试，以及依赖于标准和框架，都不足以发现和检测这 3 种类型的安全问题： <\/p><ul class=\"ibm-bullet-list\"><li>PaaS 应用程序设计级别上的安全缺陷<\/li><li>PaaS 应用程序实现级别上的安全漏洞 <\/li><li>PaaS 平台级别上的资源短缺<\/li><\/ul><p> 更好的解决方案将是，以 PaaS 作为漏洞测试平台来建立一个安全测试模型。该模型包含以下阶段：<\/p><ul class=\"ibm-bullet-list\"><li>发现阶段<\/li><li>自动化的漏洞扫描<\/li><li>漏洞评估流程<\/li><li>安全评估流程<\/li><li>渗透测试<\/li><li>安全审核<\/li><li>安全评审<\/li><\/ul><p><em>发现阶段<\/em>\n                是安全测试模型的基础；它是各连续阶段的构建基块。通过使用此模型，可发现并分析任何阶段中的缺口，然后再进入下一个阶段。此流程会反复执行，直至到达安全评审阶段。<\/p><p>如果测试人员在任何阶段中找到安全测试问题，她可返回到一个早期阶段，使用新信息重复测试过程，然后再进入下一个阶段。<\/p><p>测试人员应对她应返回到任何以前阶段的次数设置自己的上限。她应记录每个阶段中新的或改进的安全测试的结果，直至达到上限。<\/p><p>下面我们看看每个阶段，结合场景对它们进行分析。 <\/p><h2 id=\"N10086\">发现阶段：SaaS 升级<\/h2><p>将 PaaS 用作漏洞测试平台时，发现阶段是安全测试中的第一个阶段。 <\/p><h3 id=\"N1008D\">工作原理<\/h3><p> 您首先识别要在 PaaS 上开发和测试哪些应用程序。然后尝试检测或发现应用程序的潜在漏洞，比如： <\/p><ul class=\"ibm-bullet-list\"><li>应用程序中的逻辑缺陷<\/li><li>对用户查询的缓慢响应<\/li><li>数据库连接的不当配置<\/li><\/ul><p> 您常常会在文档（包括代码和日志）中找到此信息。 <\/p><h3 id=\"N1009C\">问题场景<\/h3><p> 您发现一个在内部良好运行的应用程序，无法作为软件即服务 (SaaS)\n                应用程序很好地运行。在云中运行该应用程序时，它的攻击注入漏洞（由对无效数据的处理导致）就会显现出来。 <\/p><h3 id=\"N100A2\">解决方案场景<\/h3><p> 对该内部部署应用程序中的代码进行评审，然后在 PaaS 测试环境中执行模拟的攻击注入。 <\/p><h2 id=\"N100A8\">自动化的漏洞扫描：IaaS 升级<\/h2><p> 经过发现阶段之后，使用一个（或多个）自动化漏洞扫描工具来匹配各种条件与已知漏洞，查找已知的安全问题。 <\/p><h3 id=\"N100AF\">工作原理<\/h3><p>\n                这种类型的工具自动设置风险级别，无需人为干预来验证或解释各个级别。该工具可以辅以基于凭据的扫描，使用提供的凭据来向一个本地帐户服务进行身份验证，帮助消除一些常见的误报。 <\/p><h3 id=\"N100B5\">问题场景<\/h3><p> PaaS 运行所在的基础架构即服务 (IaaS) 经过升级，增添了可能带有隐藏漏洞的虚拟机。<\/p><p>在虚拟化的环境中，可创建使用防火墙、路由器、交换机和 IPS 设备启用的隔离和安全区。麻烦在于，虚拟机 (VM) 在 IaaS\n                内游荡，可能很难让系统的安全规则不断跟踪这些机器。 <\/p><h3 id=\"N100BD\">解决方案场景<\/h3><p> 获取安全策略管理工具，确定控制 VM 管理的流程已就绪。这可以保证，更改 VM 的位置会触发将需要的安全功能复制到新位置的过程。<\/p><p>寻找虚拟化感知的解决方案。<em>虚拟化感知<\/em> 或<em> VM 感知<\/em> 的系统和网络组件可识别\n                VM，使用正确且不断改变的策略帮助您的集中管理控制台工具跟踪、监视和更新这些 VM。这进而帮助您管理网络安全策略，通过 VMM/Hypervisor\n                加强可视化和可控化。 <\/p><h2 id=\"N100CB\">漏洞评估流程：多个主机漏洞<\/h2><p> 漏洞评估流程阶段基于发现流程和漏洞扫描阶段，用于识别安全漏洞。 <\/p><h3 id=\"N100D2\">工作原理<\/h3><p> 漏洞评估流程将发现的安全漏洞放入所测试的 PaaS 环境中。例如，从报告中消除常见的误报，确定应该应用到每个报告发现结果的风险级别。 <\/p><h3 id=\"N100D8\">问题场景<\/h3><p> PaaS 开发人员的云资源优化应用程序导致了报告中的误报，报告显示用户已成功访问 PaaS，而事实上应用程序出现故障。这一故障导致 PaaS\n                平台完全关闭。该应用程序没有识别出故障或实现较短的超时。这对确定服务水平协议 (SLA) 可用性保证所需的性能数据产生了负面影响。<\/p><p>PaaS\n                开发人员没有构建包含单台主机的简单服务；这台主机允许她创建可幸免于主机故障的复制的服务实例。相反，她构建了包含多台相互依赖的主机的服务，她发现这些服务无法在主机故障中幸免遇难。<\/p><p>我们看看开发人员如何构建包含多台相互依赖的主机的服务。如果开发人员有一个包含业务逻辑组件（A、B 和\n                C）的结算应用程序，她可以创建一个像这样的服务组：<\/p><p>In (A1, B1, C1)、(A2, B2, C2)、(An, Bn, Cn)，其中 <em>n<\/em> 是表示服务组类别编号的组件类型编号： <\/p><ul class=\"ibm-bullet-list\"><li>对于服务类别 1： \n<ul class=\"ibm-bullet-list\"><li>A1 是查找服务编码的逻辑。<\/li><li>B1 是将服务类别插入账单中的逻辑。<\/li><li>C1 是检查 ZIP 编码准确性的逻辑。<\/li><\/ul><\/li><li>对于服务类别 2： \n<ul class=\"ibm-bullet-list\"><li>A2 是查找服务编码的逻辑。<\/li><li>B2 是将服务类别插入账单中的逻辑。<\/li><li>C2 是检查 ZIP 编码准确性的逻辑。<\/li><\/ul><\/li><li>对于服务类别 n： \n<ul class=\"ibm-bullet-list\"><li>An 是查找服务编码的逻辑。<\/li><li>Bn 是将服务类别插入账单中的逻辑。<\/li><li>Cn 是检查 ZIP 编码准确性的逻辑。<\/li><\/ul><\/li><\/ul><p> 由于较长的超时，用户在系统出现健康问题时能够访问系统。 <\/p><h3 id=\"N10105\">解决方案场景<\/h3><p> 为了修复该问题，使系统不会发生故障，开发人员将这些组件分解为独立的池，比如：(A1, A2,...An )、(B1, B2...Bn )、(C1,\n                C2, ...Cn)。<\/p><p>这使她能够在健康的数据中心中创建多个冗余的服务副本。这意味着，如果组件 A1 发生故障或变慢，同一个独立的池中从 A2 到 An\n                的所有其他组件不会发生故障。类似地，第二个独立的组件池 (B1-Bn) 和第三个组件池 (C1-Cn) 不会发生故障。<\/p><p>因此用户能够访问健康的系统。在漏洞评估过程的结果报告中不会出现误报。 <\/p><h2 id=\"N1010F\">安全评估流程：阈值级注入漏洞<\/h2><p> 安全评估流程基于漏洞评估流程，它添加了手动验证来确认可能在生产阶段中发生的风险暴露级别。 <\/p><h3 id=\"N10116\">工作原理<\/h3><p>\n                安全评估流程不包含利用漏洞来获取进一步的访问权。它可以通过对系统的授权访问形式来确认系统设置，涉及检查日志、系统响应、错误消息、代码和数值分析验证。<\/p><p>安全评估拓宽了被测试系统的范围。它未涵盖一个特定的漏洞可能导致的风险暴露深度。 <\/p><h3 id=\"N1011E\">问题场景<\/h3><p>\n                当假期购物季来临时，系统检测到更高的工作负载需求。作为响应，系统快速创建了更多资源实例来动态平衡工作负载需求。这需要更多用户和更多的数据请求来访问系统。<\/p><p>由于阈值级的注入，不需要的资源从未被释放，最终导致系统崩溃。访问系统来手动确认生产阶段中可能发生的风险暴露级别，从未完成过。 <\/p><h3 id=\"N10126\">解决方案场景<\/h3><p>\n                手动检查日志、系统响应、错误消息和代码，验证对系统的访问是否获得授权。手动验证是否存在阈值策略，列出云计算服务使用者和提供者在制定以下策略的过程中应执行的操作： <\/p><ul class=\"ibm-bullet-list\"><li>资源阈值策略，用于确保动态平衡了应用程序在云中的使用，控制在该阈值水平或之下。<\/li><li>用户阈值策略，用于确保用户能够并发地访问应用程序，并发量最高上限为提供商的用户许可规定的限制数，控制在阈值水平或之下。<\/li><li>数据请求阈值策略，用于确保对应用程序的数据请求可立即得到处理，控制在该阈值水平或之下。<\/li><\/ul><h2 id=\"N10133\">渗透测试：LDAP/AD 注入漏洞<\/h2><p> 渗透测试模拟遭受攻击的 PaaS。它基于以前的阶段，测试利用发现的漏洞来获取 PaaS 和 IaaS 的进一步访问权的过程。 <\/p><h3 id=\"N1013A\">工作原理<\/h3><p> 渗透测试对攻击者获取机密信息、影响数据完整性或服务可用性以及对 PaaS 带来各种影响的能力进行测试。<\/p><p>每项测试还会比较测试人员的问题解决能力，即采用众多渗透测试工具来查找自动化工具无法识别的漏洞的能力。渗透测试还会测试防御者检测攻击并做出适当响应的能力。<\/p><p>依据 NIST SP 800-115（<a href=\"#resources\">参考资料<\/a>），渗透测试利用的大部分漏洞包括： <\/p><ul class=\"ibm-bullet-list\"><li>错误配置<\/li><li>缓冲区溢出<\/li><li>错误的输入验证<\/li><li>争用条件<\/li><li>错误的文件和目录权限<\/li><\/ul><p> 渗透测试人员应能够确定何时停止渗透，避免进一步操作损害 PaaS 和底层系统。它可能导致系统失去可用性或暴露敏感数据。 <\/p><h3 id=\"N10155\">问题场景<\/h3><p> LDAP/AD 注入漏洞被利用，会导致系统崩溃。攻击者利用应用程序的故障来让在 LDAP 中具有特殊含义的字符失效。<\/p><p>LDAP 注入非常类似于 SQL 注入，会在使用未在应用程序中验证的用户提供的数据构造 LDAP\n                语句时发生。这会导致执行任意命令，比如为未授权的查询授予权限和修改 LDAP 树中的内容。<\/p><h3 id=\"N1015D\">解决方案场景<\/h3><p> 探索使用一流的外部渗透测试工具来测试 LDAP 和 SQL 注入漏洞。该工具应涵盖其他类型的安全漏洞，比如跨站点脚本攻击\n                (XSS)、不当的身份验证协议，以及不当的数据库连接配置。寻找好的内部渗透测试工具，测试 LDAP 和安全策略是否足以防御 LDAP/AD\n                注入的意外引入。<\/p><p>另外，寻找不错的无线站点渗透测试工具，测试<em>驾驶攻击 (wardriving)<\/em>（在移动的车辆中搜索脆弱的 WiFi\n                网络）和中间人攻击。确保无线安全协议足够安全，接入点和客户端（移动设备、笔记本电脑）得到正确配置。可使用适当的配置来预防仿冒行为异常的笔记本电脑，尝试拦截可用于注入\n                LDAP/AD 恶意软件的客户端接入点通信。使用您的移动笔记本电脑或固定的台式机来发现属于您的不安全的无线网络。 <\/p><h2 id=\"N10168\"> 安全审核流程：阈值不一致性<\/h2><p> 安全审核是对公司的信息系统安全性的一种系统性评估，度量它对一组既定的性能标准的遵守程度。 <\/p><h3 id=\"N1016F\">工作原理<\/h3><p>\n                安全审核常常用于确定信息系统对法律制度、行业标准和安全策略的遵守程度。安全审核使用我们介绍的早期的安全工具方法，评估信息系统、信息处理流程（机密或非机密）和用户实践的安全性。 <\/p><h3 id=\"N10175\">问题场景<\/h3><p> 审核揭示，尽管早期的安全工具方法已更正了问题，但还没有合适的阈值水平。审核发现，阈值水平未设置时，开发人员无法知道： <\/p><ul class=\"ibm-bullet-list\"><li>资源是否被过度使用。<\/li><li>尝试访问 PaaS 的开发人员数量是否达到了用户许可中指定的限制。<\/li><li>开发人员发送的数据请求是否超出了阈值水平。<\/li><\/ul><h3 id=\"N10182\">解决方案场景<\/h3><p> 审核人员应推荐开发人员在制定以下策略的过程中应执行的操作： <\/p><ul class=\"ibm-bullet-list\"><li>资源阈值策略，用于确保动态平衡了应用程序在云中的资源使用情况，控制在该阈值水平或之下。<\/li><li>用户阈值策略，用于确保用户能够并发地访问应用程序，并发量最高上限为提供商的用户许可规定的限制数，控制在阈值水平或之下。<\/li><li>数据请求阈值策略，用于确保对应用程序的数据请求可立即得到处理，控制在该阈值水平或之下。<\/li><\/ul><p>\n                阈值策略应解决数值分析漏洞以及如何处理它们。简言之，如果截断和舍入错误超出了可接受的界限，获取的指标将失去意义。在开发可解决适定性问题的数值稳定的算法上，PaaS\n                开发人员拥有的经验很可能比提供商更多。这将确保阈值策略将在您到达安全评审阶段之前建立。 <\/p><h2 id=\"N10191\">安全评审流程：合规性验证<\/h2><p> 安全评审涉及到验证行业或内部安全策略是否已应用到系统组件或产品上的流程。 <\/p><h3 id=\"N10198\">工作原理<\/h3><p> 安全评审通常通过差距分析或代码评审来完成，或者通过评审设计文档和架构图来完成。它不使用其他安全工具方法（漏洞评估、安全评估、渗透测试或安全审核）。 <\/p><h3 id=\"N1019E\">问题场景<\/h3><p> 在安全评审过程中，一个组织部门没有完全遵守信息安全测试和评估技术指南上的 NIST Special Publication 800-115\n                的一些方面。 <\/p><h3 id=\"N101A4\">解决方案场景<\/h3><p> 审阅文档以确定策略和规程的技术和安全方面是否最新，审查日志以确保安全控件记录了 PaaS\n                使用信息，以及组织是否遵守其日志管理策略。日志信息示例包括： <\/p><ul class=\"ibm-bullet-list\"><li>有关成功和失败的身份验证尝试的身份验证服务器或系统日志<\/li><li>有关恶意活动和不当使用的入侵检测和防御系统日志<\/li><li>记录已知脆弱服务和应用程序的信息的安全日志<\/li><li>记录用户阈值、数据请求和资源阈值的水平的阈值日志<\/li><\/ul><p> 自动审核工具应该可以减少大多数日志类型的评审时间。 <\/p><h2 id=\"N101B5\">结束语<\/h2><p>\n                在计划执行安全测试的过程中，请考虑解决该模型各个阶段的安全测试问题的最佳实践。在进入下一个阶段之前，您需要对可返回到前一个阶段来解决测试问题的次数设置限制。组建一个包含开发人员、管理人员和业务分析师的团队，让他们能更轻松地完成在生命周期的每个阶段执行安全测试的工作。<\/p><CMA ID: 976104><Site ID: 10><XSLT stylesheet used to transform this file: dw-document-html-7.0.xsl>\r\n\r\n\r\n<\/div>\r\n<\/div>\r\n","createTime":"2014-07-03 00:00:00","deployTime":"2014-07-03 00:00:00","id":0,"intro":"在不同场景中评估、集成和定义各种安全测试概念。探索一个示例用户 PaaS 测试环境结构，它是安全测试模型的基础。","keyword":"","recommend":false,"source":"http://www.ibm.com/developerworks/cn/cloud/library/cl-paas-testing/index.html","title":"将 PaaS 作为漏洞测试平台","typeId":0,"updateTime":"2014-07-03 00:00:00"}
{"author":"","clickNumber":0,"content":"\r\n<div class=\"ibm-columns\">\r\n<div class=\"ibm-col-1-1\">\r\n\r\n<h2 id=\"1.问题描述 |outline\">问题描述<\/h2><p>随着 Web2.0 技术的发展，大家对于网站功能和易使用性的要求越来越高，网站的制作也越来越复杂。JavaScript 是基于 Web 的用户界面开发必不可少的脚本语言，为 Web 界面开发提供了很多便利。伴随着 Web 用户界面的受重视程度提升，对 JavaScript 代码的测试要求也越来越高，例如，针对不同的浏览器进行单元测试，并且希望更进一步得到这些测试代码覆盖率以便判断测试是否足够。可惜的是，相对于 Java 领域各种强大的单元测试工具，在 JavaScript 领域这方面的研究才起步不久，目前业界虽然有一些工具可以帮助进行 JavaScript 单元测试，也有工具可以做到代码覆盖率的统计，但是还处于各自为政状态。要把他们整合到一起协同工作并不容易。本文先就 JavaScript 单元测试和覆盖率做一简单介绍，然后用一个例子重点展现怎样整合这些工具达到强大的测试功能。<\/p><h2 id=\"2.用户界面的自动化测试和单元测试 |outline\">用户界面的自动化测试和单元测试<\/h2><p>一个网站的用户界面是非常易于变化的，当我们对于用户界面进行改动后，同样也需要有足够的测试来保证这个改动符合我们的预期，在理想状态下，开发人员在提交代码之前就能够进行这种测试并及时得到反馈，如果测试没有通过就不能提交代码。改正发现的问题后继续测试，并最终通过和提交。<\/p><p>然而即使在今天大多数的网站仍然是通过手工测试来保证用户界面的正确性，手工测试会占用到大量的人力物力，成本很高。而且手工测试花费的时间也多，很难在开发人员提交代码前给予及时的测试反馈，导致开发人员在没有足够测试的支持下提交代码，并造成潜在的代码质量问题。因此，我们需要自动化测试来保证代码的质量。<\/p><p>除了自动化之外，我们还需要单元测试，因为前端开发工程师要保证用户界面的正确性，但是如果进行传统的端到端测试，测试结果很大程度上会依赖于后端的运行结果。比如后端的一个错误会影响到前端界面不能按照预期来显示。所以在测试的时候需要把后端给替换成 mock，在测试用例中模拟后端的行为。<\/p><p>然而，对用户界面进行单元测试的难度，相对于其他模块的单元测试来说也更高。这通常是因为用户界面的代码总是和整个环境以及其他模块紧密相关，很难将它分离做单独的测试。好在大部分 JavaScript 开发框架都能够对于网站的用户界面和其背后的业务逻辑进行一定程度的解耦，另外还有很多测试工具在单元测试上提供支持。主流的 JavaScript 测试工具，如 DOH，QUnit，JSTestDriver，JSUnit 等，都提供了单元测试的可能性。<\/p><p>值得一提的是，虽然名义上使用哪个测试工具对于你使用哪个开发框架没有严格的依赖，但是部分测试工具是某些开发框架的扩展，它对于该框架有着天然的支持。比如 Qunit 之于 jQuery，以及 DOH 之于 Dojo。因此如果使用了 jQuery 或者 Dojo 开发用户界面，应该首选与之对应的 Qunit 或 DOH 来进行测试。<\/p><h2 id=\"3.测试 JavaScript 代码覆盖率 |outline\">测试 JavaScript 代码覆盖率<\/h2><ol type=\"1\"><li>有了自动化单元测试还不够，获取和分析代码覆盖率是确保测试质量的重要手段。代码覆盖率描述的是代码被测试的比例和程度。简单地说，光是编写用例来测试代码，而不检查究竟哪些代码被测试过，哪些还没有测试过，很容易形成测试的漏洞。代码覆盖率是一种白盒测试方法，因为它需要对代码本身进行理解和分析。通过测试代码覆盖率可以得知哪些代码未被覆盖，从而进一步补足测试用例。<\/li><li/><li>对于 Java 编写的代码，我们已经有很成熟的覆盖率测试方案，例如开源工具库 EMMA 和 JoCoCo.然而对于 JavaScript 代码来说,无论是工具的成熟度还是人们对代码覆盖率的关注程度,都远不如 Java。这更需要我们对现有工具进行组合和定制。<\/li><\/ol><p>目前业界主要的代码覆盖率工具是 JSCoverage，以及其后续版本 JSCover。另外一些新兴测试框架也逐渐加入了对于覆盖率的支持，比如 Intern。<\/p><h2 id=\"4.协同工作：在 DOH 单元测试中使用 JScoverage 计算代码覆盖率 |outline\">协同工作：在 DOH 单元测试中使用 JScoverage 计算代码覆盖率<\/h2><p>对于以上提到的每一种开发框架和测试工具，网上都能找到很多实例来教你怎样使用它们。但是要在一个大型工程中把它们整合到一起来发挥最大功用却并不那么容易。需要不断的尝试和总结，下面我们就使用我们项目中的一个例子，来展示怎样使他们更好的协同工作。我们的方法可能不是唯一的方法，但是是经过项目实践行之有效的最佳实践。<\/p><p>在我们的项目中，我们大量使用了 Dojo 工具库来开发我们的前端代码，因此我们使用 Dojo 的自带测试框架 DOH 来进行自动化单元测试，但是 DOH 并不能提供测试覆盖率的支持，于是我们借助 JSCoverage 来帮助我们计算覆盖率。<\/p><ol type=\"1\"><li>确定要测试的 JavaScript 代码并整理到独立的文件夹中\n<p>为了使代码整洁和可测试性，我们需要尽可能把 JavaScript 文件与 html 文件分开，做成单独的 JavaScript 文件，写在 HTML 中间的 JavaScript 代码是没法进行覆盖率分析的。另外为了后续工作的方便，尽量把需要测试的 JavaScript 代码放在一个独立的文件夹下面。<\/p><p>在我们的项目中，我们把要测试的 JavaScript 代码放在了 iaas 目录之下。<\/p><\/li><li>编写 DOH 测试代码\n<p>在明确了需要测试的 JavaScript 代码后，就可以开始针对他们编写 DOH 测试代码了。同样，这些测试代码也放到一个目录下便于管理。一般来说我们会针对每一个 JavaScript 文件或者模块编写一个测试文件，然后使用一个单独文件作为测试入口来加载所有的测试用例。<\/p><p>在我们的项目中，所有的 DOH 测试代码放到 iaas/doh 的目录之下，然后在这个目录下建立 iaasDOHTest.js 文件作为入口，并在这个文件中加载其他所有测试用例，见清单 1<\/p><h5 id=\"N100A4\">清单 1. iaasDOHTest.js 代码<\/h5><div class=\"codesection\"><pre class=\"displaycode\">require(dojoConfig,[\n\t\"iaas/doh/wizard/Wizard\",\n\n\t//iaas/util  util 模块的测试用例\n\t\"iaas/doh/util/image\",\n\t\"iaas/doh/util/instance\",\n\t\"iaas/doh/util/key\",\n\t\n\t//iaas/singleton   singleton 模块的测试用例\n\t\"iaas/doh/singleton/imageListStore\",\n\t\"iaas/doh/singleton/instanceListStore\",\n\t\"iaas/doh/singleton/keyListStore\"\n]);<\/pre><\/div><p>这时，我们就能通过在浏览器输入以下地址直接运行这个 DOH 测试并察看测试结果了。<\/p><div class=\"codesection\"><pre class=\"displaycode\">https://localhost/framework/doh/runnerCoverage.html?test=iaas/doh/iaasDOHTest<\/pre><\/div><p>由于本文的重点在于整合使用测试工具的最佳实践，对于如何编写 DOH 测试本身并不作展开介绍，读者可以通过登陆参考文献中的 DOH 官网来学习这部分知识。<\/p><\/li><li><code>使用<\/code> JSCoverage <code>来生成测试代码<\/code><p>JSCoverage 是现有的 JavaScript 代码的覆盖率测试工具之一，其原理是先对待分析的 JavaScript 代码进行注入修改，生成新的代码，让其有能力对执行过的代码进行记录，然后在测试的时候运行新的代码。新代码在语义上完全包含了老的代码，从而保证测试的正确性，又能通过代码执行的记录算出覆盖率。<\/p><p>首先我们要安装 JSCoverage 软件，在我们项目中把该软件装到了/jscoverage 目录下，这个目录和 iaas 目录同级。<\/p><p>然后我们就要进行代码的注入修改了，JSCoverage 软件有几种使用方式，如服务器模式，代理模式和文件模式等。在我们的实例中，我们选用文件模式，因为我们觉得这种模式最为灵活，可以和 DOH 集成更好。以文件模式使用 JSCoverage 时，在 jscoverage 的目录下按照清单 2 执行命令<\/p><h5 id=\"N100BF\">清单 2. 案例中使用 jscoverage 的命令<\/h5><div class=\"codesection\"><pre class=\"displaycode\">sudo ./jscoverage --encoding=UTF-8 --no-instrument= doh ./iaas ./instrumented<\/pre><\/div><p>在这行代码中，jscoverage 是一个可执行命令，紧跟其后的是我们在命令中用到的两个可选参数：<\/p><ul class=\"ibm-bullet-list\"><li>--encoding 选项: 制定编码方式，若不指定，默认为 ISO-8859-1。我们的 JavaScript 文件编码方式为 utf-8，所以这里也要改为 utf-8<\/li><\/ul><ul class=\"ibm-bullet-list\"><li>--no-instrument 选项：不分析位于指定文件夹下的 JavaScript 文件。有时候在我们的 JavaScript 源代码中也有些不需要进行覆盖率统计的文件，比如第三方编写的代码库。在上述示例中，我们并不对 doh 目录下的文件进行注入，因为我们需要的是待测文件的覆盖率，而不是测试文件本身的覆盖率。<\/li><\/ul><p>之后两个参数是命令的必须参数：<\/p><ul class=\"ibm-bullet-list\"><li>代码源目录：待测试代码的目录，JSCoverage 会读取这个目录下的文件进行注入分析。<\/li><\/ul><ul class=\"ibm-bullet-list\"><li>目标目录：JSCoverage 生成新的代码后会放到这个目录之中，在统计覆盖率的时候需要运行这个目录下的代码，另外，覆盖率分析结果报表也会放在这个目录之中。<\/li><\/ul><p>在我们的例子中，JSCoverage 将分析 iaas 这个目录下的文件，进行注入后把生成的文件放到 instrumented 目录下面。<\/p><p><code>这时，如果我们运行<\/code> instrumented <code>目录下面的代码，<\/code>JSCoverage<code>\n就会进行代码覆盖率的统计了，生成的结果会放在 <\/code>instrumented<code> 目录下面的 <\/code>jscoverage.html<code>\n文件中，可以使用浏览器直接打开这个 <\/code>HTML<code> 文件，就能看到覆盖率分析结果了。<\/code><\/p><\/li><li>定制 DOH 的 runner.html 文件，以同时进行 DOH 的测试和统计代码覆盖率。\n<p>接下来我们就要使 DOH 能够运行到生成的新的代码，而不是原来的代码了。同时，我们也希望 DOH 可以直接连到测试的覆盖率结果页面。<\/p><p>按照清单 3 所示，定制 DOH 的 runner.html 文件，增加访问 JSCoverage 结果的按钮，引用 JSCoverage 的测试结果。<\/p><h5 id=\"N100F1\">清单 3. 案例中增加按钮访问 JSCoverage 结果<\/h5><div class=\"codesection\"><pre class=\"displaycode\">&lt;button style=\"margin-top: 5px; float: left;\" \nonclick=\"window.open('../../contributions/iaas/1.0/shared/instrumented/jscoverage.html');\"&gt;\nCoverage Report&lt;/button&gt;<\/pre><\/div><p>为了避免把原来的 DOH 自带文件覆盖，将新定制过的 runner.html 文件改名，比如 runnerCoverage.html，放到 DOH 的 runner.html 相同的目录。<\/p><p>在选择执行代码的问题上，DOH 可以通过在 url 后面通过 path 参数，来指定模块的加载路径，因此，现在执行单元测试并且计算代码覆盖的 url 是<\/p><div class=\"codesection\"><pre class=\"displaycode\">https://localhost/framework/doh/runnerCoverage.html?test=iaas/doh/iaasDOHTest&amp;\npaths=iaas,../../instrumented<\/pre><\/div><p>可以看到 DOH 把 iaas 模块映射到了 instrumented 目录，这样实际测试的就是经过注入的代码了。访问该 url 后，运行结果如图 1 所示：<\/p><h5 id=\"N10101\">图 1. DOH 运行结果<\/h5><img alt=\"DOH 运行结果\" src=\"/sunshine_new/images/174405026/image003.png\" width=\"509\" /><p>点击 Coverage Result，我们可以看到如下代码覆盖率统计结果，如图 2 所示<\/p><h5 id=\"N1010F\">图 2 代码覆盖率统计结果<\/h5><img alt=\"图 2 代码覆盖率统计结果\" src=\"/sunshine_new/images/174405026/image005.png\" width=\"566\" /><p>需要注意的是，注入后的代码要计算覆盖率，比原始代码要大得多，运行时在性能上会有损失，执行速度大致是原来的一半。因此这种方法主要是为了得到单元测试的覆盖率。有时候我们也会需要性能测试，了解执行这些测试所需要的时间，这个时候就要用原来的代码了。<\/p><p>如果还是要运行原始的 DOH 测试，可以通过如下的链接进行访问：<\/p><div class=\"codesection\"><pre class=\"displaycode\">https://localhost/framework/doh/runner.html?test=iaas/doh/iaasDOHTest&amp;paths=iaas,../../iaas<\/pre><\/div><p>注意这两个链接的两个不同之处，一个是 DOH 的主文件，我们仍然使用 runner.html。另外就是参数 path，仍然指向原始的文件 iaas 目录。上面两个链接可以同时工作，也便于测试时的自由选用。<\/p><\/li><\/ol><h2 id=\"5.结论 |outline\">结论<\/h2><p>综上所述， 在大型网站开发中，往往需要对于用户界面做自动化单元测试，并计算代码覆盖率。DOH 单元测试框架作为 Dojo 工具库的单元测试工具，是测试 Dojo 最好的工具，JSCoverage 是一款计算覆盖率的利器。在我们的实例中，我们运用 DOH 定制 JavaScript 的测试，并组合使用了 JSCoverage，能够同时获得 DOH 测试结果和代码覆盖率，提高了测试的效率和准确性。<\/p><CMA ID: 976001><Site ID: 10><XSLT stylesheet used to transform this file: dw-document-html-7.0.xsl>\r\n\r\n\r\n<\/div>\r\n<\/div>\r\n","createTime":"2014-07-03 00:00:00","deployTime":"2014-07-03 00:00:00","id":0,"intro":"在很多情况下我们需要自动化用户界面的单元测试，以提高代码的准确性和测试的效率。现今对 Java 代码的自动化测试和单元测试已经非常成熟，然而用户界面经常使用 JavaScript 而不是 Java 来开发。能够对 JavaScript 进行自动化单元测试，并能计算代码覆盖率的工具并不成熟。本文先简单介绍 JavaScript 测试的一些工具，然后重点实例展示在项目中整合使用 Dojo+DOH+Jscoverage 的一个最佳实践。","keyword":"","recommend":false,"source":"http://www.ibm.com/developerworks/cn/web/1406_niugang_webtest/index.html","title":"Web 页面自动化测试及代码覆盖率分析","typeId":0,"updateTime":"2014-07-03 00:00:00"}
{"author":"","clickNumber":0,"content":"\r\n<div class=\"ibm-columns\">\r\n<div class=\"ibm-col-1-1\">\r\n\r\n<a id=\"OLE_LINK17\"><\/a><h2 id=\"1.背景介绍 |outline\">背景介绍<\/h2><p>前面文章具体介绍了如何使用 Base Clear Case、UCM Clear Case 和 RTC、CQ 等 Rationa CLM 产品通过 CMI 来实现 OSLC 的集成，以及集成操作中所要遵循的一些操作规则。本文将介绍 CMI 的查询功能。<\/p><p>对于产品之间的集成操作，查询功能必不可少，它可以帮助用户在不需要任何客户端和登录另一端产品的服务器的情况下了解另一端产品的某个关注焦点的状态、进度。不但要了解自身产品关于另一个产品某条目录的关联信息，也要了解另一个产品其他目录的状态，以便更改或作出随时改变。<\/p><p>对于 Clear Case 和 CLM 产品例如 Clear Quest（以下简称 CQ）和 Rational Team Concert （以下简称 RTC）集成来说，查询的功能不仅包括查询当前分支或活动的集成信息，也包括 CLM 产品 Server 端其他有关的信息，如 CQ 的其他缺陷的描述和 ID 和 RTC 其他该工作项的描述和 ID。这样我们就可以在查找的结果上更改现有的集成信息，如把此版本或活动关联到另一个工作项或缺陷。而不用再登录到 CQ，RTC 上查询现有的缺陷或工作项。本身的 Clear Case 的集成查询也支持命令行的形式，这样可以使得查询所要集成的 Provider 信息更方便。<\/p><h2 id=\"1.准备工作 |outline\">准备工作<\/h2><p>在进行例子之前，我们需要安装一些 Rational 的软件，包括 Clear Case8.0.0.8 以上版本，同时需要已经配置好的 Clear Quest 服务器以及 RTC 服务器，并创建样例数据。在我们引入的例子中，我们使用了的版本如下：<\/p><ul class=\"ibm-bullet-list\"><li>Rational Clear Case 以及 Clear Quest 8.0.0.9 版本<\/li><li>Rational Jazz Team Server Version: 4.0.4 M1 版本<\/li><\/ul><h2 id=\"1.BaseClearCase 通过 CMI 和 CLM 产品集成查询的原理 |outline\">Base Clear Case 通过 CMI 和 CLM 产品集成查询的原理<\/h2><p>Clear Case 的查询功能集成到了 Clear Case 的本身命令行里，这使得命令行用户只要多加一个查询参数就可以实现查询功能，下面则是 Base Clear Case 的集成在分支 branch 上实现查询的具体功能简单描述：<\/p><div class=\"codesection\"><pre class=\"displaycode\">cleartool settask -help\nUsage: settask -find [-provider provider_name] {-pname pname |\n               -brtype brtype_name}\n       settask [-view view_tag] {task-selector | -none |\n               [-add_task task-selector[,...]]\n               [-remove_task [task-selector[,...]]]}<\/pre><\/div><p>-find        参数来告诉 CMI 要实现查询操作。<\/p><p>-provider    参数来指定要查的集成 Provider 的名字。<\/p><p>    -pname       从某个具体的 Clear Case 端更改的版本来提取集成的 Provider Server              的信息来查询此 Provider 的所有记录信息。<\/p><p>-brtype      从某个分支上提取具体的集成 Provider Server 的信息，来查询此 Provider 上的所有记录信息。<\/p><p>在查询之前，我们仍然要配置 Provider 基本 Server 地址和查询地址。由于 Rational CLM 软件生命周期管理工具的很多产品都提供了 OSLC 接口，这就使得 Clear Case 的集成查询功能的配置和使用很方便。后面将详细介绍如何在通过命令好的形式完成查询功能，这将对于了解 CMI 查询功能的基本原理很有帮助。<\/p><h2 id=\"1.BaseClearCase 和 CLMCQ，RTC 集成的查询功能 |outline\">Base Clear Case 和 CLM CQ，RTC 集成的查询功能<\/h2><h3 id=\"N1008A\">配置 Base Clear Case CMI 查询功能<\/h3><p>为了实现 CMI 的查询功能，首先要把集成的 Provider 关联到工作的 Vob，然后再把此 Provider 关联到所要工作的分支上，并在此步配置 queryuri 属性即要查找的 Provider Server 的查询 OSLC 地址。命令行如下所示：<\/p><p><a href=\"#N10093\" class=\"ibm-popup-link\" onclick=\"ibmweb.overlay.show('N10093',this);return false;\">点击查看代码清单<\/a><\/p><div id=\"N10093\" class=\"dw-sidefile-overlay ibm-common-overlay ibm-overlay-alt-two\"><div class=\"ibm-head\"><p><a href=\"#close\" class=\"ibm-common-overlay-close\">关闭 [x]<\/a><\/p><\/div><div class=\"ibm-body\"><div class=\"ibm-main\"><div class=\"ibm-container ibm-alternate\"><div class=\"ibm-container-body\"><div class=\"codesection\"><pre class=\"displaycode no-auto-overflow\">cleartool mkcmprovider -vob . -type cmrtc -version v1_0 -desc \"RTC provider\" -connection baseUrl:https://qwin182.ratl.swg.usma.ibm.com:9443/ccm rtcprovider\n\n cleartool mkcmprovider -brtype main -context \"queryUri:/web/projects/Best%20Project%20Ever#action=com.ibm.team.workitem.runSavedQuery&amp;id=_GRZlst9CEeKsxr9ds6iT8Q\" rtcprovider<\/pre><\/div><\/div><\/div><\/div><\/div><div class=\"ibm-footer\"><><\/div><\/div><p>然后通过 cleartool des brtype:main 来检测 queryUri 属性是否配置正确配置到此分支上。具体 Clear Case 命令行操作如图所示：<\/p><h5 id=\"N10098\">图 1. 配置查询参数<\/h5><img alt=\"配置查询参数\" src=\"/sunshine_new/images/负2012465084/image003.jpg\" width=\"636\" /><p>我们所做的查询操作省略了搭建 Clear Case 和 Rational Team Concert 的集成环境的步骤以及创建 VOB，View 和配置 CMI 功能方法，具体可参考此 CMI 前面系列的文章。<\/p><p>如上图所示我们在 VOB 上配置了 RTC Provider 的信息其中包括 baseuri 即要集成的 Server 地址。然后将此 Provider 信息配置到了具体将要工作的分支上，在分支的上下文里，指定了查询操作的 queryUri。CMI 将会合成 baseUrl 和 queryUri 来完成整个查询的 OSLC 地址。两者缺一不可，如果条件可以，你可以尝试把 baseUrl 和 queryUri 拼接起来在浏览器里验证 RTC Server 是否正常访问。<\/p><h3 id=\"N100A7\">Base Clear Case CMI 的基本查询功能<\/h3><p>CMI 查询的命令如下：<\/p><div class=\"codesection\"><pre class=\"displaycode\">settask -find [-provider provider_name] {-pname pname | -brtype brtype_name}<\/pre><\/div><p>从命令行解释可以看出，provider 参数是可选的，而-pname 和-brtype 两者必须选一。<\/p><p>如果设定了 provider 就从该 provider 的 baseUrl 和 queryUri 属性查找服务器的内容并返回到 Clear Case 端。如果没有设定将遍历查找分支上所有 Provider，并把结果依次返回到 Clear Case 端。返回的格式是：id@provider 名字：provider 描述。对应的 RTC Provider 和 CQ Provider 就是<\/p><p>工作项 id@RTCprovider 名字：工作项描述<\/p><p>  缺陷 id@CQprovider 名字：缺陷描述<\/p><p>查询会返回所有此 provider 的所有信息，但在 CMI 后台处理中为了防止给服务器和本地内存很大压力每次查询和 Provider Server 的通信仅返回 25 条信息，如果查询了多个 Provider，而第一个 Provider 的返回信息少于 25 个，CMI 后台会继续访问第二个 Provider 直到返回的记录有 25 个，随后返回前台，保存在 Clear Case 的缓存里，再继续查询满足查询条件的其他 Provider 的关联缺陷或工作项信息。数字 25 只是后台为了提高查询性能而设定的默认一次查询返回的最高条数，而不是返回到前台客户最多能看到的条目数。由于查询使用了缓存技术，同样的查询语句如果再次运行，查询返回速度比第一次查询速度要快得多。<\/p><p>pname 和 brtype_name 两个参数必须设定一个，pname 是某个包含集成信息的版本的文件路径，brtype_name 是分支的名字，CMI 根据你设置的 pname 或 brtype_name 来得到分支配置的 Provider 信息，以防用户没有通过-provider 设定具体要查找的 Provider 信息。<\/p><p>如果其中某个 provider 失败，将提示报错但并不影响其他 provider 查找的结果，如下图所示：<\/p><p>我们通过上面提到的命令设置了 provider 的 queryuri，然后用 lsprovider 命令确认设置的 queryUri 已经正确，然后用 settask 命令查找这个 provider 的所有内容，返回的内容包括 Server 的一个 Task 的 id 跟着@后的 server 名字，最后是这个 Task 的名字 summary。<\/p><p>如下图所示，我们在分支上关联了两个要集成的 Provider，CQPROV 和 rtcprovider，通过设定具体要查询的 Provider 可以查到这个分支上关联的 Provider 的所有工作项。根据查询结果，用户可以使用 CMI 后面的关联操作，或者关联到某个文件更改版本，或者关联到完成此工作项的活动。<\/p><h5 id=\"N100C5\">图 2. 通过命令行查看查询结果<\/h5><img alt=\"通过命令行查看查询结果\" src=\"/sunshine_new/images/负2012465084/image005.jpg\" width=\"682\" /><p>通过配置的 baseUrl 和 queryUri 来访问 RTC Provider 页面如图所示：<\/p><p>查询的结果包括 Provider 的 Id 和 Summary 信息,和在 Clear Case 通过 CMI 查询的结果一致。<\/p><h5 id=\"N100D5\">图 3. RTC 里验证查询结果一致<\/h5><img alt=\"RTC 里验证查询结果一致\" src=\"/sunshine_new/images/负2012465084/image007.jpg\" width=\"576\" /><h3 id=\"N100E0\">Base Clear Case 通过 CMI 和 CQ 集成的查询功能<\/h3><p>上面是对于 RTC provider 的查询，如果是 CQ Provider，只需设置-provider CQPROV<\/p><p>CQPROV 是 CQ provider 的名字，查询结果如下：<\/p><h5 id=\"N100EA\">图 4. 通过 Provider 参数进行查询<\/h5><img alt=\"通过 Provider 参数进行查询\" src=\"/sunshine_new/images/负2012465084/image009.jpg\" width=\"576\" /><p>而对应的 CQ provider 的 web 页面为：<\/p><h5 id=\"N100F8\">图 5. RTC 里验证待查询的信息<\/h5><img alt=\"RTC 里验证待查询的信息\" src=\"/sunshine_new/images/负2012465084/image011.jpg\" width=\"576\" /><p>如果我们不设置具体要查询的 provider 信息而是通过具体文件版本的路径或分支来查询，由于他们都是为了帮助来查找分支上关联的 Provider 信息所以会遍历分支上的所有 Provider 并把记录全打出来，如果这个文件所在的分支和你指定的分支一样，他们的查询结果将一致。如下图所示：<\/p><p>文件 1.c 关联了两个 Provider 的两个 task，这是必须的，因为在前面同系列文章介绍关联规则 3 中指出，文件 1.c 必须关联所有配置在所工作分支上的 Provider。然后我们通过两个不同的参数会查出此分支上所有 Provider 的记录。这两个参数是互斥的，有且仅能制定一个，如图 7 所示<\/p><h5 id=\"N10108\">图 6. 在分支上查询帮助命令<\/h5><img alt=\"在分支上查询帮助命令\" src=\"/sunshine_new/images/负2012465084/image013.jpg\" width=\"673\" /><h5 id=\"N10114\">图 7. 通过设定查询参数进行查询<\/h5><img alt=\"通过设定查询参数进行查询\" src=\"/sunshine_new/images/负2012465084/image014.jpg\" width=\"547\" height=\"659\" /><p><a href=\"#N1011B\" class=\"ibm-popup-link\" onclick=\"ibmweb.overlay.show('N1011B',this);return false;\">点击查看大图<\/a><\/p><div id=\"N1011B\" class=\"dw-sidefile-overlay ibm-common-overlay ibm-overlay-alt-two\"><div class=\"ibm-head\"><p><a href=\"#close\" class=\"ibm-common-overlay-close\">关闭 [x]<\/a><\/p><\/div><div class=\"ibm-body\"><div class=\"ibm-main\"><div class=\"ibm-title\"><h2>图 7. 通过设定查询参数进行查询<\/h2><\/div><div class=\"ibm-container ibm-alternate\"><div class=\"ibm-container-body\"><img alt=\"通过设定查询参数进行查询\" src=\"/sunshine_new/images/负2012465084/image014.jpg\" width=\"684\" /><\/div><\/div><\/div><\/div><div class=\"ibm-footer\"><><\/div><\/div><h3 id=\"N10120\">Base Clear Case 的查询错误处理<\/h3><p>如图下图所示，如果我们的 queryuri 设置错误，如把 queryuri 设置成空，运行查询功能将提示错误信息。如果尝试不设置具体要查询的 provider，CMI 将遍历分支上所有 provider 的查询，成功的就打印出来结果，不成功的打印出具体的报错信息。从而看得出来，新的查询功能有很好的容错性。<\/p><h5 id=\"N10128\">图 8.查询遇到错误<\/h5><img alt=\"查询遇到错误\" src=\"/sunshine_new/images/负2012465084/image016.jpg\" width=\"685\" /><h2 id=\"1.UCMClearCase 通过 CMI 和 CLM 产品集成查询的原理 |outline\">UCM Clear Case 通过 CMI 和 CLM 产品集成查询的原理<\/h2><p>有了上面对 Base Clear Case 的查询知识，就很容易了解 UCM Clear Case 的查询原理。同 Base Clear Case 查询一样，UCM 的查询也是集成在已有 Clear Case 命令中：<\/p><div class=\"codesection\"><pre class=\"displaycode\">cleartool lsact -h\nUsage: lsactivity [-short | -long | -fmt format |\n                   -ancestor [-fmt format] [-depth depth] ] [-obsolete]\n                  [-invob vob-selector | -in stream-selector [-recurse] |\n                   activity-selector ... |\n                  [[-cact | -me | -user username] [-view view-tag | -cview]] ]\n       lsactivity -contrib activity-selector ...\n       lsactivity -find [-provider provider_name]\n                  [-in stream-selector | -view view-tag | -cview |\n                   activity-selector]<\/pre><\/div><p>在 UCM 里实现查找的功能集成到了 cleartool lsactivity 命令中<\/p><p>-provider 和 Base Clear Case 查询一样。同样可选的 Provider 参数。<\/p><p>-in stream-selector 类似于分支的 brtype。<\/p><p>-view view-tag 由于 UCM 中每个 stream 都包含用户使用的视图 View, 所以多了 view-tag 来通过视图找到工作的流，然后在流上找到关联的 Provider 信息。<\/p><p>-cview 即当前工作的视图，从而找当前工作的默认流，从流上找到配置的 Provider 查询地址<\/p><p>Activity-selector 通过 activity 找到此 activity 工作的流，从而找到流上的 Provider 的查询地址。<\/p><p>通过上面的命令行说明发现，和 Base 集成上查询的不同之处是 除了-find，其他参数都是可选的。<\/p><p><strong>UCM <\/strong><strong>Clear Case 和 CLM CQ<\/strong><strong>，<\/strong><strong>RTC 集成的查询功能<\/strong><\/p><h3 id=\"N10155\">配置 UCM Clear Case CMI 查询功能<\/h3><p>为了实现 CMI 的查询功能，首先要把集成的 Provider 关联到正在工作的 Vob，然后再把此 Provider 关联到所要工作的分支上，并配置 queryuri 属性，此属性为要查找的 Provider Server 的查询 OSLC 地址。命令行如下所示：<\/p><p><a href=\"#N1015E\" class=\"ibm-popup-link\" onclick=\"ibmweb.overlay.show('N1015E',this);return false;\">点击查看代码清单<\/a><\/p><div id=\"N1015E\" class=\"dw-sidefile-overlay ibm-common-overlay ibm-overlay-alt-two\"><div class=\"ibm-head\"><p><a href=\"#close\" class=\"ibm-common-overlay-close\">关闭 [x]<\/a><\/p><\/div><div class=\"ibm-body\"><div class=\"ibm-main\"><div class=\"ibm-container ibm-alternate\"><div class=\"ibm-container-body\"><div class=\"codesection\"><pre class=\"displaycode no-auto-overflow\">cleartool mkcmprovider -vob . -type cmrtc -version v1_0 -desc \"RTC provider\"\n-connection baseUrl:https://qwin182.ratl.swg.usma.ibm.com:9443/ccm rtcprovider\n\n cleartool mkcmprovider -stream lzhao_int_stream@/usr/vobs/lzhao_ucm_pvob   \n-context \"queryUri:web/projects/CC%20Bridge%20Test%20Project%20Area#action=com.ibm.team.workitem.runSavedQuery\n&amp;id=_d4fW4CiXEeKSXN2AyCuolg\" -enable true -options activityFormat:ACT_%task-id_%stream-name,\nvalidate:true rtcprovider<\/pre><\/div><\/div><\/div><\/div><\/div><div class=\"ibm-footer\"><><\/div><\/div><p>然后通过以下命令：来检测 queryUri 属性是否配置正确<\/p><div class=\"codesection\"><pre class=\"displaycode\">cleartool lsprovider Cstream lzhao_dev_stream@/usr/vobs/lzhao_ucm_pvob<\/pre><\/div><p>  具体 Clear Case 命令行操作如图所示：<\/p><h5 id=\"N10169\">图 9. RTC 里验证关联的活动<\/h5><img alt=\"RTC 里验证关联的活动\" src=\"/sunshine_new/images/负2012465084/image018.jpg\" width=\"651\" /><h3 id=\"N10174\">UCM Clear Case CMI 的基本查询功能<\/h3><p>UCM Clear Case 的后台查询步骤，缓存的处理，性能的提升都，以及查询的返回结果和 Base Clear Case 的查询一致，这里不再敖述。如下图所示：<\/p><p>我们在流 lzhao_int_stream 上配置了两个 Provider，通过 lsprovider 命令可以看到 baseUrl 和 queryUri 已经正确的配置到了各自 Provider 上。<\/p><h5 id=\"N1017E\">图 10. UCM 集成时用命令行进行查询<\/h5><img alt=\"UCM 集成时用命令行进行查询\" src=\"/sunshine_new/images/负2012465084/image020.jpg\" width=\"648\" /><p>如果我们不指定具体的查询 provider 信息，将会遍历所有的 Provider，并输出查询结果，如果其中某个 Provider 查询报错，将和 Base Clear Case 查询一样，输出错误信息，同时打印出正确的 Provider 返回的结果。<\/p><p>如下图所示：<\/p><p>由于 CQ Provider cqprov 的 query 查询条件没有通过验证，将打印出错误信息，但 RTC 的 provider 查询结果仍然正确的打印了出来，CMI 查询 Provider 的遍历顺序和 lsprovider 显示的从上到下的 Provider 排列的顺序一致。我们可以像 Base Clear Case 一样通过 web 页面访问 Provider Server 验证查询结果是否和 Provider 端一致。<\/p><h5 id=\"N10190\">图 11. 不设置参数的默认查询<\/h5><img alt=\"不设置参数的默认查询\" src=\"/sunshine_new/images/负2012465084/image022.jpg\" width=\"687\" /><h2 id=\"1.结论 |outline\">结论<\/h2><p>本文在读者了解了如何使用 Configuration management Interface 来实现 Base/UCM Clear Case 与 Clear Quest 及 RTC 的集成的基础上详细介绍了集成操作中的查询功能，由于基于新的 CMI 架构。查询功能集成到了 settask 命令里，给传统 Clear Case 用户带来了方便，同时次查询功能支持多个集成产品的交互查询以及良好的容错机制，使得我们很容易通过查询的结果选择关联的工作项或缺陷。如果是在 GUI 界面每次操作将弹出所要集成的 Task 列表供你选择集成，此操作后台仍然调用的查询功能。从而可见，查询功能在集成操作时被广泛的使用。<\/p><CMA ID: 975221><Site ID: 10><XSLT stylesheet used to transform this file: dw-document-html-7.0.xsl>\r\n\r\n\r\n<\/div>\r\n<\/div>\r\n","createTime":"2014-07-03 00:00:00","deployTime":"2014-07-03 00:00:00","id":0,"intro":"在对前面文章 Base/UCM Clear Case 和 CLM 产品集成的了解的基础上，本文着重讲解 CMI 的集成查询功能，CMI 的查询功能使用很方便，由于本身 CMI 的基本功能架构的良好，使得基于 Clear Case 版本控制功能而开发的查询不但有了更好的查询性能，而且有很好的扩展性。熟练的掌握 CMI 的查询功能不但有利于方便操作想要集成到具体产品的记录，也有助于了解集成的产品的其他记录信息，有利于对操作错误的诊断和修正。","keyword":"","recommend":false,"source":"http://www.ibm.com/developerworks/cn/rational/1406_zhaoliang_ccclm3/index.html","title":"通过 CMI 实现 ClearCase 和 CLM 产品的集成查询","typeId":0,"updateTime":"2014-07-03 00:00:00"}
{"author":"","clickNumber":0,"content":"\r\n<div class=\"ibm-columns\">\r\n<div class=\"ibm-col-1-1\">\r\n\r\n<h2 id=\"1.什么是 Init 系统,init 系统的历史和现状 |outline\">什么是 Init 系统,init 系统的历史和现状<\/h2><p>Linux 操作系统的启动首先从 BIOS 开始，接下来进入 boot loader，由 bootloader 载入内核，进行内核初始化。内核初始化的最后一步就是启动 pid 为 1 的 init 进程。这个进程是系统的第一个进程。它负责产生其他所有用户进程。<\/p><p>init 以守护进程方式存在，是所有其他进程的祖先。init 进程非常独特，能够完成其他进程无法完成的任务。<\/p><p>Init 系统能够定义、管理和控制 init 进程的行为。它负责组织和运行许多独立的或相关的始化工作(因此被称为 init 系统)，从而让计算机系统进入某种用户预订的运行模式。<\/p><p>仅仅将内核运行起来是毫无实际用途的，必须由 init 系统将系统代入可操作状态。比如启动外壳 shell 后，便有了人机交互，这样就可以让计算机执行一些预订程序完成有实际意义的任务。或者启动 X 图形系统以便提供更佳的人机界面，更加高效的完成任务。这里，字符界面的 shell 或者 X 系统都是一种预设的运行模式。<\/p><p>大多数 Linux 发行版的 init 系统是和 System V 相兼容的，被称为 sysvinit。这是人们最熟悉的 init 系统。一些发行版如 Slackware 采用的是 BSD 风格 Init 系统，这种风格使用较少，本文不再涉及。其他的发行版如 Gentoo 是自己定制的。Ubuntu 和 RHEL 采用 upstart 替代了传统的 sysvinit。而 Fedora 从版本 15 开始使用了一个被称为 systemd 的新 init 系统。<\/p><p>可以看到不同的发行版采用了不同的 init 实现，本系列文章就是打算讲述三个主要的 Init 系统：sysvinit，UpStart 和 systemd。了解它们各自的设计特点，并简要介绍它们的使用。<\/p><p>在 Linux 主要应用于服务器和 PC 机的时代，SysVinit 运行非常良好，概念简单清晰。它主要依赖于 Shell 脚本，这就决定了它的最大弱点：启动太慢。在很少重新启动的 Server 上，这个缺点并不重要。而当 Linux 被应用到移动终端设备的时候，启动慢就成了一个大问题。为了更快地启动，人们开始改进 sysvinit，先后出现了 upstart 和 systemd 这两个主要的新一代 init 系统。Upstart 已经开发了 8 年多，在不少系统中已经替换 sysvinit。Systemd 出现较晚，但发展更快，大有取代 upstart 的趋势。<\/p><p>本文的第一部分先简要介绍 sysvinit。<\/p><h2 id=\"2.Sysvinit 概况 |outline\">Sysvinit 概况<\/h2><p>sysvinit 就是 system V 风格的 init 系统，顾名思义，它源于 System V 系列 UNIX。它提供了比 BSD 风格 init 系统更高的灵活性。是已经风行了几十年的 UNIX init 系统，一直被各类 Linux 发行版所采用。<\/p><h3 id=\"N1006A\">运行级别<\/h3><p>Sysvinit 用术语 runlevel 来定义\"预订的运行模式\"。Sysvinit 检查 '/etc/inittab' 文件中是否含有 'initdefault' 项。 这告诉 init 系统是否有一个默认运行模式。如果没有默认的运行模式，那么用户将进入系统控制台，手动决定进入何种运行模式。<\/p><p>sysvinit 中运行模式描述了系统各种预订的运行模式。通常会有 8 种运行模式，即运行模式 0 到 6 和 S 或者 s。<\/p><p>每种 Linux 发行版对运行模式的定义都不太一样。但 0，1，6 却得到了大家的一致赞同：<\/p><ul class=\"ibm-bullet-list\"><li>0 关机<\/li><li>1 单用户模式<\/li><li>6 重启<\/li><\/ul><p>通常在 /etc/inittab 文件中定义了各种运行模式的工作范围。比如 RedHat 定义了 runlevel 3 和 5。运行模式 3 将系统初始化为字符界面的 shell 模式；运行模式 5 将系统初始化为 GUI 模式。无论是命令行界面还是 GUI，运行模式 3 和 5 相对于其他运行模式而言都是完整的正式的运行状态，计算机可以完成用户需要的任务。而模式 1，S 等往往用于系统故障之后的排错和恢复。<\/p><p>很显然，这些不同的运行模式下系统需要初始化运行的进程和需要进行的初始化准备都是不同的。比如运行模式 3 不需要启动 X 系统。用户只需要指定需要进入哪种模式，sysvinit 将负责执行所有该模式所必须的初始化工作。<\/p><h3 id=\"N10080\">sysvinit 运行顺序<\/h3><p>Sysvinit 巧妙地用脚本，文件命名规则和软链接来实现不同的 runlevel。首先，sysvinit 需要读取/etc/inittab 文件。分析这个文件的内容，它获得以下一些配置信息：<\/p><ul class=\"ibm-bullet-list\"><li>系统需要进入的 runlevel<\/li><li>捕获组合键的定义<\/li><li>定义电源 fail/restore 脚本<\/li><li>启动 getty 和虚拟控制台<\/li><\/ul><p>得到配置信息后，sysvinit 顺序地执行以下这些步骤，从而将系统初始化为预订的 runlevel X。<\/p><ul class=\"ibm-bullet-list\"><li>/etc/rc.d/rc.sysinit<\/li><li>/etc/rc.d/rc 和/etc/rc.d/rcX.d/   (X 代表运行级别 0-6)<\/li><li>/etc/rc.d/rc.local<\/li><li>X Display Manager（如果需要的话）<\/li><\/ul><p>首先，运行 rc.sysinit 以便执行一些重要的系统初始化任务。在 RedHat 公司的 RHEL5 中(RHEL6 已经使用 upstart 了)，rc.sysinit 主要完成以下这些工作。<\/p><ul class=\"ibm-bullet-list\"><li>激活 udev 和 selinux<\/li><li>设置定义在/etc/sysctl.conf 中的内核参数<\/li><li>设置系统时钟<\/li><li>加载 keymaps<\/li><li>使能交换分区<\/li><li>设置主机名(hostname)<\/li><li>根分区检查和 remount<\/li><li>激活 RAID 和 LVM 设备<\/li><li>开启磁盘配额<\/li><li>检查并挂载所有文件系统<\/li><li>清除过期的 locks 和 PID 文件<\/li><\/ul><p>完成了以上这些工作之后，sysvinit 开始运行/etc/rc.d/rc 脚本。根据不同的 runlevel，rc 脚本将打开对应该 runlevel 的 rcX.d 目录(X 就是 runlevel)，找到并运行存放在该目录下的所有启动脚本。每个 runlevel X 都有一个这样的目录，目录名为/etc/rc.d/rcX.d。<\/p><p>在这些目录下存放着很多不同的脚本。文件名以 S 开头的脚本就是启动时应该运行的脚本，S 后面跟的数字定义了这些脚本的执行顺序。在/etc/rc.d/rcX.d 目录下的脚本其实都是一些软链接文件，真实的脚本文件存放在/etc/init.d 目录下。如下所示：<\/p><h5 id=\"N100BA\">清单 1.rc5.d 目录下的脚本<\/h5><div class=\"codesection\"><pre class=\"displaycode\">[root@www ~]# ll /etc/rc5.d/\nlrwxrwxrwx 1 root root 16 Sep  4  2008 K02dhcdbd -&gt; ../init.d/dhcdbd\n....(中间省略)....\nlrwxrwxrwx 1 root root 14 Sep  4  2008 K91capi -&gt; ../init.d/capi\nlrwxrwxrwx 1 root root 23 Sep  4  2008 S00microcode_ctl -&gt; ../init.d/microcode_ctl\nlrwxrwxrwx 1 root root 22 Sep  4  2008 S02lvm2-monitor -&gt; ../init.d/lvm2-monitor\n....(中间省略)....\nlrwxrwxrwx 1 root root 17 Sep  4  2008 S10network -&gt; ../init.d/network\n....(中间省略)....\nlrwxrwxrwx 1 root root 11 Sep  4  2008 S99local -&gt; ../rc.local\nlrwxrwxrwx 1 root root 16 Sep  4  2008 S99smartd -&gt; ../init.d/smartd\n....(底下省略)....<\/pre><\/div><p>当所有的初始化脚本执行完毕。Sysvinit 运行/etc/rc.d/rc.local 脚本。<\/p><p>rc.local 是 Linux 留给用户进行个性化设置的地方。您可以把自己私人想设置和启动的东西放到这里，一台 Linux Server 的用户一般不止一个，所以才有这样的考虑。<\/p><h3 id=\"N100C3\">Sysvinit 和系统关闭<\/h3><p>Sysvinit 不仅需要负责初始化系统，还需要负责关闭系统。在系统关闭时，为了保证数据的一致性，需要小心地按顺序进行结束和清理工作。<\/p><p>比如应该先停止对文件系统有读写操作的服务，然后再 umount 文件系统。否则数据就会丢失。<\/p><p>这种顺序的控制这也是依靠/etc/rc.d/rcX.d/目录下所有脚本的命名规则来控制的，在该目录下所有以 K 开头的脚本都将在关闭系统时调用，字母 K 之后的数字定义了它们的执行顺序。<\/p><p>这些脚本负责安全地停止服务或者其他的关闭工作。<\/p><h3 id=\"N100D0\">Sysvinit 的管理和控制功能<\/h3><p>此外，在系统启动之后，管理员还需要对已经启动的进程进行管理和控制。原始的 sysvinit 软件包包含了一系列的控制启动，运行和关闭所有其他程序的工具。<\/p><p><strong>halt<\/strong><\/p><p>停止系统。<\/p><p><strong>init<\/strong><\/p><p>这个就是 sysvinit 本身的 init 进程实体，以 pid1 身份运行，是所有用户进程的父进程。最主要的作用是在启动过程中使用/etc/inittab 文件创建进程。<\/p><p><strong>killall5<\/strong><\/p><p>就是 SystemV 的 killall 命令。向除自己的会话(session)进程之外的其它进程发出信号，所以不能杀死当前使用的 shell。<\/p><p><strong>last<\/strong><\/p><p>回溯/var/log/wtmp 文件(或者-f 选项指定的文件)，显示自从这个文件建立以来，所有用户的登录情况。<\/p><p><strong>lastb<\/strong><\/p><p>作用和 last 差不多，默认情况下使用/var/log/btmp 文件，显示所有失败登录企图。<\/p><p><strong>mesg<\/strong><\/p><p>控制其它用户对用户终端的访问。<\/p><p><strong>pidof<\/strong><\/p><p>找出程序的进程识别号(pid)，输出到标准输出设备。<\/p><p><strong>poweroff<\/strong><\/p><p>等于 shutdown -h Cp，或者 telinit 0。关闭系统并切断电源。<\/p><p><strong>reboot<\/strong><\/p><p>等于 shutdown Cr 或者 telinit 6。重启系统。<\/p><p><strong>runlevel<\/strong><\/p><p>读取系统的登录记录文件(一般是/var/run/utmp)把以前和当前的系统运行级输出到标准输出设备。<\/p><p><strong>shutdown<\/strong><\/p><p>以一种安全的方式终止系统，所有正在登录的用户都会收到系统将要终止通知，并且不准新的登录。<\/p><p><strong>sulogin<\/strong><\/p><p>当系统进入单用户模式时，被 init 调用。当接收到启动加载程序传递的-b 选项时，init 也会调用 sulogin。<\/p><p><strong>telinit<\/strong><\/p><p>实际是 init 的一个连接，用来向 init 传送单字符参数和信号。<\/p><p><strong>utmpdump<\/strong><\/p><p>以一种用户友好的格式向标准输出设备显示/var/run/utmp 文件的内容。<\/p><p><strong>wall<\/strong><\/p><p>向所有有信息权限的登录用户发送消息。<\/p><p>不同的 Linux 发行版在这些 sysvinit 的基本工具基础上又开发了一些辅助工具用来简化 init 系统的管理工作。比如 RedHat 的 RHEL 在 sysvinit 的基础上开发了 initscripts 软件包，包含了大量的启动脚本 (如 rc.sysinit) ，还提供了 service，chkconfig 等命令行工具，甚至一套图形化界面来管理 init 系统。其他的 Linux 发行版也有各自的 initscript 或其他名字的 init 软件包来简化 sysvinit 的管理。<\/p><p>只要您理解了 sysvinit 的机制，在一个最简的仅有 sysvinit 的系统下，您也可以直接调用脚本启动和停止服务，手动创建 inittab 和创建软连接来完成这些任务。因此理解 sysvinit 的基本原理和命令是最重要的。您甚至也可以开发自己的一套管理工具。<\/p><h3 id=\"OLE_LINK2\">Sysvinit 的小结<\/h3><p>Sysvinit 的优点是概念简单。Service 开发人员只需要编写启动和停止脚本，概念非常清楚；将 service 添加/删除到某个 runlevel 时，只需要执行一些创建/删除软连接文件的基本操作；这些都不需要学习额外的知识或特殊的定义语法(UpStart 和 Systemd 都需要用户学习新的定义系统初始化行为的语言)。<\/p><p>其次，sysvinit 的另一个重要优点是确定的执行顺序：脚本严格按照启动数字的大小顺序执行，一个执行完毕再执行下一个，这非常有益于错误排查。UpStart 和 systemd 支持并发启动，导致没有人可以确定地了解具体的启动顺序，排错不易。<\/p><p>但是串行地执行脚本导致 sysvinit 运行效率较慢，在新的 IT 环境下，启动快慢成为一个重要问题。此外动态设备加载等 Linux 新特性也暴露出 sysvinit 设计的一些问题。针对这些问题，人们开始想办法改进 sysvinit，以便加快启动时间，并解决 sysvinit 自身的设计问题。<\/p><p>Upstart 是第一个被广泛应用的新一代 init 系统。我们在接下来的第二部分介绍 UpStart。<\/p><CMA ID: 976052><Site ID: 10><XSLT stylesheet used to transform this file: dw-document-html-7.0.xsl>\r\n\r\n\r\n<\/div>\r\n<\/div>\r\n","createTime":"2014-07-02 00:00:00","deployTime":"2014-07-02 00:00:00","id":0,"intro":"近年来，Linux 系统的 init 进程经历了两次重大的演进，传统的 sysvinit 已经淡出历史舞台，新的 init 系统 UpStart 和 systemd 各有特点，而越来越多的 Linux 发行版采纳了 systemd。本文简要介绍了这三种 init 系统的使用和原理，每个 Linux 系统管理员和系统软件开发者都应该了解它们，以便更好地管理系统和开发应用。本文是系列的第一部分，主要讲述 sysvinit 的特点和使用。","keyword":"","recommend":false,"source":"http://www.ibm.com/developerworks/cn/linux/1407_liuming_init1/index.html","title":"浅析 Linux 初始化 init 系统，第 1 部分: sysvinit","typeId":0,"updateTime":"2014-07-02 00:00:00"}
{"author":"","clickNumber":0,"content":"\r\n<div class=\"ibm-columns\">\r\n<div class=\"ibm-col-1-1\">\r\n\r\n<div class=\"dw-sidebar ibm-inset\"><h2 id=\"N10058\">关于本系列<\/h2><p>Java 传承的是平台，而不是语言。有超过 200 种语言可以在 JVM 上运行，它们之中不可避免地会有一种语言最终取代 Java\n                    语言，成为编写 JVM 程序的最佳方式。本系列将探讨三种下一代 JVM 语言：Groovy、Scala 和\n                    Clojure，比较并对比新的功能和范例，让 Java 开发人员对自己近期的未来发展有大致的了解。<\/p><\/div><p> 本系列的初衷是对三种较新的 JVM 语言进行比较，帮助您评估其中哪一种语言是 Java 语言最有可能的继任者。但与此同时，Java\n                语言经历了它自从增加范型以来最为重要的一次变革。现在，Java 本身展示出了众多 Groovy、Scala 与 Clojure\n                语言中最令人满意的特性。在本文中，我将 Java 8 视为 Java\n                下一代语言，并给出了一些示例来说明该语言的编程范型已经被有效增强到了何种程度。<\/p><h2 id=\"N1005F\">最后的高阶函数<\/h2><p> 高阶函数使用其他函数作为参数，并返回其他函数作为结果。Java 最终以 <em>lambda 表达式<\/em>\n                的形式拥有了高阶函数，它或许是流行语言中最后一个拥有高阶函数的语言。Java 8\n                工程师不仅将高阶函数收入语言中，而且还聪明地支持老式接口，以便利用函数功能。<\/p><p> 在 \"<a href=\"http://www.ibm.com/developerworks/cn/java/j-jn10/index.html\">函数式编码风格<\/a>\" 一文中，我演示了如何使用 Java\n                下一代语言实现来解决一个通常要求强制解决的问题。该问题假设要在一个输入的姓名清单中删除单字符的项，并返回一个以逗号隔开的清单，并将其中的每个姓名都被转换为大写。清单\n                1 中给出了这个强制性的 Java 解决方案。<\/p><h5 id=\"listing1\">清单 1. 强制性的姓名转换<\/h5><div class=\"codesection\"><pre class=\"displaycode\">public String cleanNames(List&lt;String&gt; listOfNames) {\n    StringBuilder result = new StringBuilder();\n    for(int i = 0; i &lt; listOfNames.size(); i++) {\n        if (listOfNames.get(i).length() &gt; 1) {\n            result.append(capitalizeString(listOfNames.get(i))).append(\",\");\n        }\n    }\n    return result.substring(0, result.length() - 1).toString();\n}\n\npublic String capitalizeString(String s) {\n    return s.substring(0, 1).toUpperCase() + s.substring(1, s.length());\n}<\/pre><\/div><p> 在以前的 Java 版本中，迭代属于规范，但在 Java 8 中，这项任务将由<em>流（stream）<\/em> 更好地完成 &#8212;\n                流是一种抽象概念，就像是在集合与 UNIX&#174; 管道之间搭起了一座桥梁。清单 2 使用了流。<\/p><h5 id=\"listing2\">清单 2. Java 8\n                中的姓名转换<\/h5><div class=\"codesection\"><pre class=\"displaycode\">public String cleanNames(List&lt;String&gt; names) {\n    return names\n            .stream()\n            .filter(name -&gt; name.length() &gt; 1)\n            .map(name -&gt; capitalize(name))\n            .collect(Collectors.joining(\",\"));\n}\n\nprivate String capitalize(String e) {\n    return e.substring(0, 1).toUpperCase() + e.substring(1, e.length());\n}<\/pre><\/div><p><a href=\"#listing1\">清单 1<\/a> 中的迭代版本必须将过滤器、转换与连接合并到一个 <code>for<\/code>\n                循环中，因为针对每个任务在集合上进行循环的效率非常低。借助 Java 8\n                    中的流，您可以连接函数并将它们组合在一起，直到调用生成输出的函数（称为<em>终端操作<\/em>）为止，比如\n                <code>collect()<\/code> 或 <code>forEach()<\/code>。<\/p><div class=\"dw-sidebar ibm-inset\"><p>我使用了一些语法糖来创建 <a href=\"#listing2\">清单 2<\/a> 中的 lambda\n                    表达式。<code>.filter(name -&gt; name.length() &gt; 1)<\/code> 是\n                    <code>filter((name) -&gt; name.length() &gt; 1<\/code>\n                    的简写形式。对于单个参数而言，那一对括号是多余的。<\/p><\/div><p><a href=\"#listing2\">清单 2<\/a> 中的 <code>filter()<\/code> 方法与函数式语言中常见的 filter\n                方法是一样的（参见 \"<a href=\"http://www.ibm.com/developerworks/cn/java/j-jn11/index.html\">Java 下一代：克服同义词干扰<\/a>\"）。<code>filter()<\/code> 方法接受一个返回 Boolean\n                值的高阶函数，该值被用作一个过滤标准：<code>true<\/code> 表示包含在已过滤的集合中，而 <code>false<\/code>\n                表示在已过滤的集合中找不到它。<\/p><p><code>filter()<\/code> 方法接受一个 <code>Predicate&lt;T&gt;<\/code> 类型，这是一个返回\n                Boolean 值的方法。如果愿意的话，您可以显式地创建谓词实例，如清单 3 中所示。<\/p><h5 id=\"listing3\">清单 3. 手动创建一个谓词<\/h5><div class=\"codesection\"><pre class=\"displaycode\">Predicate&lt;String&gt; p = (name) -&gt; name.startsWith(\"Mr\");\nList&lt;String&gt; l = List.of(\"Mr Rogers\", \"Ms Robinson\", \"Mr Ed\");\nl.stream().filter(p).forEach(i -&gt; System.out.println(i));<\/pre><\/div><p> 在 <a href=\"#listing3\">清单 3<\/a> 中，通过将过滤的 lambda 表达式指定给它，我创建了一个谓词。当我在第三行调用\n                <code>filter()<\/code> 方法时，我将谓词作为期望的参数进行传递。<\/p><p> 在 <a href=\"#listing2\">清单 2<\/a> 中，<code>map()<\/code> 方法按照预期将\n                <code>capitalize()<\/code> 方法应用于集合中的每个元素。最后，我调用了 <code>collect()<\/code>\n                方法，这是一个终端操作 &#8212; 一个从流中生成值的方法。<code>collect()<\/code> 方法执行类似的\n                    <em>reduce<\/em> 操作：组合元素，以便生成一个（通常）更小的结果，有时候只生成了一个值（例如，一次 <em>sum<\/em>\n                操作）。Java 8 有一个 <code>reduce()<\/code> 方法，但在这个例子中，<code>collect()<\/code>\n                方法更适用，因为它对可变容器（比如 <code>StringBuilder<\/code>）的处理更加高效。<\/p><p> 通过向现有的类和集合添加函数式结构，比如<em>映射（map）<\/em> 和<em>缩减（reduce）<\/em> 操作，Java\n                需要面对高效更新集合的问题。例如，如果您不能在典型的 Java 集合（如 <code>ArrayList<\/code>）上使用<em>缩减<\/em>\n                操作，它的作用就会要小很多。Scala 与 Clojure 中的很多集合库在默认情况下都是不可变的，这让运行时能够产生高效的操作。Java 8\n                不能强迫开发人员修改集合，而且 Java 中很多现有的集合类都是可变的。因此，Java 8 中包含对诸如\n                <code>ArrayList<\/code> 与 <code>StringBuilder<\/code> 之类集合执行<em>可变缩减（mutable\n                    reduction）<\/em>操作的方法，这些方法将会更新现有元素，而不是更新每次替换结果。尽管 <code>reduce()<\/code>\n                也能用在 <a href=\"#listing2\">清单 2<\/a> 中，但 <code>collect()<\/code>\n                对于这个实例中返回的集合更加高效。<\/p><p>我在 \"<a href=\"http://www.ibm.com/developerworks/cn/java/j-jn13/index.html\">对比并发性<\/a>\" 一文中谈到的函数式语言的优势之一就是，通常只要添加一个修饰符就能轻松地并行处理集合。Java 8\n                也提供同样的优势，如清单 4 中所示。<\/p><h5 id=\"listing4\">清单 4. Java 8\n                中的并行处理<\/h5><div class=\"codesection\"><pre class=\"displaycode\">public String cleanNamesP(List&lt;String&gt; names) {\n    return names \n            .parallelStream() \n            .filter(n -&gt; n.length() &gt; 1) \n            .map(e -&gt; capitalize(e)) \n            .collect(Collectors.joining(\",\"));\n}<\/pre><\/div><p> 和在 Scala 中一样，只需添加一个 <code>parallelStream()<\/code> 修饰符，便可在清单 4\n                中并行完成流操作。函数式编程将实现细节交给运行时来完成，这样它就可以在更高的抽象层上工作。可将线程轻松地应用于集合就是这种优势的一种证明。<\/p><p>Java 8 中的 reducer 类之间存在差异，这使得向现有的语言构件添加深度范型变得非常困难。Java 8\n                团队做了大量的工作，才能以基本无缝的方式添加函数式结构。这种集成的一个良好示例是添加函数式接口。<\/p><h2 id=\"N10124\">函数式接口<\/h2><p> 一种常见的 Java 模式是附带一个方法的接口，该接口也被称为 <em>SAM<\/em>（单一抽象方法）接口，比如\n                <code>Runnable<\/code> 或 <code>Callable<\/code>。在多数情况下，SAM\n                主要被用作可移植代码的一种传送机制。Java 8 使用 lambdas 表达式这种方式实现了可移植代码。一种叫做<em>函数式接口<\/em>\n                的聪明机制支持 lambdas 与 SAM 以有用的方式进行交互。每个函数式接口都包含一个抽象方法（并可以包含几个<a href=\"#dm\">默认方法<\/a>）。函数式接口增强了现有的 SAM 接口，支持使用 lambda\n                表达式代替传统的匿名内部类。例如，<code>Runnable<\/code> 接口现在可以使用\n                <code>@FunctionalInterface<\/code> 注释进行标记。这种可选的注释用于告诉编译器检查\n                <code>Runnable<\/code> 是一个接口（不是类或枚举），而且被注释的类型满足函数式接口的要求。<\/p><p> 作为 lambda 表达式可替代性的一个例子，我通过传递一个 lambda 表达式来代替 <code>Runnable<\/code> 匿名内部类，在\n                Java 8 中创建了一个新线程：<\/p><div class=\"codesection\"><pre class=\"displaycode\">new Thread(() -&gt; System.out.println(\"Inside thread\")).start();<\/pre><\/div><p> 在很多有用的地方，函数式接口可以与 lambda 表达式无缝集成。函数式接口是一项重大创新，因为它与已有的 Java 模式能够完美融合。<\/p><h4 id=\"dm\">默认方法<\/h4><p> 借助 Java 8，您还可以在接口上声明<em>默认方法<\/em>。默认方法就是公共的非抽象非静态方法（有方法体），在接口类型中进行声明，并使用\n                <code>default<\/code> 关键字进行标记。每个默认方法都自动被添加给实现接口的类 &#8212;\n                一种使用默认功能修饰类的便捷方法。例如，<code>Comparator<\/code> 接口现在包含的默认方法超过一打。如果使用 lambda\n                表达式创建一个比较器，我可以轻松创建反转比较器，如清单 5 中所示。<\/p><h5 id=\"listing5\">清单 5. <code>Comparator<\/code>\n                    的默认方法<\/h5><div class=\"codesection\"><pre class=\"displaycode\">List&lt;Integer&gt; n = List.of(1, 4, 45, 12, 5, 6, 9, 101);\nComparator&lt;Integer&gt; c1 = (x, y) -&gt; x - y;\nComparator&lt;Integer&gt; c2 = c1.reversed();\nSystem.out.println(\"Smallest = \" + n.stream().min(c1).get());\nSystem.out.println(\"Largest = \" + n.stream().min(c2).get());<\/pre><\/div><p> 在清单 5 中，我创建了一个 <code>Comparator<\/code> 实例，并使用 lambda 表达式来封装它。然后，我可以通过调用\n                <code>reversed()<\/code> 默认方法来创建一个反转比较器。将默认方法附加给接口的能力模仿了 <em>mixins<\/em>\n                的通常用法（参见 \"<a href=\"http://www.ibm.com/developerworks/cn/java/j-jn8/index.html\">混入和特征<\/a>\" 一文），这是对 Java 语言的一种有益补充。<\/p><h4 id=\"N10177\">可选<\/h4><p> 请注意，在 <a href=\"#listing5\">清单 5<\/a> 中的终端调用中，最后调用了 <code>get()<\/code>。对\n                <code>min()<\/code> 这种内置方法的调用返回一个 <code>Optional<\/code> 而非值。这种行为模仿了 Java\n                下一代的 <em>option<\/em> 特性，正如 \"<a href=\"http://www.ibm.com/developerworks/cn/java/j-jn4/index.html\">Groovy、Scala 与 Clojure 的共性，第 3 部分<\/a>\" 一文的 Scala\n                中一样。<code>Optional<\/code> 可防止方法返回将 <code>null<\/code> 作为错误与\n                <code>null<\/code> 作为合法值进行合并。例如，只有合法结果存在时，Java 8 才可以使用\n                <code>ifPresent()<\/code> 方法来执行代码块。例如，这段代码只会在有值存在时才打印结果：<\/p><div class=\"codesection\"><pre class=\"displaycode\">n.stream()\n    .min((x, y) -&gt; x - y)\n    .ifPresent(z -&gt; System.out.println(\"smallest is \" + z));<\/pre><\/div><p>如果希望执行其他的操作，那么还可以使用 <code>orElse()<\/code> 方法。浏览 Java 8 中的\n                <code>Comparator<\/code> 接口对您了解默认方法有多么强大有很好的启发作用。<\/p><h2 id=\"N101A9\">关于流的更多信息<\/h2><div class=\"ibm-pull-quote ibm-inset\"><blockquote><p><em><span class=\"ibm-pullquote-open\">“<\/span>Java 8 中的流接口及其相关功能是一套经过深思熟虑的扩展集合，可以将 Java\n                    语言带上一个新的层面。<span class=\"ibm-pullquote-close\">”<\/span><\/em><\/p><\/blockquote><p class=\"ibm-pullquote-source\"/><\/div><p> Java 8 中的<em>流<\/em> 抽象概念让很多高级的功能特性变为可能。流在很多方面与集合很像，但也存在关键区别：<\/p><ul class=\"ibm-bullet-list\"><li>流不存储值，更像是从输入源通过终端操作到达目的地的一条管道。<\/li><li>流被设计为是函数式的，而不是状态式的。例如，<code>filter()<\/code>\n                    操作返回经过过滤的值的流，同时不会修改底层集合。<\/li><li>流操作正在尝试尽量变懒（参见 \"<a href=\"http://www.ibm.com/developerworks/cn/java/j-jn12/index.html\"><em>Java 下一代<\/em>：内存化和函数式协同<\/a>\" 和 \"<a href=\"http://www.ibm.com/developerworks/cn/java/j-ft18/index.html\"><em>函数式思维<\/em>：惰性计算，第 1 部分<\/a>\"）。惰性集合仅在必须检索值的时候才会执行操作。<\/li><li>流可以是无限制的。例如，您可以构造一个流来返回所有数字，然后使用诸如 <code>limit()<\/code> 和\n                    <code>findFirst()<\/code> 之类的方法来收集子集。<\/li><li>与 <code>Iterator<\/code> 类似，流在使用时才被充满，在后续再次使用之前，必须重新生成它。<\/li><\/ul><p> 流操作要么是<em>中间<\/em>操作，要么是<em>终端<\/em> 操作。中间操作返回一个新流，并始终是懒惰的。例如，在流上使用\n                <code>filter()<\/code> 操作并不会真正过滤流，而是创建一个只在<em>终端<\/em>\n                操作进行遍历时返回过滤后值的流。终端操作会遍历流，产生值或副作用（如果您编写的函数存在副作用，这会让人气馁）。<\/p><p> 流已经包含很多有用的终端操作。例如，我在<a href=\"https://www.ibm.com/developerworks/cn/views/global/libraryview.jsp?sort_by=&amp;show_abstract=true&amp;show_all=&amp;search_flag=&amp;contentarea_by=Java+technology&amp;search_by=函数式思维&amp;topic_by=-1&amp;type_by=所有类别&amp;ibm-search=搜索\"><em>函数式思维<\/em><\/a> 系列文章中举的数字分类器例子（这个例子也出现在前面的两篇 <a href=\"https://www.ibm.com/developerworks/cn/views/global/libraryview.jsp?sort_by=&amp;show_abstract=true&amp;show_all=&amp;search_flag=&amp;contentarea_by=Java+technology&amp;search_by=Java+下一代&amp;product_by=-1&amp;topic_by=-1&amp;type_by=所有类别&amp;ibm-search=搜索\"><em>Java 下一代<\/em><\/a> 文章中）。清单 6 使用 Java 8 实现了该分类器。<\/p><h5 id=\"listing6\">清单 6. Java 8\n                中的数字分类器<\/h5><div class=\"codesection\"><pre class=\"displaycode\">public class NumberClassifier {\n\n    public static IntStream factorsOf(int number) {\n        return range(1, number + 1)\n                .filter(potential -&gt; number % potential == 0);\n    }\n\n    public static boolean isPerfect(int number) {\n        return factorsOf(number).sum() == number * 2;\n    }\n\n    public static boolean isAbundant(int number) {\n        return factorsOf(number).sum() &gt; number * 2;\n    }\n\n    public static boolean isDeficient(int number) {\n        return factorsOf(number).sum() &lt; number * 2;\n    }\n\n}<\/pre><\/div><p> 如果熟悉我使用其他语言实现的数字分类器版本（参见 \"<a href=\"http://www.ibm.com/developerworks/cn/java/j-ft1/\"><em>函数式思维<\/em>：从功能的角度思考<\/a>\"），您就会注意到清单 6 缺少一个 <code>sum()<\/code>\n                方法声明。在这段代码使用其他语言的所有实现中，我不得不自己编写 <code>sum()<\/code> 方法。Java 8 中提供了一个作为终端操作的\n                <code>sum()<\/code> 方法，这样我就不必再编写它了。通过隐藏可变部分，函数式编程降低了开发人员犯错的可能性。如果我不需要实现\n                <code>sum()<\/code>，也就不会在实现过程中犯错。Java 8 中的流接口及其相关功能是经过深思熟虑的扩展集合，将 Java\n                语言提升到了一个新的层面。<\/p><p> 在数字分类器的其他版本中，我显示了 <code>factors()<\/code>\n                方法的一个优化版本，它只会遍历寻找等于平方根的可能因子，并生成对称的因子。Java 8 <code>factors()<\/code>\n                方法的优化版本如清单 7 中所示。<\/p><h5 id=\"listing7\">清单 7. Java 8\n                中经过优化的分类器<\/h5><div class=\"codesection\"><pre class=\"displaycode\">    public static List fastFactorsOf(int number) {\n        List&lt;Integer&gt; factors = range(1, (int) (sqrt(number) + 1))\n                .filter(potential -&gt; number % potential == 0)\n                .boxed()\n                .collect(Collectors.toList());\n        List factorsAboveSqrt = factors\n                .stream()\n                .map(e -&gt; number / e).collect(toList());\n        factors.addAll(factorsAboveSqrt);\n        return factors.stream().distinct().collect(toList());\n    }<\/pre><\/div><p>即便支持对流进行合并 ，<a href=\"#listing7\">清单 7<\/a> 中的 <code>factorsOf()<\/code>\n                方法无法将两个流合并为一个结果。然而，一旦某个流被遍历，被耗尽资源（这一点与 <code>Iterator<\/code>\n                相同），在再次使用之前，必须重新生成该流。在 <a href=\"#listing7\">清单 7<\/a>\n                中，我使用流创建了两个集合并将结果连接在一起，还添加了对 <code>distinct()<\/code>\n                的调用，以便处理由整数平方根引起的边缘情况。Java 8 中流的强大功能令人印象深刻，包括构建流的能力。 <\/p><h2 id=\"N1022F\">结束语<\/h2><p> 在这篇文章中，我经过研究将 Java 8 称作 Java 下一代语言，而它确实当之无愧。精心设计的流库和聪明的扩展机制（比如默认方法）让大量现有的\n                Java 代码通过极小的代价便能从新功能中获益。<\/p><p> 在下一篇文章中，我将讲述一些在选择语言方面的想法。<\/p><CMA ID: 976004><Site ID: 10><XSLT stylesheet used to transform this file: dw-document-html-7.0.xsl>\r\n\r\n\r\n<\/div>\r\n<\/div>\r\n","createTime":"2014-06-30 00:00:00","deployTime":"2014-06-30 00:00:00","id":0,"intro":"这一期的 Java 下一代文章将通过调查了解 Java 8 版本是否是您的下一个编程语言的合理候选。本文将介绍 lambda 代码块和 streaming API 如何将 Java 升级为一种现代语言。","keyword":"","recommend":false,"source":"http://www.ibm.com/developerworks/cn/java/j-jn15/index.html","title":"Java\n            下一代: 使用 Java 8 作为 Java 下一代语言","typeId":0,"updateTime":"2014-06-30 00:00:00"}
{"author":"","clickNumber":0,"content":"\r\n<div class=\"ibm-columns\">\r\n<div class=\"ibm-col-1-1\">\r\n\r\n<h2 id=\"N1006B\">简介<\/h2><p>IBM&#174; PureApplication&#174; System 随带了一组授权的 Virtual Application\n                Patterns\n                (VAPs)，可用于创建新\n                VAP，并为现有模式库做贡献。这些模式的用户可能需要自定义它们，让它们适合特定的用例，他们可能需要在不更改底层模式实现的情况下执行这种自定义，因为他们可能无法访问模式代码，他们的模式许可可能不允许更改模式定义，或者此模式的其他用户可能想要这种自定义。<\/p><p>在其他情况下，您可能需要自定义多种模式类型，注入与特定模式类型实现无关的跨功能代理。例如，您可能需要将一个剖析代理注入到所有部署在应用服务器上的模式类型中。<\/p><p>本文将展示如何在不接触模式插件代码或更改模式定义的情况下扩展现有 VAPs。文中将展示如何构建一个插件，在 VAP\n                实例上注入和执行自定义代码，以及如何过滤该代码将插入其中的 VAP 实例。本文包含一个示例插件，用于将自定义代码插入到包含\n                WebSphere&#174; Application Server 角色的 VAP 实例中。<\/p><h2 id=\"N1007D\">场景<\/h2><p>本文使用 Web Application Pattern Type VAP 作为插件注入技术的目标。该场景假设 Web Application\n                Pattern 想要在安装 WebSphere Application Server\n                的同一个虚拟机上安装一些额外的二进制文件，然后在应用服务器启动后在它之上执行一些额外的配置。假设这些二进制文件需要将 50 GB 的额外磁盘附加到\n                WebSphere Application Server 虚拟机上，并挂载到文件夹 /dataStorageForAgent\n                上。该示例将展示如何编写一个 TopologyProcessor 实现来重写未解决的拓扑结构模型（vm-templates\n                部分）。TopologyProcessor 实现将过滤掉除包含 WebSphere Application Server 角色的部署外的所有 VAP\n                部署。在包含 WebSphere Application Server 角色的部署上，该实现将添加示例插件脚本包，并注入一个示例插件角色。<\/p><p>通过将示例插件角色 SInstall 添加到 WebSphere Application Server 角色所在的同一个 vm-template\n                节中，插件的生命周期被注入到 WebSphere Application Server 角色所在的相同虚拟机中。因此将调用示例插件部分\n                install.py，而且在插件部分安装步骤中，将从 Storehouse 存储库下载插件二进制文件。示例插件 configure.py\n                脚本将在配置步骤中调用。示例 configure.py 等待应用服务器启动，然后运行一个包含插件二进制文件的示例 shell\n                脚本。该示例还展示了如何使用 TopologyProcessor 注入需要的额外磁盘空间，并将其挂载到指定的文件夹中。<\/p><h2 id=\"N10086\">构建一个 VAP\n                插件，将自定义代码注入到现有模式中<\/h2><p>以下各节将展示如何构建一个 VAP 插件，根据特定的条件将您自己的代码注入到运行的 VAP 实例中。此技术利用了 VAP 转换框架和\n                com.ibm.maestro.model.transform.TopologyProcessor 接口的一个实现，该实现可用于在部署之前处理和转换\n                VAP 拓扑结构。构建 VAP 插件：<\/p><ol type=\"1\"><li>创建一个 VAP 插件和相应的模式类型来捕获自定义代码实现。<\/li><li>在插件配置文件 config.json 中，为辅助模式类型定义个通配符值 “*”，使得该插件能够添加到任何 VAP 部署中。该插件将包含常规\n                    VAP 部分和角色生命周期脚本，比如 install.py、configure.py、start.py 和 stop.py。<\/li><li>创建一个 TopologyProcessor 实现，它将定义一个过滤条件来识别要自定义的 VAP 实例。<\/li><li>对于选择要自定义的实例，更新为解决的拓扑结构 JSON 模型，并包含插件的脚本包和角色。<\/li><li>修改未解决的拓扑结构 JSON 模型，并添加您的代码需要的其他任何定制。例如，您可以修改拓扑结构 JSON\n                    模型，添加一个存储卷，然后将它挂载到一个本地文件夹。<\/li><\/ol><h3 id=\"N10099\">TopologyProcessor<\/h3><p>本文中讨论的代码注入技术是使用 com.ibm.maestro.model.transform.TopologyProcessor\n                接口来实现的，本节将介绍这个接口。后面的几节将介绍插件生命周期脚本，以及包含模式类型二进制文件的插件执行脚本。在 VAP 部署期间，任何参与 VAP\n                和实现 com.ibm.maestro.model.transform.TopologyProcessor\n                接口的插件都可处理和修改拓扑结构定义，使该插件能够将任何自定义配置、角色或包注入到 VAP 拓扑结构中，无需对 VAP\n                模式执行代码更改或更改虚拟应用程序生成器中的模式定义。<\/p><p>在部署期间，PureApplication System 部署框架调用插件的 TopologyProcessor 实现中提供的公共\n                JSONObject processTopology(JSONObject topology)\n                方法。该拓扑结构对象方法签名表示要部署的实例的未解决的拓扑结构模型 TopologyProcessor 的插件实现可更改这个未解决的 JSON\n                模型，然后将更新的模型返回到部署框架。该框架使用返回的已更新拓扑结构 JSON 模型来部署实例。<\/p><p>本文提供了示例用例的 TopologyProcessor 实现。如清单 1 所示，processTopology(JSONObject\n                topology) 方法中的代码首先寻找拓扑结构对象中的 vm-templates 节，以验证部署的实例是否拥有 WebSphere\n                Application Server 角色：<\/p><h5 id=\"N100A5\">清单 1. 验证 WebSphere Application Server\n                    角色是否包含在部署中<\/h5><div class=\"codesection\"><pre class=\"displaycode\">private final String[] agentInjectToRoles = new String[] {\"WAS\"};\nJSONArray templates = (JSONArray)topology.get(\"vm-templates\");\nfor (Object obj : templates) {\t\n   if( injectPlugin(template) ) {\n      .... inject the sample plug-in role and package here ....\n      .... also add new disk and mount to vm folder here ....\n      }\n}\n/** \n * Return true here if you want the plug-in to attach to this type of role \n */\nprotected boolean injectPlugin(JSONObject template)\n{\n   JSONArray rolesArray = (JSONArray)template.get(\"roles\");\n   if (rolesArray == null) {\n      return false;    \n   }    \n   for (Object roleObj : rolesArray) { \n      JSONObject role = (JSONObject) roleObj;\n      if(role.get(\"type\") != null) { \n         String roleType = role.get(\"type\").toString(); \n         for(String agentInjectRole : agentInjectToRoles) {\n            if( roleType.equals(agentInjectRole))\n               return true;\t\n          }\n      } \n   }  \n   return false;  \n}<\/pre><\/div><p>然后，如果 vm-template 包含 WebSphere Application Server 角色，那么该代码会添加示例插件角色和脚本包，如清单\n                2 所示。 示例插件生命周期脚本在实例激活期间调用。<\/p><h5 id=\"N100AD\">清单 2.\n                添加角色和脚本包<\/h5><div class=\"codesection\"><pre class=\"displaycode\">addRoles(template, new JSONObject[] { sagentRole });\naddPackages(template, new String[] { \"SInstall\" });<\/pre><\/div><p>该代码还修改了拓扑结构模型定义，以便添加一个新磁盘，并将它挂载到 /dataStorageForAgent 挂载点上，如清单 3 所示：<\/p><h5 id=\"N100B5\">清单 3.\n                添加新磁盘<\/h5><div class=\"codesection\"><pre class=\"displaycode\">JSONArray vmStorage = null;\nif(template.get(\"storage\") == null) {\n   vmStorage = new JSONArray();\n   template.put(\"storage\", vmStorage);\n}\nelse {\n   vmStorage = (JSONArray) template.get(\"storage\");\n} \naddVMStorage(vmStorage, \"ext-sagentSt1\", \"/dev/sdb\",\n   \"/dataStorageForAgent\");<\/pre><\/div><h2 id=\"N100BA\">示例 VAP 插件<\/h2><p>除了 TopologyProcessor 实现之外，示例插件还定义了以下生命周期脚本和配置文件。有关 VAP\n                生命周期脚本和如何使用它们的更多信息，请参阅文章底部的 <a href=\"#resources\">参考资料<\/a>。<\/p><h3 id=\"N100C5\">config.json<\/h3><p>此配置文件定义了此插件所属的模式类型。清单 4 显示了示例的配置文件。该插件将 SimpleInstallAgent\n                定义为主要的模式类型。此模式类型用于将插件导入 PureApplication System 中，并在必要时刷新插件。该配置还定义了一个辅助模式\n                “*”，则会意味着此插件可由系统中的任何模式类型使用。通过拥有一个辅助模式 “*”，插件可附加到任何已部署的 VAP 实例。<\/p><h5 id=\"N100CD\">清单 4.\n                示例插件配置文件<\/h5><div class=\"codesection\"><pre class=\"displaycode\">\"name\": \"sagent\",\n\"version\": \"1.0.0.0\",\n\"patterntypes\": {\n   \"primary\": {\n      \"SimpleInstallAgent\": \"1.0\"\n   },\n   \"secondary\":[\n      {\n      \"*\":\"*\"\n      }\n   ] \n}<\/pre><\/div><h3 id=\"N100D2\">install.py<\/h3><p>部分安装脚本从 Storehouse 存储库下载插件二进制文件并解压该文件，然后将它们转移到 /home/virtuser 文件夹下，如清单 5\n                所示：<\/p><h5 id=\"N100DA\">清单 5.\n                部分安装脚本<\/h5><div class=\"codesection\"><pre class=\"displaycode\"># Copy your binary from storehouse into /tmp/downloads\ndownloadPath = '/tmp/downloads'\nlogger.debug('creating directory: ' + downloadPath);\nmaestro.trace_call(logger, ['mkdir', downloadPath])\nstorehousePath = 'SAgentBinaries/SampleContent.tar.gz'\nlogger.debug('start downloading AGENT install binaries from storehouse:\n   %s to local folder: %s' % (storehousePath, downloadPath))\n# Maestro unzip your binary into the location (downloadPath) you specified\ninstallerUrl = urlparse.urljoin(maestro.filesurl, storehousePath)\t\nmaestro.downloadx(installerUrl, downloadPath)\nlogger.debug('AGENT binaries download completed complete')\n# move myproductInstall.sh script to /home/idcuser/ProductFolder\nlogger.debug('move scripts from /tmp/downloads to /home/virtuser ')\nargs=['mv', '/tmp/downloads/ProductFolder', '/home/virtuser']\nlogger.debug(args)\nrc = maestro.trace_call(logger, args)\nmaestro.check_status(rc, 'Failed to move ProductFolder folder')<\/pre><\/div><h3 id=\"N100DF\">configure.py<\/h3><p>此脚本在 /opt/IBM 文件夹下寻找 WebSphere Application Server\n                startServer.log，并等待一个可用的日志。在找到该文件后，该脚本每隔 60 秒检查是否在文件中找到了消息 “Open for\n                e-business”。找到此消息后，该脚本会使用 WebSphere Application Server 管理员用户凭据调用插件配置脚本\n                /home/virtuser/ProductFolder/productConfigure.sh。productConfigure.sh\n                简单地列出了可用的 Java 虚拟机 WebSphere Application Server API。清单 6 显示了 confgure.py\n                中的代码：<\/p><h5 id=\"N100E7\">清单 6.\n                角色配置脚本<\/h5><div class=\"codesection\"><pre class=\"displaycode\">template = maestro.node['template']\nuser_id=''\nuser_pwd=''\nif 'roles' in template:\n   roles = template['roles']\n   for role in roles:\n      if 'name' in role and role['name'] == 'DMGR' and 'parms' in role:\n         logger.debug('DMGR parms are %s' % role['parms'])\n         for key in role['parms']:\n            roleParms = role['parms'][key]\n            if key == 'dmgr_user':\n               user_id = roleParms\n            elif key == 'dmgr_pwd':\n               user_pwd = str(maestro.decode(roleParms))\n            elif 'name' in role and role['name'] == 'WAS' and 'parms' in role:\n               logger.debug('WAS parms are %s' % role['parms'])\n               for key in role['parms']:\n                  roleParms = role['parms'][key]\n                  if key == 'USERID':\n                     user_id = roleParms\n                  elif key == 'PASSWORD':\n                     user_pwd = str(maestro.decode(roleParms))\nlogPath=''\nmatches = []\nwhile len(matches) == 0:\n   for root, dirnames, filenames in os.walk('/opt/IBM'):\n      for filename in fnmatch.filter(filenames, 'startServer.log'):\n         matches.append(os.path.join(root, filename))\n   time.sleep(60)\nif len(matches) &gt; 0:\n   logPath = '%s' % matches[0]\nwasInstalled = False\nwhile wasInstalled == False:\n   logger.debug('wait for the WAS server to start')\n   if os.path.isfile(logPath):\n      logger.debug('startServer.log file found, check status')\n      with open(logPath, 'r') as content_file:\n          content = content_file.read()\n          if content.rfind('open for e-business') != -1:\n             wasInstalled = True\n          else:\n             logger.debug('WAS start log content does not contain open\n                 for e-business message, wait')          \n   else:\n      logger.debug('%s file not found, wait' % logPath)\n   if wasInstalled == False:\n      time.sleep(60)\nlogger.debug(\"WAS server is running, configure the agent now\")\nconfigscript = '/home/virtuser/ProductFolder/productConfigure.sh'\n# run productConfigure.sh script\nargs=[configscript, user_id, user_pwd]\nlogger.debug('user_id is %s ' % user_id)\nrc = maestro.trace_call(logger, args)\nmaestro.check_status(rc, 'Failed to run install scripts')<\/pre><\/div><h2 id=\"N100EC\">示例 VAP 模式类型<\/h2><p>模式类型 exportSimpleInstallAgent-1.0.0.0.tgz 将示例二进制文件包装在\n                files/SampleContent.tar.gz 下。如果下载附加的示例并使用任何有效的解压工具打开此文件，您就会看到该 tar\n                归档文件包含以下文件：<\/p><ul class=\"ibm-bullet-list\"><li><strong>productInstall.sh<\/strong>：该示例 shell 脚本展示如何使用脚本来从 parts\n                    install.py 生命周期脚本安装产品二进制文件。此脚本将在示例角色 SInstall 配置步骤之前执行。<\/li><li><strong>productConfigure.sh<\/strong>：该示例 shell\n                    脚本展示如何使用应用服务器管理员凭据执行应用服务器配置。此 shell 脚本由 SInstall 角色 configure.py\n                    生命周期脚本调用。此脚本接受两个参数：WebSphere Application Server 管理员用户 ID 和密码。此脚本调用\n                    listJvm.py 来列出 JVM。清单 7 演示了 productConfigure.sh 脚本。<\/li><\/ul><h5 id=\"N100FD\">清单 7.\n                示例应用服务器配置<\/h5><div class=\"codesection\"><pre class=\"displaycode\">#!/bin/sh\nUSER_ID=$1\nUSER_PWD=$2\necho \"Configure the product \"\nWAS_BIN=`find /opt/IBM -name wsadmin.sh`\necho \"WAS_BIN=$WAS_BIN\"\necho \"Configure agent\"\nDIR_NAME=$(dirname $0)\necho $DIR_NAME\npushd $DIR_NAME\necho \"List JVM \"\n$WAS_BIN/wsadmin.sh -user $USER_ID -password $USER_PWD -f /home/virtuser/ProductFolder/listJvm.py\necho \"End List JVM \"\npopd<\/pre><\/div><p>将模式类型导入 PureApplication System 中时，二进制文件的 tar 归档文件将被上传到 Storehouse\n                存储库。Storehouse for PureApplication System 是一个包含系统和 VAP 工作负载工件的存储库。<\/p><p>要查看存储在 Storehouse 存储库中的工件，可导航到 <strong>Workload console =&gt; System =&gt;\n                    Storehouse Browser<\/strong>。 请注意，只有能够访问 System 菜单的用户才能查看 Storehouse\n                Browser。<\/p><p>Storehouse 存储库可用于存储产品二进制文件，可在实例激活期间通过 VAP 实例进行访问。在以下段略中，您将看到如何使用 Storehouse\n                存储库存储示例插件二进制文件。<\/p><h2 id=\"N1010B\">将插件二进制文件上传到 Storehouse\n                存储库<\/h2><p>产品二进制文件可上传到 Storehouse 存储库，方法是将该二进制文件与包含 VAP 插件的模式类型包装在一起。我们将使用这种方法将示例二进制文件\n                SampleContent.tar.gz 上传到以下 Storehouse\n                存储库位置：/admin/files/SAgentBinaries/。<\/p><p>要将二进制文件 SampleContent.tar.gz 与模式类型包装在一起，首先需要定义模式类型中的文件夹格式，如图 1 所示。请注意，根据执行\n                Ant 脚本 addStorehouseFiles.xml 的需要，二进制归档文件位于文件夹\n                \\patterntype.sagent\\storehouse\\files\\SAgentBinaries 下，稍后将会解释这一点。 <\/p><h5 id=\"fig01\">图 1. 模式类型结构<\/h5><img alt=\"模式类型结构\" src=\"/sunshine_new/images/2020050871/images/fig01.jpg\" width=\"264\" /><p>放置二进制归档文件后，执行以下步骤来创建模式类型归档文件\n                \\patterntype.sagent\\exportSimpleInstallAgent-1.0.0.0.tgz：<\/p><ol><li>构建模式类型和插件代码。要构建模式类型和插件而不使用二进制文件，请右键单击 patterntype.sagent 并选择\n                        <strong>IBM Pattern Toolkit =&gt; Build<\/strong>。<\/li><li>运行 \\patterntype.sagent\\addStorehouseFiles.xml：右键单击\n                    \\patterntype.sagent\\addStorehouseFiles.xml 并选择 <strong>运行 As =&gt; Ant\n                        Build<\/strong>，将二进制文件添加到模式类型归档文件中。执行这个 Ant\n                    脚本将生成一个具有合适的文件夹结构的模式类型，从而将二进制文件上传到 Storehouse 存储库位置\n                    /admin/files/SAgentBinaries/。执行此步骤后，如果使用任何归档文件解压工具打开构建的模式类型，效果如图 2\n                    所示。该归档文件包含一个 files 文件夹，其中包含二进制文件 SampleContent.tar.gz。 <h5 id=\"fig02\">图 2. 包含 Storehouse\n                            二进制文件的模式类型归档文件<\/h5><img alt=\"包含 Storehouse 二进制文件的模式类型归档文件\" src=\"/sunshine_new/images/2020050871/images/fig02.jpg\" width=\"297\" /><\/li><li>构建模式类型后，就可以将它导入 PureApplication System 中。转到 Workload Console，然后选择\n                        <strong>Cloud =&gt; Pattern Types<\/strong> 链接。使用\n                        <strong>plus<\/strong> 操作导入模式类型 tar 文件，该文件位于\n                    /patterntype.sagent\\export\\SimpleInstallAgent-1.0.0.0.tgz\n                    下。如果导入成功，那么您会在 Storehouse Browser 中看到 SampleContent.tar.gz，如图 3 所示。 <h5 id=\"fig03\">图 3. 导入模式类型后的 Storehouse 内容<\/h5><img alt=\"导入模式类型后的 Storehouse 内容\" src=\"/sunshine_new/images/2020050871/images/fig03.jpg\" width=\"339\" /><\/li><\/ol><h2 id=\"N10144\">使用示例<\/h2><p>本文提供了以下示例模式类型（包含源代码）：patterntype.sagent-1.0.0.0.tgz<\/p><p>将 patterntype.sagent-1.0.0.0.tgz 导入 IBM PureApplication System 中后，您会看到一个文件\n                /admin/files/SAgentBinaries/SampleContent.tar.gz 被添加到 Storehouse Browser\n                中，如图 3 所示。您还应该在 <strong>Workload Console =&gt; Cloud =&gt; Pattern\n                    Types<\/strong> 下看到名为 sample.sagent-1.0 的模式类型。<\/p><p>导入并启用模式类型 sample.sagent-1.0 后，部署 Web Application 模式类型的一个实例。部署 Web\n                Application 模式类型后，执行以下步骤，验证示例插件角色 SInstall 是否已附加到运行 WebSphere Application\n                Server 的虚拟机上：<\/p><ol><li>在部署的实例的<strong>虚拟机透视图<\/strong>上，单击 Web Application 虚拟机的\n                        <strong>Middleware Status<\/strong> 列下的 <strong>Show more<\/strong>\n                    链接。您将会看到 SInstall 角色，如图 4 所示，它是示例插件定义的角色。 <h5 id=\"fig04\">图 4. 附加到 WebSphere Application Server\n                            实例的示例角色<\/h5><img alt=\"附加到 WebSphere Application Server 实例的示例角色\" src=\"/sunshine_new/images/2020050871/images/fig04.jpg\" width=\"715\" /><\/li><li>在同一个虚拟机上，单击 <strong>Log<\/strong> 链接。验证是否有一个针对 SInstall 角色的\n                    trace.log。打开此日志（如图 5 所示）并检查示例插件代码是否已按预期调用。 <h5 id=\"fig05\">图 5.示例插件跟踪日志<\/h5><img alt=\"示例插件跟踪日志\" src=\"/sunshine_new/images/2020050871/images/fig05.jpg\" width=\"499\" /><\/li><li>在 WebSphere Application Server 实例上，使用 <strong>Manage =&gt; Operations\n                        =&gt; ssh<\/strong> 链接添加一个 ssh 密钥，然后使用 virtuser 作为用户名通过 ssh\n                    登录到系统中。执行如图 6 所示的命令 df -h，验证是否能看到一个 50GB 的额外磁盘被附加到\n                    /dataStorageForAgent。 <h5 id=\"fig06\">图 6. 示例挂载文件夹<\/h5><img alt=\"示例挂载文件夹\" src=\"/sunshine_new/images/2020050871/images/fig06.jpg\" width=\"732\" /><\/li><\/ol><h2 id=\"N10183\">结束语<\/h2><p>本文介绍了一种自定义现有 VAP 模式并注入您的自定义代码的技术，它不需要更改现有模式插件代码或模式定义。此技术涉及到创建一个实现\n                TopologyProcessor 接口的新插件，以及创建合适的辅助模式配置，以便可以将该插件用于所有 VAP 模式部署。通过使用\n                TopologyProcessor 扩展，您了解了如何在部署期间更新任何 VAP 实例的拓扑结构定义，以及如何注入新插件角色和磁盘。<\/p><CMA ID: 976095><Site ID: 10><XSLT stylesheet used to transform this file: dw-document-html-7.0.xsl>\r\n\r\n\r\n<\/div>\r\n<\/div>\r\n","createTime":"2014-06-30 00:00:00","deployTime":"2014-06-30 00:00:00","id":0,"intro":"本文将介绍如何构建一个 Virtual Application Pattern (VAP) 插件，在模式部署时将自定义代码注入现有 VAP 中。此技术支持自定义或扩展 VAP，无需更改模式代码或定义，并在 VAP 实例上运行您的自定义代码。","keyword":"","recommend":false,"source":"http://www.ibm.com/developerworks/cn/cloud/library/cl-ps-aim1402-ipasvap/index.html","title":"使用 IBM PureApplication System 将自定义代码注入 Virtual Application Patterns\n            中","typeId":0,"updateTime":"2014-06-30 00:00:00"}
{"author":"","clickNumber":0,"content":"\r\n<div class=\"ibm-columns\">\r\n<div class=\"ibm-col-1-1\">\r\n\r\n<h2 id=\"1.简介 |outline\">简介<\/h2><p>AngularJS 是一款来自 Google 的前端 JavaScript 框架，也是\n    SPA（single-page-application，单页应用）框架。AngularJS 框架的体积非常小，但是设计理念和功能却非常强大，极大地简化前端开发的负担，它快速成为了 JavaScript 的主流框架，帮助开发者从事 web 开发。<\/p><h3 id=\"1.1.SPA，MVC|outline\">SPA 和 MVC<\/h3><p>SPA：单页面应用是指用户通过浏览器加载独立的 HTML 页面并且无需离开此导航页面。对用户操作来说，一旦加载和执行单个页面应用程序通常会有更多的响应，这就需要返回到后端 Web 服务器，而单页面应用为用户提供了一个更接近本地移动或桌面应用程序的体验，这就是单页面应用的优势所在。<\/p><p>MVC：模型(model)－视图(view)－控制器(controller)的缩写，一种软件设计典范，用一种业务逻辑、数据、界面显示分离的方法组织代码，将业务逻辑聚集到一个部件里面，在改进和个性化定制界面及用户交互的同时，不需要重新编写业务逻辑。MVC 被独特的发展起来用于映射传统的输入、处理和输出功能在一个逻辑的图形化用户界面的结构中。<\/p><h3 id=\"1.2.基本概念 |outline\">基本概念<\/h3><p>针对客户端应用开发的 AngularJS 吸收了传统的 MVC 基本原则，但并不只是传统意义上的 MVC，更接近于 MVVM（Model-View-ViewModel)。<\/p><p>Model：是应用中的数据，一般是简单的 JavaScript 对象。<\/p><p>ViewModel：是一个用来提供特别数据和方法从而维护指定 View 的对象。<\/p><p>View：是 AngularJS 解析后渲染和绑定后生成的 HTML，它能帮助您创建 web 应用的架构。<\/p><p>$scope(作用域)：是 AngularJS 中的一个 JavaScript 对象，这个对象使用简单的 API 来侦测和广播状态变化。在这里就是要将域模型暴露给视图<code>(<\/code>模板<code>),<\/code>只需把属性设置给$scope 实例，就可以在模板渲染时得到这个值。<\/p><p>$scope 也可以针对特定的视图来扩展数据和特定的功能，只要在$scope 实例上定义一些函数就能将特定的 UI 逻辑暴露给模板。<\/p><p>Controller（控制器）：控制器的首要任务就是初始化$scope 对象。在实践中，初始化的逻辑由下面的这些责任组成：提供模型初始化的值；扩展$scope UI 行为（方法）。<\/p><p>控制器都是普通的 JavaScript 函数，它们并不必去继承一些框架特定提供的类，也不必去调用任何特定的 AngularJS API 才能去正确地执行它们的任务。<\/p><p>Directive(指令)：指令可以用来创建自定义的标签，它们可以用来装饰元素或者操作 DOM 属性，也可以作为标签、属性、注释和类名使用。<\/p><h3 id=\"1.3.使用 AngularJs 的几个理由 |outline\">使用 AngularJs 的几个理由<\/h3><p>简单容易上手，将会由下个章节的几个例子来证明 AngularJs 的简单易用。<\/p><p>有谷歌团队支持的开源框架。<\/p><p>非常全面，涵盖了 Unit Test、HTML 模板、数据绑定等性质，是一个非常快速的前端开发解决方案。<\/p><h2 id=\"2.实践教程 |outline\">实践教程<\/h2><h3 id=\"2.1.在 HTMLpage 里面加入 AngularJS|outline\">在 HTML page 里面加入 AngularJS<\/h3><p>在您的 JavaScript 文件中加入以下代码，即可使用 AngularJS。<\/p><h5 id=\"2.1.1.清单 1.加入 AngularJS 引用 |outline\">清单 1.加入 AngularJS 引用<\/h5><div class=\"codesection\"><pre class=\"displaycode\">&lt;script type=\"text/javascript\" src=\"https://ajax.googleapis.com/ajax/libs/angularjs/1.2.3/angular.min.js\"\n&gt;&lt;/script&gt;<\/pre><\/div><h3 id=\"2.2.从双向数据绑定开始 |outline\">从双向数据绑定开始<\/h3><p>双向数据绑定是 AngularJS 的一个重要特性，它提供了一个简单的机制，能够让您通过{{ 表达式 }}这个形式轻松地绑定数据到 HTML 上，请看下面这个简单的数据绑定的例子。<\/p><a id=\"OLE_LINK13\"><\/a><h5 id=\"2.2.1.清单 2.双向数据绑定 |outline\">清单 2.双向数据绑定<\/h5><div class=\"codesection\"><pre class=\"displaycode\"><strong>index.html<\/strong>\n!DOCTYPE html&gt;&lt;html&gt;\n&lt;head&gt;\n&lt;/head&gt;\n&lt;body&gt;\n  &lt;div ng-app=\"\"&gt;\n    &lt;input type=\"text\" ng-model=\"data.message\"&gt;\n    &lt;h1&gt;{{data.message + \" world\"}}&lt;/h1&gt;\n  &lt;/div&gt;\n  &lt;script type=\"text/javascript\" \nsrc=\"https://ajax.googleapis.com/ajax/libs/angularjs/1.2.3/angular.min.js\"&gt;&lt;/script&gt;\n&lt;/body&gt;\n&lt;/html&gt;<\/pre><\/div><p>在最外层的 div 中设置了一个 ng-app 属性(少了这个属性，AngularJS 就没办法工作)， 一般这个属性表明这个元素已经这个元素内部的所有元素都是属于设定的这个 app 的。在后面我们会详细说到 ng-app 这个属性。<\/p><p>在这个 div 内部，设置了一个 input，并对 data.message 这个 Model 做双向数据绑定。最后，使用{{data.message}}告诉 AngularJS 在指定的 HTML 处显示 data.message 这个 Model 的数据，也就是用户输入的数据。<\/p><p>就这么几句话，就已经是完成了一个本来要耗费多得多的时间和代码来开发的动态应用。在这里，我们不需要给双向数据绑定写任何规则，不需要给更新 Model 和 View 写任何代码，甚至不需要编写任何 Model。事实上，我们根本都还没开始碰 JavaScript。我们不需要写代码，直到我们想开发更个性化的应用行为为止。<\/p><h3 id=\"2.3.controller 和$scope 的使用 |outline\">controller 和$scope 的使用<\/h3><p>controller 在 AngularJS 里面也是非常重要的，它把数据和前端显示内容联系在一起，这里将会提供一个例子演示 controller 和$scope 的基本用法。<\/p><h5 id=\"2.3.1.清单 3.controller 和$scope|outline\">清单 3.controller 和$scope<\/h5><div class=\"codesection\"><pre class=\"displaycode\"><strong>index.html<\/strong>\n&lt;!DOCTYPE html&gt;\n&lt;html&gt;\n&lt;head&gt;\n   &lt;script type=\"text/javascript\" src=\"main.js\"&gt;&lt;/script&gt;\n&lt;/head&gt;\n&lt;body&gt;\n  &lt;div ng-app=\"\"&gt;\n    &lt;div ng-controller=\"MyFirstCtrl\"&gt;\n      &lt;h1&gt;{{data.message + \" world\"}}&lt;/h1&gt;      \n    &lt;/div&gt;\n&lt;/div&gt;\n     &lt;script type=\"text/javascript\" \nsrc=\"https://ajax.googleapis.com/ajax/libs/angularjs/1.2.3/angular.min.js\"&gt;&lt;/script&gt;\n&lt;/body&gt;\n&lt;/html&gt;\n<strong>main.js<\/strong>\nfunction MyFirstCtrl($scope){\n  $scope.data = {message: \"Hello\"};\n}<\/pre><\/div><a id=\"OLE_LINK2\"><\/a><a id=\"OLE_LINK1\"><\/a><p>使用 ng-controller 这个属性替代上个例子中的 ng-model 属性。\"MyFirstCtrl\"这个 controller 的作用域是当前 div 以及其所有子元素。<\/p><p>在新建的 main.js 中，定义一个叫 FirstCtrl 的处理函数，传入$scope(这个$scope 关联于当前 div 元素及其所有子元素)。<\/p><p>现在我们可以在有 ng-controller= MyFirstCtrl 属性的 DOM 元素的任何子元素里访问这个 data 对象，因为它在$scope 上。<\/p><p>$scope 实际上就是一个 JavaScript 对象，controller 和 view 都可以访问它，所以我们能利用它在两者间传递信息。在这个$scope 对象里，我们既存储数据，又存储将要运行在 view 上的函数。<\/p><h3 id=\"2.4.多个 controller 之间共享数据 |outline\">多个 controller 之间共享数据<\/h3><p>本例将会使用 Service factory 来处理多个 controller 共享数据的问题<\/p><h5 id=\"2.4.1.清单 4.Controller 之间的共享数据 |outline\">清单 4.Controller 之间的共享数据<\/h5><div class=\"codesection\"><pre class=\"displaycode\"><strong>index.html<\/strong>\n&lt;!DOCTYPE html&gt;\n&lt;html&gt;\n&lt;head&gt;\n&lt;/head&gt;\n&lt;body&gt;\n  &lt;div ng-app=\"myApp\"&gt;\n    &lt;div ng-controller=\"MyFirstCtrl\"&gt;\n      &lt;input type=\"text\" ng-model=\"data.message\"&gt;\n      &lt;h1&gt;{{data.message}}&lt;/h1&gt;\n    &lt;/div&gt;\n    &lt;div ng-controller=\"MySecondCtrl\"&gt;\n      &lt;input type=\"text\" ng-model=\"data.message\"&gt;\n      &lt;h1&gt;{{data.message}}&lt;/h1&gt;\n    &lt;/div&gt;\n  &lt;/div&gt;\n  &lt;script type=\"text/javascript\" \nsrc=\"https://ajax.googleapis.com/ajax/libs/angularjs/1.2.3/angular.min.js\"&gt;&lt;/script&gt;\n  &lt;script type=\"text/javascript\" src=\"main.js\"&gt;&lt;/script&gt;\n&lt;/body&gt;\n&lt;/html&gt;\n<strong>main.js<\/strong>\nvar myApp = angular.module('myApp', []);\nmyApp.factory('Data', function() {\n    return {message: \"I'm data from a service\"}\n})\nfunction FirstCtrl($scope, Data){\n  $scope.data = Data;\n}\nfunction SecondCtrl($scope, Data){\n  $scope.data = Data;\n}<\/pre><\/div><p>现在我们定义第一个 app 命名为\"myApp\",它其实就是一个 AngularJS 的模块。[] 代表这个定义的模块没有任何依赖模块。注意，在 HTML 中的名字需要跟 JavaScript 中定义的 app 的名字一致。<\/p><p>有个这个 myApp,我们可以创建一个 factory 来提供我们需要的 service。在这个例子中，我们的 service 名字叫 Data,它返回了一个字符串\"I'm Data from a service\"。刷新页面，可以看到从 service 返回的数据。<\/p><h5 id=\"2.4.2.图 1.运行结果 |outline\">图 1.\n    运行结果<\/h5><img alt=\"运行结果\" src=\"/sunshine_new/images/994663078/image003.jpg\" width=\"239\" /><p>创建一个 service 就是简单的返回一个函数，这个函数返回一个对象。这个对象是在创建应用实例的时候创建的（记住，这个对象是单例对象）。<\/p><p>从这个例子可以看到，两个 controller 之间是完全独立的，并没有 root controller 或者 controller 直接的继承关系，仅仅是把 service 和这个对象传入两个 controller 中。<\/p><h3 id=\"2.5.使用 Filter|outline\">使用 Filter<\/h3><p>过滤器（filter）正如其名，作用就是接收一个输入，通过某个规则进行处理，然后返回处理后的结果。主要用在数据的格式化上，例如获取一个数组中的子集，对数组中的元素进行排序等。ng 内置了一些过滤器，它们是：currency(货币)、date(日期)、filter(子串匹配)、json(格式化 json 对象)、limitTo(限制个数)、lowercase(小写)、uppercase(大写)、number(数字)、orderBy(排序)。总共九种。下面例子是一个自定义的 filter。<\/p><a id=\"2.5.1.清单 5.使用 Filter|outline\"><\/a><p><strong>清单 5. 使用 Filter<\/strong><\/p><div class=\"codesection\"><pre class=\"displaycode\">index.html\n&lt;!DOCTYPE html&gt;\n&lt;html&gt;\n&lt;head&gt;\n&lt;/head&gt;\n&lt;body&gt;\n  &lt;div ng-app=\"myApp\"&gt;\n    &lt;div ng-controller=\"MyFirstCtrl\"&gt;\n      &lt;input type=\"text\" ng-model=\"data.message\"&gt;\n      &lt;h1&gt;{{data.message}}&lt;/h1&gt;\n    &lt;/div&gt;\n    &lt;div ng-controller=\"MySecondCtrl\"&gt;\n      &lt;input type=\"text\" ng-model=\"data.message\"&gt;\n      &lt;h1&gt;{{data.message|reverse}}&lt;/h1&gt;\n    &lt;/div&gt;\n  &lt;/div&gt;\n  &lt;script type=\"text/javascript\" \n  src=\"https://ajax.googleapis.com/ajax/libs/angularjs/1.2.3/angular.min.js\"&gt;&lt;/script&gt;\n  &lt;script type=\"text/javascript\" src=\"main.js\"&gt;&lt;/script&gt;\n&lt;/body&gt;\n&lt;/html&gt;\nmain.js\nvar myApp = angular.module('myApp', []);\nmyApp.factory('Data', function() {\n    return {message: \"I'm data from a service\"}\n})\nmyApp.filter('reverse', function(Data) {\n    return function(text) {\n      return text.split(\"\").reverse().join(\"\") + Data.message;\n  }\n})\nfunction FirstCtrl($scope, Data){\n  $scope.data = Data;\n}\nfunction SecondCtrl($scope, Data){\n  $scope.data = Data;\n  }\n}<\/pre><\/div><p>在 main.js 中加入对 filter 的定义，我们定义了一个名为\"reverse\"的 filter，它的功能是把字符反转然后再加上从上一个清单中讲的 service 中得到的字符串。<\/p><p>我们对 MySecondCtrl 中的文字应用了\"reverse\"这个 filter，&lt;h1&gt;{{data.message|reverse}}&lt;/h1&gt;, 所以在第二个 div 中的文字有了图中所示的效果。<\/p><h5 id=\"2.5.2.图 2.运行结果 |outline\">图 2.运行结果<\/h5><img alt=\"运行结果\" src=\"/sunshine_new/images/994663078/image005.jpg\" width=\"369\" /><h3 id=\"2.6.ng-repeat 指令属性 |outline\">ng-repeat 指令属性<\/h3><p>ng-repeat：在处理一组数据的时候，经常需要把同一个 UI 重复很多次，AngularJS 提供了 ng-repeat 属性来帮助您解决这个问题。<\/p><p>ng-repeat 指令遍历一个数据集合中的每个数据元素，加载 HTML 模版把数据渲染出来。被重复使用的模版元素，就是我们绑定了这个指令属性的 DOM 元素。每一个使用模版渲染的 DOM 元素都有自己的 scope。请看下面这个例子：<\/p><h5 id=\"2.6.1.清单 6.使用 ng-repeat|outline\">清单 6. 使用 ng-repeat<\/h5><div class=\"codesection\"><pre class=\"displaycode\"><strong>i<\/strong><strong>ndex.html<\/strong>\n&lt;!DOCTYPE html&gt;\n&lt;html&gt;\n&lt;head&gt;\n&lt;/head&gt;\n&lt;body&gt;\n  &lt;div ng-app=\"myApp\"&gt;\n      &lt;div ng-controller=\"SecondCtrl\"&gt;\n      &lt;ul&gt;\n      &lt;li ng-repeat=\"person in roommates\" &lt;/li&gt;\n      &lt;/ul&gt;\n  &lt;/div&gt;\n  &lt;/div&gt;\n  &lt;script type=\"text/javascript\" \nsrc=\"https://ajax.googleapis.com/ajax/libs/angularjs/1.2.3/angular.min.js\"&gt;&lt;/script&gt;\n  &lt;script type=\"text/javascript\" src=\"main.js\"&gt;&lt;/script&gt;\n&lt;/body&gt;\n&lt;/html&gt;\n<strong>main.js<\/strong>\nvar myApp = angular.module('myApp', []);\nmyApp.controller('SecondCtrl', function ($scope){\n    $scope.isRed = true;\n    $scope.isGreen = false;\n    $scope.roommates = [\n     { name: 'Lucy'}, \n     { name: 'Lily'},\n     { name: 'Sean'},\n     { name: 'Adam'}\n ];\n});<\/pre><\/div><p>在 HTML 中的 ul 标签上设置 ng-repeat 属性，并用\"person in roomates\"指明集合并做遍历，就可以加载 HTML 模板把集合中的元素都轻松渲染出来。结果如下：<\/p><h5 id=\"2.6.2.图 3.运行结果 |outline\">图 3.\n    运行结果<\/h5><img alt=\"运行结果\" src=\"/sunshine_new/images/994663078/image007.jpg\" width=\"142\" /><h3 id=\"2.7.ng-class 指令属性 |outline\">ng-class 指令属性<\/h3><p>ng-class 可以用来标记某个 class 是否被应用，通常用来处理是否加载某个 css 样式。请看下面这个例子。<\/p><p>更换之前例子中代码的 HTML Body 部分如下：在 HTML 中将每个 li 都设置上 ng-class 属性，且 ng-class=\"{'black':isBlack,'red':isRed}\"，意思是当 isBlack 的值为 true 时，加载 black class，相反 isBlack 的值为 false，不加载 black class。<\/p><h5 id=\"2.7.1.清单 7.使用 ng-class 例子的 html 和 css 部分 |outline\">清单 7. 使用\n    ng-class 例子的 HTML 和 CSS 部分<\/h5><div class=\"codesection\"><pre class=\"displaycode\"><strong>i<\/strong><strong>ndex.html<\/strong>\n&lt;!DOCTYPE html&gt;\n&lt;html&gt;\n&lt;head&gt;\n  &lt;title&gt;AngularJS Tutorials&lt;/title&gt;\n   &lt;link rel=\"stylesheet\" type=\"text/css\" href=\"Style.css\" &gt;\n&lt;/head&gt;\n&lt;body&gt;\n  &lt;div ng-app=\"myApp\"&gt;\n      &lt;div ng-controller=\"SecondCtrl\"&gt;\n      &lt;ul&gt;\n      &lt;li ng-repeat=\"person in roommates\" ng-class=\"{'black':isBlack,'red':isRed}\"&gt;{{person.name}}&lt;/li&gt;\n      &lt;/ul&gt;\n     &lt;button ng-click=\"changeColor()\"&gt;Click Here&lt;/button&gt;\n    &lt;/div&gt;\n  &lt;/div&gt;\n  &lt;script type=\"text/javascript\" \n   src=\"https://ajax.googleapis.com/ajax/libs/angularjs/1.2.3/angular.min.js\"&gt;&lt;/script&gt;\n  &lt;script type=\"text/javascript\" src=\"main.js\"&gt;&lt;/script&gt;  \n&lt;/body&gt;\n&lt;/html&gt;\n<strong>Style.css<\/strong>\n.red {\n color: red;\n}\n.black {\n color: black;\n}<\/pre><\/div><p>isBlack 的值为 true 还是 false，是在 JavaScript 里面决定的。如下所示，我们在初始化时给一个默认值，就是 isBlack 为 true，而 isRed 为 false。当点击了 button 之后触发 changeColor 函数，把 isBlack 的值设为！isBlack, 这样在每次点击 button 后 isBlack 的值都会发生改变，从而 html 上&lt;li&gt;的样式也跟着改变。<\/p><h5 id=\"2.7.2.清单 8.使用 ng-class 例子的 js 部分 |outline\">清单 8. 使用 ng-class\n    例子的 JS 部分<\/h5><div class=\"codesection\"><pre class=\"displaycode\"><strong>main.js<\/strong>\nvar myApp = angular.module('myApp', []);\nmyApp.controller('SecondCtrl', function ($scope){\n       $scope.isBlack = true;\n       $scope.isRed = false;\n  $scope.roommates = [\n   { name: 'Lucy'},\n   { name: 'Lily'},\n   { name: 'Sean'},\n   { name: 'Adam'}\n ];\n $scope.changeColor = function () {\n  $scope.isRed = !$scope.isRed;\n  $scope.isBlack = !$scope.isBlack; \n}\n});<\/pre><\/div><h3 id=\"2.8.ng-click 指令属性 |outline\">ng-click 指令属性<\/h3><p>ng-click：ng-click 指令属性给 DOM 元素注册了一个点击事件的监听器。当此 DOM 元素上有点击事件发生（即当此 button 或 link 被点击时），AngularJS 就会执行表达式的内容，并相应地更新 view。ng-click 指令属性给 DOM 元素注册了一个点击事件的监听器。当此 DOM 元素上有点击事件发生（即当此 button 或 link 被点击时），AngularJS 就会执行表达式的内容，并相应地更新 view。在上面那个例子里，我们给 button 绑定了一个 changColor()的处理函数。 &lt;button ng-click=\"changeColor()\"&gt;Click Here&lt;/button&gt;， 并且在 controller 里面实现了这个函数，这样在 click 这个 button 的时候就会调用对应的 changeColor 函数。<\/p><p>我们也可以用 ng-click 来调用在 controller 里写好并绑定在$scope 上的函数，例如：<\/p><h5 id=\"2.8.1.清单 9.使用 ng-click|outline\">清单 9. 使用 ng-click<\/h5><div class=\"codesection\"><pre class=\"displaycode\">index.html\n&lt;button ng-click=\"sayHello()\"&gt;Say hello&lt;/button&gt;\n<strong>main.js<\/strong> \napp.controller('MyController', function($scope) {\n   $scope.sayHello = function() {\n   alert(\"hello!\");\n   }\n });<\/pre><\/div><h3 id=\"2.9.ng-init 指令属性 |outline\">ng-init 指令属性<\/h3><p>ng-init：它其实是在启动时运行的函数，让我们能够在程序运行前设定初始变量的值。如下例所示，我们初始化了 name 为\"tester\"字符串。<\/p><h5 id=\"2.9.1.清单 10.使用 ng-init|outline\">清单 10. 使用 ng-init<\/h5><div class=\"codesection\"><pre class=\"displaycode\">&lt;b ng-init='name = \"tester\"'&gt;Hello, {{ name }}&lt;/b&gt;<\/pre><\/div><h3 id=\"2.10.第一个 Directive――使用自定义指令属性 |outline\">第一个 Directive――使用自定义指令属性<\/h3><p>Directive 可以让我们创建自定义的指令属性，它可以让用户把自定义的行为绑定在某个 DOM 元素上，或者可以把这个 DOM 元素或其子元素变型。在这里例子中，我们创建了一个自定义指令属性 super。它的行为是返回的是一个 template，就是一个 html 代码段，把这个指令限制在\"E\",也就是元素。<\/p><h5 id=\"2.10.1.清单 11.使用自定义指令属性 Directive|outline\">清单 11. 使用自定义指令属性 Directive<\/h5><div class=\"codesection\"><pre class=\"displaycode\"><strong>index.html\n<\/strong>&lt;!DOCTYPE html&gt;\n&lt;html&gt;\n&lt;head&gt;&lt;/head&gt;\n&lt;body&gt;\n &lt;div ng-app=\"myApp\"&gt;\n &lt;super&gt;&lt;/super&gt;\n &lt;/div&gt;\n &lt;script type=\"text/javascript\"\nsrc=\"https://ajax.googleapis.com/ajax/libs/angularjs/1.2.3/angular.min.js\"&gt;&lt;/script&gt;\n&lt;script type=\"text/javascript\" src=\"main.js\"&gt;&lt;/script&gt;\n&lt;/body&gt;\n&lt;/html&gt;\n<strong>main<\/strong><strong>.js\n<\/strong>var app = angular.module(\"myApp\", []);\napp.directive(\"super\", function() {\n return {\n restrict: \"E\",\n        template: \"&lt;div&gt;This is my first Directive &lt;/div&gt;\"\n }\n})<\/pre><\/div><p>点开网页，可以看到从 Directive 返回的 HTML 段，因为我们设置了 restrict:\"E\",所以看到下图中 super 的子节点元素就是 Directive 返回的 div<\/p><h5 id=\"2.10.2.图 4.运行结果 |outline\">图 4.\n    运行结果<\/h5><img alt=\"运行结果\" src=\"/sunshine_new/images/994663078/image009.jpg\" width=\"381\" /><h3 id=\"2.11.限制您的 Directive――使用 Restrict|outline\">限制您的 Directive――使用 Restrict<\/h3><p>Restrict 用来限制只有满足条件的才可以使用自定义的指令属性，也就是 Directive。一共可以用于以下的四类，E-元素，A-属性，C-样式类，M-注释。下面是一个限制为 A(属性)的例子。<\/p><p>把上例中的&lt;body&gt;内的 div 替换成下面代码<\/p><h5 id=\"2.11.1.清单 12.在您的 Directive 上使用 Restrict|outline\">清单 12. 在您的 Directive 上使用 Restrict<\/h5><div class=\"codesection\"><pre class=\"displaycode\"><strong>i<\/strong><strong>ndex.html<\/strong>\n&lt;div ng-app=\"myApp\"&gt;\n &lt;!-- directive:man --&gt;\n &lt;div super class=\"flash\"&gt;&lt;/div&gt;\n&lt;/div&gt;\n<strong>main.js\n<\/strong>var app = angular.module(\"myApp\", []);\napp.directive(\"super\", function() {\n return {\n restrict: \"A\",\n link: function() {\n alert(\"I'm working stronger\")\n }\n }\n})\n\napp.directive(\"flash\", function() {\n return {\n restrict: \"C\",\n link: function() {\n alert(\"I'm working faster\")\n }\n }\n})\napp.directive(\"man\", function() {\n return {\n restrict: \"M\",\n link: function() {\n alert(\"I'm comment\")\n }\n }\n})<\/pre><\/div><h5 id=\"2.11.2.图 5.运行结果 |outline\">图 5.\n    运行结果<\/h5><img alt=\"运行结果\" src=\"/sunshine_new/images/994663078/image011.jpg\" width=\"232\" /><p>从 HTML 中可以看到 super 是 div 的用户自定义属性，flash 是一个样式类，&lt;!-- directive:man --&gt; 是一段注释，注释必须遵守这个格式。在 JavaScript 里面我们写了三个 directive，分别对应处理 link 后面对应的是处理函数。第一个 directive 限定的是 A（属性），第二个 directive 限定的是 C（样式类），第三个限定的是 M(注释)，用对应的处理函数来处理。可以自己把 JavaScript 中的 restrict A 和 C，M 对调，会看到三个 alert 都不出现。<\/p><h2 id=\"3.总结 |outline\">总结<\/h2><p>我们已经看到了 AngularJS 最基本的用法以及一些简单的例子，还有很多 AngularJS 的精美特性没有提到，感兴趣的请阅读我提供的参考资源。<\/p><CMA ID: 975700><Site ID: 10><XSLT stylesheet used to transform this file: dw-document-html-7.0.xsl>\r\n\r\n\r\n<\/div>\r\n<\/div>\r\n","createTime":"2014-06-26 00:00:00","deployTime":"2014-06-26 00:00:00","id":0,"intro":"AngularJS 是一款来自 Google 的前端 JavaScript 框架，它的设计理念和功能却非常强大，它快速成为了 JavaScript 的主流框架，简化了前端开发的负担，来帮助开发者从事 web 开发。本文将介绍 AnjularJS 中的几个重要概念，并提供简单易懂的例子深入学习 AngularJS。","keyword":"","recommend":false,"source":"http://www.ibm.com/developerworks/cn/web/1406_rentt_angularjs/index.html","title":"Angular.js 介绍及实践教程","typeId":0,"updateTime":"2014-06-26 00:00:00"}
{"author":"","clickNumber":0,"content":"\r\n<div class=\"ibm-columns\">\r\n<div class=\"ibm-col-1-1\">\r\n\r\n<p>Java 8 的最大变化在于添加了对 <em>lambda 表达式<\/em> 的支持。Lambda\n                    表达式是可按引用传递的代码块。它们类似于一些其他编程语言中的<em>闭包<\/em>：它们是实现某项功能的代码，可接受一个或多个输入参数，而且可返回一个结果值。闭包是在一个上下文中定义的，可访问（对于\n                lambda 表达式而言是只读访问）来自上下文的值。<\/p><p>如果您不熟悉闭包，不用害怕。Java 8 lambda 表达式其实是匿名内部类的一种特殊化，而几乎所有 Java\n                开发人员都熟悉匿名内部类。匿名内部类提供了一个接口的内联实现，或者一个基类的子类，我们一般只会在代码中的一个地方使用它。Lambda\n                表达式的使用方式一样，但它有一个简写的语法，使得它们比标准内部类定义更简洁。<\/p><p>在本文中，您将了解如何在各种情形下使用 lambda 表达式，还将了解 Java 语言 <code>interface<\/code>\n                定义的相关扩展。参见 <a href=\"http://www.ibm.com/developerworks/cn/views/java/libraryview.jsp?sort_by=&amp;show_abstract=true&amp;show_all=&amp;search_flag=&amp;contentarea_by=Java+technology&amp;search_by=JVM+%E5%B9%B6%E5%8F%91%E6%80%A7&amp;topic_by=-1&amp;type_by=%E6%89%80%E6%9C%89%E7%B1%BB%E5%88%AB&amp;ibm-search=%E6%90%9C%E7%B4%A2\"><em>JVM\n                        并发性<\/em><\/a> 系列下的姊妹篇 “<a href=\"http://www.ibm.com/developerworks/cn/java/j-jvmc2/index.html\">Java\n                            8 并发性基础<\/a>”，查看使用 lambdas 的更多示例，包括将它们与 Java 8 <em>streams<\/em>\n                特性一起使用的示例。<\/p><h2 id=\"N1006A\">了解 lambdas<\/h2><p>Lambda 表达式始终是 Java 8 称为<em>函数式接口<\/em> 的一个对象的实现：定义单一抽象方法的\n                <code>interface<\/code> 类。对单一抽象方法的限制很重要，因为 lambda 表达式语法不使用方法名。相反，该表达式使用了\n                    <em>duck typing<\/em>（匹配参数和返回类型，就像在许多动态语言中所做的那样）来确保所提供的 lambda\n                与预期的接口方法相兼容。<\/p><p>在清单 1 中的简单示例中，使用了 lambda 来对 <code>Name<\/code> 实例进行排序。<code>main()<\/code>\n                方法中的第一个代码块使用了一个匿名内部类来实现 <code>Comparator&lt;Name&gt;<\/code> 接口，第二个代码块使用了\n                lambda 表达式。（参见 <a href=\"#resources\">参考资料<\/a>，获取本文完整样例代码的链接。）<\/p><h5 id=\"listing1\">清单 1. 匿名内部类与 Lambda\n                表达式的对比<\/h5><div class=\"codesection\"><pre class=\"displaycode\">public class Name {\n    public final String firstName;\n    public final String lastName;\n\n    public Name(String first, String last) {\n        firstName = first;\n        lastName = last;\n    }\n\n    // only needed for chained comparator\n    public String getFirstName() {\n        return firstName;\n    }\n\n    // only needed for chained comparator\n    public String getLastName() {\n        return lastName;\n    }\n\n    // only needed for direct comparator (not for chained comparator)\n    public int compareTo(Name other) {\n        int diff = lastName.compareTo(other.lastName);\n        if (diff == 0) {\n            diff = firstName.compareTo(other.firstName);\n        }\n        return diff;\n    }\n    ...\n}\n\npublic class NameSort {\n    \n    private static final Name[] NAMES = new Name[] {\n        new Name(\"Sally\", \"Smith\"),\n        ...\n    };\n    \n    private static void printNames(String caption, Name[] names) {\n        ...\n    }\n\n    public static void main(String[] args) {\n\n        // sort array using anonymous inner class\n        Name[] copy = Arrays.copyOf(NAMES, NAMES.length);\n        Arrays.sort(copy, new Comparator&lt;Name&gt;() {\n            @Override\n            public int compare(Name a, Name b) {\n                return a.compareTo(b);\n            }\n        });\n        printNames(\"Names sorted with anonymous inner class:\", copy);\n\n        // sort array using lambda expression\n        copy = Arrays.copyOf(NAMES, NAMES.length);\n        Arrays.sort(copy, (a, b) -&gt; a.compareTo(b));\n        printNames(\"Names sorted with lambda expression:\", copy);\n        ...\n    }\n}<\/pre><\/div><p>在 <a href=\"#listing1\">清单 1<\/a> 中，lambda 用于替代一个惯用匿名内部类。这种惯用内部类在实践中都很常见，因此\n                lambda 表达式立即赢得了 Java 8 程序员的器重。（在本例中，内部类和 lambda 都使用在 <code>Name<\/code>\n                类中实现的一个方法来执行比较工作。如果 <code>compareTo()<\/code> 方法代码内联在 lambda\n                中，那么表达式就不怎么简洁了。） <\/p><h2 id=\"N1009B\">标准函数式接口<\/h2><p>新的 <code>java.util.function<\/code> 包定义旨在使用 lambdas 的广泛函数式接口。这些接口分为几大类：<\/p><ul class=\"ibm-bullet-list\"><li>Function：接受一个参数，基于参数值返回结果<\/li><li>Predicate：接受一个参数，基于参数值返回一个布尔值<\/li><li>BiFunction：接受两个参数，基于参数值返回结果<\/li><li>Supplier：不接受参数，返回一个结果<\/li><li>Consumer：接受一个参数，无结果 (<code>void<\/code>)<\/li><\/ul><p>这些类别中大部分都包含几个用于处理基本原始参数或返回类型的变量。许多接口定义可用于组合实例的方法，如清单 2 中所示。<\/p><h5 id=\"listing2\">清单 2. 组合谓词<\/h5><div class=\"codesection\"><pre class=\"displaycode\">// 使用谓词组合删除匹配的名称\nList&lt;Name&gt; list = new ArrayList&lt;&gt;();\nfor (Name name : NAMES) {\n    list.add(name);\n}\nPredicate&lt;Name&gt; pred1 = name -&gt; \"Sally\".equals(name.firstName);\nPredicate&lt;Name&gt; pred2 = name -&gt; \"Queue\".equals(name.lastName);\nlist.removeIf(pred1.or(pred2));\nprintNames(\"Names filtered by predicate:\", list.toArray(new Name[list.size()]));<\/pre><\/div><p><a href=\"#listing2\">清单 2<\/a> 中的代码定义了一对\n                <code>Predicate&lt;Name&gt;<\/code>，一个与名 <em>Sally<\/em> 匹配，第二个与姓\n                    <em>Queue<\/em> 匹配。<code>pred1.or(pred2)<\/code>\n                方法调用构建所定义的组合谓词，方法是依次应用两个谓词，如果两个谓词之一等于 <code>true<\/code>（与 Java 中的逻辑\n                <code>||<\/code> 运算符一样），则返回 <code>true<\/code>。<code>List.removeIf()<\/code>\n                方法应用这个组合谓词从列表中删除匹配的名称。<\/p><p>Java 8 定义了 <code>java.util.function<\/code>\n                接口的许多有用的组合，但组合不一致。谓词变量（<code>DoublePredicate<\/code>、<code>IntPredicate<\/code>、<code>LongPredicate<\/code>\n                和\n                <code>Predicate&lt;T&gt;<\/code>）都定义了相同的组合和修改方法：<code>and()<\/code>、<code>negate()<\/code>\n                和 <code>or()<\/code>。但 <code>Function&lt;T&gt;<\/code>\n                的原始变量不定义任何组合或修改方法。如果您有使用函数式编程语言的经验，那么您可能会发现这些差异和遗漏很古怪。<\/p><h3 id=\"N100F5\">更改 <code>interfaces<\/code><\/h3><p><code>interface<\/code> 类的结构（比如 <a href=\"#listing1\">清单 1<\/a> 中使用的\n                <code>Comparator<\/code>）在 Java 8 中有了变化，部分原因是为了让 lambda 表达式更可用。Java 8\n                之前的接口只能定义常量和稍后必须实现的抽象方法。Java 8 增加了在接口中同时定义 <code>static<\/code> 和\n                <code>default<\/code>\n                方法的能力。一个接口中的静态方法实际上与一个抽象类中的静态方法相同。默认方法更像是旧式的接口方法，但有一个附带的实现，只有在重写方法时才会使用该实现。<\/p><p>默认方法的一个重要特性是，可以将它们添加到一个现有的 <code>interface<\/code>\n                中，同时不会破坏与使用该接口的其他代码的兼容性（除非您的现有代码正好出于另一个目的使用相同的方法名）。这是一个强大的特性，Java 8\n                设计人员使用它来改进对许多预置 Java 库的 lambda 表达式的支持。清单 3 显示一个示例，采用第三种方式对添加到 <a href=\"#listing1\">清单 1<\/a> 代码中的名称进行排序。<\/p><h5 id=\"listing3\">清单 3. 串连 key-extractor\n                    Comparator<\/h5><div class=\"codesection\"><pre class=\"displaycode\">// sort array using key-extractor lambdas\ncopy = Arrays.copyOf(NAMES, NAMES.length);\nComparator&lt;Name&gt; comp = Comparator.comparing(name -&gt; name.lastName);\ncomp = comp.thenComparing(name -&gt; name.firstName);\nArrays.sort(copy, comp);\nprintNames(\"Names sorted with key extractor comparator:\", copy);<\/pre><\/div><p><a href=\"#listing3\">清单 3<\/a> 中的代码首先展示了如何使用新的\n                <code>Comparator.comparing()<\/code> 静态方法来基于您定义的 key-extraction lambda 创建一个\n                Comparator（从技术上来讲，key-extraction lambda 是\n                <code>java.util.function.Function&lt;T,R&gt;<\/code> 接口的一个实例，其中生成的\n                Comparator 的类型在分配时与 <code>T<\/code> 兼容，而且所提取的键类型 <code>R<\/code> 实现了\n                <code>Comparable<\/code> 接口。）另外还展示如何使用新的\n                <code>Comparator.thenComparing()<\/code> 默认方法组合 Comparator，在 <a href=\"#listing3\">清单 3<\/a> 中，该方法返回了一个新\n                comparator，它按照姓氏对第一个数组进行排序，按照名字对第二个数组进行排序。<\/p><p>您可能认为您可以将 comparator 构造函数内联为：<\/p><div class=\"codesection\"><pre class=\"displaycode\">Comparator&lt;Name&gt; comp = Comparator.comparing(name -&gt; name.lastName)\n    .thenComparing(name -&gt; name.firstName);<\/pre><\/div><p>遗憾的是，这对于 Java 8 类型推断不管用。您需要使用以下任意一种形式为编译器提供有关静态方法所返回结果的预期类型的更多信息：<\/p><div class=\"codesection\"><pre class=\"displaycode\">Comparator&lt;Name&gt; com1 = Comparator.comparing((Name name1) -&gt; name1.lastName)\n    .thenComparing(name2 -&gt; name2.firstName);\nComparator&lt;Name&gt; com2 = Comparator.&lt;Name,String&gt;comparing(name1 -&gt; name1.lastName)\n    .thenComparing(name2 -&gt; name2.firstName);<\/pre><\/div><p>第一种形式将 lambda 参数的类型添加到 lambda\n                表达式：<code>(Name name1) -&gt; name1.lastName<\/code>。有了这一协助，编译器就可以了解其余要做的工作是什么。第二种形式将传递给\n                <code>comparing()<\/code> 方法的函数式接口（在本例中由 lambda 实现）的类型 <code>T<\/code> 和\n                <code>R<\/code> 告诉编译器。<\/p><p>轻松构造和串连 comparator 的能力是 Java 8 的一个有用功能，但其代价是增加了复杂性。Java 7\n                <code>Comparator<\/code> 接口定义了两个方法（<code>compare()<\/code> 和保证要为每个对象定义的无处不在的\n                <code>equals()<\/code>）。Java 8 版本定义了 18 个方法（原始的 2 个方法，加上 9 个新静态方法和 7\n                个新的默认方法）。您会发现，为使用 lambdas 而产生的这一大规模接口膨胀模式会在 Java 标准库的相当一部分中重复出现。<\/p><h2 id=\"N1015A\">使用 lambdas 这样的现有方法<\/h2><p>如果有一个现有的方法已经满足了您的需要，那么您可以使用<em>方法引用<\/em> 来直接传递该方法。清单 4 展示了该方法。<\/p><h5 id=\"listing4\">清单 4. 使用 lambdas\n                这样的现有方法<\/h5><div class=\"codesection\"><pre class=\"displaycode\">...\n// sort array using existing methods as lambdas\ncopy = Arrays.copyOf(NAMES, NAMES.length);\ncomp = Comparator.comparing(Name::getLastName).thenComparing(Name::getFirstName);\nArrays.sort(copy, comp);\nprintNames(\"Names sorted with existing methods as lambdas:\", copy);<\/pre><\/div><p><a href=\"#listing4\">清单 4<\/a> 与 <a href=\"#listing3\">清单 3<\/a>\n                中实现的功能一样，不同的是使用了现有的方法。您可以使用 Java 8 <code>ClassName::methodName<\/code>\n                方法引用语法，像使用 lambda 表达式一样使用任意方法。这与定义调用该方法的 lambda 具有完全相同的效果。您可以对静态方法、lambda\n                的特定对象或输入类型的实例方法（如 <a href=\"#listing4\">清单 4<\/a> 所示，其中\n                <code>getFirstName()<\/code> 和 <code>getLastName()<\/code> 方法是所比较的\n                <code>Name<\/code> 的实例方法）以及构造函数使用方法引用。<\/p><p>方法引用不仅使用方便，比起使用 lambda 表达式它们可能更有效，而且对于编译器（这就是为什么在清单 4 最后一部分对比 lambdas 出现问题而使用方法引用工作正常的原因）也提供了更好的类型信息。如果您在使用一个已经存在的方法引用和使用一个 lambda 之间做出选择，您应该总是更倾向于使用方法引用。<\/p><h2 id=\"N10185\">捕获的和非捕获的 lambdas<\/h2><p>本文中您看到的 lambda 示例都是<em>非捕获的<\/em>，也就是说，它们是简单的表达式，仅使用作为接口方法参数的等效值传递进来的值。Java\n                8 中<em>捕获的<\/em> lambdas 使用了所包含的上下文中的值。捕获的 lambdas 类似于其他一些 JVM 语言（包括\n                Scala）中使用的闭包，但不同之处在于，在 Java 8 中，所包含的上下文中的任何值必须是 <em>effectively\n                final<\/em>。即该值必须是真正的 <code>final<\/code>（因为引用自匿名内部类的值必须在早期 Java\n                    版本中）<em>或者<\/em> 在上下文中从未被修改过。这一标准同时适用于 lambda 表达式和匿名内部类使用的值。<\/p><p>您可以使用一些解决方法来应对 effectively final 限制。例如，如果要在一个 lambda\n                表达式中仅使用某些变量的当前值，那么您可以添加一个新方法，接受这些值作为参数，并为 lambda\n                表达式（以适当接口引用的形式）返回捕获的值。如果想要一个 lambda 表达式来修改封闭的上下文中的值，那么可以将该值包装到一个可变容器中。<\/p><p>与捕获的 lambdas 相比，非捕获的 lambdas 可以得到更高效的处理，因为编译器可以将它们生成为包含类中的静态方法，而且运行时可以直接内联调用。捕获的 lambdas 可能效率稍差一点，但在相同的上下文中它的性能应至少与匿名内部类一样。<\/p><h2 id=\"N1019F\">Lambdas 幕后揭秘<\/h2><p>Lambda 表达式看起来非常像匿名内部类，但实现方式不同。Java\n                内部类是庞大的构造函数；一直到字节码级别，每个内部类都有一个独立的类文件。很多数据是重复的（主要采用常量池项的形式），类加载增加了相当大的运行时开销，这一切都只是为了支持少量增加的代码。<\/p><p>Java 8 没有为 lambdas 使用独立的类文件，而是依赖 Java 7 中添加的 <code>invokedynamic<\/code>\n                字节码指令。<code>invokedynamic<\/code> 以一个 bootstrap 方法为目标，该方法在首次被调用时创建 lambda\n                表达式实现。随后，返回的实现被直接调用。这样就避免了独立类文件的空间开销以及加载类的大量运行时开销。lambda 函数究竟是<em>如何<\/em>\n                实现的就交由 bootstrap 来决定。Java 8 当前生成的 bootstrap 代码在运行时为 lambda\n                构建了一个新类，但未来的实现可自由使用不同的方法。<\/p><p> Java 8 结合了一些优化措施，使得通过 <code>invokedynamic<\/code> 进行的 lambdas\n                实现在实践中行之有效。其他大部分 JVM 语言，包括 Scala (2.10.x)，为闭包使用编译器生成的内部类。这些语言的未来版本可能转向\n                <code>invokedynamic<\/code> 方法，以便利用 Java 8（和更高版本）的优化。<\/p><h2 id=\"N101B9\">Lambda 的限制<\/h2><p>正如我在文章开头所提到的，lambda 表达式几乎是一些特殊函数接口的实现。您只可以通过 lambdas 作为接口引用和其他接口的实现，您只可使用一个 lambda 作为将要创建的具体接口。清单 5\n                通过一对相同（除了名称）的函数式接口展示了这一限制。Java 8 编译器接受 <code>String::length<\/code>\n                方法作为两个接口的 lambda 实现。但在将 lambda 定义为第一个接口的实例之后，就不能将其用作第二个接口的实例。<\/p><h5 id=\"listing5\">清单 5. Lambda\n                的限制<\/h5><div class=\"codesection\"><pre class=\"displaycode\">private interface A {\n    public int valueA(String s);\n}\nprivate interface B {\n    public int valueB(String s);\n}\npublic static void main(String[] args) {\n    A a = String::length;\n    B b = String::length;\n\n    // compiler error!\n    // b = a;\n\n    // ClassCastException at runtime!\n    // b = (B)a;\n\n    // works, but ugly (wraps in a new lambda)\n    b = (x) -&gt; a.valueA(x);\n    System.out.println(b.valueB(\"abc\"));\n}<\/pre><\/div><p>Scala 等函数式编程语言使用函数类型（而不是接口）来定义变量。在这种语言中使用<em>高阶函数<\/em>\n                是很常见的事情：高阶函数是将函数作为参数传递或将函数作为值返回的函数。其编程风格要比 lambdas 灵活得多，包括能够将函数作为构建块来组建其他函数。由于 Java 8 没有定义函数类型，所以您不能以这种方式创建 lambdas。您可以创建<em>接口<\/em>（如 <a href=\"#listing3\">清单 3<\/a>\n                所示），但编写的代码仅用于处理所涉及到的特定接口。仅仅在新的 <code>java.util.function<\/code> 程序包中，就专门创建了\n                43 个用于 lambdas 的接口。将这些接口添加到上百个现有接口中，您可以看到构建接口的方式总是受到极大的限制。<\/p><p>在进行使用接口（而不是添加函数类型到 Java）的选择时，一定要深思熟虑。这样做会排除对 Java 库进行重大变动的需要，同时支持对现有的库使用\n                lambda 表达式。这样做的弊端在于，它将 Java 8 限定为所谓的 “接口编程” 或类似函数式的编程，而非真正的函数式编程。但随着 JVM\n                上开始支持其他多种语言，包括函数式语言，这一限制就没那么严重了。<\/p><h2 id=\"N101DA\">结束语<\/h2><p>Lambdas 是 Java 语言的一个重大扩展，而且随着所有 Java 人员将其应用程序迁移到 Java 8，Lambda\n                表达式很快将成为他们不可缺少的一个工具。在与 Java 8 <em>streams<\/em> 结合使用时，Lambdas 特别有用。参阅 “<a href=\"http://www.ibm.com/developerworks/cn/java/j-jvmc2/index.html\">JVM\n                    并发性：Java 8 并发性基础<\/a>”，了解 lambdas 与 Java 8\n                streams 如何共同简化并发编程和提高应用程序性能。<\/p><CMA ID: 975193><Site ID: 10><XSLT stylesheet used to transform this file: dw-document-html-7.0.xsl>\r\n\r\n\r\n<\/div>\r\n<\/div>\r\n","createTime":"2014-06-26 00:00:00","deployTime":"2014-06-26 00:00:00","id":0,"intro":"Java 8 包含一些重要的新的语言功能，为您提供了构建程序的更简单方式。Lamba 表达式为内联代码块定义了一种新语法，其灵活性与匿名内部类一样，但样板文件要少得多。接口更改使得接口可以添加到现有接口中，同时又不会破坏与现有代码的兼容性。本文将了解这些更改是如何协同工作的。","keyword":"","recommend":false,"source":"http://www.ibm.com/developerworks/cn/java/j-java8lambdas/index.html","title":"Java 8 语言变化","typeId":0,"updateTime":"2014-06-26 00:00:00"}
{"author":"","clickNumber":0,"content":"\r\n<div class=\"ibm-columns\">\r\n<div class=\"ibm-col-1-1\">\r\n\r\n<h2 id=\"major1\">从一个传说讲起<\/h2><p>这是一个耳熟能详的传说：传说中，凤凰是人世间幸福的使者，每五百年，它就要背负着积累于人世间的所有不快和仇恨恩怨，投身于熊熊烈火中自焚，以生命和美丽的终结换取人世的祥和和幸福。在肉体经受了巨大的痛苦和轮回后它们才能获得更美好的躯体得以重生。佛教徒把这个故事称为“涅”。<\/p><p>的确，一切苦难和磨砺的尽头也是新的希望开始的地方。作为 IT 从业人员，特别是程序员的你，是否也想过或者期望经历这样的涅呢？如果你曾经或者现在正在经历如下的痛苦，那么 Bluemix 就是为你而准备的。<\/p><ul class=\"ibm-bullet-list\"><li>\n不停的安装各种运行时，容器以及繁杂的第三方依赖包<\/li><li>\n安装并配置一切必须的服务（数据库，移动服务等）<\/li><li>\n将所需的服务与应用进行关联，配置端口/IP/防火墙等<\/li><li>\n建立动态路由以及负载均衡机制<\/li><li>\n保证从底层到应用层各个层次的高可用性<\/li><li>\n确保日志的完整收集和高效分析<\/li><li>\n日常要做好应用的性能监控<\/li><li>\n保证应用可以根据负载的大小进行灵活的伸缩<\/li><li>\n最后，不断的重复着 开发》测试》上线 的轮回<\/li><\/ul><h2 id=\"major2\">Bluemix 带来了什么<\/h2><p>Bluemix 致力于解决上述在软件开发过程中遇到的问题，旨在帮助程序员更快速的开发，测试，部署和运维云平台应用。<\/p><h3 id=\"major3\">什么是 Bluemix？<\/h3><p>简单的讲，Bluemix 就是一个开放的公有云平台，允许程序员在上面运行几乎所有类型的应用，而不用为硬件，软件，网络等其他因素分心。如上文提到，Bluemix 处于云世界的中间层，也就是 PaaS 层。如下图所示：<\/p><h5 id=\"img001\">图 1. Bluemix 扮演的角色<\/h5><img alt=\"图 1. Bluemix 扮演的角色\" src=\"/sunshine_new/images/负1736471717/img001.png\" width=\"429\" /><p>通常来讲，所谓 PaaS 指的是运行在 Iaas 层上的一系列软件服务，并把服务器平台或开发环境作为一种服务提供给用户，也就是“平台即服务”。Bluemix 运行在 IBM 的 IaaS 层产品 Softlayer 之上。Softlayer 在 2013 年被 IBM 收购，其主要为用户提供企业级的 IT 基础设施的建设和解决方案，无论是在性能还是在安全性上都有很高的质量保证，有兴趣的读者可以参考文章最后的资源链接进一步学习。用户的应用程序通过很简单的操作（大部分场景只需要一条简单的命令即可）就能部署应用到 Bluemix 环境里，程序员不需要去关心底层的操作系统，运行时，网络等等一切和 code 本身无关的东西，而可以把全部的精力放到程序的设计和优化上。<\/p><h3 id=\"major4\">选择 Bluemix 的理由<\/h3><p>Bluemix 作为 PaaS 层产品给程序员带来了很多的优势：第一，节省时间和精力，程序员可以把所有的心思都放在应用程序的编写和调优上，而不用去担心繁杂的平台基础架构和设施，更有利于发掘程序员的创造力，开发出更高质量，高性能的应用；第二，加速应用程序上线，在实际的操作中，只需要简单的几条命令或者 UI 界面的几次点击操作就能轻松的完成各种应用程序的部署，而完全不用去担心硬件采购，软件安装等等这些先期准备工作；第三，很容易的满足应用程序对各种新功能和新服务的需求，IBM 及其合作伙伴负责提供优质的服务，程序员只需要简单的“绑定”操作就能将服务加入到应用程序中；第四，Bluemix 支持的语言，运行时，框架等都是程序员已经熟知的，采用 Bluemix 平台几乎不需要增加新的学习成本；最后一点是，Bluemix 底层采用 IaaS 是可以提供企业级需求的 Softlayer，可以有效的保证平台的高性能和高安全性。<\/p><p>目前，Bluemix 正处于公开测试阶段，程序员只需要简单的注册就能轻松的使用 Bluemix 提供的平台云服务。在测试阶段，每个注册账号可以获得 8G 的内存空间用来部署和运行足够多的应用，其中还包括多达 20 个云服务的使用权，注册网址是：www.bluemix.net<\/p><h3 id=\"major5\">Bluemix 运行时和 Buildpacks<\/h3><p>在 Bluemix 中程序运行时是以 Buildpacks 的形式提供给用户的，通过下面这张图，可以了解运行时和 Buildpack 的关系。<\/p><h5 id=\"img002\">图 2. 图解 Buildpack<\/h5><img alt=\"图 2. 图解 Buildpack\" src=\"/sunshine_new/images/负1736471717/img002.png\" width=\"581\" /><p>在 Bluemix 中自带四种 Bludpacks，分别是 Liberty for Java，Node.js，Ruby on Rails，Ruby Sinatra。如果部署的应用是上面四种语言之一，那么在部署应用的时候就不需要指定相应的 Buildpack，平台自身会根据部署的应用类型选择对应的 Buildpack。在本文开始的部分，我们提到 Bluemix 支持几乎所有类型的应用，那么除了上面四种应用，其他类型的应用又是通过什么方法进行部署呢？答案就是在部署应用的时候，明确的指定应用所需的 Buildpack 类型，这些 Buildpack 有的来自社区，有的来自程序员自己的开发，因为 Bluemix 是一个开放的云平台架构，允许第三方根据其标准去做一些客制化的拓展。下图所列的就是目前 Bluemi 支持的运行时类型。<\/p><h5 id=\"img003\">图 3. 运行时（Runtimes）<\/h5><img alt=\"图 3. 运行时（Runtimes）\" src=\"/sunshine_new/images/负1736471717/img003.png\" width=\"582\" /><h3 id=\"major6\">Bluemix 提供的服务（Services）和功能插件（Add-Ons）<\/h3><p>应用程序往往不是单独存在的，它需要额外的附加一些新的价值才能使其丰富起来，在 Bluemix 中这些应用程序的附加值是通过服务（Services）和功能插件（Add-Ons）来实现的。在 Bluemix 中，为程序员提供了分门别类的多种服务，这些服务主要包括：Web 和应用服务，移动开发服务，数据管理服务，大数据，DevOps 服务等等。Bluemix 可以做到以最小的代价将相应的服务添加到应用程序中，以此来丰富应用程序，这些操作既可以通过命令行，也可以通过基于浏览器的 UI 来完成。在使用过程中，用户可以创建多个服务的实例，同样多个应用也可以同时使用同一个服务实例。<\/p><p>功能插件（Add-Ons）可以理解成一种特殊的服务，这些功能插件是为运行时来提供更高层次的附加功能。用户可以根据自己的需求，选择应用是否连接到一个或者多个功能插件上，以此来丰富运行的应用程序。功能插件与服务的不同之处在于，同一个 Space 里，只能有一个功能插件实例，多个应用去连同一种功能插件的时候，实际上连的是同一个插件实例，共享同一份服务资源。<\/p><p>对于服务和功能插件来说，当某一个服务绑定到应用中，或者当应用连接到某一个功能插件上时，关于这个服务和功能插件的相关服务信息就会被写进一个成为“VCAP_SERVICES”的系统环境变量中，用户可以在代码里通过调用 System.getenv(“VCAP_SERVICES”) 来获取具体的信息，这些信息是遵循一定的格式的 JSON 字符串，例如对于某一个数据库的服务，读到的环境变量里主要就是数据库的连接信息，用户可以在应用程序里获取并建立与数据库的连接。<\/p><h2 id=\"major7\">如何使用 Bluemix Java 运行时<\/h2><p>BlueMix 为程序员提供了多种方法开发，测试应用并最终运行在 Bluemix 运行时中，本文主要关注 Bluemix Java 运行时，并向读者介绍最常用的几种方法，其他运行时的使用方法和本文介绍的类似，读者可以自行使用。<\/p><h3 id=\"major8\">使用命令行工具部署和管理应用<\/h3><p>命令行工具一直受大多数程序员欢迎，高效并且高性能，你想在 Bluemix 上做的任何事情，都可以通过命令行工具来完成。比如下面所列，是我们和应用打交道时用到的最频繁的操作。<\/p><ul class=\"ibm-bullet-list\"><li>\n应用的部署，启动，停止，重启以及删除、<\/li><li>\n服务的创建，绑定，以及解除绑定等操作<\/li><li>\n查看和监控应用程序的日志<\/li><\/ul><p>命令行工具的安装也很简便，请首先阅读文章末尾的参考资源安装命令行工具。使用 Bluemix 之前，需要首先注册 Bluemix 账号，访问 www.bluemix.net 注册 Bluemix 账号，当这些都完成以后，让我们开始你的平台云之旅吧！<\/p><p>当使用命令行部署 Java EE 的应用到 Bluemix 的时候，Bluemix 支持三种格式应用的部署，分别是：WAR，EAR 以及直接上载一个 Liberty server 到 Bluemix。除了支持这三种格式的打包文件外，还支持将打包文件解压成目录结构，通过命令行将整个目录结构上传并部署到 Bluemix 环境。我们这里将以一个 WAR 应用为例子来详细讲解每一步的操作，关于其他两种格式的应用的部署与 WAR 应用的部署几乎是一样的，详细介绍请阅读参考资源――部署 Liberty 应用到 Bluemix。<\/p><p><strong>登录 Bluemix<\/strong><\/p><p>使用之前注册的用户名和密码登录到 Bluemix，为部署应用做准备：<\/p><p>首先，使用“cf api”建立于 Bluemix 的连接，连接地址是 https://api.ng.bluemix.net<\/p><h5 id=\"listing1\">清单 1. 连接 Bluemix<\/h5><div class=\"codesection\"><pre class=\"displaycode\">USAGE:\n cf api [URL]\n\nC:\\Users\\IBM_ADMIN&gt;<strong>cf api https://api.ng.bluemix.net<\/strong>\nSetting api endpoint to https://api.ng.bluemix.net...\nOK\n\nAPI endpoint: https://api.ng.bluemix.net (API version: 2.2.0)\nNot logged in. Use 'cf login' to log in.<\/pre><\/div><p>其次，运行“cf login”登录到 Bluemix 并选择所要工作的组织和空间<\/p><h5 id=\"listing2\">清单 2. 登录 Bluemix<\/h5><div class=\"codesection\"><pre class=\"displaycode\">USAGE:\n cf login [-a API_URL] [-u USERNAME] [-p PASSWORD] [-o ORG] [-s SPACE]\n\nC:\\Users\\IBM_ADMIN&gt;cf login\nAPI endpoint: https://api.ng.bluemix.net\n\nUsername&gt; xiuleizh@cn.ibm.com\n\nPassword&gt;\nAuthenticating...\nOK\n\nSelect an org (or press enter to skip):\n1. xiuleizh@cn.ibm.com\n2. OE_Runtimes_SVT\n\nOrg&gt; 1\nTargeted org xiuleizh@cn.ibm.com\n\nTargeted space dev\n\nAPI endpoint: https://api.ng.bluemix.net (API version: 2.2.0)\nUser: xiuleizh@cn.ibm.com\nOrg: xiuleizh@cn.ibm.com\nSpace: dev<\/pre><\/div><p><strong>部署应用到 Bluemix<\/strong><\/p><p>本文提供一个例子应用供大家下载部署使用，这个应用是 HelloWithMongo.war，里面包含了一个简单的 servlet 以及一些对 Non-SQL 数据库 Mongo 的基本操作，在 Bluemix 提供的数据库服务里包含了 Mongo 数据库，我们直接拿来使用。<\/p><p>运行“cf push”命令来部署应用到 Bluemix：<\/p><h5 id=\"listing3\">清单 3. 部署应用到 Bluemix<\/h5><div class=\"codesection\"><pre class=\"displaycode\">USAGE:\n Push a single app (with or without a manifest):\n cf push APP [-b BUILDPACK_NAME] [-c COMMAND] [-d DOMAIN] [-f MANIFEST_PATH]\n [-i NUM_INSTANCES] [-m MEMORY] [-n HOST] [-p PATH] [-s STACK] [-t TIMEOUT]\n [--no-hostname] [--no-manifest] [--no-route] [--no-start]\n\nC:\\Users\\IBM_ADMIN&gt;cf push HelloMongoDW -p C:\\A_Workspace\\apps\\HelloWithMongo.war\nCreating app HelloMongoDW in org xiuleizh@cn.ibm.com / space dev as xiuleizh@cn.\nibm.com...\nOK\n\nUsing route hellomongodw.ng.bluemix.net\nBinding hellomongodw.ng.bluemix.net to HelloMongoDW...\nOK\n\nUploading HelloMongoDW...\nUploading from: C:\\A_Workspace\\apps\\HelloWithMongo.war\n53.4K, 14 files\nOK\n\nStarting app HelloMongoDW in org xiuleizh@cn.ibm.com / space dev as xiuleizh@cn.\nibm.com...\n-----&gt; Downloaded app package (484K)\nOK\n\n\nBuildpack Version: 20140527-0132\n-----&gt; Downloading IBM 1.7.0 JRE from http://file.icap.cdl.ibm.com/icapShared/jr\ne/ibm-java-jre-7.0-6.0-linux-x86_64-small-footprint-uncompressed-jar-20140116.ta\nr.gz (0.0s)\n Expanding JRE to .java (1.2s)\nDownloading from output/wlp/com.ibm.ws.liberty-2014.4.0.0-201405270132.tar.gz ..\n. (0.0s).\nInstalling archive ... (0.6s).\n\n\n\n-----&gt; Uploading droplet (93M)\n\n0 of 1 instances running, 1 starting\n1 of 1 instances running\n\nApp started\n\nShowing health and status for app HelloMongoDW in org xiuleizh@cn.ibm.com / spac\ne dev as xiuleizh@cn.ibm.com...\nOK\n\nrequested state: started\ninstances: 1/1\nusage: 1G x 1 instances\nurls: hellomongodw.ng.bluemix.net\n\n state since cpu memory disk\n#0 running 2014-05-30 06:45:02 PM 0.6% 329.8M of 1G 179.1M of 1G<\/pre><\/div><p>部署成功以后可以运行“cf apps”查看应用的运行状态。在这里有几点需要说明：第一，&lt;app_name&gt;最好要做到唯一，不和部署在 Bluemix 上的其他应用重复，因为默认情况下这个&lt;app_name&gt;会和 domain 组成应用的访问连接，即：&lt;app_name&gt;.ng.bluemix.net，每一个应用的访问连接应该是唯一的，如果不是唯一，部署的过程中会报错提醒，我们只要换一个不一样的名字即可；第二，cf push 命令默认会将当前目录下的所有内容 push 到云端，除非我们显示的使用 Cp 参数显示的指定要部署的内容；第三，从上面的输出中可以看到，应用的访问路径是“urls: hellomongodw.ng.bluemix.net”，即“http:// hellomongodw.ng.bluemix.net”，这也是默认的 Bluemix 中应用的访问路径的统一格式“appname.domain”。<\/p><p><strong>绑定 MongoDB 服务到例子应用<\/strong><\/p><p>这个例子应用使用了 Mongo 数据库，在访问应用之前需要将 Mongo 数据库绑定到已经部署成功的应用中，在 Bluemix 中使用数据库也非常简单，无需安装，无需做任何配置，只需要简单的执行几条命令：<\/p><p>首先，创建一个 Mongo 数据的实例<\/p><h5 id=\"listing4\">清单 4. 创建 Mongo 数据库实例<\/h5><div class=\"codesection\"><pre class=\"displaycode\">USAGE:\n cf create-service SERVICE PLAN SERVICE_INSTANCE\n\nC:\\Users\\IBM_ADMIN&gt;cf create-service mongodb 100 mongo_demo\nCreating service mongo_demo in org xiuleizh@cn.ibm.com / space dev as xiuleizh@c\nn.ibm.com...\nOK<\/pre><\/div><p>如果想要得到某一种服务的 SERVICE PLAN，可以单独运行“cf marketplace”进行查看，当然，也可以查看每个服务的说明文档，这些信息都会在服务提供者提供的使用文档里进行说明。<\/p><p>其次，当创建好数据库实例后，需要运行一个绑定的命令将数据库实例和应用程序进行绑定，比如上面创建的 Mongo 数据库实例 mongo_demo，使用如下命令进行绑定<\/p><h5 id=\"listing5\">清单 5. 绑定 Mongo 数据库和应用程序<\/h5><div class=\"codesection\"><pre class=\"displaycode\">USAGE:\n cf bind-service APP SERVICE_INSTANCE\n\nC:\\Users\\IBM_ADMIN&gt;cf bind-service HelloMongoDW mongo_demo\nBinding service mongo_demo to app HelloMongoDW in org xiuleizh@cn.ibm.com / spac\ne dev as xiuleizh@cn.ibm.com...\nOK\nTIP: Use 'cf push' to ensure your env variable changes take effect<\/pre><\/div><p>当执行完绑定命令后，有的时候我们需要重新运行“cf push”使得数据库的绑定操作生效，操作很简单，仅仅是把之前部署应用的命令重新执行一遍，即：<\/p><h5 id=\"listing6\">清单 6. 重新部署应用<\/h5><div class=\"codesection\"><pre class=\"displaycode\">C:\\Users\\IBM_ADMIN&gt;cf push HelloMongoDW -p C:\\A_Workspace\\apps\\HelloWithMongo.war\n\nUpdating app HelloMongoDW in org xiuleizh@cn.ibm.com / space dev as xiuleizh@cn.\nibm.com...\nOK\n\nUploading HelloMongoDW...\nUploading from: C:\\A_Workspace\\apps\\HelloWithMongo.war\n53.4K, 14 files\nOK\n\nStopping app HelloMongoDW in org xiuleizh@cn.ibm.com / space dev as xiuleizh@cn.\nibm.com...\nOK\n\nStarting app HelloMongoDW in org xiuleizh@cn.ibm.com / space dev as xiuleizh@cn.\nibm.com...\n-----&gt; Downloaded app package (484K)\n-----&gt; Downloaded app buildpack cache (4.0K)\nOK\n\n\nBuildpack Version: 20140527-0132\n-----&gt; Downloading IBM 1.7.0 JRE from http://file.icap.cdl.ibm.com/icapShared/jr\ne/ibm-java-jre-7.0-6.0-linux-x86_64-small-footprint-uncompressed-jar-20140116.ta\nr.gz (0.0s)\n Expanding JRE to .java (1.1s)\nDownloading from output/wlp/com.ibm.ws.liberty-2014.4.0.0-201405270132.tar.gz ..\n. (0.0s).\nInstalling archive ... (0.6s).\nDownloading from output/wlp/com.ibm.ws.liberty.ext-2014.4.0.0-201405270132.tar.g\nz ... (0.0s).\nInstalling archive ... (0.3s).\n-----&gt; Installing client jar(s) from output/serviceClient/mongo-2.10.1.jar (0.0s\n)\n-----&gt; Uploading droplet (119M)\n\n0 of 1 instances running, 1 starting\n0 of 1 instances running, 1 starting\n1 of 1 instances running\n\nApp started\n\nShowing health and status for app HelloMongoDW in org xiuleizh@cn.ibm.com / spac\ne dev as xiuleizh@cn.ibm.com...\nOK\n\nrequested state: started\ninstances: 0/1\nusage: 1G x 1 instances\nurls: hellomongodw.ng.bluemix.net\n\n state since cpu memory disk\n#0 running 2014-06-01 06:35:01 PM 0.7% 331.2M of 1G 212.9M of 1G<\/pre><\/div><p>对比第一次部署应用到 Bluemix 的输出，最明显的变化是多了一些关于 Mongo 数据库的输出，在重新部署的时候，Bluemix 自动安装了 Mongo 数据库的驱动程序，这样应用就可以正常运行了。<\/p><p>在浏览器中输入“http://hellomongodw.ng.bluemix.net”，将会看成如下页面：<\/p><h5 id=\"img004\">图 4. 访问应用主页<\/h5><img alt=\"图 4. 访问应用主页\" src=\"/sunshine_new/images/负1736471717/img004.png\" width=\"581\" /><p>读者可以可以看到有两个连接，点击第一个连接，程序会首先向 Mongo 数据库中插入几条数据，然后将这几条数据检索出来，并在页面进行展现，点击 MongoServlet，应用成功返回如下页面，则说明应用成功运行了。<\/p><h5 id=\"img005\">图 5. 操作 Mongo 数据库<\/h5><img alt=\"图 5. 操作 Mongo 数据库\" src=\"/sunshine_new/images/负1736471717/img005.png\" width=\"356\" /><p>点击第二个连接，程序会打印出环境变量的相关信息，从中，读者可以查看有关 Mongo 数据的连接信息，如下图：<\/p><h5 id=\"img006\">图 6. 打印环境变量<\/h5><img alt=\"图 6. 打印环境变量\" src=\"/sunshine_new/images/负1736471717/img006.png\" width=\"582\" /><p>到这里我们已经成功的在 Bluemix 上部署并运行了一个示例应用，接下来再介绍几个常用的和应用程序相关的命令：<\/p><p><strong>清单 7. 其他常用命令<\/strong><\/p><p>1. 停止，启动以及重启应用<\/p><p>停止：<\/p><div class=\"codesection\"><pre class=\"displaycode\">USAGE:\n cf stop APP\n\nC:\\Users\\IBM_ADMIN&gt;cf stop HelloMongoDW\nStopping app HelloMongoDW in org xiuleizh@cn.ibm.com / space dev as xiuleizh@cn.\nibm.com...\nOK<\/pre><\/div><p>启动：<\/p><div class=\"codesection\"><pre class=\"displaycode\">USAGE:\n cf start APP\n\nC:\\Users\\IBM_ADMIN&gt;cf start HelloMongoDW\nStarting app HelloMongoDW in org xiuleizh@cn.ibm.com / space dev as xiuleizh@cn.\nibm.com...\nOK\n\n0 of 1 instances running, 1 starting\n0 of 1 instances running, 1 starting\n1 of 1 instances running\n\nApp started\n\nShowing health and status for app HelloMongoDW in org xiuleizh@cn.ibm.com / spac\ne dev as xiuleizh@cn.ibm.com...\nOK\n\nrequested state: started\ninstances: 1/1\nusage: 1G x 1 instances\nurls: hellomongodw.ng.bluemix.net\n\n state since cpu memory disk\n#0 running 2014-06-01 09:28:56 PM 0.6% 338.5M of 1G 212.9M of 1G<\/pre><\/div><p>重启：<\/p><div class=\"codesection\"><pre class=\"displaycode\">USAGE:\n cf restart APP\n\nC:\\Users\\IBM_ADMIN&gt;cf restart HelloMongoDW\nStopping app HelloMongoDW in org xiuleizh@cn.ibm.com / space dev as xiuleizh@cn.\nibm.com...\nOK\n\nStarting app HelloMongoDW in org xiuleizh@cn.ibm.com / space dev as xiuleizh@cn.\nibm.com...\nOK\n\n0 of 1 instances running, 1 starting\n0 of 1 instances running, 1 starting\n0 of 1 instances running, 1 starting\n1 of 1 instances running\n\nApp started\n\nShowing health and status for app HelloMongoDW in org xiuleizh@cn.ibm.com / spac\ne dev as xiuleizh@cn.ibm.com...\nOK\n\nrequested state: started\ninstances: 1/1\nusage: 1G x 1 instances\nurls: hellomongodw.ng.bluemix.net\n\n state since cpu memory disk\n#0 running 2014-06-01 09:34:03 PM 0.7% 334.8M of 1G 212.9M of 1G<\/pre><\/div><p>2. 解绑定，删除服务实例<\/p><p>解绑定：<\/p><div class=\"codesection\"><pre class=\"displaycode\">USAGE:\n cf unbind-service APP SERVICE_INSTANCE\n\nC:\\Users\\IBM_ADMIN&gt;cf unbind-service HelloMongoDW mongo_demo\nUnbinding app HelloMongoDW from service mongo_demo in org xiuleizh@cn.ibm.com /\nspace dev as xiuleizh@cn.ibm.com...\nOK<\/pre><\/div><p>删除：<\/p><div class=\"codesection\"><pre class=\"displaycode\">USAGE:\n cf delete-service SERVICE_INSTANCE [-f]\n\nOPTIONS:\n -f Force deletion without confirmation\n\nC:\\Users\\IBM_ADMIN&gt;cf delete-service mongo_demo\n\nAre you sure you want to delete the service mongo_demo ? y\nDeleting service mongo_demo in org xiuleizh@cn.ibm.com / space dev as xiuleizh@c\nn.ibm.com...\nOK<\/pre><\/div><p>3. 查看应用日志<\/p><div class=\"codesection\"><pre class=\"displaycode\">USAGE:\n cf logs APP\n\nOPTIONS:\n --recent Dump recent logs instead of tailing<\/pre><\/div><p>4. 删除应用<\/p><div class=\"codesection\"><pre class=\"displaycode\">USAGE:\n cf delete APP [-f]\n\nOPTIONS:\n -f Force deletion without confirmation\n\nC:\\Users\\IBM_ADMIN&gt;cf delete HelloMongoDW\n\nReally delete HelloMongoDW?&gt; y\nDeleting app HelloMongoDW in org xiuleizh@cn.ibm.com / space dev as xiuleizh@cn.\nibm.com...\nOK<\/pre><\/div><p><strong>巧用 Manifest.yml 文件<\/strong><\/p><p>当我们使用“cf push”命令部署应用的时候，这个命令有可能会变的非常冗长，在清单 3 中我们给出了其用法，这条命令有很多的参数可以选择，只要我们设置好相应的参数，就可以在一条命令里执行多个操作，例如：<\/p><p>cf push appName Cp myapp.war Cb https://github.com/ryanjbaxter/mybuildpack -i 5 Cm 512M --no-start<\/p><p>在上述命令中，除了部署应用外，我们还额外指定了应用要使用的 Buildpack，以及应用实例的数量，分配的内存大小以及部署后是否选择启动，在开发调试的时候，每次都输入这么长的命令会显的很麻烦，为了解决这个问题，我们可以使用 manifest.yml 文件，如下是一个示例：<\/p><h5 id=\"listing8\">清单 8. Manifest 示例<\/h5><div class=\"codesection\"><pre class=\"displaycode\">applications:\n\n- name: appName\npath: HelloWorldDW.war\n memory: 512M\n instances: 5 \n buildpack: https://github.com/ryanjbaxter/mybuildpack\nservices:\n - todo-mongo-db<\/pre><\/div><p>在如上示例中，我们定义了一些在部署应用的时候应该做的操作，当我们需要部署的时候，只需简单的在命令行里运行“cf push”即可，不再需要在后面跟很多的参数，需要注意的是：第一，当运行完“cf push”后，命令行会默认加载当前路径下的 manifest.yml，如果当前路径下没有 manifest.yml 文件，需要在“cf push”后加“-f”参数，指向一个全路径。<\/p><h3 id=\"major9\">通过 Bluemix 控制台管理应用<\/h3><p>命令行工具为程序员提供了很多命令来完成各种工作，同时，Bluemix 也提供了一个基于浏览器的 UI 界面，结合使用，会更高的提供应用程序的开发效率，在 UI 上同样也提供了一些更加丰富的功能。要使用 UI 进行应用管理，首先我们需要先部署一个应用到 Bluemix，继续之前，请读者自行完成上节中的清单 1，清单 2 以及清单 3。<\/p><p>Bluemix UI 的访问连接是：https://ace.ng.bluemix.net，输入注册的 Bluemix 账号进行登录，登陆后点击仪表盘（DASHBOARD）并在右上角选择要进入的 Organization 和 Space，如下图：<\/p><h5 id=\"img007\">图 7. 登录 Bluemix UI<\/h5><img alt=\"图 7. 登录 Bluemix UI\" src=\"/sunshine_new/images/负1736471717/img008.png\" width=\"581\" /><p>如果您已经完成了清单 1 到清单 3 就会在 Applications 旁边看到一个已经部署好的应用，应用的名字是 HelloMongoDW，单击这个应用，进入应用的管理界面：<\/p><h5 id=\"img008\">图 8. 应用管理界面<\/h5><img alt=\"图 8. 应用管理界面\" src=\"/sunshine_new/images/负1736471717/img008.png\" width=\"581\" /><p>在这个界面里向程序员展示了一些关于应用的基本信息，并提供了一些关于应用的操作链接。在这里我们单击 ADD A SERVICE 为示例程序绑定一个 Mongo 数据库：<\/p><h5 id=\"img009\">图 9. 创建 Mongo 数据库<\/h5><img alt=\"图 9. 创建 Mongo 数据库\" src=\"/sunshine_new/images/负1736471717/img009.png\" width=\"578\" /><p>当点击 CREATE 后，UI 会提示是否要重启应用，来使得数据库的操作生效，点击 OK，UI 会自动重启应用。应用重启后，会在应用管理界面看到一个新的 Mongo 示例，显示 Mongo 被成功的绑定了。<\/p><h5 id=\"img010\">图 10. 成功绑定 Mongo 数据库<\/h5><img alt=\"图 10. 成功绑定 Mongo 数据库\" src=\"/sunshine_new/images/负1736471717/img010.png\" width=\"581\" /><p>点击上面的 Routes 连接，我们就可以访问应用了，整个过程只需要点击几个按钮，就完成了应用的部署和服务的绑定。接下来我们再介绍几个 UI 里常用的功能：<\/p><p>点击上图中的 Liberty，进入运行时管理页面：<\/p><h5 id=\"img011\">图 11. 运行时管理页面<\/h5><img alt=\"图 11. 运行时管理页面\" src=\"/sunshine_new/images/负1736471717/img011.png\" width=\"582\" /><p>在这个页面里，我们可以：1，查看关于程序和运行时的基本信息；2，修改程序运行实例的数量以及分配内存的大小。3，点击左侧的 Files and Logs 可以查看应用的日志输出，如下图：<\/p><h5 id=\"img012\">图 12. 查看应用日志输出<\/h5><img alt=\"图 12. 查看应用日志输出\" src=\"/sunshine_new/images/负1736471717/img012.png\" width=\"581\" /><p>同时，我们还可以点击 CATALOG 去查看 Bluemix 提供的运行时和服务的详细列表和使用说明，如下图：<\/p><h5 id=\"img013\">图 13. Bluemix 功能一览<\/h5><img alt=\"图 13. Bluemix 功能一览\" src=\"/sunshine_new/images/负1736471717/img013.png\" width=\"581\" /><p>点击 DOCS 可以查看 Bluemix 的所有文档，点击 COMMUNITY，进入 Bluemix 的开发者社区，在使用 Bluemix 的过程中碰到的任何疑问都能在这里找到合适的答案。在这里我们就不再一一介绍，有兴趣的读者可以自行研读，并做一些实际的操作。<\/p><h3 id=\"major10\">安装 Eclipse 插件开发和部署应用<\/h3><p>一个应用从无到有需要借助开发工具来完成应用的开发，大多数 Java 程序员的选择都是 Eclipse，Bluemix 同样提供了丰富的插件来帮助程序员使用 Eclipse 与 Bluemix 进行联合开发，装上了 Bluemix 插件的 Eclipse 可以连接到 Bluemix 平台上，在 Eclipse 里只需一个简单的拖拽动作就能将应用快速的部署到 Bluemix 上，同时插件还提供了完成的应用生命周期的管理功能。在 Eclipse Marketplace 中搜索 Bluemix 并安装插件到 Eclipse 中就能方便的使用这些功能：<\/p><h5 id=\"img014\">图 14. 使用 Eclipse 插件开发 Bluemix 应用<\/h5><img alt=\"图 14. 使用 Eclipse 插件开发 Bluemix 应用\" src=\"/sunshine_new/images/负1736471717/img014.png\" width=\"582\" /><p>除了可以进行应用开发外，Bluemix 还提供了一种称为 Dev Ops 的服务，通过该服务，可以实现应用的持续集成，敏捷开发，除了这些，Dev Ops 还提供了一个基于 Web 页面的 IDE，程序员只需要打开浏览器就能进行应用程序的开发，并将开发完成的应用一键部署到云端，这些对于开发人员来说都是非常高效有用的工具。详细的使用方法都可以在参考资源里找到。<\/p><h2 id=\"major11\">总结<\/h2><p>Bluemix 给程序员带来的便利还有很多，在这里我们只能窥见一斑，不能做到事事巨细，希望通过本文的介绍让更多的程序员了解平台云带给 IT 的变化。云计算已经正在改变着人们的生活方式，作为程序员的我们，也同样在经历着这些变化，一种新的工具或者平台的出现，必定有其存在的理由，更要有其适合发展的土壤，IBM Bluemix 就是这样一个平台，虽然目前提供的功能还不是特别完善，但是随着云计算的不断发展，Bluemix 也将会不断演进，不断的提供更多的功能来服务程序员，并引领云计算带给 IT 的变化。<\/p><CMA ID: 975709><Site ID: 10><XSLT stylesheet used to transform this file: dw-document-html-7.0.xsl>\r\n\r\n\r\n<\/div>\r\n<\/div>\r\n","createTime":"2014-06-26 00:00:00","deployTime":"2014-06-26 00:00:00","id":0,"intro":"云计算在近年来不断发展，并越来越多的转化成实际的产品被企业级的客户接受并采纳，特别是云计算中的“平台即服务”（简称 PaaS）已经在云计算的发展浪潮中逐步站稳脚跟，Pivotal Cloud Foundry 的异军突起，逐步建立了 PaaS 在云计算的地位，使得平台公有云发展迅猛. 正是基于这样的趋势，IBM 发布了自己的公有云产品，产品名称是 IBM Bluemix，目前正处在公开测试阶段。Bluemix 建立在 Apache 开源项目 Cloud Foundry 之上，并提供了 IBM 及其合作伙伴开发的高质量的服务（Services）供 IT 从业人员使用。本文以 Bluemix 平台的核心组件 - Bluemix Java 运行时为主线，来向读者介绍 IBM 公有云产品 Bluemix，和读者一起去领略平台云给 IT 带来的变化。","keyword":"","recommend":false,"source":"http://www.ibm.com/developerworks/cn/websphere/library/techarticles/1406_zhuxl_bluemix/1406_zhuxl_bluemix.html","title":"初探 IBM Bluemix","typeId":0,"updateTime":"2014-06-26 00:00:00"}
{"author":"","clickNumber":0,"content":"\r\n<div class=\"ibm-columns\">\r\n<div class=\"ibm-col-1-1\">\r\n\r\n<h2 id=\"1.Introduction|outline\">简介<\/h2><p>IBM PureApplication System（W1500 和 W1700 v1.0 及\n                v1.1）是一个盒装云计算系统，配有用来在云中部署和执行工作负载的硬件和软件，拥有将私有云环境添加到企业数据中心所需的一切功能。本文将概述\n                PureApplication System 中包含的硬件，并使用系统控制台来查看各个组件。<\/p><p>本文是由三篇文章组成的文章系列的第 1 部分，该文章系列将介绍 PureApplication System\n                为了托管应用程序运行时环境而提供的硬件和软件基础：<\/p><ul class=\"ibm-bullet-list\"><li><strong>硬件<\/strong>：您正在阅读的这篇文章介绍了组成 PureApplication System 的硬件。<\/li><li><strong>虚拟化硬件<\/strong>：<a href=\"http://www.ibm.com/developerworks/cn/cloud/library/cl-aim1301-bestpractices-iaas-pureapp/\">在 IBM PureApplication System 中使用基础架构即服务的最佳实践<\/a> 会向您介绍\n                    PureApplication System 如何虚拟化其硬件，从而实现基础架构即服务 (IaaS)。<\/li><li><strong>运行时环境<\/strong>：<a href=\"http://www.ibm.com/developerworks/cn/websphere/library/techarticles/1210_woolf/1210_woolf.html\">在 IBM PureApplication System 中管理应用程序运行时环境<\/a> 介绍了 PureApplication\n                    System 中的虚拟化硬件如何用于实现工作负载所部属到的应用程序运行时环境。<\/li><\/ul><p>每篇文章都以前一篇文章为基础，以便全面地解释这一基础知识。<\/p><h2 id=\"2.ClassesofPureApplicationSystem|outline\">PureApplication System 的类型<\/h2><p>PureApplication System 目前有四种类型：<\/p><ul class=\"ibm-bullet-list\"><li><strong>W1500 Small Rack<\/strong>：矮机架 W1500，配备 32、64、96 或者 128 个\n                    Intel&#174; CPU 核心。<\/li><li><strong>W1500 Large Rack<\/strong>：高机架 W1500，配备\n                    64、96、128、160、192、224、384 或者 608 个 Intel CPU 核心。<\/li><li><strong>W1700 Small Rack<\/strong>：矮机架 W1700，配备 32、64、96 或者 128 个\n                    Power&#174; CPU 核心。<\/li><li><strong>W1700 Large Rack<\/strong>：高机架 W1700，配备\n                    64、96、128、160、192、224、384 或者 608 个 Power CPU 核心。<\/li><\/ul><p>表 1 显示了这些硬件类型的快速比较。表 1 中的管理节点缩写如下面所示（请参阅 <a href=\"#management_nodes\">管理节点<\/a> 部分，了解有关的详细信息）：<\/p><ul class=\"ibm-bullet-list\"><li><strong>PSM<\/strong>：PureSystems Manager<\/li><li><strong>VSM<\/strong>：Virtualization System Manager<\/li><li><strong>FSM<\/strong>：PureFlex System Manager<\/li><\/ul><h5 id=\"N1009D\">表 1. PureApplication System 硬件分类<\/h5><table border=\"0\" cellpadding=\"0\" cellspacing=\"0\" class=\"ibm-data-table\" summary=\"Table using a heading tag for the caption, all columns left-aligned, 4 columns with 3 column headings showing PureApplication System classes hardware\"><thead xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"><tr><th/><th>W1500 小机架<\/th><th>W1700 小机架<\/th><th>W1500 大机架<\/th><th>W1700 大机架<\/th><\/tr><\/thead><tbody xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"><tr><td style=\"text-align:left; vertical-align:top\"><strong>机架<\/strong><\/td><td>25U - 1.3 M 19\"<\/td><td>25U - 1.3 M 19\"<\/td><td>42U - 2.0 M 19\"<\/td><td>42U - 2.0 M 19\"<\/td><\/tr><tr><td style=\"text-align:left; vertical-align:top\"><strong>节点机箱<\/strong><\/td><td>1 个 Flex 机箱<\/td><td>1 个 Flex 机箱<\/td><td>3 个 Flex 机箱<\/td><td>3 个 Flex 机箱<\/td><\/tr><tr><td style=\"text-align:left; vertical-align:top\"><strong>处理器<\/strong><\/td><td>Intel Xeon E5-2670 8 核<\/td><td>POWER7+ 8 核<\/td><td>Intel Xeon E5-2670 8 核<\/td><td>POWER7+ 8 核<\/td><\/tr><tr><td style=\"text-align:left; vertical-align:top\"><strong>计算节点<\/strong><\/td><td>2、4、6 或者 8<\/td><td>2、3 或者 4<\/td><td>4、6、8、10、12、14、24 或者 38<\/td><td>2、3、4、5、6、7、12 或者 19<\/td><\/tr><tr><td style=\"text-align:left; vertical-align:top\"><strong>CPU\n                                核心<\/strong><\/td><td>32、64、96 或者 128<\/td><td>32、64、96 或者 128<\/td><td>64、96、128、160、192、224、384 或者 608<\/td><td>64、96、128、160、192、224、384 或者 608<\/td><\/tr><tr><td style=\"text-align:left; vertical-align:top\"><strong>内存<\/strong><\/td><td>0.5、1.0、1.5 或者 2.0 TB RAM<\/td><td>0.5、1.0、1.5 或者 2.0 TB RAM<\/td><td>1.0、1.5、2.0、2.5、3.0、3.5、6.0 或者 9.5 TB RAM<\/td><td>1.0、1.5、2.0、2.5、3.0、3.5、6.0 或者 9.5 TB RAM<\/td><\/tr><tr><td style=\"text-align:left; vertical-align:top\"><strong>存储节点<\/strong><\/td><td>1 个 V7000 控制器<br />1 个 V7000 扩展<\/td><td>1 个 V7000 控制器<br />1 个 V7000 扩展<\/td><td>2 个 V7000 控制器<br />2 个 V7000 扩展<\/td><td>2 个 V7000 控制器<br />2 个 V7000 扩展<\/td><\/tr><tr><td style=\"text-align:left; vertical-align:top\"><strong>存储驱动器<\/strong><\/td><td>6 个 400 GB SSD<br />40 个 600 GB HDD<\/td><td>6 个 400 GB SSD<br />40 个 600 GB HDD<\/td><td>16 个 400 GB SSD<br />80 个 600 GB HDD<\/td><td>16 个 400 GB SSD<br />80 个 600 GB HDD<\/td><\/tr><tr><td style=\"text-align:left; vertical-align:top\"><strong>存储容量<\/strong><\/td><td>2.4 TB SSD<br />24.0 TB HDD<\/td><td>2.4 TB SSD<br />24.0 TB HDD<\/td><td>6.4 TB SSD<br />48.0 TB HDD<\/td><td>6.4 TB SSD<br />48.0 TB HDD<\/td><\/tr><tr><td style=\"text-align:left; vertical-align:top\"><strong>管理节点<\/strong><\/td><td>2 个 PSM<br />2 个 VSM<\/td><td>2 个 PSM<br />2 个 FSM<\/td><td>2 个 PSM<br />2 个 VSM<\/td><td>2 个 PSM<br />2 个 FSM<\/td><\/tr><tr><td style=\"text-align:left; vertical-align:top\"><strong>网络<\/strong><\/td><td colspan=\"4\" style=\"text-align:center; vertical-align:top\">2 个\n                            IBM RackSwitch 64 端口 10 Gb 以太网交换机<\/td><\/tr><tr><td style=\"text-align:left; vertical-align:top\"><strong>电源<\/strong><\/td><td colspan=\"4\" style=\"text-align:center; vertical-align:top\">4 个\n                            配电单元 (PDU)<\/td><\/tr><\/tbody><\/table><p>每个型号在其类型内都是可升级的，最大可分别升级至 W1500-128、W1700-128、W1500-608 和\n                W1700-608。无需断电即可执行升级。<\/p><h2 id=\"3.PureApplicationSystemhardwarecapabilities|outline\">系统硬件<\/h2><p>让我们首先来探讨一下整个 PureApplication System 机架中适用于每个系统类型的硬件。<\/p><h3 id=\"4.Rackinfrastructure|outline\">基础架构图<\/h3><p>您可以在集成控制台中查看特定 PureApplication System 中的硬件实时视图。为此，请打开 Infrastructure Map。选择\n                    <strong>System Console &gt; Hardware &gt; Infrastructure\n                Map<\/strong>，如图 1 所示。要访问 Hardware 菜单，需要为用户授予 Hardware administration 角色，如\n                    <a href=\"http://www.ibm.com/developerworks/websphere/library/techarticles/1211_woolf/1211_woolf.html\">Managing administrative access in IBM PureApplication System<\/a>\n                中所述。<\/p><h5 id=\"fig1\">图 1. 系统硬件菜单<\/h5><img alt=\"系统硬件菜单\" src=\"/sunshine_new/images/533659640/images/figure1.jpg\" width=\"580\" /><p>Infrastructure Map 可视作一个交互式图片，如图 2 所示，并可作为组件的层级树状结构。如需了解更多信息，请查看\n                PureApplication System 信息中心的 <a href=\"http://pic.dhe.ibm.com/infocenter/psappsys/v1r1m0/topic/com.ibm.puresystems.appsys.1500.doc/systemconsole/t_infragraphic.html\">Viewing the hardware infrastructure<\/a> 主题。<\/p><h5 id=\"fig2\">图 2. W1500-96 Infrastructure Map -\n                    图形视图<\/h5><img alt=\"W1500-96 Infrastructure Map - 图形视图\" src=\"/sunshine_new/images/533659640/images/figure2.jpg\" width=\"580\" /><h3 id=\"N10192\">硬件基础架构<\/h3><p>与图 2 中所示的 Infrastructure Map 图形视图类似，图 3 演示了 W1500 Large Rack\n                系统机架中的硬件组件布局。<\/p><h5 id=\"fig3\">图 3. IBM PureApplication System\n                    W1500-608 硬件<\/h5><img alt=\"IBM PureApplication System W1500-608 硬件\" src=\"/sunshine_new/images/533659640/images/figure3.gif\" width=\"578\" /><p>如 Infrastructure Map 和图 3 中所示，W1500 Large Rack 系统是一个大机架（一个 42U 机柜，高 2.015\n                米，宽 644 毫米，纵深 1100 毫米，全负荷情况下总重 1088 千克），从上到下包含以下主要组件：<\/p><ul class=\"ibm-bullet-list\"><li><strong>位于顶部的机架交换机 (ToR)<\/strong>：这是一对 IBM System Networking\n                    RackSwitch&#8482; G8264 64 端口 10 Gb 以太网交换机。 <ul class=\"ibm-bullet-list\"><li>要查看这些信息，请转至 <strong>System Console<\/strong> &gt;\n                                <strong>Hardware<\/strong> &gt; <strong>Network\n                                Devices<\/strong>。网络设备页面还列出了各个机箱的网络和 SAN 交换机。<\/li><li>要查看网络配置的详细信息，请转至 <strong>System Console &gt; System &gt;\n                                Customer Network Configuration<\/strong>。<\/li><\/ul><\/li><li><strong>存储节点<\/strong>：这是一对 IBM Storwize&#174; V7000\n                    存储单元，每个单元都是一个控制器节点与一个扩展节点的配对，并与一个将两个单元作为单个 SAN 进行管理的控制器聚合。 <ul class=\"ibm-bullet-list\"><li>要想查看这些信息，请转至 <strong>System Console<\/strong> &gt;\n                                <strong>Hardware<\/strong> &gt; <strong>Storage\n                                Devices<\/strong>。<\/li><\/ul><\/li><li><strong>Flex 机箱<\/strong>：系统包含三个 IBM Flex System&#8482; Enterprise\n                    Chassis Type 7893 机箱，高度均为 10U（编号为 3、2 和 1，编号 1\n                    的机箱位于底部）。机箱相当于计算节点的扩展插口。将计算节点放入机箱就像将抽屉放入文件柜一样。在将节点插入到托架时，节点中的相应连接器和托架就会组合在一起。这一设计有助于在系统运行期间更换计算节点。 <ul class=\"ibm-bullet-list\"><li>要想查看这些信息，请转至 <strong>System Console &gt; Hardware &gt; Flex\n                                Chassis<\/strong>。<\/li><\/ul><\/li><li><strong>服务笔记本电脑<\/strong>：一台连接到系统的笔记本电脑被存放在机架中编号为 2 和 3 的机箱之间的一个 1U\n                    抽屉中。IBM 用它来管理系统。<\/li><li><strong>配电单元 (PDU)<\/strong>：机架包含四个\n                    PDU，分别插在外部电源上。这几个单元依次将电源分配到机箱的电源模块、交换机和存储节点。<\/li><\/ul><p>每个 Flex 机箱都包含几个组件：<\/p><ul class=\"ibm-bullet-list\"><li><strong>计算节点<\/strong>：每个机箱包含十四个计算节点托架，分七行两列排列。每个托架都支持一个 Intel\n                    计算节点。如果使用的是 W1700，那么两个并列的托架能够支持一个 Power 计算节点。参见 <a href=\"#fig4\">图\n                        4<\/a>。 <ul class=\"ibm-bullet-list\"><li>要查看系统的计算节点，请转至 <strong>System Console &gt; Hardware &gt;\n                                Compute Nodes<\/strong>。<\/li><\/ul><\/li><li><strong>管理节点<\/strong>：Chassis 1 和 Chassis 2 各使用两个托架来托管管理节点： <ul class=\"ibm-bullet-list\"><li><strong>Virtualization System Manager<\/strong>\n                                (<strong>VSM<\/strong>)：在节点托架 1 中托管，管理计算节点的虚拟机管理程序。如果使用的是\n                            W1700，那么该节点就是 PureFlex System Manager (FSM)。参阅 <a href=\"#fig4\">图 4<\/a> 和 <a href=\"#management_nodes\">管理节点<\/a> 一节。<\/li><li><strong>PureSystems Manager<\/strong>\n                            (<strong>PSM<\/strong>)：托管在节点托架 2 中，它托管了 IBM Workload Deployer\n                            (IWD)。<\/li><li>要查看系统的管理节点，请转至 <strong>System Console &gt; Hardware &gt;\n                                Management Nodes<\/strong>。<\/li><\/ul><\/li><li><strong>网络交换机<\/strong>：每个机箱包含一对 66 端口 IBM Flex System Fabric EN4093\n                    10Gb Scalable Switch 以太网交换机，用于连接它的计算节点。机箱交换机通过一个 40 Gbps 以太网主干（4 个 10\n                    GB 以太网电缆）连接到顶部机架交换机。<\/li><li><strong>SAN 交换机<\/strong>：每个机箱包含一对 48 端口的 IBM Flex System FC5022 16Gb\n                    SAN Scalable Switch 光纤通道交换机，用于将其计算节点连接到系统的共享存储。 <ul class=\"ibm-bullet-list\"><li>要查看机箱的网络和 SAN 交换机，请转至 <strong>System Console &gt; Hardware\n                                &gt; Network Devices<\/strong>。<\/li><\/ul><\/li><li><strong>电源模块<\/strong>：每个机箱包含 6 个电源，每侧 3\n                    个。电源是冗余提供的，所以即使一个电源模块失效，也能保持机箱及其计算节点继续工作。<\/li><li><strong>继续冷却设备<\/strong>：这些设备是 10 个用于控制硬件温度的风扇。<\/li><\/ul><h3 id=\"N1022A\">Power 型号<\/h3><p>W1700 Large Rack 中的硬件与对应的 W1500 类型机箱中的硬件非常相似。图 4 显示了 W1700 Large Rack\n                系统机架中的硬件组件布局。<\/p><h5 id=\"fig4\">图 4. IBM PureApplication System\n                    W1700-608 硬件<\/h5><img alt=\"IBM PureApplication System W1700-608 硬件\" src=\"/sunshine_new/images/533659640/images/figure4.gif\" width=\"578\" /><p>这个硬件与 W1500 Large Rack 中的硬件非常相似，主要区别是 W1700 包含 Power 计算节点，而不是 Intel 计算节点。与\n                Intel 计算节点相比，Power\n                计算节点包含两倍多的核心以及两倍多的内存。放置该硬件的盒子是两倍宽，所以它占用机箱中的两个水平托架，这样每个机箱会支持一半的 Power\n                计算节点。除了计算节点外，存储和网络也是相同的。<\/p><p>另一个区别是，虚拟化管理节点是 PureFlex System Manager (FSM)，而不是 Virtualization System\n                Manager (VSM)。请参阅 <a href=\"#management_nodes\">管理节点<\/a> 一节。<\/p><h3 id=\"N10243\">较小的机架<\/h3><p>W1500 Small Rack 中的这个硬件是 W1500 Large Rack 中的硬件的一个子集。图 5 显示了 W1500 Small\n                Rack 系统机架中的硬件组件布局。<\/p><h5 id=\"fig5\">图 5. IBM PureApplication System W1500-64\n                    硬件<\/h5><img alt=\"IBM PureApplication System W1500-64 硬件\" src=\"/sunshine_new/images/533659640/images/figure5.gif\" width=\"567\" /><p>如图 5 所示，W1500 Small Rack 是一个小机架（25U 机柜，高 1.267 米，宽 605 毫米，纵深 997\n                毫米，全负荷状态下重量为 385 千克），包含与较大的同类机架相同的主要组件类型：<\/p><ul class=\"ibm-bullet-list\"><li>2 个顶部机架交换机<\/li><li>1 个服务笔记本电脑<\/li><li>4 个电源模块<\/li><li>1 个存储单元（一个控制器/扩展对）<\/li><li>1 个 Flex 机箱： <ul class=\"ibm-bullet-list\"><li>4 个管理节点<\/li><li>多达 10 个计算节点的托架<\/li><\/ul><\/li><\/ul><p>这个硬件与 W1500 Large Rack 中的硬件非常相似，但略有不同：<\/p><ul class=\"ibm-bullet-list\"><li>较矮，略窄于机柜（25U 而不是 42U）<\/li><li>1 个机箱，而不是三个<\/li><li>最多 10 个计算节点<\/li><li>1 个存储单元，而不是两个<\/li><li>4 个电源模块，水平堆放在存储和服务笔记本之间<\/li><\/ul><p>所有 W1500 中的计算节点都是相同的，并且存储和联网的方式也是相同的。<\/p><p>W1700 Small Rack 中的硬件（即 Power 小机架）与 W1500 Small Rack 中的硬件（即 Intel\n                小机架）非常类似。主要区别是不包含 Intel 计算节点，单个机箱的空间可存放最多 5 个 Power 计算节点。<\/p><h3 id=\"5.Hardwareresiliency|outline\">硬件弹性<\/h3><p>系统硬件的基本主题就是，为了实现弹性，各个节点往往是冗余的，以避免出现单点故障。系统不仅包含多个计算节点，还包含两对管理节点、两个系统网络交换机、两个存储单元，以及四个\n                PDU。Large Rack 机箱系统包含三个 Flex 机箱。每个机箱包含一对网络交换机、一对 SAN 交换机和六个电源。计算节点中的网络和\n                SAN 适配器有多个端口，用于增加带宽和弹性。<\/p><p>硬件还将系统的管理和用户工作负载隔离开。管理节点 - PureSystems&#8482; Manager 和 Virtualization\n                System Manager 或 PureFlex&#8482; System Manager -\n                都托管在其自身的计算节点中。这会将它们和用户工作负载隔离开，这样，系统管理功能就可以在自己的专用硬件中运行。这样做还消除了标准计算节点的大多数管理开销，使其资源可以专供用户工作负载使用。如果出现故障，有两对管理节点应对故障，其中一对处于待命状态，是另一对的备用。<\/p><h2 id=\"N10284\">系统组件<\/h2><p>让我们更详细地探讨一下各个硬件组件。<\/p><h3 id=\"6.W1500computenodes|outline\">W1500\n                计算节点<\/h3><p>计算节点通常也称为集成技术元素 (ITE)，有时也被称为 “刀片”，专指那些尚未被专门化为管理节点的节点，计算节点是非常小巧的计算机。W1500\n                系统包含许多 Intel 计算节点，特别是 IBM Flex System x240 计算节点，这些节点各自包含以下组件：<\/p><ul class=\"ibm-bullet-list\"><li><strong>CPU<\/strong>：一个 Intel 计算节点包含一个双处理器、16 核芯片组。这些芯片是两个 8 核 2.6 GHz\n                    Intel&#174; Xeon&#174; E5-2670 115W 处理器，一共有 16 个物理核心，虚拟机管理程序将其用作 32\n                    个逻辑核心（也就是说，虚拟机管理程序能够在这 16 个核心中运行 32 个并发线程）。在这 32 个逻辑核心中，28\n                    个核心可供用户工作负载使用。<\/li><li><strong>内存<\/strong>：一个 Intel 计算节点包含 256&#160;GB 的 RAM：8 2x16 GB、1333\n                    MHz、DDR3、LP RDIMMS (1.35 V)。<\/li><li><strong>存储<\/strong>：计算节点的 SAN 接口卡是一个 IBM Flex System FC3172 2-port 8\n                    GB FC Adapter 光纤通道适配器。节点还包含两个 250 GB 2.5\n                    英寸的硬盘驱动器，它们往往不被系统采用，常被忽略。<\/li><li><strong>网络<\/strong>：计算节点的网络接口卡是一个 4 端口的 IBM Flex System CN4054 10 GB\n                    Virtual Fabric Adapter 以太网适配器。<\/li><li><strong>外壳<\/strong>：Intel\n                    计算节点的外壳只有一半的宽度，这意味着每个计算节点能够放置到单个机箱托架上，而且两个计算节点能够能够并排放置在相邻的托架上（参见 <a href=\"#fig3\">图 3<\/a> 和 <a href=\"#fig5\">图 5<\/a>）。<\/li><\/ul><p>图 6 说明了计算节点中的这些组件。<\/p><h5 id=\"fig6\">图 6. 计算节点组件<\/h5><img alt=\"计算节点组件\" src=\"/sunshine_new/images/533659640/images/figure6.jpg\" width=\"479\" /><h3 id=\"7.W1700computenodes|outline\">W1700\n                计算节点<\/h3><p>W1700 系统包含许多 Power 计算节点，特别是 IBM Flex System p460 计算节点，它包含以下组件：<\/p><ul class=\"ibm-bullet-list\"><li><strong>CPU<\/strong>：Power 计算节点包含一个四核处理器，32 核芯片组。这些芯片是四个 8 核 3.61 GHz\n                    POWER7+ 处理器，一共有 32 个物理核心，虚拟机管理程序将它们用作 128 个逻辑核心（也就是说，128 个并发线程）。在这 128\n                    个逻辑核心中，116 个核心课用于用户工作负载。<\/li><li><strong>内存<\/strong>：Power 计算节点包含 512&#160;GB 的 RAM：16 2x16 GB、1066\n                    MHz、DDR3、LP RDIMMS (1.35 V)。<\/li><li><strong>存储<\/strong>：这和 Intel 计算节点中包含的适配器相同，但它包含两个适配器。计算节点的 SAN 接口卡是两个\n                    IBM Flex System FC3172 2-port 8 GB FC Adapter 光纤通道适配器。节点还包含两个 250 GB\n                    2.5 英寸的硬盘驱动器，它们往往不被系统采用，常被忽略。<\/li><li><strong>网络<\/strong>：这和 Intel 计算节点张包含的适配器类似，但它包含两个适配器。计算节点的网络接口卡是两个 IBM\n                    Flex System EN4054 4-port 10 GB 以太网适配器。<\/li><li><strong>外壳<\/strong>：Power 计算节点的外壳是全宽度，这意味着它是 Intel 计算节点的两倍宽。每个 Power\n                    计算节点占用一对水平放置的机箱托架（参见 <a href=\"#fig4\">图 4<\/a>）。<\/li><\/ul><p>与 W1500 计算节点相比，W1700 计算节点包含其两倍的核心和内存。由于在体积上也是两倍，所以机架支持一半的数量。<\/p><p>每个计算节点都可以访问所有计算节点共享的系统资源：存储和网络。<\/p><h3 id=\"8.Sharedresources|outline\">共享资源：存储<\/h3><p>PureApplication System 高机架提供 6.4 TB 的固态驱动器 (SSD) 存储，以及 48 TB 的硬盘驱动器 (HDD)\n                存储；其中，4.8 TB 和 43.2 TB 是可用的：<\/p><ul class=\"ibm-bullet-list\"><li>这个存储器被放置在由两个 IBM Storwize V7000\n                    存储单元组成的集群中。每个单元包含一个与扩展节点配对的控制器节点（也称为附件）。<\/li><li>每个节点包含两个节点容器，被配置为活动/备用容器。活动的容器控制了对节点存储的访问。<\/li><li>四个联合节点中的磁盘是 16 * 400 GB 2.5\" SSD 和 80 * 600 GB 2.5\" HDD。<\/li><li>控制器包括 IBM System Storage&#174; Easy Tier&#174; 存储管理系统软件。<\/li><li>存储被组织成独立磁盘冗余阵列 (RAID)，其中 5 个阵列用于冗余。每个存储单元包含 40 个 HDD 和 8 个 SSD。 <ul class=\"ibm-bullet-list\"><li>在 40 个 HDD 中，一个作为热备件预留，余下的 39 个硬盘被组织到三个由 13 个磁盘组成的阵列中，其中包括 12\n                            个数据段和 1 个奇偶校验段的条带。<\/li><li>8 个 SDD 是一个热备件，以及由 7 个磁盘组成的阵列，其中包括 6 个数据段和 1 个奇偶校验段的条带。<\/li><\/ul><\/li><li>计算节点通过 2 端口的 8 GB 光纤通道适配器访问作为 SAN 的存储器。<\/li><\/ul><h3 id=\"N10304\">共享资源：网络<\/h3><p>PureApplication System 的内部物理网络通过两个顶部机架交换机 (ToR)、两个 IBM System Networking\n                RackSwitch G8264 64 端口的以太网交换机来访问，其中交换机和外部网络之间的最大带宽为 320 Gbps。它们的配置显示在\n                Customer Network Configuration 页面上（请转至 <strong>System Console &gt; System\n                    &gt; Customer Network Configuration<\/strong>）。以下是端口的使用方法：<\/p><ul class=\"ibm-bullet-list\"><li>每个交换机上的端口 41-56（一共 16 个端口）用于连接数据中心网络： <ul class=\"ibm-bullet-list\"><li>每个端口都是 10/1 GB 以太网。内置的连接器类型是铜线，但是每个端口也可以和光纤连接器相连，或者直接接入连接\n                            (DAC)。<\/li><li>两个交换机中的各对端口应该是链路聚合的，以实现高可用性。<\/li><\/ul><\/li><li>端口 63（在任一交换机上）连接服务笔记本电脑，IBM 也用这个端口来引导和管理系统。<\/li><li>端口 64（链路聚合）是管理 LAN 端口。<\/li><li>系统交换机上的其他端口提供了用于应用程序和管理网络的三个机架的网络交换机之间的以太网连接，并相互连接两个 ToR 交换机。<\/li><\/ul><h3 id=\"management_nodes\">管理节点<\/h3><p>PureSystems Manager (PSM) 不仅托管了可以部署模式的 Workload\n                Deployer，还托管了系统的管理服务。这些服务可通过以下三个接口进行访问：<\/p><ul class=\"ibm-bullet-list\"><li><strong>控制台<\/strong>：集成控制台，一个 Web GUI。<\/li><li><strong>REST API<\/strong>：具象状态传输应用程序编程接口。<\/li><li><strong>CLI<\/strong>：命令行接口。<\/li><\/ul><p>这些接口通过其 IP 地址来访问 PSM，该地址是 Customer Network Configuration 页面上显示的浮动管理 IP\n                    地址（<strong>System Console &gt; System &gt; Customer Network\n                    Configuration<\/strong>）。在这个 IP 地址上打开 Web 浏览器将会打开系统的集成控制台。<\/p><p>虚拟化管理节点 - Virtualization System Manager（VSM，位于 W1500 上）和 PureFlex System\n                Manager（FSM，位于 W1700 上） - 管理虚拟机管理程序。W1500 和 W1700\n                上的虚拟机管理程序管理相同，但在这两种型号上的工作方式略有不同。两种型号的不同芯片组、Intel&#174; 与 Power\n                运行不同的虚拟机管理程序软件：VMware 与 PowerVM。VSM 和 FSM 运行相同的硬件，但分别运行不同的虚拟机管理程序管理软件\n                VMware vCenter 与 PowerVM。<\/p><p>表 2 总结了两种虚拟化管理节点类型中的区别。<\/p><h5 id=\"N10341\">表 2. 虚拟化管理节点对比<\/h5><table border=\"0\" cellpadding=\"0\" cellspacing=\"0\" class=\"ibm-data-table\" summary=\"3 column table with 2 column headings, table uses a heading tag for the caption, text in table shows virtualization management comparison\"><thead xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"><tr><th style=\"vertical-align:top\"/><th style=\"text-align:left; vertical-align:top\">W1500 Intel<\/th><th style=\"text-align:left; vertical-align:top\">W1700 Power<\/th><\/tr><\/thead><tbody xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"><tr><td style=\"text-align:left; vertical-align:top\">处理器<\/td><td style=\"text-align:left; vertical-align:top\">Intel Xeon<\/td><td style=\"text-align:left; vertical-align:top\">POWER7+<\/td><\/tr><tr><td style=\"text-align:left; vertical-align:top\">虚拟机管理程序软件<\/td><td style=\"text-align:left; vertical-align:top\">VMware vSphere\n                            Hypervisor (ESXi)<\/td><td style=\"text-align:left; vertical-align:top\">IBM PowerVM<\/td><\/tr><tr><td style=\"text-align:left; vertical-align:top\">虚拟化管理节点<\/td><td style=\"text-align:left; vertical-align:top\">Virtualization\n                            System Manager (VSM)<\/td><td style=\"text-align:left; vertical-align:top\">PureFlex System\n                            Manager (FSM)<\/td><\/tr><tr><td style=\"text-align:left; vertical-align:top\">虚拟机管理程序管理软件<\/td><td style=\"text-align:left; vertical-align:top\">VMware vCenter\n                            Server<\/td><td style=\"text-align:left; vertical-align:top\">PowerVM\n                            VMControl<\/td><\/tr><\/tbody><\/table><p>尽管存在这些差异，但是 PureSystems Manager (PSM) 在两种型号中使用该虚拟机管理程序管理软件的方式相同。<\/p><h3 id=\"N1037A\">Management LAN 端口<\/h3><p>管理 LAN 端口使管理员能够连接到 PureSystems Manager (PSM)，包括集成控制台。Customer Network\n                Configuration 页面指定了管理端口，该端口始终为顶部机架上的端口 64（链路聚合）。这个管理端口是客户管理网络的一员，在表 3\n                中列出。顶部机架交换机配置有 VLAN ID，用于 Aggregate Port 64 配置的 VLAN 域中的客户管理网络。<\/p><h5 id=\"N10387\">表 3. 客户管理网络<\/h5><table border=\"0\" cellpadding=\"0\" cellspacing=\"0\" class=\"ibm-data-table\" summary=\"3 column table with 2 column headings, table uses a heading tag for the caption, text in table shows Customer management network comparison\"><thead xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"><tr><th style=\"vertical-align:top\">名称<\/th><th style=\"text-align:left; vertical-align:top\">网络名称<\/th><th style=\"text-align:left; vertical-align:top\">VLAN ID<\/th><\/tr><\/thead><tbody xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"><tr><td style=\"text-align:left; vertical-align:top\">客户管理<\/td><td style=\"text-align:left; vertical-align:top\">CUSTMGMT<\/td><td style=\"text-align:left; vertical-align:top\">指定客户<\/td><\/tr><\/tbody><\/table><p>这个客户管理网络可使用网络管理员指定的任何可用 VLAN ID。VLAN 需要在外部网络上进行定义来支持管理员访问 PSM。<\/p><h3 id=\"N103A3\">管理网络<\/h3><p>系统需要三个 VLAN 来从内部管理其组件。Customer Network Configuration 将其作为 Internal Network\n                VLAN 列出。每个管理 VLAN 也在 Virtual Networks 页面上与其他 VLAN 一起列出（<strong>System\n                    Console &gt; Hardware &gt; Virtual Network<\/strong>）。表 4 列出了这些管理\n                VLAN。<\/p><h5 id=\"N103B4\">表 4. 管理网络<\/h5><table border=\"0\" cellpadding=\"0\" cellspacing=\"0\" class=\"ibm-data-table\" summary=\"3 column table with headers, table uses a heading tag for the caption. Text in table shows Management networks\" width=\"60%\"><thead xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"><tr><th style=\"text-align:left; vertical-align:top\">名称<\/th><th style=\"text-align:left; vertical-align:top\">网络名称<\/th><th style=\"text-align:left; vertical-align:top\">VLAN ID<\/th><\/tr><\/thead><tbody xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"><tr><td style=\"text-align:left; vertical-align:top\">移动性<\/td><td style=\"text-align:left; vertical-align:top\">VMOTION<\/td><td style=\"text-align:left; vertical-align:top\">1358<\/td><\/tr><tr><td style=\"text-align:left; vertical-align:top\">控制台<\/td><td style=\"text-align:left; vertical-align:top\">CONSOLE<\/td><td style=\"text-align:left; vertical-align:top\">3201<\/td><\/tr><tr><td style=\"text-align:left; vertical-align:top\">管理<\/td><td style=\"text-align:left; vertical-align:top\">MERION<\/td><td style=\"text-align:left; vertical-align:top\">4091<\/td><\/tr><\/tbody><\/table><p>为了确保这三个 VLAN ID 在网络上是惟一的，应该在网络上保留它们，让其他所有 VLAN 都不会使用它们。至少，具有这些 ID 的网络 VLAN\n                将无法连接到系统，因为顶部机架交换机会阻塞流量。<\/p><p>除了这些系统范围内的管理网络外，每个云组（PureApplication System 的虚拟化特性）还需要自己的管理 VLAN。这些 VLAN ID\n                也应进行保留，或者至少将由顶部机架交换机进行阻塞。<\/p><h3 id=\"N103E6\">应用程序网络<\/h3><p>Customer Network Configuration 页面还使管理员能够定义 VLAN，客户工作负载将用其来彼此通信，并将每个应用程序\n                VLAN 与顶部机架交换机中的端口或链路聚合关联。当添加或删除交换机中已配置的 VLAN\n                时，系统会花几分钟时间来重新配置其顶部机架和网络交换机，然后，系统将识别 VLAN 更改。<\/p><p>这些应用程序 VLAN 必须在网络上进行定义，以支持不在系统上运行的部分应用程序（例如，客户端 GUI\n                和企业数据库）与在系统上作为工作负载运行的部分应用程序之间的通信。<\/p><h2 id=\"9.Conclusion|outline\">结束语<\/h2><p>本文回顾了 PureApplication System\n                中包含的硬件。介绍了主要的硬件组件，描述了各个组件的详细信息和关系，并展示了如何在集成控制台中找到它们。了解了这些信息之后，您现在就对\n                PureApplication System 中的硬件有了更高的理解。<\/p><h3 id=\"N103F6\">致谢<\/h3><p>作者衷心感谢以下 IBM 工作人员，感谢他们对本文提供的帮助：<strong>Hendrik van\n                    Run<\/strong>、<strong>Jose Altuve<\/strong>、<strong>Jim\n                    Robbins<\/strong>、<strong>Ajay Apte<\/strong> 和 <strong>James\n                    Kochuba<\/strong>。<\/p><CMA ID: 957439><Site ID: 10><XSLT stylesheet used to transform this file: dw-document-html-7.0.xsl>\r\n\r\n\r\n<\/div>\r\n<\/div>\r\n","createTime":"2014-06-26 00:00:00","deployTime":"2014-06-26 00:00:00","id":0,"intro":"IBM PureApplication System 是一个盒装云计算系统，配有用来在云中部署和执行工作负载的硬件和软件 - 拥有将私有云环境添加到企业数据中心所需的一切功能。本文将概述 PureApplication System 中包含的硬件和软件。","keyword":"","recommend":false,"source":"http://www.ibm.com/developerworks/cn/cloud/library/cl-ps-aim1302-hardwarepureapp/index.html","title":"IBM PureApplication System 中的硬件之旅","typeId":0,"updateTime":"2014-06-26 00:00:00"}
{"author":"","clickNumber":0,"content":"\r\n<div class=\"ibm-columns\">\r\n<div class=\"ibm-col-1-1\">\r\n\r\n<h2 id=\"major1\">Javacore 与 WebSphere Commerce 性能问题<\/h2><p>近年来，依据 WebSphere Commerce（以下简称为 WC）搭建的电子商务网站系统日益增多。由于系统本身的复杂性，一旦系统出现问题，尤其是性能问题，问题诊断和定位就会非常困难。下图所示为由 WC 系统为核心搭建的电子商务网站的一般逻辑架构 , 如图 1 所示：<\/p><h5 id=\"img001\">图 1. 电子商务网站的一般逻辑架构<\/h5><img alt=\"图 1 电子商务网站的一般逻辑架构\" src=\"/sunshine_new/images/负934160391/img001.png\" width=\"404\" /><p>在整个系统架构中，核心应用逻辑运行在 WebSphere 应用服务器上。当系统出现性能问题时，虽然实际问题的根源可能分布在各个节点上，但是通过在应用服务器上的线程运行状态分析，都有助于对整个系统的当前状态以及可能的问题根源进行快速定位。WebSphere 应用服务器运行在 JVM（Java 虚拟机）之上。所以掌握通过 Javacore 进行 Java 线程分析，对于解决 WC 系统中的性能问题至关重要。<\/p><p>本文介绍如何通过 Javacore 文件分析线程运行状态，以及辅助分析工具的使用。并通过实例讲解如何利用 Java 线程分析解决 WC 系统中的性能问题。本文所介绍的分析方法对于其他基于 JavaEE 构建的企业应用也有借鉴意义。<\/p><h2 id=\"major2\">如何通过 Javacore 了解线程运行状况<\/h2><p>Javacore 是一个当前 JVM 运行状态的快照。通过对 Javacore 的分析，可以了解在 JVM 中运行的应用程序的当前状态，比如是否“卡”在某一点上，或在某些代码上运行时间太长。<\/p><h3 id=\"major3\">Javacore 的基本内容<\/h3><p>Javacore，也可以称为“threaddump”或是“javadump”，它是 Java 提供的一种诊断特性，能够提供一份可读的当前运行的 JVM 中线程使用情况的快照。即在某个特定时刻，JVM 中有哪些线程在运行，每个线程执行到哪一个类，哪一个方法。<\/p><p>应用程序如果出现不可恢复的错误或是内存泄露，就会自动触发 Javacore 的生成。而为了性能问题诊断的需要，我们也会主动触发生成 Javacore。在 AIX、Linux、Solaris 环境中，我们通常使用 kill -3 &lt;PID&gt; 产生该进程的 Javacore。IBM Java6 中产生 Javacore 的详细方法可以参考文章 [1]。<\/p><p>对于 IBM JVM，AIX 平台上的 Javacore 会被写到 javacore.&lt;date&gt;.&lt;time&gt;.&lt;PID&gt;.&lt;sequence&gt;.txt 中。对于 Oracle JVM，Javacore 被附加到 native_stdout.txt。Javacore 的内容有两列，第一列是“类型”，第二列表示“数据”，如清单 1 所示：<\/p><h5 id=\"listing1\">清单 1<\/h5><div class=\"codesection\"><pre class=\"displaycode\">1TISIGINFO Dump Event \"user\" (00004000) received \n 1TIDATETIME Date: 2013/12/22 at 23:05:18 \n 1TIFILENAME Javacore filename: \n /usr/WebSphere/AppServer/profiles/demo_solr/javacore.20131222.230518.7995516.0004.txt<\/pre><\/div><p>通常情况下，Javacore 中除了线程信息外，还能提供关于操作系统，应用程序环境，线程，程序调用栈，锁，监视器和内存使用等相关信息。<\/p><p>为了便于分析，Javacores 的每一段的开头，都会用“----------”和上一信息块区分开来。每一信息块的标题会以“=========”来标识，很容易找到，如清单 2 所示：<\/p><h5 id=\"listing2\">清单 2<\/h5><div class=\"codesection\"><pre class=\"displaycode\">NULL ------------------------------------------------------------------------ \n 0SECTION GPINFO subcomponent dump routine \n NULL ================================ \n 2XHOSLEVEL OS Level : AIX 7.1 \n 2XHCPUS Processors - \n 3XHCPUARCH Architecture : ppc64 \n 3XHNUMCPUS How Many : 8 \n 3XHNUMASUP NUMA is either not supported or has been disabled by user \n NULL \n 1XHERROR2 Register dump section only produced for SIGSEGV, SIGILL or SIGFPE. \n NULL<\/pre><\/div><p>Javacore 文件中，每行都包含一个标签，这个标签最多由 15 个字符组成。第一位数字表示信息的详细级别，级别越高代表信息越详细。接着的两个字符是段标题的缩写，例如：“CI”表示 Command line interpreter，“CL”表示 Class loader，“LK”表示 Locking，“ST”表示 Storage，“TI”表示 Title，“XE”表示 Execution engine 等。余下的字符表示信息的概述。如下清单 3 所示：<\/p><h5 id=\"listing3\">清单 3<\/h5><div class=\"codesection\"><pre class=\"displaycode\">3XMTHREADINFO \"Thread-18\" J9VMThread:0x00000000308DA900, \n j9thread_t:0x0000010016C4F2E0, java/lang/Thread:0x000000004136E3E8, state:P, prio=5<\/pre><\/div><p>虽然不同版本的 JVM 所产生的 Javacore 的格式会稍有不同，但基本都包含下面几个内容：<\/p><p><strong>TITLE 信息块：<\/strong>描述 Javacore 产生的原因，时间以及文件的路径。常见的 Javacore 产生的原因可以参考文章 [2]。最常见的有下面三种：<\/p><p>user：SIGQUIT 信号<\/p><p>gpf：程序一般保护性错误导致系统崩溃<\/p><p>systhrow：JVM 内部抛出的异常<\/p><p><strong>GPINFO 信息块：<\/strong>GPF（一般保护性错误）信息<\/p><p><strong>ENVINFO 信息块：<\/strong>系统运行时的环境和 JVM 参数<\/p><p><strong>MEMINFO 信息块：<\/strong>内存使用情况和垃圾回收情况<\/p><p><strong>LOCKS 信息块：<\/strong>用户监视器（monitor）和系统监视器（monitor）情况<\/p><p><strong>THREADS 信息块：<\/strong>所有 java 线程的状态信息和执行堆栈<\/p><p><strong>CLASSES 信息块：<\/strong>类加载信息<\/p><p>Javacore 中的线程可分为以下几种状态：<\/p><ul class=\"ibm-bullet-list\"><li>\n死锁（Deadlock）【重点关注】：一般指多个线程调用间，进入相互资源占用，导致一直等待无法释放的情况。<\/li><li>\n执行中（Runnable）【重点关注】：一般指该线程正在执行状态中，该线程占用了资源，正在处理某个请求，有可能在对某个文件操作，有可能进行数据类型等转换等。<\/li><li>\n等待资源（Waiting on condition）【重点关注】：等待资源，如果堆栈信息明确是应用代码，则证明该线程正在等待资源，一般是大量读取某资源、且该资源采用了资源锁的情况下，线程进入等待状态。又或者，正在等待其他线程的执行等。<\/li><li>\n等待监控器检查资源（Waiting on monitor）<\/li><li>\n暂停（Suspended）<\/li><li>\n对象等待中（Object.wait()）<\/li><li>\n阻塞（Blocked）【重点关注】：指当前线程执行过程中，所需要的资源长时间等待却一直未能获取到，被容器的线程管理器标识为阻塞状态，可以理解为等待资源超时的线程。这种情况在应用的日志中，一般可以看到 CPU 饥渴，或者某线程已执行了较长时间的信息。<\/li><li>\n停止（Parked）<\/li><\/ul><p>通过对 Javacore 数据的分析经验，结合对具体应用代码逻辑的理解，有经验的工程师可以直接通过文本编辑器查看原始 Javacore 文件来分析当前应用程序的运行状态。一般初学者则需要通过一些工具进行更直观的分析。<\/p><h3 id=\"major4\">图形化分析工具 TMDA<\/h3><p>有很多图形化工具可以用于 Javacore 的分析。笔者常用的工具为：IBM Thread and Monitor Dump Analyzer for Java 工具，简称 TMDA。TMDA 提供以下功能：<\/p><ul class=\"ibm-bullet-list\"><li>\n提供一个简洁的 Javacore 内容的总结，包括一些初步的预警信息，线程柱状图，内存使用情况信息等等。<\/li><li>\n方便地分析线程栈和监视器（monitor）的用户接口<\/li><li>\n方便地进行多个 Javacore 中的线程栈和监视器进行比较的用户接口<\/li><\/ul><p>无论是初学者还是性能分析专家都可以使用 TMDA 进行 Javacore 的快速分析。关于 TMDA 的更多介绍可以参考它的社区：参考文献 [3]<\/p><h3 id=\"major5\">WC 线程执行堆栈分析<\/h3><p>不论是否利用 TMDA 工具进行分析，对 Javacore 的分析最终都会落实在具体线程的执行堆栈上。如果对具体应用的代码不熟悉，那么看着一个个长长的执行堆栈，可能会觉得无从下手。本部分介绍 WC 线程执行堆栈的常见代码和对应的功能模块。初学者可以根据这些示例推测某个线程的当前运行状态。需要注意的是，WC 的不同版本，同样的功能模块的具体代码可能会发生变化，经过用户定制的代码就更是千差万别。本部分提供的只是依据 WC FEP7 版本代码的一些示例，读者需要根据自己所处理的系统的实际代码情况灵活掌握，不可拘泥。<\/p><p>通常一个 Javacore 里面会有上百个线程，这些线程的地位并不一样。有些线程是系统运行的“入口线程”，而其他一些线程只是由这些线程派生出来的辅助线程。所以 Javacore 分析过程中一定要抓住这些主要线程。<\/p><p>WC 的核心是一个 Web 应用，所以大部分 WC 的 Javacore 以应用服务器的 Web 容器为入口。用来处理前台商店或后台管理端的 JVM 基本类似，但专门运行定时任务的 JVM 会有所区别。下图 2 所示为以 Web 容器为入口线程的一般调用结构：<\/p><h5 id=\"img002\">图 2. 调用结构<\/h5><img alt=\"图 2 调用结构\" src=\"/sunshine_new/images/负934160391/img002.gif\" width=\"582\" /><p>从 Web 容器入口开始，一般会进入 Servlet 执行。如果有缓存而且命中的话，则会进入 DynaCache 的相关代码。如果无缓存或缓存不命中，如果是 JSP 页面，则会执行 JSP 的相关代码，否则会执行相应的逻辑。代码逻辑处理过程中，经常会访问到数据库（通过 DSL 或 EJB）或 Solr 搜索（通过 BOD 或 REST），还有可能访问到外部系统集成接口（通过 HTTP 同步调用或消息队列）。如果数据库服务器 / 搜索服务器 / 系统集成服务器分布在其他节点上，那么这些调用最终都会转化为网络访问。<\/p><p>以下为一个正在处理 JSP 页面中的数据库请求的执行堆栈示例，如图 3、4、5：<\/p><h5 id=\"img003\">图 3. 堆栈实例（1）<\/h5><img alt=\"图 3 堆栈实例（1）\" src=\"/sunshine_new/images/负934160391/img003.png\" width=\"581\" /><h5 id=\"img004\">图 4. 堆栈实例（2）<\/h5><img alt=\"图 4 堆栈实例（2）\" src=\"/sunshine_new/images/负934160391/img004.png\" width=\"582\" /><h5 id=\"img005\">图 5. 堆栈实例（3）<\/h5><img alt=\"图 5 堆栈实例\" src=\"/sunshine_new/images/负934160391/img005.png\" width=\"582\" /><p>自下而上的关键代码：<\/p><ol type=\"1\"><li>Web 容器处理请求\n\t\t\t\t <p>Package 名 / 类名 . 方法名：com.ibm.ws.webcontainer/WebContainer.handleRequest<\/p><\/li><li>RuntimeFilter \n\t\t\t\t <p>Package 名 / 类名 . 方法名：com.ibm.commerce.webcontroller/RuntimeServletFilter.doFilterAction<\/p><\/li><li>Servlet 处理\n                   <p>Package 名 / 类名 . 方法名：com.ibm.commerce.struts/ECActionServlet.doGet<\/p><p>或者<\/p><p>Package 名 / 类名 . 方法名：com.ibm.commerce.struts/ECActionServlet.doPost<\/p><\/li><li><strong>JSP 处理<\/strong><p>Package 名 / 类名 . 方法名：com.ibm._jsp/_(JSP 文件名 )._jspService<\/p><\/li><li>Command 执行（图例为 BOD command）\n\t\t\t\t <p>Package 名 / 类名 . 方法名：com.ibm.commerce.*/Abstract(*)CmdImpl.performExecute<\/p><\/li><li>DSL \n\t\t\t\t  <p>Package 名 / 类名 . 方法名：com.ibm.commerce.foundation.server.services.dataaccess/AbstractDataServiceFacade.*<\/p><\/li><li>JDBC \n                    <p>查询<\/p><p>Package 名 / 类名 . 方法名：com.ibm.ws.rsadapter.jdbc/WSJdbcPreparedStatement.executeQuery<\/p><p>或 Package 名 / 类名 . 方法名：com.ibm.ws.rsadapter.cci/WSResourceAdapterBase.executeQuery<\/p><p>更新<\/p><p>Package 名 / 类名 . 方法名：com.ibm.ws.rsadapter.jdbc/WSJdbcPreparedStatement.executeUpdate<\/p><p>或 Package 名 / 类名 . 方法名：com.ibm.ws.rsadapter.cci/WSResourceAdapterBase.executeUpdate<\/p><\/li><li>数据库驱动代码\n                     <p>DB2<\/p><p>Package 名：com.ibm.db2.*<\/p><p>Oracle<\/p><p>Package 名 / 类名 . 方法名：oracle.jdbc.driver/OraclePreparedStatement.executeInternal<\/p><\/li><li><strong>外部网络访问<\/strong><p>（网络读）Package 名 / 类名 . 方法名：java.net/SocketInputStream.socketRead0<\/p><p>（网络写）Package 名 / 类名 . 方法名：java.net/SocketOutputStream.socketWrite0<\/p><\/li><\/ol><p>其他常见的执行堆栈举例：<\/p><ul class=\"ibm-bullet-list\"><li><strong>空闲（Idle）<\/strong><p>这样的堆栈表示当前线程处于空闲状态（对于 Web 容器而言，即当前线程没有接收到 Web 请求）。其调用栈为：<\/p><p>Package 名 / 类名 . 方法名：java.lang/Object/wait<\/p><p>…<\/p><p>Package 名 / 类名 . 方法名：com.ibm.ws.util/ThreadPool$Worker. run<\/p><p>或者<\/p><p>Package 名 / 类名 . 方法名：com.ibm.io.async/AsyncLibrary. aio_getioev*<\/p><p>…<\/p><p>Package 名 / 类名 . 方法名：com.ibm.ws.util/ThreadPool$Worker. run<\/p><h5 id=\"img006\">图 6 示例截图<\/h5><img alt=\"图 6 示例截图\" src=\"/sunshine_new/images/负934160391/img006.png\" width=\"573\" /><\/li><li>事务（Transaction）处理\n\t\t\t <p>提交（Commit）<\/p><p>Package 名 / 类名 . 方法名：com.ibm.commerce.server/TransactionManager.commit<\/p><p>回滚（Rollback）<\/p><p>Package 名 / 类名 . 方法名：com.ibm.commerce.server/TransactionManager.rollback<\/p><\/li><li>缓存（DynaCache）读取\n\t\t\t <p>Package 名 / 类名 . 方法名：com.ibm.ws.cache/Cache.getEntry（或 getCacheEntry）<\/p><p>基于 WXS 的缓存则为<\/p><p>Package 名 / 类名 . 方法名：com.ibm.ws.objectgrid.dynacache/RemoteCoreCacheImpl.get<\/p><\/li><li>MultiClick 处理\n\t\t\t <p>Package 名 / 类名 . 方法名：com.ibm.commerce.webcontroller.doubleclick/MultiClickRequestHandler. waitForResponse<\/p><\/li><li>消息处理（MQ）\n\t\t\t <p>Package 名 / 类名 . 方法名：com.ibm.mq.jmqi.remote.internal/RemoteRcvThread.run<\/p><\/li><li>搜索（Solr）处理\n\t\t\t <p>Package 名 / 类名 . 方法名：org.apache.solr.client.solrj/SolrServer.query<\/p><\/li><li>REST 处理\n\t\t\t <p>Package 名 / 类名 . 方法名：com.ibm.commerce.foundation.internal.client.util/RESTHandler.execute<\/p><\/li><\/ul><p>前面作者已经强调，不同版本的 WC 代码或者经过定制的代码会有不同。读者必须在实际系统开发运维过程中积累经验，形成自己的代码样例“库”。这样才能在长长的执行堆栈中迅速抓住关键信息。<\/p><h2 id=\"major6\">案例分析<\/h2><p>本部分通过两个具体实例讲解如何通过 Javacore 分析来分析解决 WC 系统中的性能问题。当系统出现性能问题的时候，通常系统的工作状态会发生某些异常。我们的任务就是通过 Javacore 分析来找出系统关键线程的运行状态变化。这里一般都需要获取多次 Javacore 并进行比较，发现哪些是“变”的部分，哪些是“不变”的部分。所以，谁和谁比，比什么，是分析问题的关键。<\/p><h3 id=\"major7\">逻辑死锁问题<\/h3><p>Javacore 分析经常用于解决逻辑死锁问题。使用 TMDA 工具，可以在图形界面中快速找出不同线程之间的等待关系，如图 7 所示：<\/p><h5 id=\"img007\">图 7. TMDA 工具图形界面<\/h5><img alt=\"图 7 TMDA 工具图形界面\" src=\"/sunshine_new/images/负934160391/img007.png\" width=\"485\" /><p>如果在同一个 JVM 内部出现了线程之间循环等待的状况，就会进入线程之间的死锁（Deadlock）状态。对于未定制的 WC 系统而言，直接出现这样的死锁问题的可能性比较小。较常见的是在整个系统的不同节点之间出现的逻辑死锁问题，这种问题一般不能直接在 Javacore 中识别出来。本节通过一个 WC 内部测试过程中遇到的案例介绍如何分析解决这种逻辑死锁问题。<\/p><p>这是一个随机浏览产品目录的测试场景。在这个场景中，WC 应用服务器接收请求，并调用搜索服务器上的索引进行处理。简化后的系统架构图（省略了 Web 服务器）如图 8 所示：<\/p><h5 id=\"img008\">图 8. 简化的系统架构图<\/h5><img alt=\"图 8 简化的系统架构图\" src=\"/sunshine_new/images/负934160391/img008.png\" width=\"308\" /><p>这里，搜索服务器在处理过程中会有一次回调到应用服务器，通过应用服务器获取某些搜索所需的数据。<\/p><p>我们对这个测试场景进行了用户数递增的压力测试，正常情况下，我们期望看到的结果是随着用户数的增加，系统的吞吐量逐渐上升，最后达到一个平稳状态（达到 CPU 瓶颈）。但是实际测试过程中看到的现象却是，当并发用户数增加到某个数值的时候，系统吞吐率突然下降，最终降低到 0，如图 9、10。<\/p><h5 id=\"img009\">图 9. 并发用户数<\/h5><img alt=\"图 9 并发用户数\" src=\"/sunshine_new/images/负934160391/img009.jpg\" width=\"199\" /><h5 id=\"img010\">图 10. 吞吐率<\/h5><img alt=\"图 10 吞吐率\" src=\"/sunshine_new/images/负934160391/img010.jpg\" width=\"226\" /><p>此时，我们监控两个节点上的 CPU 使用状况。发现吞吐量降低为 0 的同时，CPU 使用率也几乎降低为 0。因此，初步可以判断系统出现了逻辑死锁问题。反之，如果某个节点上的 CPU 使用率（或其他资源使用率）很高，则有可能是逻辑死循环或其他代码实现问题。<\/p><p>要想进一步分析就需要通过 Javacore 分析获取当前 JVM 的运行状态信息。这里我们需要分别在应用服务器和搜索服务器端获取 Javacore（采样的时间点要同步）。采样点可以做三次，在吞吐率下降前采样一次，下降后采样两次（中间间隔 30 秒以上）。然后对这三次 Javacore 进行对比分析。<\/p><p>在 TMDA 中打开采样到的 Javacore 文件。TMDA 提供的“Compare Threads”功能可以用来比较这些 Javacore 文件：<\/p><h5 id=\"img011\">图 11. TMDA 比较菜单<\/h5><img alt=\"图 11 TMDA 比较菜单\" src=\"/sunshine_new/images/负934160391/img011.png\" width=\"164\" /><p>先来看 WC 应用服务器端的 Javacore 文件。前文已经解释过 Web 容器通常是整个应用的入口，所以我们重点关注 Web 容器相关线程的状态。TMDA 比较的结果如图 12 所示：<\/p><h5 id=\"img012\">图 12. TMDA 比较结果<\/h5><img alt=\"图 12 TMDA 比较结果\" src=\"/sunshine_new/images/负934160391/img012.png\" width=\"366\" /><p>用黄底色表示（TMDA 的不同版本显示效果可能略有区别）的线程表示在两次采样中的状态相同（执行堆栈相同）。这里可以很清楚地看到在第二次和第三次采样点上，所有 Web 容器的线程执行状态都相同，系统已经进入了假死（HANG）状态（注意这两次采样发生在系统吞吐率降为 0 之后）。<\/p><p>这里需要注意，在第一个采样点（系统吞吐率下降之前），还有很多线程处于“阻塞”（Blocked）状态。而在第二、第三个采样点上，除了个别线程处于阻塞状态外，多数线程都处于“执行中”（Runnable）状态。由此可见，不能完全依赖 Javacore 中标明的线程状态来判断当前系统的状态，关键还是要看执行堆栈中实际在执行的代码。处于“执行中”状态的线程可能实际在等待，而处于“等待资源”（Waiting on condition）状态的线程可能实际是“执行中”状态。<\/p><p>我们进一步分析第二、第三个采样点上，Web 容器各线程的执行堆栈。我们发现，虽然下层处理的页面（JSP）各有不同，但是顶层处于运行中的代码都一样：<\/p><h5 id=\"img013\">图 13. 执行堆栈<\/h5><img alt=\"图 13 执行堆栈\" src=\"/sunshine_new/images/负934160391/img013.png\" width=\"550\" /><p>基本上所有的 Web 容器线程都在等待 REST 请求的网络返回。根据前面描述的简化后的系统结构图，可以推断所有线程都在等候搜索服务器的处理结果。这是作者根据对系统结构的理解进行的判断，如果读者在实际问题分析过程中无法确定，可以使用 netstat 进行网络监控，根据 HTTP 链接的建立情况进一步确认。<\/p><p>下一步，我们再比较搜索服务器端的三个时间点上的 Javacores 文件。结果是类似的，同样第二个和第三个采样点上 Web 容器的所有线程都进入了假死（HANG）状态：<\/p><h5 id=\"img014\">图 14. 三个采样点比较结果<\/h5><img alt=\"图 14 三个采样点比较结果\" src=\"/sunshine_new/images/负934160391/img014.png\" width=\"279\" /><p>我们再来看看搜索服务器端处于“执行中”的线程都在干什么。基本上所有执行堆栈的顶端都在执行如下代码：<\/p><h5 id=\"img015\">图 15. 执行堆栈代码<\/h5><img alt=\"图 15 执行堆栈代码\" src=\"/sunshine_new/images/负934160391/img015.png\" width=\"553\" /><p>经过代码分析，我们发现这是搜索服务器端在通过 REST 回调 WC 应用服务器，获取 BCS（BusinessConextService）相关的数据。<\/p><p>这样的调用关系为什么会导致逻辑上的死锁呢？关键在于对 Web 容器的线程池资源的竞争上。每个 WC 端接收到的请求在处理过程中需要占用 Web 容器的线程池的一个线程资源，而这个处理逻辑在处理过程中请求了搜索服务器端，又通过搜索服务器端回调到 WC 端，这就需要占用 Web 容器的线程池的另一个线程资源。<\/p><p>这个逻辑关系可以简化为图 16：<\/p><h5 id=\"img016\">图 16. 简化逻辑关系图<\/h5><img alt=\"图 16 简化逻辑关系图\" src=\"/sunshine_new/images/负934160391/img016.png\" width=\"309\" /><p>在应用服务器的 Web 容器线程池资源上，通过搜索服务器的回调形成了一个闭环。这类似于标准的“哲学家就餐问题”，如果所有的请求都占用了第一个线程资源，而请求第二个线程资源，那么所有的线程都会阻塞在这个状态上，形成死锁。要解决这个线程死锁问题，必须消除这个资源占用上的闭环。可以采取的方案包括消除从 Search 端的 REST 回调，建立一个独立的线程池专门负责处理 Search 端的回调，等等。<\/p><h3 id=\"major8\">寻找性能瓶颈<\/h3><p>除了分析逻辑死锁问题外，Javacore 分析也可以用于寻找性能瓶颈。一般来说，寻找代码逻辑中的性能瓶颈，需要对代码的执行路径进行 Profiling（执行统计分析）。Profiling 工具一般有两种。能够提供完整执行堆栈的工具一般都是侵入式的，运行开销很高，并不适于在高负载的生产环境中使用。基于采样（sampling）的工具运行开销很小，但通常都不提供完整的执行堆栈。这里其实可以把 Javacore 分析当作辅助的 Profiling 工具来用。每个 Javacore 都提供了在某一时刻正在运行的代码的执行堆栈，这可以看作一个采样点。如果多做几次采样点，那么根据这些 Javacore 数据就可以进行一个执行路径的粗略 Profiling（不过总体采样点数量比真正的 Profiling 工具少很多）。<\/p><p>我们仍以一个 WC 产品测试过程中遇到的问题为例介绍这种分析方法。<\/p><p>我们在某个产品开发的版本测试过程中发现，搜索结果页面（SearchResultDisplay）的性能比前一个版本下降了很多。为了找出性能下降的原因，我们对该页面进行了单场景压力测试。当系统性能进入稳定状态后，我们在 WC 应用服务器端做了 Javacore 数据采样。<\/p><p>同样，我们的入口线程仍是 Web 容器的线程。这里要解决的是性能下降问题（系统 CPU 占用率很高），而不是逻辑死锁问题。所以我们关注的重点是同一次采样内部线程之间的横向比较，而不是多次采样之间的横向比较，所以只需要用到 TMDA 的线程分析功能，而不需要使用线程比较功能。<\/p><p>如果关注于执行堆栈的顶部代码，我们发现 Web 容器各线程的执行状况比较分散，似乎没有什么规律。但是如果从执行堆栈的底部往上看，就会发现某些规律。这里我们发现在 Web 容器的 25 个线程（等于线程池的大小）中，有一半以上的执行堆栈在执行如下图 17 代码：<\/p><h5 id=\"img017\">图 17. 执行代码<\/h5><img alt=\"图 17 执行代码\" src=\"/sunshine_new/images/负934160391/img017.png\" width=\"553\" /><p>由于这是单场景压力测试，基本上所有的 Web 容器线程都在执行相同的 JSP：SearchBasedCategoryPage。如果这个 JSP 里面没有明显的性能瓶颈，那么 Web 容器的 25 个线程应该随机运行在这个 JSP 的不同代码逻辑之中。我们实际观察到的现象则是有一半以上的线程都在执行如下代码：<\/p><p>com/ibm/commerce/infrastructure/facade/client/AbstractInfrastructureFacadeClient.getOnlineStore<\/p><p>为了排除代码执行随机性的影响，我们又在随后的系统执行过程中多做了几次采样，仍然得到了类似的结果。<\/p><p>这就表示该代码有可能是整个 JSP 逻辑中的性能瓶颈（当然还不能完全确定）。另一方面，通过与前一个版本的 Javacore 进行对比分析，发现前一版本的 Javacore 中并没有出现该代码。这说明该代码是当前版本新引入的代码。通过进一步的代码分析发现，这是在当前版本中新加入的一段处理客户定制逻辑的新代码。我们屏蔽了该端代码后，重新进行了性能测试，发现性能基本上可以恢复到前一版本的水平。因此最终可以确定是这段代码导致了当前版本的性能下降问题。<\/p><p>如何解决这类性能问题呢？首先应该是评估原始的实现逻辑，是否需要在每一个页面请求的处理过程中执行这段逻辑。如果不需要，则可以直接屏蔽该代码段。如果这一段逻辑必须在每一个页面请求中执行，则可以考虑引入适当的缓存机制，降低重复执行时的开销。<\/p><p>这种分析方法也可以用于在客户生产系统中快速定位整个系统的性能瓶颈。生产系统执行的页面请求是多种多样的，通常情况下，在生产系统上做 Javacore 应该找不到什么规律。反之，如果多次采样可以发现系统在高负载运行状态下，Web 容器线程的执行堆栈存在某些规律，比如：大部分线程都在执行目录页面（CategoryDisplay）显示。而页面访问统计的结果显示，目录页面的访问频率并不比其他页面高很多。这种情况下就很有可能在 CategoryDisplay 页面有性能瓶颈。下一步就可以进行单场景的压力测试来进一步寻找 CategoryDisplay 页面逻辑中的性能瓶颈。<\/p><p>如果能将 Javacore 分析的结果，与其他基于采样的 Profiling 工具的分析结果相结合，则更容易快速找到代码中的性能瓶颈。<\/p><CMA ID: 975726><Site ID: 10><XSLT stylesheet used to transform this file: dw-document-html-7.0.xsl>\r\n\r\n\r\n<\/div>\r\n<\/div>\r\n","createTime":"2014-06-26 00:00:00","deployTime":"2014-06-26 00:00:00","id":0,"intro":"随着电子商务应用的广泛应用和用户体验度的提升，对一个生产环境的突发问题的快速诊断和解决以及系统恢复变得越来越关键。一般情况下，我们会有一定的监控，恢复的流程和手段，包括搜集相应的信息并进行相应的分析。本文中会着重介绍一下如何分析 Javacores（Javadumps）来诊断出线程挂起，死锁，资源争抢等资源瓶颈等问题，并以一个 WC 线程死锁的案例来帮助大家分析理解 Javacore，从而确定相应的解决方案。","keyword":"","recommend":false,"source":"http://www.ibm.com/developerworks/cn/websphere/library/techarticles/1406_tuzy_javacore/1406_tuzy_javacore.html","title":"通过 Javacore 诊断线程挂起等性能问题","typeId":0,"updateTime":"2014-06-26 00:00:00"}
{"author":"","clickNumber":0,"content":"\r\n<div class=\"ibm-columns\">\r\n<div class=\"ibm-col-1-1\">\r\n\r\n<h2 id=\"major1\">前言<\/h2><p>本文是对使用 IBM 内容管理系统为平台的广东农信银行客户后督系统的分析和介绍，以及对大数据量和高吞吐的基于 DB2 数据库的 IBM Content\n                Manager\n                系统的一些设计上的分析以及一些实际问题的解决，系统在调优后性能和吞吐量满足的客户的需求，可以作为类似系统的参考，但是要注意，每一个系统都有自己独特的需求和实际情况，本文无法涵盖您在系统建设过程中的所有问题，欢迎联系我们做进一步探讨。另外，将来实际系统中在数据量达到一定量级时，可能会碰到新的难题，我们希望能和客户一起协作解决并将经验分享给大家。第\n                2 部分，我们将着重介绍实例问题和分析解决的办法供类似系统参考。<\/p><h2 id=\"major2\">对于实例系统中出现的与性能和高并发相关的关键问题的分析和解决<\/h2><p>在客户的实际后督生产系统中，在系统工程师的努力下，经过了对网络、存储、DB2、WAS、TSM 和 CM\n                的调优以后，依旧在高吞吐和为此设计的高并发的系统中发现了两个棘手的问题，严重影响了性能，并造成了一些 CM 孤儿数据 (Orphan data)\n                很难被处理，这些问题虽然不一定会在每个系统中都出现，但一旦出现解决起来耗时耗力，在客户和 IBM\n                支持人员的协作下，问题得到了圆满的解决，本文借此机会感谢所有参与解决这些问题的客户和 IBM\n                支持人员，并将问题和分析解决的思路共享出来，可以供有类似问题的高吞吐高并发内容管理系统参考。<\/p><h3 id=\"major3\">问题一. 启用迁移后资源数据库占用 CPU 达到\n                100%<\/h3><p>此时 I/O，网络资源都很充足，根据对动态 SQL 语句的监控，发现大量并发操作会执行同一条语句。<\/p><h5 id=\"listing1\">清单 1. 造成 CPU100%问题的 SQL<\/h5><div class=\"codesection\"><pre class=\"displaycode\">Statement : SELECT TRANSACTIONID FROM RMTRANSACTIONS WHERE (( OBJ_LIBRARYID = ? AND OBJ_ITEMID = ? AND\nOBJ_VERSION =? AND OBJ_COLLID = ? ) OR ( OBJ_TMP_ITEMID = ?\nAND OBJ_TMP_VERSION = ? AND OBJ_TMP_COLLID = ? )) AND TRANSACTIONID&lt;&gt;?<\/pre><\/div><p>此语句的访问计划 (Access plan) 虽然使用了如下的索引 TRAN_ID_X1，但是访问的行数巨大并造成了巨量的逻辑读，经过分析是造成\n                CPU 资源占用过大的根本原因。<\/p><h5 id=\"listing2\">清单 2. 调优前访问计划<\/h5><div class=\"codesection\"><pre class=\"displaycode\">Optimizer Plan:\n Rows \n Operator \n (ID) \n Cost \n 0 \n n/a \n RETURN \n ( 1) \n 0.015443 \n | \n 0 \n n/a \n FETCH \n ( 2) \n 0.015443 \n / \\\n 0 0 \n n/a n/a \n IXSCAN Table: \n ( 3) RM2ADMIN \n 0.0150991 RMTRANSACTIONS \n | \n 0 \n Index: \n RM2ADMIN \n TRAN_ID_X1<\/pre><\/div><p>分析 RMTRANSACTIONS 表可以发现此表是 VOLATILE 类型的表，并且有三个索引：<\/p><ul class=\"ibm-bullet-list\"><li> 主键索引<\/li><\/ul><p>包含 (OBJ_COLLID, OBJ_ITEMID, OBJ_VERSION, OBJ_LIBRARYID, TRANSACTION_DATE)\n                字段。<\/p><ul class=\"ibm-bullet-list\"><li> 索引 TRAN_TMP_ID_X0<\/li><\/ul><p>包含 (OBJ_TMP_COLLID, OBJ_TMP_ITEMID, OBJ_TMP_VERSION) 字段。<\/p><ul class=\"ibm-bullet-list\"><li> 索引 TRAN_ID_X1<\/li><\/ul><p>包含 (TRANSACTIONID, TRANSACTION_DATE, PROCESSTIMEOUT) 字段。<\/p><p>根据清单 1 内动态 SQL 语句的写法，访问执行计划可能使用两种路径，路径 1 就是现在清单 2 中使用的索引 TRAN_ID_X1，路径 2\n                就是在或 (or) 条件中使用主键索引和索引 TRAN_TMP_ID_X0。由于 RMTRANSACTIONS 表是 VOLATILE\n                类型的表，VOLATILE 代表这个表是变动非常频繁的表，统计信息已经不能正确反映实际的数据量，DB2\n                在表的查询时候只要有满足条件的索引，会忽略统计信息，优先使用索引，这个表的特点就是资源数据库有事务发生时候会记录相应的事务记录，事务结束后会删除相应的记录，所以一般情况下记录很少或者为\n                0，当打包迁移发生时，会在短时间内有大量事务产生，记录数可能在 0 到几万条之间频繁变化，非常符合 VOLATILE\n                表的特性，而且这三个索引都有期望的 SQL 语句会经常使用，索引的设计和定义也没有问题。那么问题出在哪呢？<\/p><p>我们结合迁移的场景仔细分析这个 SQL 语句，会发现，索引 TRAN_ID_X1(TRANSACTIONID, TRANSACTION_DATE,\n                PROCESSTIMEOUT) 影响的查询条件是 TRANSACTIONID&lt;&gt;?，业务的含义是寻找有没有其他的\n                TRANSACTIONID 和现在要使用的是否有相同的，对于一个迁移事务，对应的表内应该没有相同的 TRANSACTIONID\n                或者至多一条，所以在这个&lt;&gt;? 的条件中，将会在索引扫描后对基础表做全表扫描去匹配剩下的条件 (比如 OBJ_ITEMID)\n                等，这样一来，使用这个索引的结果就是做了一次索引的全扫描加上全表扫描，这样就会造成大量的行读，这样我们就分析出来错误的根本原因是在客户的现场环境中对于\n                RMTRANSACTIONS 这张 VOLATILE 表没有找到最优的访问计划，实际上数据分析的结果应该是选用路径 2\n                的访问计划，这样索引扫描的结果应该是几乎为 0 的记录数，也就基本没有任何表扫描。<\/p><p>由于是 VOLATILE 表，此表本身统计信息长期为 0 不具备参考价值，优化器有可能会根据系统的各个条件选取路径 1 或者路径\n                2，我们测试的系统中都选择了高效的路径 2，但是客户的实际系统中还是有一定的可能选择路径 1，即使选用路径 1\n                这个问题也不一定都能暴漏出来，只有迁移的并发吞吐达到一定的量级 (比如每秒迁移超过 1000) 才可能会呈现出来，DB2\n                本身也对这种极少可能发生的访问路径选取异常设计了解决方案。问题分析出来以后，剩下的就是使用 DB2 提供的 OPTPROFILE 的方案去强制为清单\n                1 的 SQL 指定路径 2 的索引方案。<\/p><p>下面是建立 OPTPROFILE 的步骤：<\/p><ol type=\"1\"><li> 创建 SYSTOOLS.OPT_PROFILE 表 <div class=\"codesection\"><pre class=\"displaycode\">db2 connect to rmdb\ndb2 \"call sysinstallobjects('opt_profiles', 'c', '', '')\"<\/pre><\/div><\/li><li> 创建 PMR35104.PROF1.xml，包含 SQL 的 GUIDELINE。 <div class=\"codesection\"><pre class=\"displaycode\">&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;\n&lt;OPTPROFILE VERSION=\"9.1.0.0\"&gt;\n&lt;STMTPROFILE ID=\"PMR35104\"&gt;\n&lt;STMTKEY &gt;\n&lt;![CDATA[\nSELECT TRANSACTIONID FROM RMTRANSACTIONS WHERE \n(( OBJ_LIBRARYID = ? AND OBJ_ITEMID = ? AND OBJ_VERSION = ? AND \nOBJ_COLLID = ? ) OR ( OBJ_TMP_ITEMID = ? AND OBJ_TMP_VERSION = ? AND\nOBJ_TMP_COLLID = ? )) AND TRANSACTIONID&lt;&gt;?\n]]&gt;\n&lt;/STMTKEY&gt;\n&lt;OPTGUIDELINES&gt;&lt;IXOR TABID=\"Q1\"/&gt;&lt;/OPTGUIDELINES&gt;\n&lt;/STMTPROFILE&gt;\n&lt;/OPTPROFILE&gt;<\/pre><\/div><\/li><li> 创建文件 profiledata，内容为\"PMR35104\",\"PROF1\",\"PMR35104.PROF1.xml\" <div class=\"codesection\"><pre class=\"displaycode\">vi profiledata\n\"PMR35104\",\"PROF1\",\"PMR35104.PROF1.xml\"<\/pre><\/div><\/li><li> 将 profiledata 装载到 systools.opt_profile 表中； <div class=\"codesection\"><pre class=\"displaycode\">import from profiledata of del modified by lobsinfile replace into systools.opt_profile;<\/pre><\/div><\/li><li> 检查 SQL 语句是否走了新的索引。 <div class=\"codesection\"><pre class=\"displaycode\">--RMADMIN 用户登录系统：\ndb2stop force\ndb2start\ndb2 connect to rmdb\ndb2 set current optimization profile PMR35104.PROF1\ndb2 \"set current explain mode explain\"\ndb2 \"SELECT TRANSACTIONID FROM RMTRANSACTIONS WHERE((OBJ_LIBRARYID = ? AND OBJ_ITEMID =\n? AND OBJ_VERSION = ? AND OBJ_COLLID = ?) OR (OBJ_TMP_ITEMID = ? AND OBJ_TMP_VERSION\n= ? AND OBJ_TMP_COLLID = ?)) AND TRANSACTIONID&lt;&gt;?\"\ndb2 \"set current explain mode no\"\ndb2exfmt -d rmdb1 -1 -o db2exfmt_alan_exfmt_opt.out<\/pre><\/div><\/li><\/ol><p>检查 db2exfmt_alan_exfmt_opt.out 文件，查看执行计划是否如清单 3 所示。<\/p><h5 id=\"listing3\">清单 3. 调优后访问计划<\/h5><div class=\"codesection\"><pre class=\"displaycode\"> Rows \n RETURN\n ( 1)\n Cost \n I/O \n |\n 0 \n FETCH \n ( 2)\n 0.0326346 \n 0 \n /----+----\\\n 0 0 \n RIDSCN TABLE: RM1ADMIN\n ( 3) RMTRANSACTIONS\n 0.0322871 Q1\n 0 \n /------+------\\\n 0 0 \n SORT SORT \n ( 4) ( 6)\n 0.0164133 0.0164133 \n 0 0 \n | |\n 0 0 \n IXSCAN IXSCAN\n ( 5) ( 7)\n 0.0153824 0.0153824 \n 0 0 \n | |\n 0 0 \n INDEX: SYSIBM INDEX: RM1ADMIN\n SQL130130132712470 TRAN_TMP_ID_X0\n Q1 Q1<\/pre><\/div><p>从清单 3 左下部分中我们可以看到，查询的访问计划已经转而使用我们希望的主键索引和索引 TRAN_TMP_ID_X0 做索引查询。<\/p><p>由于资源数据库的应用是部署在 WAS 上的，在 DB2 服务端设置完后，需要对 WAS 端进行设置，使得 WAS 连接数据库的应用使用\n                PMR35104.PROF1。<\/p><h5 id=\"img001\">图 1. WAS 应用 OPTPROFILE<\/h5><img alt=\"图 1. WAS 应用 OPTPROFILE\" src=\"/sunshine_new/images/586795776/img001.png\" width=\"583\" /><p>添加定制属性：<\/p><p>属性名：optimizationProfile <\/p><p>属性值：PMR35104.PROF1<\/p><p>定制完成后，需要重启 WAS 服务器。<\/p><p>结论：在使用了 DB2 的 OPTPROFILE 的方法之后，进行测试后发现开启单个 WAS 集群应用服务器后数据库服务器的 CPU 使用率在\n                5%左右，4 个应用服务器同时启动后，CPU 使用率大约在 20%左右，网络的吞吐量能达到 400-500MB/秒, 迁移数量每个应用服务器都为\n                800 笔/秒左右，完全能满足客户的业务需求。<\/p><h3 id=\"major4\">问题二. CM 装载存在孤儿数据<\/h3><p>如前文所述，客户系统中每天白天需要装载 400 万图片项，有 10 台客户端上载程序同时工作上传，每台客户机有 10 个进程同时上载，也就是总共有\n                100 个进程同时上载文档图片，并且使用 4 组 WAS ND 集群服务器，每个集群包含 4\n                个节点。在批量上载过程中，每导入几千万的数据，总会有一些孤儿数据产生，经过分析，这些孤儿数据产生的原因是，产生问题的几条数据，每条数据对于同一个上载任务，有时间很近的两条上载任务向资源服务器发出请求，虽然由于主键约束系统会拒绝其中的一条，但实际进入的一条时间戳会产生不一致，检验工具会把这条数据标记为孤儿数据。经过诊断分析，CM\n                本身不会对同一条上载记录做重复上载命令，最终认定是由于 RM 使用集群，IHS 使用安装时默认的转发功能导致，建议将 IHS\n                上的重新转发功能取消。具体表现为同一个请求在一个节点上执行超时（默认为 60 秒），IHS\n                可能将该请求转发不同的节点上，而不同节点上的数据信息不一致，导致 CM 报错并产生脏数据（包括孤儿数据）。对 WAS 的具体修改如下：<\/p><ol type=\"1\"><li> 修改 IHS 的配置文件 plugin-cfg.xml，将其中的 ServerIOTimeout=\"60\"\n                    、PostBufferSize=\"64\"修改为 ServerIOTimeout=\"300\"\n                    、PostBufferSize=\"0\"。这样设置表示，IHS 上的请求在 300 秒内没有收到 WAS\n                    的响应，不会自动进行转发，会报超时错误。<\/li><li> 修改 WAS 应用服务器的 ServerIOTimeout 参数（读/写超时）的值为 0，即读写超时时不转发请求。 <h5 id=\"img002\">图 2. WAS 修改读写超时<\/h5><img alt=\"图 2. WAS 修改读写超时\" src=\"/sunshine_new/images/586795776/img002.png\" width=\"553\" /><\/li><li> 修改 CM 库数据库 ICMNLSDB 的 ICMSTSYSCONTROL.MAXTXDURATION 字段，默认是 86400（24\n                    小时），将其修改为较小值，IBM 建议不低于 7200 (2 小时)。该值表示 CM 事务执行的间隔等待时间。（update\n                    ICMSTSYSCONTROL set MAXTXDURATION = 7200 where LIBRARYSERVERID =\n                    1）<\/li><\/ol><p>结论：通过优化后的性能测试验证，该设置起效，CM 多线程并发装载再没有出现脏数据。<\/p><h2 id=\"major5\">小结<\/h2><p>通过本文第 2 部分的介绍，我们可以了解 CM 高吞吐高并发实例系统中几个特殊疑难问题的分析和解决方法。<\/p><h2 id=\"major6\">特别感谢<\/h2><p>特别感谢广东农信杨韶宁经理、苏汉槟经理对项目和文章的巨大支持和帮助，并对 IBM\n                参与此项目设计和问题解决的徐军、纪海、李永亮、陈宁、刘健、殷卓、胡金培、沈鑫等同事表示感谢。<\/p><h2 id=\"major7\">免责声明<\/h2><p>本文中任何带有主观性的陈述都只代表本书作者个人的观点，不代表 IBM\n                公司的官方立场。本文是对某个银行客户实例系统的分析和介绍，可以作为类似系统的参考，但是要注意，每一个系统都有自己独特的需求和实际情况，本文并不能提供适应这些系统通用模式，各个系统还是要根据自己的需求去设计架构模型和实现。<\/p><CMA ID: 975346><Site ID: 10><XSLT stylesheet used to transform this file: dw-document-html-7.0.xsl>\r\n\r\n\r\n<\/div>\r\n<\/div>\r\n","createTime":"2014-06-26 00:00:00","deployTime":"2014-06-26 00:00:00","id":0,"intro":"大数据量和高吞吐是银行内容管理系统长期设计的核心问题，本文通过内容管理系统在农信银行后督系统的设计和实现实例 (基于 DB2V97 数据库)，描述对于内容管理系统如何针对每天大约 400 万个图片、可能存放 15 年达到 2PB 文件规模的大数据量系统进行数据模型设计、表分区以及压缩的具体设计实现，以及系统在高并发下一些实际问题的处理，系统上线后吞吐量和性能得到了客户的认可，可以为类似的银行系统提供重要的参考。","keyword":"","recommend":false,"source":"http://www.ibm.com/developerworks/cn/data/library/bd-1406-bankimagedesign-part2/index.html","title":"银行影像内容大数据系统的设计以及实例问题分析，第 2 部分: 实例问题分析篇","typeId":0,"updateTime":"2014-06-26 00:00:00"}
{"author":"","clickNumber":0,"content":"\r\n<div class=\"ibm-columns\">\r\n<div class=\"ibm-col-1-1\">\r\n\r\n<h2 id=\"major1\">前言<\/h2><p>本文是对使用 IBM 内容管理系统为平台的广东农信银行客户后督系统的分析和介绍，以及对大数据量和高吞吐的基于 DB2 数据库的 IBM Content\n                Manager\n                系统的一些设计上的分析以及一些实际问题的解决，系统在调优后性能和吞吐量满足的客户的需求，可以作为类似系统的参考，但是要注意，每一个系统都有自己独特的需求和实际情况，本文无法涵盖您在系统建设过程中的所有问题，欢迎联系我们做进一步探讨。另外，将来实际系统中在数据量达到一定量级时，可能会碰到新的难题，我们希望能和客户一起协作解决并将经验分享给大家。第一部分,\n                我们将着重介绍系统背景需求以及设计。<\/p><h2 id=\"major2\">中英文术语对照表/缩略语<\/h2><p>IBM 内容管理系统：英文名 IBM Content Manager，简称 CM。<\/p><p>广东农信影像化事后监督系统：简称广东农信后督系统。<\/p><p>库数据库：英文名 Library server database，简称 LSDB。<\/p><p>资源数据库：英文名 Resource manager database，简称 RMDB。<\/p><p>资源管理应用程序：英文名 Resource manager application，简称 RMApp。<\/p><p>项类型：英文名 Itemtype。<\/p><p>资源项类型：英文名 Resource itemtype。<\/p><p>文档项类型：英文名 Document itemtype。<\/p><p>项：英文名 Item。<\/p><p>项级别：英文名 Item Level。<\/p><p>访问控制列表：英文名 Access control list，简称 ACL。<\/p><p>本地索引：英文名 Local index。<\/p><p>表分区分离：英文名 Detach partition。<\/p><p>级联目录：英文名 Hierarchical folder。<\/p><h2 id=\"major3\">系统及架构简述<\/h2><p>IBM\n                内容管理系统，是一套基于数据与内容的企业级整体行业解决方案平台，它能够帮助企业快速地解决复杂的问题，在当今瞬息万变的市场环境中更快速地制定高效的决策。客户可以利用\n                IBM\n                内容管理系统产品方便的做到：对各种原始票据、凭证、档案、影像等海量的非结构化数据的存储和管理；数据的生命周期管理；并且可以支持基于内容的分析与查找，高级案例管理，和流行的社交内容管理。<\/p><p>广东农信影像化事后监督系统是提供给全省各农合机构事后监督中心和网点使用，是监督各项业务处理的正确性、合规性、真实性和完整性，及时发现各种核算差错事故，暴露业务核算中发生的各种违章、违纪、违法行为，完善业务操作风险控制体系，实现差错处理的电子化流转，实现凭证的电子化管理的一整套管理系统。系统主要包括影像处理、重点监督、再监督、风险预警、差错处理流程管理，实物档案流程管理等功能，使用\n                IBM 内容管理平台实现对影像数据存储的生命周期管理，满足用户对大数据量历史影像数据的实时在线调阅需求。<\/p><p>经过前期的数据收集和业务估算，广东农信后督系统全省上线后，日均凭证影像张数将达到 400 万张，最近 60\n                天的凭证影像经常会发生调整、修改信息、整改差错的业务操作。而从系统建设层面考虑，日均 400\n                万张的凭证影像将导致系统的记录数和数据量非常庞大，需要考虑多个影像文件打包成一个大文件后部份读取的可能性，恰好 CM\n                的聚合迁移支持这种打包操作。如果按照会计档案需保管十五年的要求，广东农信后督系统影像文件的总存储空间将达到\n                2PB，为保证数据的读取效率同时兼顾项目建设成本，广东农信规划了如下的后督系统影像文件总体存储策略：<\/p><table border=\"0\" cellpadding=\"0\" cellspacing=\"0\" class=\"ibm-data-table\"><thead xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"><tr><th><strong>存储宿主<\/strong><\/th><th> 后督系统<br /> （10 台文件服务器） <\/th><th> CM 在线<br /> （LBOSDATA） <\/th><th> CM 近线<br /> （CM TSM 存储卷） <\/th><th> CM 离线<br /> （CM TSM 磁带卷） <\/th><\/tr><\/thead><tbody xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"><tr><td><code><strong>存储介质<\/strong><\/code><\/td><td> SAN 存储 <\/td><td> NAS 存储 <\/td><td> NAS 存储 <\/td><td> 磁带库 <\/td><\/tr><tr><td><strong>存储期限<\/strong><\/td><td> 60 天 <\/td><td> 7 天 <\/td><td> 22 个月 <\/td><td> 如果按照会计档案需保管十五年的要求，那么 CM 离线数据的存储期限将达到 13 年 <\/td><\/tr><tr><td><strong>存储模式<\/strong><\/td><td> 同一日期同一网点同一柜员几百张影像形成的一个大数据包 <\/td><td> 具体一张一张的影像 <\/td><td> CM 聚合迁移形成的 300 张影像一个文件的大数据包 <\/td><td> CM 聚合迁移形成的 300 张影像一个文件的大数据包 <\/td><\/tr><\/tbody><\/table><p>根据广东农信后督系统的实际使用需求，广东农信还规划了影像数据的生命周期管理时间窗口要求，具体为：后督系统影像文件装载至 CM（两个小时）? CM\n                影像文件迁移至 TSM（两个小时）? TSM 存储卷迁移至磁带卷（四个小时）。<\/p><p>针对广东农信后督系统影像文件的总体存储策略和影像数据生命周期管理的时间窗口要求，结合后督系统、CM 内容管理平台的扩展性（除了 CM\n                的索引库不能扩展，其他都可以扩展），加上 IBM 工程师的指导，广东农信设计了满足此高吞吐大数据量的 CM 系统架构。<\/p><p>具体为：<\/p><p>CM 数据库服务器采用 HA(High Available) 架构，每个数据库服务器节点包含 1 个库数据库和 4\n                个资源数据库、每个资源数据库对应的资源管理应用程序采用 WAS cluster 架构，保证资源管理应用程序的并发性和扩展性，每个 WAS\n                cluster 由一个 Dmgr 管理并分配 2 台物理服务器，每个物理服务器节点下有两个应用服务器，这样对于每个 WAS cluster\n                共四个应用服务器。同时，整套 CM 系统内部采用万兆网连接，TSM(Tivoli Storage Manager) 服务器也采用 HA\n                架构，确保影像数据生命周期管理的时间窗口要求以及高可用要求。下图 1 展示了一个内容管理系统比较通用基于 AIX 的 HA 系统架构图 (包含多个\n                RM 和 RMApp)：<\/p><h5 id=\"img001\">图 1. 系统架构图<\/h5><img alt=\"图 1. 系统架构图\" src=\"/sunshine_new/images/309913341/img001.png\" width=\"581\" /><h2 id=\"major4\">数据模型的选型以及表分区的设计<\/h2><p>根据计算，广东农信后督系统如果满负荷上线，大约每天需要装载 400 万条数据，每月 1.1 亿，每年约 13 亿数据，IBM\n                内容管理系统的一些表会相应的有这个数量级的记录，如此大的表会带来可能的一些问题，比如维护 (备份、Runstats、Reorg 等)\n                时间长等。另外当数据量达到一定的量级时，整个系统也可能会有一定的性能下降。我们要从数据模型设计以及数据库逻辑物理设计上尽量降低这种发生的可能性，或者能支持更大量的数据，比如银监会要求的\n                15 年数据。首先，我们根据业务的需要去设计数据模型，以下是几点可供参考的考虑：<\/p><ul class=\"ibm-bullet-list\"><li> 选择合适的项类型<\/li><\/ul><p>内容管理系统支持两种主要带文件的项类型：资源项类型和文档项类型。资源项类型相对简单，每个项只能带一个文件，但是相对文档项类型来说，每一个资源项类型可以减少操作至少\n                2 张大表，相对应的在超过 10\n                亿的海量数据量的系统来说，同样的设计，装载和其他业务的效率会更高，也更能节省空间，同时降低维护时间，所以对于海量数据的系统，如果能满足业务需求，我们更建议使用资源项类型存放扫描的文件。另外，对于需要建立多个类似项类型的设计，建议把一些共用的属性先建立一个属性组存放起来，这样能更方便的建立项类型。<\/p><ul class=\"ibm-bullet-list\"><li> 资源数据库均衡负载设计<\/li><\/ul><p>对于多个营业网点的数据，有时候为了便于管理，希望通过一定的机制把不同的营业网点的数据通过不同的资源管理应用程序导入到不同的资源数据库里，这样便于权限管理和分担一定的负载。我们可以把库数据库的默认存储设置为用户级别，如图\n                2 所示，然后为每一个营业网点或网点组建立一个装载用户，为每一个装载用户设置一个默认的 Collection\n                和相应的默认项访问控制列表，然后对于新建的项类型，选择使用项级别的检查级别，并使用用户默认 ACL 检查 (User’s default\n                ACL)，参考图 3，然后用相应的用户做装载数据，就可以控制数据装载在不同的资源数据库。<\/p><ul class=\"ibm-bullet-list\"><li> 建立合适索引<\/li><\/ul><p>对于业务查询常用的属性项，需要建立相应的索引以加快查询和获取数据的速度。<\/p><ul class=\"ibm-bullet-list\"><li> 减少不必要的关系<\/li><\/ul><p>如果没有需求，可以不建立目录、连接、引用、级联目录等复杂的关系，这些都会影响将来可能会实现的表分区分离的可能性。<\/p><ul class=\"ibm-bullet-list\"><li> 文件聚合迁移到 TSM<\/li><\/ul><p>如果对文件没有修改的需求，并且都是最大几兆的小文件，大数据影像系统可以考虑使用 CM\n                提供的聚合迁移功能，聚合迁移会将文件按照打包大小的设置进行打包后迁移到 TSM 中，会大大减少过量小文件产生的网络问题和 TSM\n                服务器的压力，并大大降低 TSM 数据库的数据量和维护成本。<\/p><h5 id=\"img002\">图 2. 库数据库默认存储设置<\/h5><img alt=\"图 2. 库数据库默认存储设置\" src=\"/sunshine_new/images/309913341/img002.jpg\" width=\"581\" /><h5 id=\"img003\">图 3. 项级别 ACL 检查以及用户默认 ACL 设置<\/h5><img alt=\"图 3. 项级别 ACL 检查以及用户默认 ACL 设置\" src=\"/sunshine_new/images/309913341/img003.png\" width=\"554\" /><p>另外，对于可预见的大表将来的使用和维护，我们建议使用 DB2V97FP1 以上的表分区方案，好处是可以更好的分时间段存放数据，更灵活的分配物理资源\n                (盘阵等)，同时可以利用 DB2V97FP1\n                之后支持的表分区中的本地索引减少维护的时间空间，对于业务模型合适的系统，将来甚至可以做到将超过一定时间不常用或者只读的数据从在线业务系统之中分离出去，然后导入到另一个内容管理系统中，降低在线系统的数据量。对于表分区的设计，我们已经有相应的白皮书和文章\n                    (请参考<a href=\"#_参考资源_(resources)\">参考资源<\/a>)\n                做了系统的介绍，本文这里只介绍一下广东农信的现在应用的实例，也就是在 CM843 系统里对于一个只包含一个资源项类型的实例系统的表分区设计。<\/p><ol type=\"1\"><li> 首先找到固定的大表 <p>固定的大表包括库数据库的 ICMSTITEMS001001 和资源数据库的 RMOBJECTS\n                    表。<\/p><\/li><li> 其次找可能的大表 <p>对于激活了历史版本文档的设计，库数据库需要增加大表 ICMSTITEMVER001001\n                        表，对于使用的连接关系的表 (比如使用了目录文档结构) 需要增加大表 ICMSTLINKS001001\n                        表，如果使用了文档类型的项类型，需要增加大表 ICMUT00300001 表和 ICMRI001001\n                        表，如果使用了级联目录关系，那么需要增加大表 ICMSTHLINKS 表。<\/p><\/li><li> 动态表名的大表 <p>下面介绍一下如何找到一个具体项类型元数据实例表。<\/p><div class=\"codesection\"><pre class=\"displaycode\">--取得 Itemtype ID，假设项类型名字是 ITNAME1\nselect keywordcode from icmstnlskeywords where keywordclass=2 and keywordname ='\nITNAME1'\n--取得 ComponentType ID\nselect * from icmstcompdefs where itemtypeid = '1004';<\/pre><\/div><p>注意：1004 应该是第一步取得的值，请用实际值替换。假如 COMPONENTTYPEID 实际值是 1007，项组件类型实例表就为\n                        ICMUT01007001。有几个 COMPONENTTYPEID，就对应有几张 ICMUT0XXXX001 表，其中 XXXX 为\n                        COMPONENTTYPEID。<\/p><\/li><li> 表分区分区频率设计 <p>根据内容管理系统数据库的特点，上述大表都有包含有时间戳的 ITEMID 字段或者类似字段，以及 DB2\n                        对表分区键选取按时间分区的建议，我们可以选取 ITEMID\n                        或者类似的字段作为表分区的分区键，表分区可以按一定时间间隔分区，比如按月分区、按季度分区、按年分区等，对于一个月有 1\n                        亿数据量的系统来说，我们可以选取一个月一个分区的设计。<\/p><\/li><li> 表分区初始分区以及结束分区的考虑\n                        <p>分区并不是无限的，所以总会有开始分区并且有结束分区，那么我们又希望结束分区不要包含太多时间段的数据，那么最好先和客户沟通一个第一次做表分区的时间段，比如客户希望系统至少运行\n                        10 年，以 2013 年 1 月到 2022 年 12 月为例，我们先要为 0-2013 年 1 月 1 日 (不包含结束日期)\n                        建立初始分区，这个初始分区包含内容管理系统的一些初始数据和可能的临时数据，假设命名为\n                        PSTART。然后中间是每个月一个分区一直建立到 2023 年 1 月 1 日 (同样不包含结束日期)，最后需要建立一个结束分区\n                        (如名字为 PEND) 从 2023 年 1 月 1 日一直到 MAX(最大时间)\n                        作为封尾分区。需要注意的是，如果在系统使用年限接近到达第一次划分预期的结尾时间时，比如提前 1 年的 2021\n                        年底选取业务空闲时期停止业务，分离现有封尾分区 PEND, 创建新的 5\n                        年或者其他年数的表分区，然后用新的预期系统最终使用时间一直到 MAX 重新封尾。<\/p><\/li><li> 表分区中用户自定义的索引设计\n                        <p>如果用户的数据模型中需要对一些字段做检索，最好使用系统管理客户端去为这些字段建立相应的索引，这样索引内就会自动加入\n                        ITEMID\n                        作为索引的一部分，这样就可以使用本地索引，这样会对分区维护和性能对会有好处。如果用户想自己使用数据库命令为数据模型的相关实例表建立自己的索引，应该在\n                        IBM 服务团队的支持下进行，对于表分区的情况，建议尽量在索引定义中加入 ITEMID\n                    字段，当然具体情况需要具体分析。<\/p><\/li><li> 表及索引压缩\n                        <p>对于有海量数据的表，在做表分区的同时可以考虑做表的压缩，也可以考虑同时压缩索引，这样会降低磁盘的使用空间，对于瓶颈主要在\n                        I/O 而 CPU 资源充足的系统，表压缩也会以牺牲一定量 CPU 资源的情况下减少 I/O\n                        占用，理论上会产生一定好的效果，实际情况，应该根据性能测试是否满足客户需要去决定最终的方案。<\/p><\/li><li> 表空间及缓冲池设计\n                        <p>为表分区的数据和索引分别建立独立的表空间和缓冲池。为索引建立单独的缓冲池好处是，对于海量数据调整数据表空间所在的缓冲池无法调优的情况下，单独调整需要内存较小的索引表空间所在的缓冲池，可能会有比较好的效果。另外即使使用了条带化的磁盘阵列作为数据库物理存储，已经可以做到将数据打散到不同的磁盘已达到\n                        I/O 并行访问的效果，我们还是建议为数据和索引建立不同的表空间\n                        (组)，这样方便维护和管理，比如可以对每年或者每季度的表分区建立一个或几个数据表空间，为所有大表的索引每年建立一个表空间。<\/p><\/li><\/ol><h2 id=\"major5\">ICMSTITEMS001001 表分区示例<\/h2><p>我们下面以库数据库里存放所有项基本信息的大表 ICMSTITEMS001001 表为例介绍按月分表分区 (2013 年和 2014 年共 2 年)\n                的示例，其他大表的表分区可以类似去设计和撰写。<\/p><p>首先，创建存储过程 SET_CONSTRAINTS 可以暂时不检查外键，便于数据表重建。<\/p><div class=\"codesection\"><pre class=\"displaycode\">db2 connect to icmnlsdb user icmadmin using icmadmin\ndb2 Ctd@ -vf set_constraints.sql<\/pre><\/div><p>其次，为 ICMSTITEMS001001\n                所在的库数据库增大部分缓冲池，并增加一个索引单独使用的缓冲池。注意下列所有缓冲区具体每个缓冲区的大小需要根据你系统实际可以分配给库数据库的内存大小去调整。<\/p><div class=\"codesection\"><pre class=\"displaycode\">--为数据表空间调整现有 bufferpool\nALTER BUFFERPOOL ICMLSMAINBP32 IMMEDIATE SIZE 120000;\nALTER BUFFERPOOL ICMLSFREQBP4 IMMEDIATE SIZE 32768;\nALTER BUFFERPOOL ICMLSVOLATILEBP4 IMMEDIATE SIZE 65536;\n--增加新的 bufferpool 为了索引表空间\nCREATE BUFFERPOOL ICMLSIDXBP32 SIZE 60000 PAGESIZE 32 K<\/pre><\/div><p>第三，为 ICMSTITEMS001001 表及其他类似的大表创建单独数据表空间，每年都会用一个表空间存放。表数据将会存放到\n                LSSTPART20YY(YY 表示年号的后两位，下同) 表空间，索引将会存放在 LSIDXPART20YY 表空间。<\/p><div class=\"codesection\"><pre class=\"displaycode\">--为所有非 2013，2014 年数据建立默认数据表空间\nCREATE LARGE TABLESPACE LSSTPART\n PAGESIZE 32 K MANAGED BY DATABASE\n USING (FILE '/home/db2inst1/db2inst1/ICMNLSDB/LSSTPART' 100M)\n AUTORESIZE YES MAXSIZE NONE \n EXTENTSIZE 32\n BUFFERPOOL ICMLSMAINBP32;\n--建立 2013 年以及 2014 年数据表空间\nCREATE LARGE TABLESPACE LSSTPART2013\n PAGESIZE 32 K MANAGED BY DATABASE\n USING (FILE '/home/db2inst1/db2inst1/ICMNLSDB/LSSTPART2013' 10G)\n AUTORESIZE YES MAXSIZE NONE \n EXTENTSIZE 32\n BUFFERPOOL ICMLSMAINBP32;\nCREATE LARGE TABLESPACE LSSTPART2014\n PAGESIZE 32 K MANAGED BY DATABASE\n USING (FILE '/home/db2inst1/db2inst1/ICMNLSDB/LSSTPART2014' 10G)\n AUTORESIZE YES MAXSIZE NONE \n EXTENTSIZE 32\n BUFFERPOOL ICMLSMAINBP32;\n--为所有非 2013，2014 年索引建立默认索引表空间\nCREATE LARGE TABLESPACE LSIDXPART\n PAGESIZE 32 K MANAGED BY DATABASE\n USING (FILE '/home/db2inst1/db2inst1/ICMNLSDB/LSIDXPART' 1G)\n AUTORESIZE YES MAXSIZE NONE \n EXTENTSIZE 32\n BUFFERPOOL ICMLSIDXBP32;\n--建立 2013 年以及 2014 年索引表空间\nCREATE LARGE TABLESPACE LSIDXPART2013\n PAGESIZE 32 K MANAGED BY DATABASE\n USING (FILE '/home/db2inst1/db2inst1/ICMNLSDB/LSIDXPART2013' 1G)\n AUTORESIZE YES MAXSIZE NONE \n EXTENTSIZE 32\n BUFFERPOOL ICMLSIDXBP32;\nCREATE LARGE TABLESPACE LSIDXPART2014\n PAGESIZE 32 K MANAGED BY DATABASE\n USING (FILE '/home/db2inst1/db2inst1/ICMNLSDB/LSIDXPART2014' 1G)\n AUTORESIZE YES MAXSIZE NONE \n EXTENTSIZE 32\n BUFFERPOOL ICMLSIDXBP32;<\/pre><\/div><p>第四，生成 ICMSTITEMS001001 分区前表的定义。<\/p><div class=\"codesection\"><pre class=\"displaycode\">db2look -d icmnlsdb -i icmadmin -w icmadmin -e -t ICMSTITEMS001001 -o items_part.sql<\/pre><\/div><p>第五，修改 items_part.sql，为每个表每个月建立表分区，总共创建到 2014 年底共 2 年的表分区。修改后的代码见附件\n                items_part.sql。<\/p><p>以此为范例，我们可以类似的为所有需要分区的表定义和设计不同分区年数，分区使用的缓冲池，表空间以及分区频率等。<\/p><h2 id=\"major6\">小结<\/h2><p>通过本系列第 1 部分的介绍，我们可以了解到如下知识：<\/p><ol type=\"1\"><li> 银行后督实例系统的业务需求和大数据量高吞吐以及相关性能的非业务需求。<\/li><li> 应对实例系统的高吞吐的系统架构和数据模型设计。<\/li><li> 应对实例系统的大数据量数据的表分区的设计和示例。<\/li><\/ol><p>通过本系列第 1 部分介绍的方案及设计，可以对高吞吐大数据方面有要求的 CM 系统的设计有所帮助。在接下来的<a href=\"http://www.ibm.com/developerworks/cn/data/library/bd-1406-bankimagedesign-part2/index.html\">第 2\n                部分<\/a>里面，我们将着重介绍一些高吞吐高并发 CM 系统中出现的一些问题的分析和解决方法。<\/p><h2 id=\"major7\">特别感谢<\/h2><p>特别感谢广东农信杨韶宁经理、苏汉槟经理对项目和文章的巨大支持和帮助，并对 IBM\n                参与此项目设计和问题解决的徐军、纪海、李永亮、陈宁、刘健、殷卓、胡金培、沈鑫等同事表示感谢。<\/p><h2 id=\"major8\">免责声明<\/h2><p>本文中任何带有主观性的陈述都只代表本书作者个人的观点，不代表 IBM\n                公司的官方立场。本文是对某个银行客户实例系统的分析和介绍，可以作为类似系统的参考，但是要注意，每一个系统都有自己独特的需求和实际情况，本文并不能提供适应这些系统通用模式，各个系统还是要根据自己的需求去设计架构模型和实现。<\/p><CMA ID: 975350><Site ID: 10><XSLT stylesheet used to transform this file: dw-document-html-7.0.xsl>\r\n<h2 id=\"download\">下载<\/h2><table class=\"ibm-data-table&#10;                    dw-download-table\" cellpadding=\"0\" cellspacing=\"0\" border=\"0\"><thead><tr><th scope=\"col\">描述<\/th><th scope=\"col\">名字<\/th><th scope=\"col\">大小<\/th><\/tr><\/thead><tbody><tr><th scope=\"row\" class=\"ibm-table-row\">set_constraints.sql<\/th><td nowrap=\"nowrap\"><a href=\"http://www.ibm.com/developerworks/apps/download/index.jsp?contentid=975350&amp;filename=set_constraints.sql&amp;method=http&amp;locale=zh_CN\">set_constraints.sql<\/a><\/td><td nowrap=\"nowrap\">2k<\/td><\/tr><tr><th scope=\"row\" class=\"ibm-table-row\">items_part.sql<\/th><td nowrap=\"nowrap\"><a href=\"http://www.ibm.com/developerworks/apps/download/index.jsp?contentid=975350&amp;filename=items_part.sql&amp;method=http&amp;locale=zh_CN\">items_part.sql<\/a><\/td><td nowrap=\"nowrap\">6k<\/td><\/tr><\/tbody><\/table>\r\n\r\n<\/div>\r\n<\/div>\r\n","createTime":"2014-06-26 00:00:00","deployTime":"2014-06-26 00:00:00","id":0,"intro":"大数据量和高吞吐是银行内容管理系统长期设计的核心问题，本文通过内容管理系统在农信银行后督系统的设计和实现实例 (基于 DB2V97 数据库)，描述对于内容管理系统如何针对每天大约 400 万个图片、可能存放 15 年达到 2PB 文件规模的大数据量系统进行数据模型设计、表分区以及压缩的具体设计实现，以及系统在高并发下一些实际问题的处理，系统上线后吞吐量和性能得到了客户的认可，可以为类似的银行系统提供重要的参考。","keyword":"","recommend":false,"source":"http://www.ibm.com/developerworks/cn/data/library/bd-1406-bankimagedesign-part1/index.html","title":"银行影像内容大数据系统的设计以及实例问题分析，第 1 部分: 设计篇","typeId":0,"updateTime":"2014-06-26 00:00:00"}
{"author":"","clickNumber":0,"content":"\r\n<div class=\"ibm-columns\">\r\n<div class=\"ibm-col-1-1\">\r\n\r\n<h2 id=\"1.IBM’sinvestmentinLinux|outline\">IBM 对 Linux 的投资<\/h2><p>您可能已经听说过 IBM Watson。如果没有，请 <a href=\"https://www.ibm.com/smarterplanet/us/en/ibmwatson/\">了解一下 IBM\n                    Watson<\/a>，因为它真的是一项突破性的技术成就。通过汇总来自 <em>The Atlantic<\/em> 文章的一些想法，IBM\n                    估计，Watson 每秒可以处理多达 6 千万页的文本。而这些文本只是普通的、简单的文字。它完全是非结构化的数据，目前 IT\n                    系统需要处理的现有信息中大约 80％ 都是这样的数据。令人惊奇的是，无论是演讲还是手写笔记的口述，Watson\n                    几乎可以理解任何自由形式的信息源。它实际上可以学习，而且学得相当快。最初，它被用来打败 Jeopardy\n                    的冠军，现在它被定位用于协助患者的医疗诊断、改善客户服务、创作新的厨师食谱和其他一些有趣的、以前无法克服的挑战。其中一些挑战显然极为重要，而另一些只是有趣和具有挑战性的应用程序，它们很可能在未来具有高度的战略意义。Watson 独特的<em>适应<\/em> 能力是：当绝对数据量与它的处理能力不匹配时，它会摇头。   <\/p><p>当涉及比特和字节时，Watson 是什么？当然，它是一系列聪明的软件组件的集合，具有创新的算法，但底层硬件基础架构是什么呢？您知道它是一台 IBM 计算机，但具体来说，它是一台 IBM Power Systems&#8482; 服务器。更具体地讲，它在运行 Linux on Power。 <\/p><p>所以，问题就变成，如果该组合可用于创建 Watson，那么它能做到我要求它做的事吗？<\/p><p>首先，IBM 对 Linux on Power 有多重视？IBM 非常重视 Linux on Power，以至于在 2013 年 9 月承诺对其投资 10 亿美元。该投资主要针对 Linux&#174; 和开源工作负载解决方案，IBM 在过去十年中还有对一系列广泛的开放计划进行了大量投资。重要的是要知道一点，它不只是来自 IBM 的投资。这是来自 IBM 的 Power Systems 品牌的专项投资。 然而，重要的是要注意，单靠资金并不能让计划成功。从经验丰富的资源获得技能是必需的，IBM 已经重新分配很多有高度积极性的销售和技术资源，完全集中于 Linux 和 Power，以及他们可以共同处理的解决方案。IBM 也销售软件 - 许多软件。您可以相信，大多数的软件在 Linux on Power 上都可以运行。您可以进一步假设这些应用程序已经过优化，可以在该平台上非常高效地运行。<\/p><p>让我们来看看一些具体细节。<\/p><p>IBM 销售的每一台 Power Systems 服务器都可以运行 Linux。事实上，IBM 销售的每一台服务器都可以运行 Linux，包括 Red Hat 和 SUSE。需要明确的是，这里所说的 Linux 与在 x86 上运行的 Linux 相同。其构建源与 x86 相同，按相同的时间表交付，并在同一时间获得支持。是什么使得它在 Power 上表现<em>更好<\/em> 呢？我们将在后面详细讨论这一点，但我们要讨论的是一些基本概念，比如性能、可靠性、虚拟化和价格。IBM 认为，这些基本概念是具有吸引力的优势 - 因此该承诺也是。<\/p><p>IBM 还在哪些其他方面对 Linux 进行了投资呢？<\/p><p>我们在美国、欧洲和亚洲建立了人员配备齐整的 <a href=\"https://www.ibm.com/linux/ltc/\"><strong>Linux 技术中心<\/strong><\/a>，为客户、独立软件供应商 (ISV)、系统集成商和托管服务提供商提供了大量的资源。在这些中心提供的服务包括技术讲座、培训、移植和迁移帮助、基准测试，等等。<\/p><p>IBM 还创建了工具和流程，支持 Linux 使用 IBM Power 技术。这样的例子有：<\/p><p><a href=\"https://www.ibm.com/developerworks/community/wikis/home?lang=en#!/wiki/W51a7ffcf4dfd_4b40_9d82_446ebc23c550/page/IBM Advance Toolchain for PowerLinux Documentation\"><strong>Advance Toolchain<\/strong><\/a>：是一套开源开发工具和运行时库，使用户可以充分利用 IBM Power 硬件特性。由 IBM 捆绑、测试和支持硬件<\/p><p><a href=\"https://www-304.ibm.com/webapp/set2/sas/f/lopdiags/sdklop.html\"><strong>Software Development Kit (SDK)<\/strong><\/a>：是在单一 GUI 环境中的重要 Linux 和 IBM 工具的集成。它包括代码扫描器，在从 x86 到 Power 的移植期间提出修改建议，以提高性能（免费）。<\/p><p><a href=\"https://www.ibm.com/linux/migrate.html\"><strong>Migration Factory<\/strong><\/a>：当迁移到 Linux 时，具有细致的、经过测试的流程的可信合作伙伴是一个重要要求。IBM 已经历过使用 <em>The Migration Factory<\/em> 将数千客户迁移到 IBM 系统上的 Linux。它使用 25 年来精心提炼的五步流程，帮助客户迁移到运行任何受支持操作系统（包括 Linux）的 IBM 系统上。<\/p><p>Watson 的基础架构以 Power 750 服务器为基础。这是一个可以直接融合在我们的 Power Systems 系列中的产品。您可以在以下图表中看到详细的产品，并且可以确信，在其中一个服务器上运行的任何应用程序可以在任何一个这些服务器上运行。 <\/p><h5 id=\"N100B3\">图 1. IBM POWER7 产品组合<\/h5><img alt=\"IBM POWER7 产品组合\" src=\"/sunshine_new/images/31848298/image001.jpg\" width=\"576\" /><p>IBM 的 Power 部门坚信，他们能够利用这一产品组合满足任何客户的要求。请了解其多样性：  <\/p><ul class=\"ibm-bullet-list\"><li>低成本的向外扩展服务器，比如 Power 710 和 Power 720<\/li><li>仅限 Linux 的服务器（专用于 Linux），比如 7R1 和 7R2<\/li><li>具有无与伦比的性能的高端企业服务器，类似于 Power 780 和 Power 795<\/li><\/ul><p>值得一提的最后一个方面是，IBM 对开源社区的贡献水平。这可能让很多人感到惊讶，但以下是由那些专注于 Linux 的公司所完成的更改（<em>贡献<\/em>）数量的部分列表。 <\/p><p><strong>(2005-2012)<\/strong><\/p><h5 id=\"N100D7\">表 1. 公司对 Linux 的贡献<\/h5><table border=\"0\" cellpadding=\"0\" cellspacing=\"0\" class=\"ibm-data-table\" summary=\"\"><thead xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"><tr><td style=\"text-align:left; vertical-align:top\"><strong>公司名称<\/strong><\/td><td style=\"text-align:left; vertical-align:top\"><strong>更改数量<\/strong><\/td><td style=\"text-align:left; vertical-align:top\"><strong>占总数的百分比<\/strong><\/td><\/tr><\/thead><tbody xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"><tr><td style=\"text-align:left; vertical-align:top\">\n无（个人）\n<\/td><td style=\"text-align:left; vertical-align:top\">\n46,982\n<\/td><td style=\"text-align:left; vertical-align:top\">\n17.9%\n<\/td><\/tr><tr><td style=\"text-align:left; vertical-align:top\">\nRedHat\n<\/td><td style=\"text-align:left; vertical-align:top\">\n31,261\n<\/td><td style=\"text-align:left; vertical-align:top\">\n11.9%\n<\/td><\/tr><tr><td style=\"text-align:left; vertical-align:top\">\nNovell\n<\/td><td style=\"text-align:left; vertical-align:top\">\n16,738\n<\/td><td style=\"text-align:left; vertical-align:top\">\n6.4%\n<\/td><\/tr><tr><td style=\"text-align:left; vertical-align:top\">\nIntel\n<\/td><td style=\"text-align:left; vertical-align:top\">\n16,219\n<\/td><td style=\"text-align:left; vertical-align:top\">\n6.2%\n<\/td><\/tr><tr><td style=\"text-align:left; vertical-align:top\"><strong>IBM<\/strong><\/td><td style=\"text-align:left; vertical-align:top\"><strong>16,073<\/strong><\/td><td style=\"text-align:left; vertical-align:top\"><strong>6.1%<\/strong><\/td><\/tr><tr><td style=\"text-align:left; vertical-align:top\">\nUnknown\n<\/td><td style=\"text-align:left; vertical-align:top\">\n13,342\n<\/td><td style=\"text-align:left; vertical-align:top\">\n5.1%\n<\/td><\/tr><tr><td style=\"text-align:left; vertical-align:top\">\nConsultant\n<\/td><td style=\"text-align:left; vertical-align:top\">\n7,986\n<\/td><td style=\"text-align:left; vertical-align:top\">\n3.0%\n<\/td><\/tr><tr><td style=\"text-align:left; vertical-align:top\">\nOracle\n<\/td><td style=\"text-align:left; vertical-align:top\">\n5,542\n<\/td><td style=\"text-align:left; vertical-align:top\">\n2.1%\n<\/td><\/tr><tr><td style=\"text-align:left; vertical-align:top\">\nAcademia\n<\/td><td style=\"text-align:left; vertical-align:top\">\n3,421\n<\/td><td style=\"text-align:left; vertical-align:top\">\n1.3%\n<\/td><\/tr><tr><td style=\"text-align:left; vertical-align:top\">\nNokia\n<\/td><td style=\"text-align:left; vertical-align:top\">\n3,272\n<\/td><td style=\"text-align:left; vertical-align:top\">\n1.2%\n<\/td><\/tr><tr><td style=\"text-align:left; vertical-align:top\">\nFujitsu\n<\/td><td style=\"text-align:left; vertical-align:top\">\n3,156\n<\/td><td style=\"text-align:left; vertical-align:top\">\n1.2%\n<\/td><\/tr><tr><td style=\"text-align:left; vertical-align:top\">\nTexas Instruments\n<\/td><td style=\"text-align:left; vertical-align:top\">\n2,982\n<\/td><td style=\"text-align:left; vertical-align:top\">\n1.1%\n<\/td><\/tr><tr><td style=\"text-align:left; vertical-align:top\">\nBroadcom\n<\/td><td style=\"text-align:left; vertical-align:top\">\n2,916\n<\/td><td style=\"text-align:left; vertical-align:top\">\n1.1%\n<\/td><\/tr><tr><td style=\"text-align:left; vertical-align:top\">\nLinux Foundation\n<\/td><td style=\"text-align:left; vertical-align:top\">\n2,890\n<\/td><td style=\"text-align:left; vertical-align:top\">\n1.1%\n<\/td><\/tr><tr><td style=\"text-align:left; vertical-align:top\">\nGoogle\n<\/td><td style=\"text-align:left; vertical-align:top\">\n2,620\n<\/td><td style=\"text-align:left; vertical-align:top\">\n1.0%\n<\/td><\/tr><\/tbody><\/table><p><strong>资料来源：<\/strong><a href=\"https://www.linuxfoundation.org/news-media/announcements/2012/04/linux-foundation-releases-annual-linux-development-report\">The\n    Linux Foundation Releases Annual Linux Development Report<\/a><\/p><p>如您所见，说到 IBM 对\n        Linux on Power 的承诺，并不仅仅是指 Watson。尽管 Watson 可以很好地证明 IBM\n        在这个领域可以做到的工作，但我们知道，我们还需要在其他许多应用领域中使用这种技术组合。 <\/p><h2 id=\"3.LinuxonPowerisbestpositionedtohandlecustomerworkloads|outline\">Linux on Power 最恰当的用途是处理客户工作负载<\/h2><p>让我们来看看在 <a href=\"https://www.gartner.com/newsroom/id/2304615\">Gartner 的 2013 全球 CIO\n                议程<\/a> 中被确定的一些趋势。当要求确定最优先考虑的技术时，<em>分析<\/em> 被排在首位，紧随其后的是<em>云<\/em>\n                和移动。其他来源也有一些支持数据，比如 83％ 的受访 CIO 将商业智能 (BI) 和分析列为其愿景计划的一部分，而 54％\n                。<em>大数据<\/em> 和<em>分析<\/em> 背后的技术是多种多样的，但有一个要求是一致的。您需要提供硬件来运行应用程序，并且该硬件必须能够在某些非常具体的领域中有卓越的性能。首先，这些应用程序在许多不同的地方都要求非常高的吞吐量。具体在哪里？仅举几例，处理器速度、内存带宽和 I/O 吞吐量。此外，<em>大数据<\/em> 和<em>分析<\/em> 需要线程，很多线程，并且它们对 Java&#8482; 也有很强的依赖性。一般来说，我们所谈论的是均衡的、高效的系统。<\/p><p>我们不要忘记其他一些工作负载对许多客户也很重要。电子邮件与协作（以社交和业务为中心）仍然具有战略意义。虽然电子邮件客户端组件显然越来越多地从桌面过渡到了移动设备，但后端基础架构仍然必须存在，以便支持任何形式的客户端。这些应用程序的安全性变得极为重要。迅速扩展，并与许多其他技术交互的能力也很重要。最后，是的，就像其他所有技术一样，性能是客户在这些工作负载中所寻求的东西。<\/p><p>此外，全球几乎每一个大公司都仍在使用包括企业资源规划 (ERP)、供应链和客户关系管理 (CRM) 在内的业务应用程序。这些大型系统有哪些独特的基础架构要求？我们需要能够快速创建新的环境，以便测试新的功能。我们需要能够动态调整系统资源（比如处理器、内存和 I/O），以便应付峰值期间的处理，比如财务结算和需求计划。这些应用程序也有一定的最高正常运行时间要求。最后，应用程序性能必须达到可接受的水平。<\/p><p>如果我们汇总最流行的工作负载中最重要的系统需求清单，它看起来可能会如下面的列表所示（所有这一切都发生在一个超安全的、经过成本优化的解决方案中）：<\/p><ul class=\"ibm-bullet-list\"><li>性能<\/li><li>可靠性<\/li><li>性能<\/li><li>可扩展性<\/li><li>性能<\/li><li>灵活性（我们称之为虚拟化）<\/li><\/ul><p>让我们确保能够在<em>云<\/em> 产品中得到这一切！<\/p><p>本文的标题是 “为何选择 Linux on POWER？”，这并非巧合。上述所有的应用程序都需要在某个地方运行，我们想从技术角度告诉您为什么运行 Linux 的 Power 服务器可以提供令人信服的业务用例。该业务用例的一部分考虑因素是价格，我们会讲到这一点，但让我们更深入地介绍一下 Power 技术。<\/p><h2 id=\"4.ComparingPowerwithIntel|outline\">比较 Power 与 Intel<\/h2><p>多年以来，Power 一直是面向中档数据库需求的首选平台。然而，当 IT 人员想到 Linux 时，几乎立刻就会想到 Intel? x86 平台。请花费一点时间来比较一下 Power 和 Intel 的特性。IBM 对 Power 平台感到非常自豪，该平台具有卓越的可靠性、可用性、可服护性、可扩展性，以及最重要的安全性。 <\/p><p>如果我们研究一下 Power 的特性，并将它们与 Intel 服务器的当前产品线进行比较（参见下文），就可以看到更好的功能和灵活性。此外，从成本的角度来看，Linux on Power 也极具吸引力。在本文的第 4 节中，将会更全面地介绍这一点。不过，下面的图表显示了 Power 胜于 Intel 的一些优势。<\/p><h5 id=\"N101CE\">图 2. Power 胜于 Intel 的一些优势<\/h5><img alt=\"Power 胜于 Intel 的一些优势\" src=\"/sunshine_new/images/31848298/image002.jpg\" width=\"850\" height=\"510\" /><p><a href=\"#N101D6\" class=\"ibm-popup-link\" onclick=\"ibmweb.overlay.show('N101D6',this);return false;\">点击查看大图<\/a><\/p><div id=\"N101D6\" class=\"dw-sidefile-overlay ibm-common-overlay ibm-overlay-alt-two\"><div class=\"ibm-head\"><p><a href=\"#close\" class=\"ibm-common-overlay-close\">关闭 [x]<\/a><\/p><\/div><div class=\"ibm-body\"><div class=\"ibm-main\"><div class=\"ibm-title\"><h2>图 2. Power 胜于 Intel 的一些优势<\/h2><\/div><div class=\"ibm-container ibm-alternate\"><div class=\"ibm-container-body\"><img alt=\"Power 胜于 Intel 的一些优势\" src=\"/sunshine_new/images/31848298/image002.jpg\" width=\"1410\" /><\/div><\/div><\/div><\/div><div class=\"ibm-footer\"><><\/div><\/div><p>在服务器中，Power 对 Intel 有三个特定的优势：<\/p><ul class=\"ibm-bullet-list\"><li><strong>性能<\/strong> C Power 利用多达 256 个高性能核心及每核心四个线程，可支持全系列服务器。Intel 销售的系统规模较小，现有产品最多 60 个核心，每核心两个线程，它们要求更多热量、散热和管理。<\/li><\/ul><ul class=\"ibm-bullet-list\"><li><strong>虚拟化<\/strong> C IBM PowerVM&#174; 是市场上惟一可以夸口零安全漏洞的虚拟机管理程序。没有其他基于 x86 的虚拟机管理程序声称可以做到这一点。PowerVM 驻留在固件中，因此，减少了时延，并支持更高的硬件整体利用率。<\/li><\/ul><ul class=\"ibm-bullet-list\"><li><strong>弹性<\/strong> C 因为 Power 是由设计了 IBM 大型机这一非常可靠的系统的同一团队设计的，内置了同样的弹性，实现更长的正常运行时间，并保证在一个日历年内有 99.997％ 的正常运行时间。Intel 无法提供接近于此数据的弹性。Power 硬件是自我修复的，并且通过实时分区迁移 (LPM) 等特性，无需任何停机时间就能完成最关键的更新。x86 服务器目前不具备同样的任务关键型弹性特点。<\/li><\/ul><p>IBM 在 20 年来一直不断按 Power 路线图前进，生产出了革命性的、最先进的处理器和晶体管技术。研究与开发可带来行业领先的创新，它们仍是 IBM 的投资重点。Power 继续有明确和详细的技术路线图。<\/p><p>Power 芯片的最新版本已经内置了加密功能，以及硬件事务内存的加速器。硬件事务内存使得 Power 服务器能够以更高的性能运行高度线程化的 Java 工作负载。<\/p><p>Power 还具有超强的内存和缓存性能。具有三级缓存和每个内存插槽两条通道，Power 为要求高内部带宽的工作负载提供了卓越的性能。<\/p><p>x86 服务器的激增往往会导致以下客户挑战：<\/p><ul class=\"ibm-bullet-list\"><li>提高系统管理成本<\/li><li>过度的能源使用和热量问题<\/li><li>电源和冷却基础架构不足<\/li><li>暴涨的软件成本<\/li><li>不断增长的人力成本<\/li><li>更多莫名其妙的故障<\/li><li>更多计划外停机<\/li><li>安全性降低<\/li><li>极少自动化，没有灵活性<\/li><\/ul><p>Power 服务器的安全性获得了增强，并且没有安全漏洞，这使得 IT 管理人员能够避免安全漏洞所带来的昂贵后果，比如：  <\/p><ul class=\"ibm-bullet-list\"><li>加强现有的 IT 安全性，并开展更多培训<\/li><li>联系其记录可能已暴露的那些人<\/li><li>监控受影响的那些人的信用<\/li><li>可能遭受财务损失的人所采取的法律行动<\/li><li>对公司/品牌声誉的损害<\/li><li>电子邮件黑名单  <\/li><li>对股价的影响<\/li><li>夺回市场地位的成本<\/li><\/ul><h3 id=\"N1021C\">定价<\/h3><p>关于 Linux 的一个常见的??说法是，它等同于 x86 或商品硬件 - 为什么会考虑在 Power 上运行 Linux？一般的看法是，在 Power 上运行 Linux 过于昂贵。 <\/p><p>正如前面所提到的，所有 Power 服务器都可以运行 Linux。然而，IBM 推出了仅使用 Linux 的单、双、四插槽服务器，分别是 IBM PowerLinux&#8482; 7R1、7R2 和 7R4，它们以具有竞争力的价格点为客户提供面向 Linux 的另一个可靠的替代平台。请看下面的图表。如果考虑采购总成本 (TCA)，其中包括服务器目录价、虚拟化、Linux 操作系统升级和支持目录价，Power 服务器上的 Linux 的 TCA 定价如果不是更便宜，至少也应该与 Intel x86 选项相当。<\/p><h5 id=\"N10228\">图 3. 比较面向 Linux 的 Power 与 Intel x86 的 TCA 定价<\/h5><img alt=\"比较面向 Linux 的 Power 与 Intel x86 的 TCA 定价\" src=\"/sunshine_new/images/31848298/image003.jpg\" width=\"720\" /><h5 id=\"N10235\">图 4. IBM PowerLinux 7R2 定价比较（以美元为单位）<\/h5><img alt=\"IBM PowerLinux 7R2 定价比较（以美元为单位）\" src=\"/sunshine_new/images/31848298/image004.jpg\" width=\"817\" /><p>除了 TCA 之外，还要考虑其他成本因素。让我们比较适用于 Power 与 x86 的虚拟化功能；具体来说是比较 PowerVM 与 VMware。如图 5 所示，PowerVM 提供了卓越的性能和价值，为客户提供的虚拟化特性更灵活、更具扩展性、更安全。客户为什么要在乎这些好处？它在成本方面有什么意义？请注意，PowerVM 灵活地配置虚拟处理器和内存，并且每个虚拟机的虚拟处理器的数量仅受限于物理服务器上的可用核心的数量。对比之下，VMware 在分配处理器和内存资源方面的灵活性有限，并且存在每插槽 32 个虚拟处理器的硬限制。这句话的意思是说，使用 PowerVM 部署的客户可以根据<em>他们的<\/em> 需要灵活地修改自己的系统配置。在当今的世界里，IT 需求是多变和动态的。PowerVM 让客户可以随需求的变化来调整自己的服务器环境。此外，PowerVM 卓越的可扩展性特征可以帮助客户将更多工作负载整合到一台服务器上。PowerVM 客户不需要购买额外的物理服务器来适应不断扩大的或新的工作负载，他们可以在一台服务器中运行更多的工作负载，这极大地提高整体系统利用率。PowerVM 让客户能够少花钱多办事。由于使用了更少的物理服务器，所以节省了电源和散热、数据中心机架空间和管理等成本。软件许可成本也是一个主要因素。大多数商业应用软件都是按核心数量发放许可的。如果可以用更少的核心完成更多工作，那么可以直接减少软件的许可费用，许可费用在 IT 预算中可能占比较大的比例。接下来，让我们探讨一下安全领域。PowerVM 被集成到 Power 虚拟机管理程序中，而且 <a href=\"https://cve.mitre.org/cgi-bin/cvekey.cgi?keyword=PowerVM\"><em>报告零漏洞<\/em><\/a>。与之对比，VMware <a href=\"https://cve.mitre.org/cgi-bin/cvekey.cgi?keyword=VMware\">报告了 561 个漏洞<\/a>。想象一下这种情况：系统有若干台主机，如果虚拟机管理程序很容易出现安全方面的问题，在其上运行的所有主机都将处于危险之中。这可能意味着对客户的业务造成严重影响，例如，停机时间。最后，如??果单独考虑虚拟化许可成本，您会注意到，PowerVM 许可对 VMWare 非常有竞争力。<\/p><h5 id=\"N10250\">图 5. 比较 PowerVM for IBM PowerLinux 与 VMWare（以美元为单位）<\/h5><img alt=\"比较 PowerVM for IBM PowerLinux 与 VMWare（以美元为单位）\" src=\"/sunshine_new/images/31848298/image005.jpg\" width=\"707\" /><p>在 2013 年第四季度，IBM 发布了两个额外的公告，这使得 IBM PowerLinux 成为对客户更具吸引力的选择。这些公告介绍了 Power Integrated Facility for Linux (IFL) 和所有 IBM PVU 许可的软件产品的更低处理器价值单元 (PVU)，适用于运行 Linux 的所有 Power 核心。 <\/p><p><a href=\"https://www.ibm.com/common/ssi/cgi-bin/ssialias?infotype=an&amp;subtype=ca&amp;appname=gpateam&amp;supplier=897&amp;letternum=ENUS113-178\">Power IFL<\/a> 是一个企业级 Power 产品，用于在大型企业中整合并集成 Linux 应用程序与 IBM AIX&#174; 和 IBM i 应用程序及数据。拥有 Power 770、780 或 795 服务器的客户可以通过<em>按需容量<\/em>（使用激活密钥增加额外的处理器和内存资源，不需要中断）增加 Linux 工作负载容量。借助 4 核心，32 GB 内存捆绑，该产品可扩展到 32 插槽。它适用于在现有企业 Power 服务器上具有不活跃容量的企业客户。客户不需要购买额外的基于 x86 的服务器来运行 Linux 工作负载，他们现在只需在现有的 Power 服务器上激活非活跃资源，激活资源不需要停机。客户可以享受 Power 企业服务器中固有的性能、安全性和可用性，同时以新的低价格简化 Linux 工作负载的采购。因为不必将额外的设备添加到数据中心，Power IFL 允许客户缩短产品上市时间。您只需输入一个密钥就可以激活所需的资源。通过使用 IFL，客户可以信心十足地将应用程序和数据放在一起，同时减少延迟并最大限度地提高利用率。<\/p><h5 id=\"N10269\">图 6. Power IFL 定价<\/h5><img alt=\"Power IFL 定价\" src=\"/sunshine_new/images/31848298/image006.jpg\" width=\"345\" /><p>第二个公告是为在运行 Linux 的所有 Power 核心上的所有 PVU 许可的软件产品降低 IBM Software Group PVU。PVU 是用于在分布式处理器技术上区分软件许可的度量单位。对于 Linux on POWER，IBM Software Group PVU 统一为每核心 70 PVU，即使是最大的 Power 服务器也一样。与此相比，对于 4 插槽和更大的 Intel 服务器是每核心 100 至 120 个 <a href=\"https://www.ibm.com/software/lotus/passportadvantage/pvu_licensing_for_customers.html\">PVU<\/a>。由于软件许可在解决方案采购中可能是最大的成本（远远高于服务器成本），在 Linux on Power 上运行此类工作负载可能会有显著的成本节约<\/p><p>Power 运行 Linux 过于昂贵的说法是不成立的。它不仅在 TCA 定价方面具有竞争力，而且还提供了客户认为比商品解决方案更卓越的特性。<\/p><p>这里是一个 <a href=\"https://www.youtube.com/watch?v=jDJSssGp9O8\">由领先的研究公司 Solitaire Interglobal Ltd 制作的基于事实的分析视频<\/a>。在这段视频中，Solitaire 比较了 x86 架构与 IBM Power Systems，并解释了为什么下一代应用程序的基础应该是 IBM Power：<\/p><h3 id=\"N10283\">技能<\/h3><p>IBM 自 1999 年以来一直是 Linux 的积极参与者，并且是针对 Linux 的全球领先的商业贡献者之一。在 2013 年，IBM Power 部又投资了十亿美元，以支持 Linux 和开源工作负载的解决方案。这项投资包括在世界各地开放新的 Power Systems Linux Center 和创新中心。<a href=\"https://www.ibm.com/systems/power/software/linux/centers/\">Power Systems Linux Center<\/a> 向全世界各地的 Linux 开发人员开放。这些地点包括中国北京、德克萨斯州奥斯汀、纽约州纽约市、日本东京和法国蒙彼利埃。Linux 中心使开发人员可以使用 Linux 和最新的 IBM Power 服务器来构建和部署新的应用程序。在中心的资源包括量身定做的客户简介、Linux 培训工作坊、移植援助，以及动手协助开发人员了解如何利用 Power 功能并优化性能。IBM 创新中心是致力于帮助 ISV 的最先进设施。<a href=\"https://www.ibm.com/partnerworld/wps/servlet/ContentHandler/isv_com_tsp_iic_overview\">创新中心<\/a> 提供的服务包括架构设计和实现咨询、移植、迁移、测试服务、应用程序集成和概??念证明的支持，以及最新技术的专业知识。<\/p><p>作为 IBM 对 Linux on Power 的承诺的一个例子，IBM 有专门负责支持客户和 ISV 使用 PowerLinux 的团队。此外，IBM 拥有 <a href=\"https://www.ibm.com/linux/ltc/\">Linux Technology Center (LTC)<\/a>，这是 IBM 的开源软件开发人员团队，他们与 Linux 开源开发社区合作。LTC 作为 Linux 技术竞争力中心，并且负责 IBM 的 Linux Distribution 合作伙伴的技术联络。 <\/p><p>IBM 也提供了其他许多社区资源。假设您需要 IBM 帮助您移植应用程序。IBM 拥有一个 <a href=\"https://www.ibm.com/partnerworld/wps/servlet/ContentHandler/isv_com_dvm_techval_chiphopper\">Chiphopper 计划<\/a>，即 IBM Systems Application Advantage for Linux。这个计划让 IBM 内部相应的资源与您和您的团队协同工作，评估潜在的移植挑战，并协助移植。另一个 IBM 计划是 <a href=\"https://www.ibm.com/systems/power/migratetoibm/path.html\">Migration Factory<\/a>。IBM Migration Factory 可以帮助您制定迁移路线图，估算迁移工作量，并为迁移定制一个业务用例。如果您需要一个用于测试的平台，但没有服务器访问权限，IBM 提供了 <a href=\"https://www.ibm.com/partnerworld/wps/servlet/ContentHandler/stg_com_sys_power-development-platform\">Power Development Platform<\/a>，它之前被称为虚拟借用程序。该计划提供对 IBM 硬件的免费远程访问。最后，IBM 拥有 Linux on <a href=\"https://www.ibm.com/developerworks/community/wikis/home?lang=en#!/wiki/W51a7ffcf4dfd_4b40_9d82_446ebc23c550\">PowerLinux 社区维基<\/a>，这是您的一站式商店，在这里，您可以找到有益的常见问题解答、视频演示、最佳实践、入门指南，并访问 Linux on Power 论坛。在讨论区发布的问题或讨论点被自动转发给整个 Linux on Power 开发团队，让您可以通过我们的专家挖掘最深的 Linux on Power 技术知识。<\/p><p>IBM 已经专门针对 Linux on Power 开发了工具，以提供额外的价值。其中一个工具是 <a href=\"https://www-304.ibm.com/webapp/set2/sas/f/lopdiags/installtools/home.html\">IBM Installation Toolkit for PowerLinux<\/a>。它包括流行工作负载的 Simplified Setup Tool、基于 Linux on Power 专家经验的调优，以及安装超过 20 个可靠性、可用性和可服务性和生产力工具。其他工具包括 SDK 和 Advance Toolchain。所有这些工具都是免费提供的，并专门针对 Power 进行了优化。<\/p><p>无论您是客户、业务合作伙伴还是 ISV，IBM 都拥有团队和资源可以帮助满足您和您所有的 Linux on Power 需求。<\/p><h2 id=\"5.Customerexamples|outline\">客户示例<\/h2><h3 id=\"N102B7\">北卡罗来纳州立大学 (NCSU)  - 大数据 - 帮助企业解决真实的信息问题<\/h3><p>在 <a href=\"https://www.youtube.com/watch?v=j6CjWVHcyEk\">视频<\/a> 中，研究人员 Michael Kowolenko 博士讨论了 IBM 在 PowerLinux 上基于云的<em>大数据<\/em> 和分析解决方案如何帮助 NCSU 建议企业进行具有高影响力的投资<\/p><p>NC State Center of Innovation Management Studies 希望教导学生如何解决复杂的业务问题，并为企业提供可操作的信息，从而帮助提高其底线。他们用作例子的企业拥有许多不同形式的数据源。 <\/p><p>他们需要一个硬件平台，该平台不但能够跟上数据量，并且不会因非常复杂的查询而陷入困境，并让学生和企业能够基于准确的输出做出正确的决策。他们也希望计算机科学系运行系统的那些人可以变得很轻松。于是，他们选择了 Linux on Power。使用多个 IBM 软件产品（Big Insights、Content Analytics、IBM SPSS&#174; 和 IBM DB2&#174;），他们能够极大地提高学生的能力，解决将影响这些企业的底线的问题。从 x86 平台迁移到 Power 平台，索引的运行从 72-96 个小时缩短到 14 个小时。<\/p><h3 id=\"N102CD\">Watson 在 MD Anderson 帮助癌症的诊断<\/h3><p><a href=\"https://www.youtube.com/watch?v=6g6VJa9Y6no\">MD Anderson Hospital 的 Lynda Chin 教授<\/a> 进行了以下讨论：通过使用 Watson，他们能够创建一个应用程序，大大加快对癌症患者的诊断和治疗。<\/p><p>IBM Watson 技术目前部署在得克萨斯州休斯敦的 MD Anderson Hospital，帮助完成各种癌症的诊断和治疗。<\/p><p>Watson 让从业者能够访问来自他们过去从未想过的来源的信息和数据。他们现在不再被孤立于自己的诊所中，而是可以拥有来自全球各地的数据源的瞬时信息，从而更好地治疗和诊断他们的患者。<\/p><p>Watson 解决了如今如何用药的基础挑战。<\/p><ul class=\"ibm-bullet-list\"><li>获得优质护理<\/li><li>医生短缺<\/li><li>缺乏标准化<\/li><li>访问成本<\/li><li>采用率不足<\/li><li>效率低下的知识共享和交流<\/li><\/ul><p>究其核心，Watson 是一个在 Linux on Power 系统上运行的 Hadoop 集群。<\/p><h2 id=\"6.Summary|outline\">结束语<\/h2><p>我们希望可以让您确信，IBM 非常重视 Linux on Power。我们对此技术的投资应该清楚说明了这一点。其中包括：在 2013 年的年中承诺十亿美元的额外投资，包括许多新的、专职的、以 Linux 为中心的人员，继续致力于构建那些使用和完善 Linux on Power 的应用程序。我们还希望，我们已经消除了有关此产品组合的一些常见误解。首先，Linux on POWER 与 x86 使用<strong>相同<\/strong> 的 Linux。其次，在 Power 上运行 Linux 并不会花费更多成本。事实上，在大多数情况下，在 Power 上运行它的采购总成本和总拥有成本将会更低，有时这种优势会非常明显。最后，Linux 在 x86 上肯定不会运行得<em>更好<\/em>。IBM POWER&#174; 处理器和周绕它的服务器基础架构是无与伦比的，他们能够提供最快的系统总吞吐量，最高水平的可靠性和安全性。<\/p><a id=\"OLE_LINK1\"><\/a><p>如果您有任何疑问或想更深入了解在本文中所讨论的任何主题的信息，您可以与作者取得联系。Grace、Ann 和 Mark 都是在 IBM 内新成立的组织中的成员，其主要任务是作为技术大使，对 Power 上运行的 Linux 的各个方面提供支持。组织中的这些和其他资源被重点用在 Linux 环境中蓬勃发展的应用程序和计划上，比如<em>大数据<\/em> 和<em>分析<\/em>。本文的作者们确定了基于 Power 的最优架构的规模和设计、解释设计，并提供了竞争硬件提供商同等规模的设计，建立从替代平台移植的路径，并对客户和 ISV 进行底层技术教育。<\/p><h2 id=\"7.Resources|outline\">参考资料<\/h2><ul class=\"ibm-bullet-list\"><li><a href=\"https://www.ibm.com/systems/power/software/linux/powerlinux/7r1/\">Power 7R1 虚拟参观<\/a><\/li><li><a href=\"https://www.ibm.com/systems/power/software/linux/powerlinux/7r2/\">Power 7R2 虚拟参观<\/a><\/li><\/ul><CMA ID: 975608><Site ID: 10><XSLT stylesheet used to transform this file: dw-document-html-7.0.xsl>\r\n\r\n\r\n<\/div>\r\n<\/div>\r\n","createTime":"2014-06-25 00:00:00","deployTime":"2014-06-25 00:00:00","id":0,"intro":"在 IBM? Power? 硬件上运行基于 Linux 的应用程序可以提供性能、可靠性和安全性的强大组合。在本文中，您将了解 IBM Power Systems? 可以提供的许多战略优势，而且您可能会对各种部署的低成本感到惊讶。了解 IBM 用于改善 Linux 体验的工具，并全面理解 IBM 对 Linux on POWER 的未来承诺。","keyword":"","recommend":false,"source":"http://www.ibm.com/developerworks/cn/linux/l-linux-on-power/index.html","title":"为何选择 Linux on Power？","typeId":0,"updateTime":"2014-06-25 00:00:00"}
{"author":"","clickNumber":0,"content":"\r\n<div class=\"ibm-columns\">\r\n<div class=\"ibm-col-1-1\">\r\n\r\n<p>人类的认知就是对建模的研究。显然，不是所有的模型都是图形化的，但毫无疑问 C 没有建模人类便无法推理论证。<\/p><p>模型是关于某个事物或一组事物的抽象，在模型中我们忽略对我们希望得到回答的问题无关，又或者对我们希望能得到支持的推理论证（reasoning）来说无关重要的细节。这使得我们可以只关注于与我们手头的分析或问题相关的细节。<\/p><p>例如，考虑图 1 中所展示的办公椅。一张椅子的模型是由什么构成的呢？<\/p><h5 id=\"fig1\">图 1. 椅子的模型<\/h5><img alt=\"椅子的图像\" src=\"/sunshine_new/images/负1682945015/image001.png\" width=\"556\" /><p>当然，这取决于您想回答的问题。如果您想去组装椅子，那您的模型就是由椅子的各个部分和安装指导构成的。如果您想依据风水来设计一个办公区域，那您就需要考虑颜色和风格了。如果您是零售商，您则会关注于成本和利用率了。这些都是合理的模型，取决于您想要执行的推理论证是什么。<\/p><div class=\"dw-sidebar ibm-inset\"><p>在您创建一个有用的模型之前，您应当清晰识别您想要回答的问题，以及您想要支持的推理论证。<\/p><\/div><p>本条建议的要点就是在您创建一个有用的模型之前，您应当清晰识别您想要回答的问题，以及您想要支持的论证。您应当清晰地 C 在您构建模型之前 C 回答以下问题：<\/p><ul class=\"ibm-bullet-list\"><li>为什么我要构建这个模型？（Why am I constructing the model?）<\/li><li>这个模型的范围是什么？（What is the scope of this model?）<\/li><li>谁是这个模型的消费者？（Who are the consumers of this model?）<\/li><li>关于这个模型这些消费者会问些什么样的问题？（What questions are the consumers likely to ask of this model?）<\/li><li>基于什么样的推理论证这些消费者会要使用这个模型？（With what reasoning are the consumers going to use this model?）<\/li><\/ul><p>这些问题中的每一个问题都可以得到一个或多个模型图。例如，如果我想要构建一个系统架构模型，我或许会对上述问题给出以下回答：<\/p><p>我构建这个模型用来推理论证系统的大规模片断，推理论证这些元素所分配到的需求，推理论证在这些元素之间接口的定义，推理系统的机械、电子以及软件工程等准则的职责分配情况。<\/p><h3 id=\"0.1.Scope|outline\">范围<\/h3><p>模型的范围（scope）就是系统工程架构，包括大规模多学科的部分（子系统）以及它们的接口。它还包括了追溯链接（trace link）来回溯到需求模型和前溯到工程特定模型（机械、电子及软件等部分）。<\/p><p><strong>模型的消费者包括：<\/strong><\/p><ul class=\"ibm-bullet-list\"><li>系统工程师（System engineer）<\/li><li>系统安全工程师（System safety engineer）<\/li><li>系统可靠性工程师（System reliability engineer）<\/li><li>安保分析师（Security analyst）<\/li><li>需求分析师（Requirements analyst）<\/li><li>机械工程师（Mechanical engineer）<\/li><li>电子工程师（Electronic engineer）<\/li><li>软件工程师（Software engineer）<\/li><\/ul><p><strong>问题包括：<\/strong><\/p><ul class=\"ibm-bullet-list\"><li>有哪些子系统？（What are the subsystems?）<\/li><li>分配到各个子系统的需求情况怎样？（How are requirements allocated to subsystems?）<\/li><li>在子系统之间有哪些的接口？（What are the interfaces between the subsystems?）<\/li><li>系统在可能存在的失败状态下是否安全？（Is the system safe in the presence of likely failures?）<\/li><li>重要的系统功能的可靠性怎样？（What is the reliability of the important system functions?）<\/li><li>有哪些资产必须处在安全策略的保护之下？（What are the assets that must be protected by security countermeasures?）<\/li><li>有哪些安全威胁和系统漏洞？（What are the security threats and the points of system vulnerability?）<\/li><li>有哪些需求是分配给机械（或电子及软件）部分的设计的？（What requirements are allocated to mechanical (or electrical or software)design?）<\/li><li>在软件和电子部分之间有哪些接口？（What are the interfaces between the software and the electronics?）<\/li><\/ul><p><strong>部分必须解决的推理论证（reasoning）：<\/strong><\/p><ul class=\"ibm-bullet-list\"><li>对错误树分析分割集合（对风险的表现有贡献的错误集合）的分析（Analysis of the fault tree analysis cut sets (sets of faults that contribute to the manifestation of a hazard)）<\/li><li>演示所有能由设计所覆盖的需求（Demonstration that all requirements are covered by the design）<\/li><li>演示所有满足某个需求的所有设计元素（Demonstration that design elements are all present to meet a requirement）<\/li><li>验证一个系统是否满足既定目标的测试用例（Test cases required to verify a system is fit for purpose）<\/li><\/ul><CMA ID: 975610><Site ID: 10><XSLT stylesheet used to transform this file: dw-document-html-7.0.xsl>\r\n\r\n\r\n<\/div>\r\n<\/div>\r\n","createTime":"2014-06-25 00:00:00","deployTime":"2014-06-25 00:00:00","id":0,"intro":"系统工程师正在响应要求更严格采用 UML 及 SysML 标准的需求。这些标准很复杂，而且既没有提供指导如何才是最佳建模技巧来使用这些建模语言有效定义需求和架构，也没有指导如何使用建模来演示交易案例，并且也没有系统工程所需的各种分析方法。Douglass 博士曾在几百个项目上提供过超过 30 年的咨询。在这一面向基于模型系统工程的十大建模建议清单里，他分享了他的观点及深度经验。","keyword":"","recommend":false,"source":"http://www.ibm.com/developerworks/cn/rational/top-10-modeling-hints-system-engineers-02/index.html","title":"系统工程的十大建模建议: #9 所有模型都是抽象，但只有一部分是有用的","typeId":0,"updateTime":"2014-06-25 00:00:00"}
{"author":"","clickNumber":0,"content":"\r\n<div class=\"ibm-columns\">\r\n<div class=\"ibm-col-1-1\">\r\n\r\n<p>在创建需求规格说明（Requirements Specification）这一工作中做得好并不像看起来的那么容易。非常难，事实上在过去的 35 年里，我还没有看到过一份需求规格说明是完全没有缺陷的。需求规格说明通常是使用“将来时”语句的文本文档。这种方式自身就有很多根本性的问题。<\/p><p>首先，文本（text），即便非常完美地表述，仍然会是含糊的，并且容易导致多种理解。非常难以用自然语言来清晰表达意思。这使得自然语言非常适合用于诗歌，而不适合用在技术规格说明中。<br /><br /><strong>备注<\/strong>：我确实曾经尝试使用 UML 状态机（state machine）来写作诗歌，但事实证明这不是一个很好的选择。<\/p><p>更进一步，也非常难以确保规格说明是完整的，并且您没有遗漏任何东西。您涵盖了系统必须操作的所有案例、情况以及环境了吗？所有的性能和其他服务要求的质量又如何？包括所有错误和例外情况了吗？<\/p><p>论证相当大数目的需求之间的一致性甚至更加困难。在一部有着数百页的规格说明里，一致性是一个棘手的问题。<\/p><p>通常此类的规格说明在交给工程师团队进行设计和开发之前是如何被验证的？大多数情况，要么是根本没有验证过（这是由于冗长的系统检验及验证周期使各种问题直到项目结束仍有待解决），要么是通过时间长得令人难以忍受的结对评审（peer review）来进行验证。<\/p><p>这一<em>问题<\/em>出在文本化需求（requirements-as-text）本质上是不可验证的。<em>解决办法<\/em>是创建模型化需求（requirements-as-model）。<\/p><p>设想一个简单的用例，一个交通灯控制系统的“夜间低流量模式”（Evening Low Volume Mode）。主干道交通灯闪烁黄灯，而次级道路交通灯闪烁红灯。图 1 显示了一个上述的简单需求集合，可以作为可执行状态机（executable state machine）进行模拟，发送消息给其环境中的各个参与者（Actor）：主干道行人（primary road pedestrians，PP）、次级道路行人（secondary road pedestrians，SP）、主干道直行车辆（primary through traffc vehicles，PV）、主干道转向车辆（primary turn traffic vehicles，PtV）、次级道路直行车辆（secondary through traffic vehicles，SV）以及次级道路转向车辆（secondary turn traffic vehicles，StV）。图片还显示了如何增加追踪链接到状态机元素上，来显示该元素所代表的需求。<\/p><h5 id=\"fig1\">图 1. “夜间低流量模式”的简单用例状态机<\/h5><img alt=\"用例状态机\" src=\"/sunshine_new/images/负277062886/image001.png\" width=\"608\" /><p>这一模型的首要好处是它是可执行的。它可以被用来探索不同的情形、不同的上下文、不同的值以及到达事件的次序。当然图 1 中的状态机确实非常简单。然而可以考虑该交通灯控制系统一个更复杂的“固定循环模式”（Fixed Cycle Mode）需求集合：<\/p><ul class=\"ibm-bullet-list\"><li><strong>用例<\/strong>：固定循环模式\n      <ul class=\"ibm-bullet-list\"><li>交叉路口包括一个主干道和次级道路<\/li><li>每一条道路都包括直行车道和左转向车道<\/li><li>直行车道，对于同一条道路的双方向，同时激发；<\/li><li>转向车道，对于同一条道路的双方向，同时激发；<\/li><li>直行车道信号灯仅仅在“红-绿-黄-红”循环中进行激发。其它的道路信号灯则在该道路允许通行时保持在红灯（以及“停止步行”灯）上；<\/li><li><strong>转向车道<\/strong>仅仅在有车辆到达转向车道时激发；否则它们一直保持红灯；<ul class=\"ibm-bullet-list\"><li>在<em>下一次<\/em>直行车道将要被正常激发时，转向车道会先于直行车道激发并让直行车道保持红灯直到转向循环完成；<\/li><li>双向的转向车道会走“红-绿-黄-红”循环。在此循环完成后，直行车道才允许循环到绿灯；<\/li><li>一旦某一次转向车道循环被处理过，就需要下一次有转向车辆到达才会再次激发此循环；<\/li><\/ul><\/li><li><strong>人行道信号灯<\/strong>一直保持“停止步行”状态直到“行人到达按钮”被按下才会被激发；<ul class=\"ibm-bullet-list\"><li>在<em>下一次<\/em>直行车道变绿灯时，该道路的人行道信号灯会执行以下循环：<ul class=\"ibm-bullet-list\"><li>停止步行<\/li><li>步行<\/li><li>闪烁“停止步行”<\/li><li>停止步行<\/li><\/ul><\/li><li>仅仅在人行道信号灯变成“停止步行”后，直行车道才会循环到黄灯上。<\/li><\/ul><\/li><\/ul><\/li><\/ul><p>这还不是一个很复杂的用例，但让人感兴趣的许多不同场景都可以在其中构想出来，这包括了多种组合：车辆在直行车道、转向车道上，以及人行道等等。这一用例的状态机在图 2 中展示，不琐碎也不明显。所有感兴趣的情况和场景都被考虑到。这一模型的执行允许您探索不同事件、条件及值的组合，来确保系统在所有时间里都是正确的。<\/p><h5 id=\"fig2\">图 2. “固定循环模式”的用例状态机<\/h5><img alt=\"用例状态机\" src=\"/sunshine_new/images/负277062886/image002.png\" width=\"664\" /><p>作为该类用例功能性分析的一个常见的结果，缺失的需求会被识别出来。它们随后会被添加到文本规格说明中，并被链接到模型规格说明的元素上。这就得到了更好的需求；需求也更加的完整、正确、清晰和精确。<\/p><CMA ID: 975616><Site ID: 10><XSLT stylesheet used to transform this file: dw-document-html-7.0.xsl>\r\n\r\n\r\n<\/div>\r\n<\/div>\r\n","createTime":"2014-06-25 00:00:00","deployTime":"2014-06-25 00:00:00","id":0,"intro":"Bruce Douglass 向您展示如何使需求更完整、正确、清晰和精确。","keyword":"","recommend":false,"source":"http://www.ibm.com/developerworks/cn/rational/top-10-modeling-hints-system-engineers-04/index.html","title":"系统工程的十大建模建议: #7 需求模型帮助您避免早期的昂贵缺陷","typeId":0,"updateTime":"2014-06-25 00:00:00"}
{"author":"","clickNumber":0,"content":"\r\n<div class=\"ibm-columns\">\r\n<div class=\"ibm-col-1-1\">\r\n\r\n<p>本条建议是我在业界所见过的，关于最常见的（错误）使用建模技术人尽皆知的抱怨：轻量级、不精确、不正确和不可维护的模型，对分析支持的功用很少，而且几乎无法回答关于利益关注的任何问题。您也许已经感觉到我对这种方式的建模毫无兴趣。我倾向于“高保真”（\"high-fidelity\"）模型。这些模型（在其范围和目的内）是完整、精确、正确和清晰的；而且是可验证的（一些有关的东西我们将会在后续的第 1 条建议中探讨）。<\/p><p>让我澄清一下：建模的价值依赖于我们在考虑模型的目的和范围的前提下，能<em>完整、清晰和精确<\/em>地进行验证的能力。餐巾纸模型（\"napkin model\"，因经常被手绘在触手可及的物体表面而得名），是一种最常见的使用 UML 或 SysML 的方式。但是以这种方式来使用模型，类似于使用约摸大概的弹道学参数来为导弹编程。导弹确实会击中某处地面目标，差别在于哪儿？如果您正好处在导弹弹道轨迹末端的弹着点上，这差别就大了。<\/p><h5 id=\"fig1\">图 1. 餐巾纸模型是不精确的<\/h5><img alt=\"在餐巾纸上草绘建模\" src=\"/sunshine_new/images/负332721833/image001.jpg\" width=\"850\" /><p><strong>注解：<\/strong>因为这是一个餐巾纸模型，没有存储库在模型之下确保它与您口袋中可能存在的其他餐巾纸模型在语义陈述上的一致性。<\/p><p>关于这一模型您可能存有的疑问包括：<\/p><ul class=\"ibm-bullet-list\"><li>这一模型尝试去描绘什么？（What is this model trying to depict?）<\/li><li>这些就是 Student 类或 Seminar 类所具有的<em>所有<\/em>属性吗？（Are those <em>all<\/em> the attributes of Student or Seminar?）<\/li><li>属性的数据类型及合适的子范围是什么？（What are the data types and appropriate subranges for the attributes?）<\/li><li>各个操作（operation）的参数和返回值是什么？（What are the parameters and return values of the operations?）<\/li><li>如何确定一次研讨会（Seminar）的合格性？需要什么信息来确定这一点？（How do you determine eligibility for a seminar? What information is needed to determine that?）<\/li><li>这些元素如何创建？它们如何彼此链接在一起？它们如何被销毁？（How are these elements created? How are they linked together? How are they destroyed?）<\/li><li>您如何界定一场研讨会是冷场还是满座？需要什么信息来界定？<code>MaxNumber:unsigned int<\/code> 属性是否缺失？（How can you tell if a seminar is empty or full? What information is needed for that? Is the <code>MaxNumber:unsigned int<\/code> attribute missing?）<\/li><li>所有的属性都有默认值吗？（Are there any default values for the attributes?）<\/li><\/ul><p>似乎听起来我像是把餐巾纸模型置于万劫不复的境地。但这并不完全正确。我认为餐巾纸模型是<em>开启<\/em>对话的一种很好的方式。在您接下来回答关于系统的结构和行为的问题和原因时，您可以将模型从“纸巾模型”转化为“高保真模型”。当模型是用具备实时模型存储库的建模工具来管理的话，这很容易做到。如果工具支持模型验证的话，则更加容易了，例如某些高端工具，Rational Rhapsody。<\/p><p>最差的情形是，不精确的思考会得到一个失败的系统。在我眼里，这是无法接受的。<\/p><CMA ID: 975612><Site ID: 10><XSLT stylesheet used to transform this file: dw-document-html-7.0.xsl>\r\n\r\n\r\n<\/div>\r\n<\/div>\r\n","createTime":"2014-06-25 00:00:00","deployTime":"2014-06-25 00:00:00","id":0,"intro":"不要基于草拟在餐巾纸上的不精确思考开始构建一个风险大容易失败的系统。Bruce Douglass 系统工程的十大建模建议系列的第 8 条帮助您从轻量级模型转型到高保真模型。","keyword":"","recommend":false,"source":"http://www.ibm.com/developerworks/cn/rational/top-10-modeling-hints-system-engineers-03/index.html","title":"系统工程的十大建模建议: #8 餐巾纸模型是开始对话最好的方式，但也绝对是结束对话最糟糕的方式。","typeId":0,"updateTime":"2014-06-25 00:00:00"}
{"author":"","clickNumber":0,"content":"\r\n<div class=\"ibm-columns\">\r\n<div class=\"ibm-col-1-1\">\r\n\r\n<h2 id=\"2.引言：|outline\">引言<\/h2><p>随着虚拟化技术日新月异的变化，一个物理服务器可以划分出大量的虚拟资源，同时管理众多的物理和虚拟资源显然成为一个庞大工程，也大大增加了实验室管理员的工作难度和强度。众所周知，ISD\n    是一个跨平台管理工具，它简化了复杂的物理和虚拟系统的管理方式，并且通过使用行业标准，同时支持在 IBM 和非 IBM 的 x86 平台上的多种操作系统和虚拟化技术。但是现在一个典型的企业级数据中心通常有超过 5000 的资源，而单独的一个 ISD 最多支持管理 5000 个资源，这必须使用多个 ISD 来进行管理。这时需要一个能够充当中央集权的数据中心来管理这些 ISD。在 ISD 6.2 版本中出现了这样的功能：HMS，它为被管理的 ISD 和普通的资源提供了一个可以显示所有数据信息的统一视图。<\/p><h2 id=\"3.名词解释：|outline\">名词解释：<\/h2><p><strong>Global Server:<\/strong> 一个能够管理其他 ISD，驱动被管理 ISD 的远程资源，帮助在分层管理环境中建立集权管理关系的 ISD。<\/p><p><strong>Domain server:<\/strong> 在分层管理环境中被 Global Server 管理的 ISD。<\/p><p><strong>REST:<\/strong> 在分层管理环境中，REST 是 Global Server 和 Domain Servers 之间通信的协议。任何一个被 Global server 管理的 Domain server 都有 REST 协议。<\/p><p><strong>Hierarchical Management:<\/strong> 分层管理是在 ISD 6.2 中一个新的功能，它能够使 Global server 发现并且管理其他的 domain server，然后建立集权管理关系。<\/p><p><strong>Hierarchical Management Server<\/strong><strong> (<\/strong><strong>HMS<\/strong><strong>):<\/strong>是 Global Server 的另一个名称。<\/p><p><strong>Launch-in-context:<\/strong> global server 利用它来查看在远程被管理系统上的任务。可以通过右键点击远程被管理系统或者选择这个被远程管理的系统，然后点击操作按钮，您可以看到可用的任务。当您选择了一个任务，global server 打开一个新的浏览器窗口或者一个便签，然后利用已有的凭证登陆到管理这个远程系统的 domain server，最后在 domain server 上执行这个被选择的任务。这整个过程被称为一个任务的 launch-in-context.<\/p><p><strong>Remote managed resource:<\/strong> 任意被 domain server 管理的资源。<\/p><p><strong>Remote managed system:<\/strong> 任意被 domain server 管理的系统。<\/p><p><strong>Reference Mep (RefMep):<\/strong> 在分层管理环境中，一个 RefMep 表示在 global server 上的一个远程被管理系统。RefMep 充当了一个在 domain server 端的真实 Mep 代理。<\/p><h2 id=\"4.HMS 概述：|outline\">HMS 概述：<\/h2><ol type=\"1\"><li>HMS 是在 ISD 6.2 版本的时候推出的一个新功能，用它来实现分层管理，并且使它成为一个中央集权的数据中心。当一个 ISD 被激活了 HMS 功能以后，它将被作为一个全局服务器(Global Server) 通过 REST 协议去管理一个或者多个普通的 ISD 服务器，通常称之为局部服务器(Domain Server)，和被这些局部服务器管理的服务器上所有数据和状态信息，同时全局服务器仍然具有一个普通 ISD 的功能。下面图 1 展示了它们之间的层次关系：<\/li><\/ol><h5 id=\"N10098\">图 1. 全局服务器与局部服务器层次关系<\/h5><img alt=\"全局服务器与局部服务器层次关系\" src=\"/sunshine_new/images/负174265209/image003.jpg\" width=\"554\" /><p>    图 1 中，位于最上面名为 IBM System Director Global Server 是已激活 HMS 功能的 ISD，我们称之为全局服务器（Global Server）。它通过 Rest 协议管理下面的 IBM System Director Server Node，即局部服务器（Domain Server）。<\/p><ol type=\"1\"><li>HMS 能通过管理多个 domain server 管理最多 10,000 个资源。<\/li><li>使用 HMS 的好处：<ol class=\"ibm-alpha-list\" type=\"a\"><li>单个的 ISD 最多能管理 5,000 个远程资源，而使用 Global server 能够帮助管理多个 ISD，并且让它们像一个数据中心。<\/li><li>当一个企业用多个 ISD 去管理不同类型服务器、运用不同的安全策略，不同的应用服务或者操作系统的时候，HMS 就能够提供一个完整的数据中心视图。<\/li><li>当一个数据中心用多个系统管理应用，HMS 能够单点控制所有的应用。<\/li><\/ol><\/li><\/ol><h2 id=\"5.开启/关闭 HMS 功能：|outline\">开启/关闭 HMS 功能：<\/h2><h3 id=\"N100B8\">开启 HMS 功能<\/h3><p>1. 通过 ISD 界面开启 HMS 功能。如图 2。<\/p><ol class=\"ibm-alpha-list\" type=\"a\"><li>在 ISD 的左边导航控制板选择<strong>设置<\/strong>，然后点击<strong>服务器首选项<\/strong>。<\/li><li>在服务器首选项页面找到<strong>分层管理<\/strong>，然后选择上<strong>启用对多个 Systems Director Server 的管理<\/strong>。<\/li><li>点击<strong>应用<\/strong>按钮。<\/li><\/ol><h5 id=\"N100D8\">图 2. 开启 HMS<\/h5><img alt=\"开启 HMS\" src=\"/sunshine_new/images/负174265209/image005.jpg\" width=\"554\" /><p>2. 通过命令行开启 HMS 功能<\/p><p>通过 SSH 或者 telnet 协议登陆到 ISD，运行命令：smcli hms/confighms Ce<\/p><p>同时可以通过命令：smcli hms/confighms Cs 查看 ISD 中 HMS 的状态是否开启。<\/p><p>开启 HMS 功能之后，通过 Global Server 发现另外一个 ISD， 等发现完成以后能在被发现的 ISD 的属性页面看到它拥有的协议里面有 REST 协议。 这是被发现的 ISD 作为一个 Domain Server 的明显标记。<\/p><h3 id=\"N100EB\">关闭 HMS 功能<\/h3><p>目前只能通过以下命令将 Global server 还原成普通的 ISD。<\/p><p>Smcli hms/confighms Cd<\/p><h2 id=\"6.HMS 支持的功能 |outline\">HMS 支持的功能<\/h2><h3 id=\"N100F9\">发现 Domain server<\/h3><p>在运用 Global server 去管理 domain server 之前，必需在 global server 端先发现 domain server。<\/p><p>发现 domain server 和发现其他资源的过程一样。只是在发现之前，要确保 HMS 已经在 Global server 端开启并且 HMS 没有在将要作为 domain server 的 ISD 上开启。<\/p><p>当发现结束以后，您能在 Global server 上面通过图标<img alt=\"\" src=\"/sunshine_new/images/负174265209/image006.gif\" width=\"16\" />分辨出这是一个 domain server。<\/p><p>此外，在 domain server 的协议属性里面将包含 REST 协议。<\/p><h3 id=\"N1010E\">请求 domain server 的管理访问权<\/h3><p>当 domain server 的发现结束后，执行下面步骤来获得每个 domain server 的管理访问权。<\/p><ol class=\"ibm-alpha-list\" type=\"a\"><li>在 ISD 的资源控制面板，选择<strong>资源浏览器<\/strong>。<\/li><li>点击<strong>domain server<\/strong>。<\/li><li>右键点击 domain server，然后选择<strong>安全<\/strong> --&gt; <strong>请求管理访问权<\/strong>。然后请求管理访问权页面就会出现。<\/li><\/ol><p>Note: 当右键点击 domain server，如果看到的是请求访问权而不是请求管理访问权，说明 domain server 在发现的时候没有通过 REST 协议。这时，需要重新发现 domain server。<\/p><ol class=\"ibm-alpha-list\" type=\"a\"><li>输入正确的用户名和密码，然后点击<strong>申请权限按钮<\/strong>。这个被开启的 domain server 和被它管理的所有系统都会被列在 Global server 里面。<\/li><\/ol><p>Note：也可以通过命令 smcli accesssy 去请求管理访问权。<\/p><h3 id=\"N10136\">请求访问权/撤销访问权<\/h3><p>Global server 能够请求和撤销被 Domain server 管理资源的访问权。这些任务在 global server 上被触发，而不需要打开新的浏览窗口。尽管这些任务在 Global server 上能够看见并且执行，但实际上请求/撤销访问权是在 domain server 上面执行的。<\/p><h3 id=\"N1013D\">利用 web 界面在被管理的资源上执行任务<\/h3><p>当 HMS 成功配置以后，可以通过 Global server 的 web 界面在被管理的远程资源上去查看和执行交互式任务。<\/p><p>局限：Global server 只能在远程被管理的资源上执行交互式的任务。一个非交互式的任务必须在 domain server 上面执行。通过 domain server 在远程被管理资源上激活和被安排好的任务不能够通过 global server 查看到。<\/p><h3 id=\"N10146\">在多个远程被管理的资源上发起任务<\/h3><p>只有被选中的远程被管理资源在同一个 domain server 上，才能够通过 global server 在多个远程被管理的资源上执行任务。<\/p><p>从控制台去鉴定 domain server 管理的远程被管理资源，执行以下步骤：<\/p><ol type=\"1\"><li>在 ISD web 界面的导航区域选择<strong>资源浏览器<\/strong>，然后任意选择一个组，在点击<strong>操作按钮<\/strong> &gt; <strong>列<\/strong>。<\/li><li>从可用的列中选择拥有的节点，点击<strong>添加<\/strong>按钮，然后点击<strong>确定<\/strong>按钮。一个名为<strong>拥有的 Domain server<\/strong>的新列将显示 Domain server 的名字和被它管理的所有远程资源。<\/li><li>在同一个 Domain server 上选择一个或者多个远程被管理的资源，右键点击其中的任意一个然后查看它们共同支持的任务。如果这些远程被管理的资源来自不同的 domain server，那么没有任何任务可用。<\/li><li>选择任何一个任务。这个任务将在一个新的浏览器标签打开。<\/li><\/ol><h3 id=\"N1016B\">不利用 launch-in-context 来执行任务<\/h3><p>以下任务可以不通过 launch-in-context 模式在 global server 端执行：<\/p><ol type=\"1\"><li>资源浏览器<\/li><li>请求访问权<\/li><li>验证链接<\/li><\/ol><p>这些任务不需要在 global server 打开一个新的浏览器窗口就能直接在一个远程被管理的系统上执行。<\/p><h3 id=\"N1017C\">在远程被管理系统上安装 ISD 插件<\/h3><p>在 domain server 上面安装 ISD 插件时，可以在 global server 执行交互式的任务通过 launch-in-context 来完成。<\/p><h3 id=\"N10183\">利用 web 界面在 domain server 上执行任务<\/h3><p>只有安全任务能够通过 global server 的 web 界面直接在 domain server 执行。其他的任务要在远程被管理资源上执行都必需通过 launch-in-context 的形式。<\/p><p>一旦 domain server 被发现和管理，将会在 global server 上面出现两个新的远程被管理资源：一个操作系统和一个服务器。这两个远程被管理资源代表了本地的 domain server。<\/p><h3 id=\"N1018C\">从 global server 执行 CLI 命令<\/h3><p>Global server 支持有限的 CLI 命令，它们包括：安全任务，组合状态类的任务的 CLI 命令才能过通过 Global server 在远程被管理的机子上面运行。<\/p><p>从 global server 在 domain server 上执行非交互的任务 CLI 是不支持的。<\/p><h3 id=\"N10195\">从 Global server 升级 domain server<\/h3><p>您必须在每一台 domain server 上面执行升级任务，同样在 global server 也是。<\/p><p>可用的升级包在 global server 端，也只能用来对 global server 升级，不能将这些升级包用于 domain server 升级。<\/p><p>但是您可以通过 launch-in-context 的方式在 global server 端给 domain server 和他们管理的远程系统进行升级。<\/p><h3 id=\"N101A0\">通过 Global server 在远程被管理系统上面安装代理程序<\/h3><p>您可以安装一个代理程序在远程被管理的系统上面通过 <em>发行版本管理<\/em>―&gt;<em>代理程序<\/em> 的 launch-in-context 任务。如果这样做，您还必须导入这个代理程序的安装包并且确保它在 domain server 上面是可用的。<\/p><h2 id=\"7.HMS 图标展示：|outline\">HMS 图标展示：<\/h2><p>在激活了 HMS 功能的 ISD 的 GUI 界面上会出现很多新的图标以区分这些服务器是由全局服务器管理。这些图标如图 3 所示：<\/p><h5 id=\"N101BC\">图 3. 各种图标及含义<\/h5><table border=\"0\" cellpadding=\"0\" cellspacing=\"0\" class=\"ibm-data-table\" summary=\"\"><thead xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"><tr><th style=\"text-align:center; vertical-align:top\">\nIcon\n<\/th><th style=\"text-align:center; vertical-align:top\">\nMeaning\n<\/th><\/tr><\/thead><tbody xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"><tr><td style=\"text-align:center; vertical-align:top\"><img alt=\"\" src=\"/sunshine_new/images/负174265209/image008.gif\" width=\"33\" /><\/td><td style=\"text-align:center; vertical-align:top\">\nDomain Server：在分层管理环境中被 Global Server 管理的 ISD。\n<\/td><\/tr><tr><td style=\"text-align:center; vertical-align:top\"><img alt=\"\" src=\"/sunshine_new/images/负174265209/image009.gif\" width=\"40\" /><\/td><td style=\"text-align:center; vertical-align:top\">\nBlade Center：刀片服务器\n<\/td><\/tr><tr><td style=\"text-align:center; vertical-align:top\"><br /><img alt=\"\" src=\"/sunshine_new/images/负174265209/image010.gif\" width=\"40\" /><\/td><td style=\"text-align:left; vertical-align:top\">\nCluster：集群就是由一些互相连接在一起的计算机构成的一个并行或分布式系统，从外部来看，它们仅仅是一个系统，对外提供统一的服务。\n<\/td><\/tr><tr><td style=\"text-align:center; vertical-align:top\"><img alt=\"\" src=\"/sunshine_new/images/负174265209/image011.gif\" width=\"40\" /><\/td><td style=\"text-align:center; vertical-align:top\">\nDevice：指物理设备\n<\/td><\/tr><tr><td style=\"text-align:center; vertical-align:top\"><img alt=\"\" src=\"/sunshine_new/images/负174265209/image012.gif\" width=\"40\" /><\/td><td style=\"text-align:center; vertical-align:top\">\nHost：包含的资源是由虚拟服务器构成。\n<\/td><\/tr><tr><td style=\"text-align:center; vertical-align:top\"><img alt=\"\" src=\"/sunshine_new/images/负174265209/image013.gif\" width=\"40\" /><\/td><td style=\"text-align:center; vertical-align:top\">\nOperating System：操作系统\n<\/td><\/tr><tr><td style=\"text-align:center; vertical-align:top\"><img alt=\"\" src=\"/sunshine_new/images/负174265209/image014.gif\" width=\"40\" /><\/td><td style=\"text-align:center; vertical-align:top\">\nPrinter：打印机设备\n<\/td><\/tr><tr><td style=\"text-align:center; vertical-align:top\"><img alt=\"\" src=\"/sunshine_new/images/负174265209/image015.gif\" width=\"40\" /><\/td><td style=\"text-align:center; vertical-align:top\">\nSwitch：指物理交换机\n<\/td><\/tr><tr><td style=\"text-align:center; vertical-align:top\"><img alt=\"\" src=\"/sunshine_new/images/负174265209/image016.gif\" width=\"41\" /><\/td><td style=\"text-align:center; vertical-align:top\"><br />\nVirtual Device：指虚拟的设备\n<\/td><\/tr><tr><td style=\"text-align:center; vertical-align:top\"><img alt=\"\" src=\"/sunshine_new/images/负174265209/image017.gif\" width=\"40\" /><\/td><td style=\"text-align:center; vertical-align:top\">\nVirtual Server：虚拟的服务器\n<\/td><\/tr><tr><td style=\"text-align:center; vertical-align:top\"><img alt=\"\" src=\"/sunshine_new/images/负174265209/image018.gif\" width=\"40\" /><\/td><td style=\"text-align:center; vertical-align:top\">\nVirtual Switch：虚拟的交换机\n<\/td><\/tr><tr><td style=\"text-align:center; vertical-align:top\"><img alt=\"\" src=\"/sunshine_new/images/负174265209/image019.gif\" width=\"38\" /><\/td><td style=\"text-align:center; vertical-align:top\">\nVirtual Card：泛指各种虚拟的卡，比如网卡\n<\/td><\/tr><\/tbody><\/table><h2 id=\"8.总结：|outline\">总结：<\/h2><p>在本文中，我们展示了 ISD 使用分层管理来满足客户集中管理的需求, 从而为用户提供更加灵活和高效的分层管理解决方案。这个功能可以应用 AIX, Unix, Linux 和 Windows 的平台上。<\/p><CMA ID: 975209><Site ID: 10><XSLT stylesheet used to transform this file: dw-document-html-7.0.xsl>\r\n\r\n\r\n<\/div>\r\n<\/div>\r\n","createTime":"2014-06-25 00:00:00","deployTime":"2014-06-25 00:00:00","id":0,"intro":"本文将展示 Hierarchical Management Server (HMS) 是什么，如何开启、关闭，它拥有哪些能力和介绍新出现的图标以及含义。HMS 是 IBM Systems Director (ISD) version 6.2 新增加的一个功能。通过本文的介绍您将对 HMS 的基本功能、使用以及新出现的图标有一个深刻的理解。","keyword":"","recommend":false,"source":"http://www.ibm.com/developerworks/cn/aix/library/1406_liupan_isd/index.html","title":"概述 IBM Systems Director 里对不同平台的分级管理","typeId":0,"updateTime":"2014-06-25 00:00:00"}
{"author":"","clickNumber":0,"content":"\r\n<div class=\"ibm-columns\">\r\n<div class=\"ibm-col-1-1\">\r\n\r\n<h2 id=\"1.背景介绍 |outline\">背景介绍<\/h2><p>UCM：Unified Changed Management 的缩写 ，统一变更管理模式，是 IBM Rational 提出的用于管理软件开发过程（包括从需求到版本发布）中所有变更的\"最佳实践\"流程。UCM 通过抽象层次的提升简化了软件开发，从而使得软件开发团队从更高的层次根据活动（activity）来管理变更。通过 UCM，一个开发活动可以自动地同其变更集（封装了所有用于实现该活动的项目工件）相关联，这样避免了管理人员手动跟踪所有文件变更。<\/p><p>在介绍 UCM ClearCase 的 CMI 集成功能之前，需要了解一下几个概念，这些会在后面的操作时经常提到<\/p><p>Activity： Activity 是 ClearCase UCM 模式中的一个概念，通过变更集 (Change Set) 跟踪完成一项开发任务所引起的所有配置项的变更。Check Out、Check In、Add to Source Control 等引起配置项发生变化的操作住 UCM 下必须关联到一个 Activity。<\/p><p>Stream： UCM 的概念，项目开发的主干，类似 Base ClearCase 里的 Branch 概念。有集成流和开发流两种，每个开发流都是集成流的一个分支，在开发流上完成工作后，再提交到集成流上，然后在集成流上做成 Build。<\/p><p>Provider：所要集成的产品如 CLM 里的 RTC、CQ，这些 Server 本身提供 OSLC 功能的的集成接口，Provider 不仅限于 Rational 自身产品还包括将能扩展集成的任何第三方产品，只要此 Server 提供 OSLC 接口功能和相应的 Driver 库。此 Driver 库用来 ClearCase 集成时动态加载。<\/p><p>Task：是 Provider 里的一条记录，主要针对 RTC 的一条工作项，包含 Task ID 和 Task 描述等，每个 ClearCase 元素的集成信息都关联到相应的 Provider 的一条 Task，如果是 CQ 就是相应的一条 Record，语义上和 RTC 的 task 类似，也有 Record ID。<\/p><h2 id=\"2.UCMClearCaseCMI 原理及目前状态 |outline\">UCM ClearCase CMI 原理及目前状态<\/h2><p>ClearCase UCM 的集成在 ClearCase 以前的版本就有，ClearCase UCM 和 ClearQuest 的集成作为配置管理变更管理工具一直帮助客户实现整个软件周期的管理，当时由于 Rational 关于软件生命周期的管理的产品有限，ClearCase 的集成主要针对 ClearQuest 单个产品解决方案，这就造成 ClearCase 的集成操作多针对 ClearQuest 一个产品的特性，源代码中很多针对 ClearQuest 定制的专有代码，随着 Rational 产品的丰富以及更新换代，ClearCase 在面对新产品的集成无法继续为每个产品都提供一个集成方案，这样一个统一的集成方案的需求迫在眉睫，而 CMI 正是这个需求的产物，它提供了统一的集成接口，并动态加载需要集成产品的驱动库和实现 OSLC 数据访问功能的产品实现交互，OSLC 是 IBM 产品都遵循的一个数据访问服务交互模式。几乎所有产品都提供 OSLC 的访问和交互功能。从此，ClearCase 里的源代码将不会以后针对相应产品的功能的特殊描述，取而代之的是用户自己定义的产品 Provider 的名字，CMI 后台通过客户指定的 Provider 的名字来动态加载相应的驱动库（由集成产品提供，接口一致），然后查找 provider 的配置地址来实现具体的集成操作。 <\/p><p>新的集成方案 CMI 定义了统一的，标准化的接口，需要集成的产品只需要实现 Interface，双方通过此接口定义的一些方法来通信，此类似于 JDBC/ODBC driver 解决和产品数据库连接和操作的思想。<\/p><p>使用体验上实现了 pluggable 的使用 CMI 的功能，CMI 的具体命令和 ClearCase 自身的命令集成在一起，并添加了关于 CMI 的相关参数和命令，这对于已经数量掌握 ClearCase 的管理员来说很容易理解和上手。<\/p><p>如果用户启用了 CMI 的功能意味着在常规的 check in/out 等操作后还要执行把新版本信息关联到 Provider 的具体 Task 里，这里添加了事务管理概念，使得本身的 check in/out 操作和集成操作在一个事务管理内，任何一个操作失败将导致整个事务操作失败，保证 ClearCase 和 Provider 端的一致。<\/p><p>    通过在 version、branch、stream 上添加一个简单属性 TaskID@ProviderName， \"@\"符号区分符后面是所集成的 server 名字，前面是这个 server 的相关记录的 ID.整个集成过程都围绕着这个接口信息通过 OSLC 的方式以 URL 访问 CLM 应用来调用和跟踪变更。<\/p><p>    可以同时和多个产品 Server 实现集成，一次 check in/out.多个产品同时记录相关联的涉及的代码变更。<\/p><p>    新的 CMI 集成方案和传统的方法具备了共同的特性：<\/p><p>    1.通过会话 session 机制实现批处理和 server 交互。<\/p><p>    2.通过队列机制处理交互阻塞。<\/p><p>    3.保持 ClearCase 管理的代码状态和 server 状态一致，有一定的容错性。<\/p><p>    4.自动关联和自动解关联。<\/p><p>    在 ClearCase V7.1.2.9 及 V8.0.0.6 以上版本中，ClearCase 实现了 CMI 与 CLM 的集成，如下所示：<\/p><p>UCM ClearCase/ClearQuest/RTC 通过 CMI 进行集成；<\/p><p>BASE ClearCase/ClearQuest/RTC 通过 CMI 进行集成；<\/p><p>RTC - CTE 通过 CMI 方式进行集成；<\/p><p>RTC - Visual Studio 通过 CMI 方式进行集成；<\/p><p>CCRC CLI (rcleartool) 基于 CMI 的增强。<\/p><p>    本篇文章通过具体例子，详细介绍如何使用 CMI 来实现 UCM ClearCase 与 ClearQuest 以及 RTC 的集成。<\/p><h2 id=\"3.准备工作 |outline\">准备工作<\/h2><p>    在进行例子之前，我们需要安装一些 Rational 的软件，包括 ClearCase8.0.0.8 以上版本，同时需要已经配置好的 ClearQuest 服务器以及 RTC 服务器，并创建样例数据。在我们引入的例子中，我们使用了的版本如下：<\/p><p>Rational ClearCase 以及 ClearQuest 8.0.0.9版本<\/p><p>Rational Jazz Team Server Version: 4.0.4 M1版本<\/p><h2 id=\"4.使用 UCMClearCase 通过 CMI 和 ClearQuest 集成 |outline\">使用 UCM ClearCase 通过 CMI 和 ClearQuest 集成<\/h2><p>步骤一：准备将要集成的 UCM ClearCase，CQ provider 的环境<\/p><p>UCM ClearCase 的 CMI 集成和 Base ClearCase 的集成都需要通过 OSLC，所以我们得首先使 Schema 支持 OSLC，如图 1-4 所示：<\/p><h5 id=\"N100B4\">图 1. 在 ClearQuest Designer 中为当前 CQ\n    Schema 添加 OSLC 补丁包<\/h5><img alt=\"在 ClearQuest Designer 中为当前 CQ Schema 添加 OSLC 补丁包\" src=\"/sunshine_new/images/1029467712/image003.jpg\" width=\"575\" /><h5 id=\"N100C0\">图 2. 选择当前最高版本 OSLC 补丁包<\/h5><img alt=\"选择当前最高版本 OSLC 补丁包\" src=\"/sunshine_new/images/1029467712/image005.jpg\" width=\"576\" /><h5 id=\"N100CC\">图 3. 指定需要支持 OSLC 的 Record\n    Types<\/h5><img alt=\"指定需要支持 OSLC 的 Record Types\" src=\"/sunshine_new/images/1029467712/image007.jpg\" width=\"581\" /><h5 id=\"N100D8\">图 4. 更新 ClearQuest 用户 DB<\/h5><img alt=\"更新 ClearQuest 用户 DB\" src=\"/sunshine_new/images/1029467712/image009.jpg\" width=\"582\" /><p>以上操作是为了在要集成的 Provider Server 准备环境和数据，并让 Provider 提供 OSLC 访问接口。此过程和 Base ClearCase 的环境准备类似。<\/p><p>步骤二：准备 UCM CMI 的集成环境<\/p><p>本文演示的集成操作都是在 RHEL 6.3 i386 GNU/Linux 平台上进行。命令行方式是 ClearCase 管理员经常使用、最快捷的 clearcase 操作方式。本文通过命令行的方式来详细介绍基于 CMI 的 UCM ClearCase 和 ClearQuest 集成的具体操作,帮助用户更深入的理解 ClearCase 的 CMI 功能。<\/p><p>首先，我们需要通过 ClearCase 命令创建基于 UCM 的 Project，为 CC 和 CQ Server 集成做好准备。<\/p><h5 id=\"N100EC\">图 5.\n    创建存储 view 和 vob 的 storage 库<\/h5><img alt=\"创建存储 view 和 vob 的 storage 库\" src=\"/sunshine_new/images/1029467712/image011.jpg\" width=\"602\" /><h5 id=\"N100FA\">图 6. 创建 ucm\n    project 需要的 VOB<\/h5><img alt=\"创建 ucm project 需要的 VOB\" src=\"/sunshine_new/images/1029467712/image013.jpg\" width=\"601\" /><p>如图所示，下面开始创建 ucm project、PVOB 和 element VOB 所需要的 component，并在这个 PVOB 上创建集成流、集成视图，开发流以及开发视图。<\/p><h5 id=\"N10106\">图 7. 创建所需 component，并在 project\n    VOB 上创建集成/开发流及相应视图<\/h5><img alt=\"创建所需 component，并在 project VOB 上创建集成/开发流及相应视图\" src=\"/sunshine_new/images/1029467712/image015.jpg\" width=\"624\" /><p>以上步骤是用 UCM 来做版本管理的必备程序。<\/p><p>UCM 的概念和原理这里不再详细介绍，简单的说它是在 base 基础上形成的统一变更管理模式，UCM 通过抽象层次的提升简化了软件开发，从而使得软件开发团队从更高的层次根据活动（activity）来管理变更（change set）。<\/p><p>步骤三 ClearCase CMI 相关的配置工作。<\/p><h5 id=\"N10118\">图 8. VOB 添加 CMI 所必须的属性<\/h5><img alt=\"VOB 添加 CMI 所必须的属性\" src=\"/sunshine_new/images/1029467712/image017.jpg\" width=\"602\" /><p>从 V8.0.0.7 起，ClearCase 本地客户端( cleartool 和 native GUIs)支持基于 CMI 的 UCM-CQ 集成。ClearCase 与 ClearQuest 通过 OSLC 接口进行交互<\/p><p>以下范例完成在 project vob 里创需要集成的 Provider Server。下面语句在所要集成的 VOB 里创建一个名字为 CQPROV 的 Provider Server，并自动关联到 VOB 属性里。<\/p><h5 id=\"N10128\">图 9.\n    为 VOB 创建连接 CQ 的 Provider<\/h5><img alt=\"为 VOB 创建连接 CQ 的 Provider\" src=\"/sunshine_new/images/1029467712/image019.jpg\" width=\"602\" /><p><code>mkcmprovider<\/code>相关参数介绍如下。<\/p><p>-<code>vob<\/code>：指定需要使用 CMI 与 CLM 集成的 vob；<\/p><p>-<code>type<\/code>：当前所创建的 CMI Provider 类型，由于是与 CQ 集成，因此值为\"cmcq\"；<\/p><p>-<code>ver<\/code>：CMI 功能版本号，值为\"v1_0\" ；<\/p><p>-<code>desc<\/code>：当前 CMI Provider 描述信息；<\/p><p>-<code>connection<\/code>：provider server 提供的 OSLC URL 地址，格式为：baseurl:http://ip/cqweb/oslc；<\/p><p><code>CQPROV<\/code>是我们所创建的 CMI Provider 的名字<\/p><p>这里的-ver 和-type 是特定的 provider 类型，CMI 需要这两个信息加载相应的驱动库，如果填写错误将导致无法找到相应的 provider 错误。 CMI 会验证 connection 地址的正确性，如果未通过验证，将报 URI 地址无法访问错误。<\/p><p>此操作必须在 Vob 里创建完 Provider 信息后，否则就会报找不到相应 Provider 的错误。<\/p><p>如果是采用 UCM 集成，需要在 stream 引用此 provider，并将 provider 与 stream 上的 activity 做关联。如果是采用 base 集成,需要在 branch 上引用此 provider，并将 provider 与 branch 里的具体 element 版本做关联。UCM ClearCase 与 ClearQuest 集成独特之处在于：在 activity 上关联集成的 provider，如 CQ，RTC 的 server 信息后，在这个 activity 下所有的 version 更改信息就会传到 Server Provider 端。UCM 的集成粒度比 Base 要大，不需在单个文件上做关联，当然这种关联也是通过从配置信息里自动获取并打上标签属性，无需手动参与。<\/p><h5 id=\"N1015B\">图 10.\n    在 Vob 里的 Stream 上引用在 Vob 里定义的 Provider 信息<\/h5><img alt=\"在 Vob 里的 Stream 上引用在 Vob 里定义的 Provider 信息\" src=\"/sunshine_new/images/1029467712/image021.jpg\" width=\"602\" /><p>Activityformat 属性定义了 activity 格式。因此在 mkact 命令创建 activity 时将默认使用此格式，自动创建 activity 名字，除非你重新指定所要创建的 activity 名字。<\/p><p>enable 属性用于确定是否启用 ClearCase 与 provider 的集成，如果不想再和这个 provider 集成，可以设置属性 enable 为 false。<\/p><p>validate 属性用于确定这个 provider 的某个 task 必须和 ClearCase 的 activity 有关联，就是 ClearCase vob 里的 activity 必须关联到此 provider 的某个 task。后面的文章会详细讲解这里的逻辑规则以及错误处理。<\/p><p>最后通过 lsprovider 命令检查在 vob 和 stream 上的 provider 配置是否正确，在配置之前也可以先 lsprovider 查看是否有人已经配置，以免重复配置。<\/p><p>如果需要更改这个 provider 的相关配置，可以在创建命令行里添加 \"-replace\"参数。具体的，请运行<code>cleartool mkcmprovider Chelp<\/code>获得相关命令使用帮助。<\/p><p>步骤四：对应之前创建的 Provider，创建所需的 CQ 认证属性<\/p><p>通过\" <code>cmiregister add -cq -name CQPROV -userdb CQWAN -dbset CQWAN -username admin<\/code>\" 命令创建对应之前创建的 Provider 所需的 CQ 认证属性，从而记录连接 CQ 所需要的登陆信息；添加完成后，可以通过\"<code>cmiregister list<\/code>\"命令来进行查看。<\/p><h5 id=\"N1017F\">图 11. 创建并记录链接 CQ 的登录信息：<\/h5><img alt=\"创建并记录链接 CQ 的登录信息：\" src=\"/sunshine_new/images/1029467712/image023.jpg\" width=\"619\" /><p>步骤五：通过 Cleartool mkact 创建 activity，并为当前的 ClearCase 操作与 ClearQuest record 相关联，如下图 12,13 所示。<\/p><p>Activity 是 ClearCase UCM 模式中的一个概念，通过变更集 (Change Set) 跟踪完成一项开发任务所引起的所有配置项的变更。在 UCM 模式下，所有的 Check Out 、 Check In 、 Add to Source Control 等引起配置项发生变化的操作必须关联到一个 Activity。<\/p><p>用户在任何时候要向控制 vob 添加资源或修改已经处于 vob 控制之下的资源，都必须将操作与某个 UCM 活动相关联。<\/p><p>我们在 stream 上创建 activity 的同时，可以创建此 activity 关联的 provider 的 taskid。实例：<\/p><div class=\"codesection\"><pre class=\"displaycode\">cleartool mkact -nc -tasks CQWAN00000001@CQPROV lzhao_act2<\/pre><\/div><p>mkact 相关参数介绍如下：<\/p><p>-tasks 参数是专门为做 UCM 集成加入的。CQWAN00000001 就是 provider CQPROV 的一个 defect id。此创建过程会验证 ClearQuest server provider 和 defect id 信息的正确性，如果不存在会报错，但是 activity 仍然能创建成功，就是没有关联到相关 ClearQuest server。<\/p><p>Lzhao_act2 是将创建的活动名称。如果不指定名称，根据前面的设置，系统将自动创建格式为 ACT_%task-id_%stream-name 的活动。<\/p><p>然后可以用 <code>cleartool lsact -l Sample_act<\/code> 去确认此 activity 已关联到相应的 provider 和 taskid，如下图书所示：<\/p><h5 id=\"N101A2\">图 12. 创建 Activity，通过命令将 CC activity 与 CQ\n    Record 做关联<\/h5><img alt=\"创建 Activity，通过命令将 CC activity 与 CQ Record 做关联\" src=\"/sunshine_new/images/1029467712/image025.jpg\" width=\"665\" /><p>通过 <code>cleartool settask<\/code> 命令可设定默认关联的 Provider 的 Task 信息，这样你在每次 check in/out 操作时，CMI 会根据此设定的信息来和 Provider 集成。如下图所示：<\/p><h5 id=\"N101B3\">图 13.\n    为 activity 设定默认关联 provider 的 task 信息<\/h5><img alt=\"为 activity 设定默认关联 provider 的 task 信息\" src=\"/sunshine_new/images/1029467712/image026.jpg\" width=\"668\" /><p>RedHat 系统里 Root 目录下的.ccas_current_tasks 记录了默认的集成信息，你可以手动在这文件里添加，也可以用 cleartool settask 命令来添加。<\/p><p>如上图实例：.ccase_current_tasks 中包含两个 view 和 provider 的集成信息，一个是 rtcprovider，另一个是 CQPROV。cmi_view 是在 Base Vob 里创建的 view，int_view 实在 UCM Vob 里创建的 view。<\/p><p><code>settask Cnone<\/code> 用于清空默认的 task 集成信息。<\/p><p>当然如果愿意，我们可以将 activity 与 provider 的更多 task 相关联。此 activity 的 changeset 会自动更新到所有相关联的 server 上。在 Server Provider 端，一条记录可以关联到几个 activity 或变更的版本。<\/p><p>UCM CMI 集成为 cleartool setact 增加了一个-tasks 的参数，允许用户为将要工作的 activity 指定若干具体的 task。如<\/p><div class=\"codesection\"><pre class=\"displaycode\">cleartool setact -tasks CQWAN00000001@CQPROV,CQWAN00000002@CQPROV<\/pre><\/div><p>另外，UCM CMI 集成增加了如下命令：<\/p><div class=\"codesection\"><pre class=\"displaycode\">cleartool chact -tasks {-add_task task-selector[,...] |\n                    -remove_task task-selector[,...] | -rmall}\n                    activity-selector[,...]<\/pre><\/div><p>允许用户同时增加或删除此 activity 关联的 tasks。可以同时用 -remove_task task1, -add_task task2 来替换 activity 的 task，也可以 -task -rmall 来删除所有 activity 关联的 provider 信息。如下图所示<\/p><h5 id=\"N101D7\">图 14.\n    为 activity 设定关联 provider 的多个 task<\/h5><img alt=\"为 activity 设定关联 provider 的多个 task\" src=\"/sunshine_new/images/1029467712/image028.jpg\" width=\"666\" /><p>此 activity act2 已经有了关联的 task CQWAN00000001@CQPROV，运行命令 <code>cleartool chact -tasks -add_task CQWAN00000002@CQPROV -remove_task CQWAN00000001@CQPROV act2.<\/code><\/p><p>在 CQ Provider 端，CQWAN00000001 关联的 activity 被删除了，同时此 activity 关联到了 CQWAN00000002@CQPROV 上。此例也可以看到基于 UCM 和基于 Base 的 ClearCase 集成的不同之处，基于 Base 的 CMI 集成关联的是改动的源代码版本信息，而基于 UCM 的 CMI 集成关联的是 activity 信息。<\/p><p>当这个 activity 创建成功，并且关联到 CQ Provider CQPROV 的记录 CQWAN00000001，就可以在 CQ 页面上看到所关联的变更集包含了刚才我们创建的 activity，如图所示：<\/p><h5 id=\"N101EB\">图 15. 在 CQ\n    Web 中查看指定 Record 对应的 CC 中变更信息<\/h5><img alt=\"在 CQ Web 中查看指定 Record 对应的 CC 中变更信息\" src=\"/sunshine_new/images/1029467712/image030.jpg\" width=\"619\" /><p>步骤六：删除 UCM ClearCase 与 ClearQuest 的集成信息，如下图 16,17 所示。<\/p><p>删除 activity 的操作将同时会把所有关联到此 activity 的 provider Server 的集成信息一同删掉,此操作逻辑包含了操作<\/p><div class=\"codesection\"><pre class=\"displaycode\">cleartool chact Crmall<\/pre><\/div><p>如下图所示：当操作 rmact 时，所关联的 provider server 响应时间会稍有等待，原因是 CMI 后台会联系 Provider Server 提交解关联（disassociation）操作。完成后再执行删除 ClearCase 端的 activity 的操作，最后返回删除成功信息。<\/p><h5 id=\"N10201\">图 16. 删除所创建的 activity，此操作将删除关联到 provider 的 CQ\n    Recorder<\/h5><img alt=\"删除所创建的 activity，此操作将删除关联到 provider 的 CQ Recorder\" src=\"/sunshine_new/images/1029467712/image032.jpg\" width=\"504\" /><p>如果需要删除此 provider 的相关配置，可以通过 rmprovider 命令去删除。删除时，该命令通知并需要你确认：你对此 vob 上 provider 的更改会导致和 stream（UCM）或 branch（Base）的配置不一致，需要同时手动更改在 stream 或 branch 上关于此 provider 的配置。就是说你在上级 vob 上更改的集成 provider 信息不会自动更新到相关的 stream（UCM）或 branch（Base）上，需要手动去更新，并且相关 type 和 version 的值必须准确。ClearCase 后台程序将根据你输入的值去需找相应的驱动库，从而为后面的删除操作做准备。<\/p><p>通过 rmprovider 去删除在 vob，stream，brtype 上配置的 provider 信息。如下图所示：<\/p><div class=\"codesection\"><pre class=\"displaycode\">Usage: rmprovider {-vob vob-selector | -replica replica-selector |\n-brtype brtype-selector | -stream stream-selector} provider_name<\/pre><\/div><h5 id=\"N10215\">图 17.\n    删除在 vob 和 stream 上配置的 provider 信息<\/h5><img alt=\"删除在 vob 和 stream 上配置的 provider 信息\" src=\"/sunshine_new/images/1029467712/image034.jpg\" width=\"637\" /><h2 id=\"5.使用 UCMClearCase 通过 CMI 和 RTC 集成（TBD）|outline\">使用 UCM ClearCase 通过 CMI 和 RTC 集成 （TBD）<\/h2><p>由于 RTC 本身已经支持 OSLC，因此当我们需要实现 Base ClearCase 与 RTC 集成时，只需要配置特定的针对 RTC 的 CMI Provider 即可。<\/p><p>从 V8.0.0.7 起，ClearCase 本地客户端( cleartool 和 native GUIs)支持基于 CMI 的 UCM ClearCase 与 RTC 集成。在配置集成前，ClearCase 管理员需要配置集成相关的 VOBs 和 UCM streams。步骤如下所示：<\/p><p>步骤一：安装 CLM jazz 平台并在 RTC 创建样例项目。<\/p><h5 id=\"N1022C\">图 18. RTC 样例工作项<\/h5><img alt=\"RTC 样例工作项\" src=\"/sunshine_new/images/1029467712/image036.jpg\" width=\"616\" /><p>我们创建了几个样例工作项主要有 ID 和 Summary 信息。<\/p><p>步骤二：通过\"Cleartool mkattype\"命令，为指定的 VOB 添加 CMI 所必需的 attrType 属性 CC_CMI_PROVIDERS。如图 19\n    所示：<\/p><h5 id=\"N1023C\">图 19. 为 VOB 添加 CMI 所必须的属性<\/h5><img alt=\"为 VOB 添加 CMI 所必须的属性\" src=\"/sunshine_new/images/1029467712/image037.jpg\" width=\"613\" /><p>步骤三：通过\"Cleartool mkcmprovider -vob\"命令创建对应于 RTC 的 Provider，该 Provider 用于保存当前所需要集成的 RTC 提供服务的 OSLC 地址信息 baseUrl；同时通过\"Cleartool mkcmprovider -stream\"命令为指定的 VOB 及其 stream 添加 CMI 进行查询时所需的 queryUri 相对地址，如图 20，21 所示:<\/p><p>以下范例完成在 project vob 里创需要集成的 Provider Server。下面语句在所要集成的 VOB 里创建一个名字为 RTCPROVU 的 Provider Server，并自动关联到 VOB 属性里。<\/p><h5 id=\"N1024C\">图 20.\n    为 VOB 创建连接 RTC 的 Provider<\/h5><img alt=\"为 VOB 创建连接 RTC 的 Provider\" src=\"/sunshine_new/images/1029467712/image039.jpg\" width=\"617\" /><p><code>mkcmprovider<\/code>相关参数介绍如下。<\/p><p>-<code>vob<\/code>：指定需要使用 CMI 与 CLM 集成的 vob；<\/p><p>-<code>type<\/code>：当前所创建的 CMI Provider 类型，由于是与 RTC 集成，因此值为\"cmrtc\"；<\/p><p>-<code>ver<\/code>：CMI 功能版本号，值为\"v1_0\" ；<\/p><p>-<code>desc<\/code>：当前 CMI RTC Provider 描述信息；<\/p><p>-<code>connection<\/code>：provider server 提供的 OSLC URL 地址，格式为：baseurl:http://ip:port/ccm<\/p><p>RTCPROVU 是我们所创建的 CMI Provider 的名字<\/p><p>这里的-ver 和-type 是特定的 provider 类型，CMI 需要这两个信息加载相应的驱动库，如果填写错误将导致无法找到相应的 provider 错误。 CMI 会验证 connection 地址的正确性，如果未通过验证，将报 URI 地址无法访问错误。<\/p><p>此操作必须在 Vob 里创建完 Provider 信息后，否则就会报找不到相应 Provider 的错误。<\/p><p>如果是采用 UCM 集成，需要在 stream 引用此 provider，并将 provider 与 stream 上的 activity 做关联。UCM ClearCase 与 RTC 集成独特之处在于：在 activity 上关联集成的 RTC server provider 信息后，在这个 activity 下所有的 version 更改信息就会传到 Server Provider 端。<\/p><h5 id=\"N1027D\">图 21.\n    在 Vob 里的 Stream 上引用在 Vob 里定义的 Provider 信息<\/h5><img alt=\"在 Vob 里的 Stream 上引用在 Vob 里定义的 Provider 信息\" src=\"/sunshine_new/images/1029467712/image041.jpg\" width=\"618\" /><p>Activityformat 属性定义了 activity 格式。因此在 mkact 命令创建 activity 时将默认使用此格式，自动创建 activity 名字，除非你重新指定所要创建的 activity 名字。<\/p><p>enable 属性用于确定是否启用 ClearCase 与 provider 的集成，如果不想再和这个 provider 集成，可以设置属性 enable 为 false。<\/p><p>validate 属性用于确定这个 provider 的某个 task 必须和 RTC 的 activity 有关联，就是 ClearCase vob 里的 activity 必须关联到此 provider 的某个 work item。<\/p><p>最后通过 lsprovider 命令检查在 vob 和 stream 上的 provider 配置是否正确，在配置之前也可以先 lsprovider 查看是否有人已经配置，以免重复配置。<\/p><p>如果需要更改这个 provider 的相关配置，可以在创建命令行里添加 \"-replace\"参数。具体的，请运行<code>cleartool mkcmprovider Chelp<\/code>获得相关命令使用帮助。<\/p><p>步骤四：通过\"cmiregister add\"命令创建对于 RTC 的连接属性<\/p><p>通过\" <code>cmiregister add -cq -name RTCPROVU -username UD0001 -password ec11ipse<\/code>\" 命令创建对应之前创建的 Provider 所需的 RTC 认证属性，从而记录连接 RTC 所需要的登陆信息；添加完成后，可以通过\"cmiregister list\"命令来进行查看。<\/p><h5 id=\"N1029D\">图 22. 创建并记录链接 RTC 的登录信息：<\/h5><img alt=\"创建并记录链接 RTC 的登录信息：\" src=\"/sunshine_new/images/1029467712/image043.jpg\" width=\"608\" /><p>步骤五：创建 activity，并为当前的 ClearCase 操作与 RTC work item 相关联。<\/p><p>Activity 是 ClearCase UCM 模式中的一个概念，通过变更集 (Change Set) 跟踪完成一项开发任务所引起的所有配置项的变更。在 UCM 模式下，所有的 Check Out 、 Check In 、 Add to Source Control 等引起配置项发生变化的操作必须关联到一个 Activity。下图 23,24 演示如何创建 activity 并与 RTC 的 WI 相关联。<\/p><p>用户在任何时候要向控制 vob 添加资源或修改已经处于 vob 控制之下的资源，都必须将操作与某个 UCM 活动相关联。我们在 stream 上创建 activity 的同时，可以创建此 activity 关联的 provider 的 taskid。<\/p><h5 id=\"N102AF\">图 23. 创建 Activity 并将 Activity 与 RTC work\n    item 做关联<\/h5><img alt=\"创建 Activity 并将 Activity 与 RTC work item 做关联\" src=\"/sunshine_new/images/1029467712/image045.jpg\" width=\"617\" /><p>此处 100 就是 provider RTCPROVU 的一个 work item id。此创建过程会验证 RTC server provider 和 work item id 信息的正确性，如果不存在会报错，但是 activity 仍然能创建成功，就是没有关联到相关 RTC server。<\/p><p>ACT_100_DEV_STREAM 是 ClearCase 创建的活动名称。由于没有指定 activity 名称，根据前面的设置，系统将自动创建格式为 ACT_%task-id_%stream-name 的活动。<\/p><p>上述步骤配置完毕，用户就可以通过 cleartool co/ci/mkelem 等命令实现对 ClearCase VOB 元素的各种操作。<\/p><h5 id=\"N102C1\">图 24. 检查 CC 变更与 RTC\n    Wi 工作项的关联<\/h5><img alt=\"检查 CC 变更与 RTC Wi 工作项的关联\" src=\"/sunshine_new/images/1029467712/image047.jpg\" width=\"617\" /><p>根据上面图 21 的设置，当我们创建与 WI 相关联的 activity 时，如果没有指定 activity 名称，系统将根据缺省的 activityFormat 来命名新创建的 activity。也可以将一个 activity 与多个 RTC 中的 WI 相关联。如下图 25 所示。<\/p><h5 id=\"N102CF\">图 25.\n    Activity 与多个 RTC 中多个 WI 相关联<\/h5><img alt=\"Activity 与多个 RTC 中多个 WI 相关联\" src=\"/sunshine_new/images/1029467712/image049.jpg\" width=\"618\" /><p>这样我们就完成了 UCM Clearcase 与 RTC 通过 CMI 实现集成的操作。<\/p><h2 id=\"6.结论 |outline\">结论<\/h2><p>本文介绍如何通过使用 Rational&#174; ClearCase CM 来实现 UCM ClearCase 与 ClearQuest 及 RTC 的集成。希望通过本文，能为使用 Rational&#174; ClearCase 的用户在处理和 CLM 集成需求方面有一定的参考，并对基于 CMI UCM 集成逻辑比较复杂的命令使用方法给出范例和建议，帮助用户更好地使用 CMI 功能。<\/p><CMA ID: 975576><Site ID: 10><XSLT stylesheet used to transform this file: dw-document-html-7.0.xsl>\r\n\r\n\r\n<\/div>\r\n<\/div>\r\n","createTime":"2014-06-25 00:00:00","deployTime":"2014-06-25 00:00:00","id":0,"intro":"ClearCase 和其他产品的传统集成方法是当需要和一个产品集成就做一套针对性方案，和每个产品的集成配置操作复杂而不高效，源代码中涉及很多集成产品的逻辑，这样导致扩展性不好，源代码难以维护。新的集成方案采用的是可插拔式，动态加载，通过统一的定制好的规则接口和新产品的通信，ClearCase 的源代码无需任何改动，就可以方便快捷的和第三方产品集成，而且配置，使用都很简单，这种简易的集成特性，拓展了 ClearCase 在其他领域的应用。本系列通过具体的例子详细介绍了如何通过使用 CMI 实现 UCM ClearCase 与 ClearQuest 及 RTC 的集成，展现 ClearCase 在 UCM 下强大的集成功能和易用性。","keyword":"","recommend":false,"source":"http://www.ibm.com/developerworks/cn/rational/1406_zhaoliang_ccclm1/index.html","title":"通过 CMI 实现 UCM ClearCase 和 CLM 的集成","typeId":0,"updateTime":"2014-06-25 00:00:00"}
{"author":"","clickNumber":0,"content":"\r\n<div class=\"ibm-columns\">\r\n<div class=\"ibm-col-1-1\">\r\n\r\n<h2 id=\"1.Introduction|outline\">简介<\/h2><p>在开发要安装在 IBM PureApplication System、IBM SmartCloud Orchestrator 或 IBM\n                Workload Deployer\n                上的虚拟应用程序模式工作负载时，您会遇到您的插件需要管理产品二进制文件的情形。产品二进制文件可能是您自己的，或者来自 IBM、SAP&#174; 或\n                Oracle&#174;\n                等第三方供应商。在本文中，您将看到可用于管理产品二进制文件的不同战略，了解您的插件如何访问和安装这些二进制文件。您还将了解这些不同战略的相对优势和劣势。<\/p><h2 id=\"2.Strategiestomanageproductbinaries|outline\">管理产品二进制文件的战略<\/h2><p>管理产品二进制文件的战略可分为以下几类：<\/p><ul class=\"ibm-bullet-list\"><li>使用 Storehouse 存储库<\/li><li>使用共享服务存储库服务器<\/li><\/ul><h2 id=\"3.UsingtheStorehouserepository|outline\">使用 Storehouse 存储库<\/h2><p>Storehouse 存储库包含系统工件、虚拟应用程序模式工作负载工件、虚拟应用程序模式部署运行时工件，以及虚拟应用程序模式故障排除工件。您可以使用\n                Storehouse Browser 查看存储在 Storehouse 存储库中的工件。<\/p><p>在 IBM Workload Deployer 和 IBM PureApplication System 中，您可以导航到\n                    <strong>Workload console &gt; System &gt; Storehouse Browser<\/strong>\n                来找到 Storehouse Browser。在 IBM SmartCloud Orchestrator 中，可以导航到\n                    <strong>SmartCloud Orchestrator console &gt; Administration &gt;\n                    Storehouse Browser<\/strong> 来找到 Storehouse Browser。只有拥有查看 System 菜单（或\n                Administration 菜单）的权限的用户才能查看 Storehouse Browser。图 1 展示了 Storehouse Browser\n                的典型内容。<\/p><h5 id=\"N10094\">图 1. Storehouse Browser<\/h5><img alt=\"Storehouse Browser\" src=\"/sunshine_new/images/负233051470/images/figure1.jpg\" width=\"850\" height=\"437\" /><p><a href=\"#N10098\" class=\"ibm-popup-link\" onclick=\"ibmweb.overlay.show('N10098',this);return false;\">点击查看大图<\/a><\/p><div id=\"N10098\" class=\"dw-sidefile-overlay ibm-common-overlay ibm-overlay-alt-two\"><div class=\"ibm-head\"><p><a href=\"#close\" class=\"ibm-common-overlay-close\">关闭 [x]<\/a><\/p><\/div><div class=\"ibm-body\"><div class=\"ibm-main\"><div class=\"ibm-title\"><h2>图 1. Storehouse Browser<\/h2><\/div><div class=\"ibm-container ibm-alternate\"><div class=\"ibm-container-body\"><img alt=\"Storehouse Browser\" src=\"/sunshine_new/images/负233051470/images/figure1.jpg\" width=\"1200\" /><\/div><\/div><\/div><\/div><div class=\"ibm-footer\"><><\/div><\/div><p>您可以使用 Storehouse 存储库来存储产品二进制文件。在工作负载部署期间，虚拟应用程序模式可以从 Storehouse\n                下载二进制文件，然后在虚拟机上安装和配置它们。要将产品二进制文件上传到 Storehouse，您可以采用以下技术之一：<\/p><ul class=\"ibm-bullet-list\"><li>使用 cURL 上传二进制文件。<\/li><li>使用您的模式类型上传二进制文件。<\/li><li>使用不同的二进制上传模式类型来上传二进制文件。<\/li><\/ul><p>上述每种技术各有优点和缺点。以下各节将介绍如何使用上述 3 种技术。通过将二进制文件 rhel_rpm.tgz 上传到以下 Storehouse\n                存储库位置，我们将演示上述技术：<code>/admin/files/Sample/Common/<\/code>。<\/p><h3 id=\"N100AB\">使用 cURL 上传二进制文件<\/h3><p>对于这项技术，您将使用 cURL 实用程序将一个二进制文件上传到 Storehouse 存储库，如清单 1 所示。清单 1\n                中的代码将文件上传到该位置，如图 2 所示。<\/p><h5 id=\"fig2\">图 2. Storehouse Browser 中的文件位置<\/h5><img alt=\"Storehouse Browser 中的文件位置\" src=\"/sunshine_new/images/负233051470/images/figure2.jpg\" width=\"495\" height=\"629\" /><p><a href=\"#N100B7\" class=\"ibm-popup-link\" onclick=\"ibmweb.overlay.show('N100B7',this);return false;\">点击查看大图<\/a><\/p><div id=\"N100B7\" class=\"dw-sidefile-overlay ibm-common-overlay ibm-overlay-alt-two\"><div class=\"ibm-head\"><p><a href=\"#close\" class=\"ibm-common-overlay-close\">关闭 [x]<\/a><\/p><\/div><div class=\"ibm-body\"><div class=\"ibm-main\"><div class=\"ibm-title\"><h2>图 2. Storehouse Browser 中的文件位置<\/h2><\/div><div class=\"ibm-container ibm-alternate\"><div class=\"ibm-container-body\"><img alt=\"Storehouse Browser 中的文件位置\" src=\"/sunshine_new/images/负233051470/images/figure2.jpg\" width=\"700\" /><\/div><\/div><\/div><\/div><div class=\"ibm-footer\"><><\/div><\/div><p>此技术的优点包括：<\/p><ul class=\"ibm-bullet-list\"><li>与其他两种技术相比，它相对简单一些。<\/li><li>它不需要其他任何工件或代码来上传二进制文件。<\/li><\/ul><p>此技术的限制包括：<\/p><ul class=\"ibm-bullet-list\"><li>cURL 的一些特征在上传的文件大小上是有限制的。<\/li><li>此方法可能不适合 PureApplication System。<\/li><\/ul><p>此外，您需要管理员权限才能将文件上传到存储库。<\/p><h5 id=\"listing1\">使用 cURL\n                上传产品二进制文件。<\/h5><div class=\"codesection\"><pre class=\"displaycode\">#Upload file to storehouse under /admin/files/Sample/Common.\ncurl -v -u <em>&lt;user&gt;<\/em>:<em>&lt;password&gt;<\/em> -k -X PUT --data-binary @rhel_rpm.tar.tgz -H \"Content-Type:\napplication/octet-stream\" https://<em>&lt;server_name&gt;<\/em>/storehouse/admin/files/Sample/Common/ rhel_rpm.tgz\n#Give full access to the current user and group Everyone to download the file.\ncurl -v -i -u <em>&lt;user&gt;<\/em>:<em>&lt;password&gt;<\/em> -k -X POST -H \"Content-Type: application/json\" \n-X POST -d \"{\\\"AccessRights\\\":{\\\"$USER\\\":\\\"F\\\",\\\"_group_:Everyone\\\":\\\"\nF\\\"}}\" https://<em>&lt;server_name&gt;<\/em>/storehouse/admin/files/Sample/Common/rhel_rpm.tgz?meta<\/pre><\/div><p>如果在 PureApplication System 上使用此技术，文件会上传到\n                Storehouse，但您可能无法将它下载到您的虚拟应用程序模式中，因为您无法将组访问控制（如上面第二个 curl 命令所示）设置为\n                “Everyone”。<\/p><h3 id=\"N100E6\">使用您的模式类型上传二进制文件<\/h3><p>对于此技术，您需要使用包含您的虚拟应用程序模式插件的模式类型来包装二进制文件。如果使用任何归档文件解压工具打开一个构建的模式类型，效果如图 3\n                所示。归档文件包含一个 patterntypes 文件夹（其中包含一个归档文件格式的模式类型项目）和一个 plugins\n                文件夹（其中包含一个归档文件格式的插件项目。将此模式类型安装到 Workload Deployer、PureApplication System 或\n                SmartCloud Orchestrator 中后，patterntypes 文件夹的内容存储在 Storehouse 存库中的\n                “/admin/patterntypes” 下，plugins 文件夹的内容存储在 Storehouse 存储库中的\n                “/admin/plugins” 下。<\/p><h5 id=\"N100EE\">图 3. 展开的已构建好的模式类型归档文件<\/h5><img alt=\"展开的已构建好的模式类型归档文件\" src=\"/sunshine_new/images/负233051470/images/figure3.jpg\" width=\"800\" /><p>现在您已经知道了 Storehouse 存储库的工作原理，为了将二进制文件\n                <code>rhel_rpm.tgz 放在 /admin/files/Sample/Common<\/code> 下，您需要一个名为\n                <code>files/Sample/Common<\/code> 的额外文件夹，其中包含已构建的模式类型归档文件中的文件\n                <code>rhel_rpm.tgz<\/code>，如图 4 所示。安装这种修改的模式类型时，二进制文件会存储在 Storehouse 存储库中的\n                <code>/admin/files/Sample/Common<\/code> 下，如 <a href=\"#fig2\">图 2<\/a>\n                所示。<\/p><h5 id=\"N1010A\">图 4. 包含二进制文件的扩展的已修改模式类型归档文件<\/h5><img alt=\"包含二进制文件的扩展的已修改模式类型归档文件\" src=\"/sunshine_new/images/负233051470/images/figure4.jpg\" width=\"550\" /><p>为了帮助您按图 4 所示打包二进制文件，我们在本文的 “下载” 部分提供了一个名为 <a href=\"#download\">addStorehouseFiles.xml<\/a> 的 Ant 构建文件。可在 IBM Workload Deployer\n                Eclipse PDK 环境中运行这个实用程序。要使用此实用程序，可打开您的 IBM Workload Deployer Eclipse PDK\n                环境，并将此 Ant 文件放在您的模式类型项目下，如图 5 所示。您还应该创建一个名为\n                    <strong>storehouse/files<\/strong> 的文件夹，如图 5 所示。子文件夹文件对应于图 4 中显示的 files\n                文件夹。<\/p><p>在使用 <strong>IBM Pattern toolkit &gt; build<\/strong> 构建模式类型后，右键单击\n                    <strong>addStorehouseFiles.xml<\/strong> 并选择 <strong>Run As &gt; Ant\n                    Build<\/strong>。Ant 脚本会解压归档文件\n                <code>/patterntype_project/export/built_pattern_type_version.tgz<\/code>，该文件是在模式构建步骤中创建的。它将该文件夹重新压缩到\n                <code>/patterntype_project/storehouse<\/code> 下。在使用示例 Ant 脚本之前，编辑\n                    <strong>addStorehouseFiles.xml<\/strong> 并更改 patternTypeFile\n                属性的值，以反映您的模式类型名称和版本。<\/p><h5 id=\"N10131\">图 5. 包含 addStorehouseFiles.xml 实用程序的模式类型 PDK\n                    项目<\/h5><img alt=\"包含 addStorehouseFiles.xml 实用程序的模式类型 PDK 项目\" src=\"/sunshine_new/images/负233051470/images/figure5.jpg\" width=\"708\" height=\"246\" /><p><a href=\"#N10135\" class=\"ibm-popup-link\" onclick=\"ibmweb.overlay.show('N10135',this);return false;\">点击查看大图<\/a><\/p><div id=\"N10135\" class=\"dw-sidefile-overlay ibm-common-overlay ibm-overlay-alt-two\"><div class=\"ibm-head\"><p><a href=\"#close\" class=\"ibm-common-overlay-close\">关闭 [x]<\/a><\/p><\/div><div class=\"ibm-body\"><div class=\"ibm-main\"><div class=\"ibm-title\"><h2>图 5. 包含 addStorehouseFiles.xml 实用程序的模式类型 PDK\n                    项目<\/h2><\/div><div class=\"ibm-container ibm-alternate\"><div class=\"ibm-container-body\"><img alt=\"包含 addStorehouseFiles.xml 实用程序的模式类型 PDK 项目\" src=\"/sunshine_new/images/负233051470/images/figure5.jpg\" width=\"1000\" /><\/div><\/div><\/div><\/div><div class=\"ibm-footer\"><><\/div><\/div><p>使用此技术的优点包括：<\/p><ul class=\"ibm-bullet-list\"><li>您可上传您想要的任意大小的文件。如果使用工作负载控制台用户界面安装该模式，您拥有 2GB 的限制。对于大于 2 GB 的大小，可使用工作负载\n                    CLI 环境。<\/li><li>您可以将二进制文件和相关插件打包并作为单个实体进行传送。<\/li><\/ul><p>如果使用此技术，在从系统删除模式类型时，会从 Storehouse 存储库删除二进制文件。这会导致以下限制：<\/p><ul class=\"ibm-bullet-list\"><li>如果二进制文件非常大，那么每次更新模式类型的功能元素时都会花很多时间和网络资源。<\/li><li>如果希望跨模式类型共享同某个二进制文件，则必须保留用来将二进制文件上传到系统中的模式类型，即使您不需要它。<\/li><\/ul><p>您需要获得管理员权限才能上传模式类型。要使用此技术，您必须是管理员组的成员。<\/p><h3 id=\"N1014A\">使用不同的二进制上传模式类型来上传二进制文件<\/h3><p>为了解决上述限制，可将二进制文件与包含虚拟应用程序模式的功能性工件的模式类型分离。使用此技术，无需让一种模式类型同时包含二进制文件和虚拟应用程序模式插件，您会有两种模式类型。第一种模式类型仅包含二进制文件，第二种模式类型包含您的虚拟应用程序模式插件。您将按照创建上一节中的模式类型的方式创建该模式类型。惟一的不同是，此模式类型没有任何虚拟应用程序模式插件。图\n                6 演示了一个仅包含示例二进制文件的模式类型。将二进制文件与虚拟应用程序模式插件分离后，可与功能性工件独立地管理二进制文件。<\/p><h5 id=\"N10152\">图 6. 展开的仅包含二进制文件的模式类型<\/h5><img alt=\"展开的仅包含二进制文件的模式类型\" src=\"/sunshine_new/images/负233051470/images/figure6.jpg\" width=\"750\" /><p>使用此技术的优点包括：<\/p><ul class=\"ibm-bullet-list\"><li>可跨模式类型共享二进制文件。<\/li><li>可彼此独立地更新和管理二进制文件和模式的功能性方面。<\/li><\/ul><p>您仍然需要获得管理员权限才能上传模式类型。要使用此技术，您必须是管理员组的成员。<\/p><h2 id=\"4.DownloadingbinaryfilesfromtheStorehouserepository|outline\">从 Storehouse 存储库下载二进制文件<\/h2><p>现在您已经将二进制文件上传到 Storehouse 存储库，我们看看如何将这些文件下载到虚拟应用程序模式实例所创建的\n                VM。您可以使用部件生命周期脚本中的虚拟应用程序模式 maestro 框架从 Storehouse 存储库下载文件。有关虚拟应用程序模式\n                maestro 框架和部件生命周期脚本的详细信息，请参阅本文的 <a href=\"#resources\">参考资料<\/a> 部分。<\/p><p>清单 2 演示了如何从 Storehouse 存储库下载二进制文件。在调用 maestro.filesurl 后，会以 HTTP URL 格式返回\n                <code>/admin/files<\/code> 的位置。然后您可以将文件位置附加到这个 URL，使用 maestro.downloadx\n                方法下载该文件并将它提取到您想要的位置。将文件下载到虚拟应用程序模式虚拟机后，就可以开始安装和配置二进制文件。<\/p><h5 id=\"listing2\">清单 2. 从 Storehouse\n                存储库下载文件<\/h5><div class=\"codesection\"><pre class=\"displaycode\">def downloadBinaries():\n\tlogger.debug(\"enter downloadBinaries\")\n\tfileName = 'Sample/Common/rhel_rpm.tgz'\n\tinstallerUrl = urlparse.urljoin(maestro.filesurl, fileName)   \n\tdownloadPath = '/home/virtuser'    \n\tlogger.debug('download ' + installerUrl)\n\tmaestro.downloadx(installerUrl, downloadPath)\n\tlogger.debug(\"exit downloadBinaries\")<\/pre><\/div><p>在本文中，我们提供了 <a href=\"#download\">示例代码<\/a> 来展示如何创建一个仅包含二进制文件的模式类型\n                (patterntype.binaryonly)，以及如何创建一个同时包含二进制文件和功能性插件（patterntype.storehouseupload\n                和 plugin.storehouseupload）的模式类型。<\/p><h2 id=\"5.Usingthesharedservicerepositoryserver|outline\">使用共享服务存储库服务器<\/h2><p>共享服务是预定义的虚拟应用程序模式，可由同一个云组中的多个工作负载部署共享，这些工作负载包括虚拟应用程序、虚拟系统和虚拟设备。每个云组仅允许共享服务的一个实例。有关共享服务和如何开发共享服务的更多细节，请参阅\n                    <a href=\"#resources\">参考资料<\/a> 部分。<\/p><p>您可以创建一个可托管您的工作负载需要的二进制文件的共享服务存储库服务器。共享服务存储库服务器可公开一些必要的接口，以便需要二进制文件的虚拟应用程序模式工作负载能够使用公开的接口连接到存储库服务器，并下载合适的文件。<\/p><p>在本文中，我们提供了一个 <a href=\"#download\">示例共享服务存储库服务器<\/a>（用作一个 NFS\n                服务器）和一个虚拟应用程序模式工作负载客户端（使用 NFS\n                挂载下载二进制文件）。在部署时，为共享服务存储库服务器分配了存储二进制文件所需的磁盘大小。共享服务存储库服务器还提供了一个部署后操作，可用于使用\n                HTTP 协议从外部系统上传必要的二进制文件。图 7 演示了这个部署后操作的视图。<\/p><h5 id=\"N10194\">图 7. 共享服务器操作的视图<\/h5><img alt=\"共享服务器操作的视图\" src=\"/sunshine_new/images/负233051470/images/figure7.jpg\" width=\"708\" height=\"282\" /><p><a href=\"#N10198\" class=\"ibm-popup-link\" onclick=\"ibmweb.overlay.show('N10198',this);return false;\">点击查看大图<\/a><\/p><div id=\"N10198\" class=\"dw-sidefile-overlay ibm-common-overlay ibm-overlay-alt-two\"><div class=\"ibm-head\"><p><a href=\"#close\" class=\"ibm-common-overlay-close\">关闭 [x]<\/a><\/p><\/div><div class=\"ibm-body\"><div class=\"ibm-main\"><div class=\"ibm-title\"><h2>图 7. 共享服务器操作的视图<\/h2><\/div><div class=\"ibm-container ibm-alternate\"><div class=\"ibm-container-body\"><img alt=\"共享服务器操作的视图\" src=\"/sunshine_new/images/负233051470/images/figure7.jpg\" width=\"1000\" /><\/div><\/div><\/div><\/div><div class=\"ibm-footer\"><><\/div><\/div><p>Workload Deployer、PureApplication System 和 SmartCloud Orchestrator\n                共享服务基础架构提供了一个注册表，其中包含已部署的共享服务的信息。客户端可在这个注册表中查询它想要使用的共享服务的信息。在示例中，存储库服务器通过此注册表向客户端公开它的主机名和\n                NFS 挂载端点。清单 3 演示了如何使用 RegistryProvider\n                接口向共享服务注册表提供信息。共享服务存储库服务器中一个有趣的存储库客户端，然后可在它的生命周期脚本中使用 maesro.registry\n                框架，从注册表获取共享服务服务器主机名和 NFS 端点，从 NFS 端点复制必要的二进制文件。清单 4\n                演示了存储库客户端如何从服务器公开的注册表获得详细信息。<\/p><h5 id=\"listing3\">清单 3.\n                    向注册表提供共享服务存储库服务器信息的代码<\/h5><div class=\"codesection\"><pre class=\"displaycode\">public class SampleSharedServiceRegistryProvider implements RegistryProvider {\n  private static final String CLASS_NAME =\n   SampleSharedServiceRegistryProvider.class.getCanonicalName();\n  private static Logger logger = Logger.getLogger(CLASS_NAME);\n  public final String LOCAL_BINARIES_REPOS_PATH=\"/shared_repository\";\n  public JSONArtifact getRegistry(String clientVersion,\n    Map&lt;String, JSONObject&gt; deploymentInfo) throws HttpException {\n    String METHOD = \"getRegistry\";\n    JSONObject registry = new JSONObject();\n    JSONObject deploymentDoc = deploymentInfo.get\n        (RegistryProviderConstants.DEPLOYMENT_DOC);\n    logger.logp(Level.FINE, CLASS_NAME, METHOD, \"enter getRegistry \");\n    //get instance ip addresses and return in the registry\n    if(deploymentDoc != null){\n      JSONObject instances = (JSONObject) deploymentDoc.get(\"instances\");\n      if (null != instances) {\n\tfor (Object key : instances.keySet()) {\n\t String keystr = (String)key;\n\t if(keystr.startsWith(\"SampleSharedService\")){\n           <strong>Object ipAddr = ((JSONObject) instances.get(key)).get(\"public-ip\");\n                       String ip = (String)ipAddr;\n                       registry.put(\"serviceHost\", ip);<\/strong>\n\t }\n        }\n      }\n     }\n     <strong>registry.put(\"mountPoint\", LOCAL_BINARIES_REPOS_PATH);<\/strong>\n     logger.logp(Level.FINE, CLASS_NAME, METHOD,\n         \"getRegistry exit. Registry return=\"+registry);\n     return registry;\n  }\n}<\/pre><\/div><h5 id=\"listing4\">清单 4.\n                    从注册表检索共享服务存储库服务器信息的客户端代码<\/h5><div class=\"codesection\"><pre class=\"displaycode\"># Retrieve info on SharedService (IP) so we know where to go\nregInfo = maestro.registry.getRegistry(<em>\"sampleMediaService\"<\/em>, <em>\"1.0\"<\/em>)\nserviceHost = regInfo[<em>'serviceHost'<\/em>]\nmountPoint = regInfo[<em>'mountPoint'<\/em>]<\/pre><\/div><p>此方法的优点在于，如果不希望通过 Storehouse\n                共享二进制文件，那么您可以拥有自己的二进制存储库服务器。因为我们使用了共享服务注册表作为查找目录，所以要求二进制文件的客户端与提供二进制文件的服务器之间的交互是松散耦合的。<\/p><p>使用共享服务存储库服务器的主要限制是，您只能为每个云组下载一种类型的共享服务。因此，云组中的所有部署必须共享同一个存储库服务器。此外，还有共享服务服务器开发和部署的其他开销。要安装和部署共享服务服务器，您需要获得管理员权限。<\/p><h2 id=\"6.Workingwiththesamples|outline\">用例<\/h2><p>以下 <a href=\"#download\">示例模式类型<\/a>（包含源代码）可用于本文：<\/p><ul class=\"ibm-bullet-list\"><li>patterntype.binaryonly-1.0.0.0.tgz<\/li><li>patterntype.storehouseupload-1.0.0.0.tgz<\/li><li>ptype.installsharedservice-1.0.0.0.tgz<\/li><\/ul><h3 id=\"N101D3\">使用 Storehouse 存储库的示例<\/h3><p>安装 <strong>patterntype.binaryonly-1.0.0.0.tgz <\/strong> 或\n                    <strong>patterntype.storehouseupload-1.0.0.0.tgz<\/strong> 时，您会看到一个名为\n                “/admin/files/Sample/Common/ rhel_rpm.tgz” 的文件被添加到 Storehouse 中，如 <a href=\"#fig2\">图 2<\/a> 所示。<\/p><p>除此之外，通过使用\n                <strong>patterntype.storehouseupload-1.0.0.0.tgz<\/strong>，您可以创建一个示例虚拟应用程序模式，如图\n                8 所示。部署此虚拟应用程序模式时，它会将上传到 Storehouse 中的文件下载并解压到虚拟机上的\n                    <strong>/home/virtuser/binaries<\/strong> 中。虚拟应用程序模式使用了 <a href=\"#listing2\">清单 2<\/a> 中所示的代码来下载该文件。<\/p><h3 id=\"N101F0\">上传大型二进制文件的技巧<\/h3><p>如果使用 Workload 控制台或 SmartCloud Orchestrator 控制台用户界面来安装模式类型，那么您将<em>无法<\/em>\n                安装大于 2 GB 的模式类型。无法使用控制台浏览器接口将大型二进制文件导入 Storehouse 中。要克服此限制，需要使用 CLI API\n                安装模式类型。您可以执行以下步骤来从命令行安装模式类型：<\/p><ol type=\"1\"><li>打开一个命令提示符，并更改到模式类型归档文件所在的目录。<\/li><li>从 IBM Workload Deployer、IBM PureApplication System 或 IBM SmartCloud\n                    Orchestrator 系统下载 <strong>CLI 压缩文件<\/strong>。然后将它解压到\n                        <strong>/pathToCli<\/strong> 下。<\/li><\/ol><p>从命令行运行以下命令，具体情况取决于您的 IBM 云解决方案：<\/p><div class=\"codesection\"><pre class=\"displaycode\">/pathToCli/pure.cli/bin/pure -h IPAS_IP -u &lt;user&gt; -p &lt;pwd&gt;<\/pre><\/div><p>或者<\/p><div class=\"codesection\"><pre class=\"displaycode\">/pathToCli/deployer.cli/bin/deployer -h IPAS_IP -u &lt;user&gt; -p &lt;pwd&gt;<\/pre><\/div><p>返回到 CLI 提示符后，运行以下命令： <\/p><div class=\"codesection\"><pre class=\"displaycode\">deployer.patterntypes.create('YourPatternType-1.0.0.0.tgz')<\/pre><\/div><h5 id=\"N10216\">图 8. 使用 patterntype.storehouseupload\n                    创建的虚拟应用程序<\/h5><img alt=\"使用 patterntype.storehouseupload 创建的虚拟应用程序\" src=\"/sunshine_new/images/负233051470/images/figure8.jpg\" width=\"850\" height=\"613\" /><p><a href=\"#N1021A\" class=\"ibm-popup-link\" onclick=\"ibmweb.overlay.show('N1021A',this);return false;\">点击查看大图<\/a><\/p><div id=\"N1021A\" class=\"dw-sidefile-overlay ibm-common-overlay ibm-overlay-alt-two\"><div class=\"ibm-head\"><p><a href=\"#close\" class=\"ibm-common-overlay-close\">关闭 [x]<\/a><\/p><\/div><div class=\"ibm-body\"><div class=\"ibm-main\"><div class=\"ibm-title\"><h2>图 8. 使用 patterntype.storehouseupload\n                    创建的虚拟应用程序<\/h2><\/div><div class=\"ibm-container ibm-alternate\"><div class=\"ibm-container-body\"><img alt=\"使用 patterntype.storehouseupload 创建的虚拟应用程序\" src=\"/sunshine_new/images/负233051470/images/figure8.jpg\" width=\"1200\" /><\/div><\/div><\/div><\/div><div class=\"ibm-footer\"><><\/div><\/div><h3 id=\"N1021F\">使用共享服务存储库模式类型的示例<\/h3><p>安装和启用模式类型 <strong>ptype.installsharedservice-1.0.0.0.tgz<\/strong>\n                后，部署共享服务，使用为您的二进制存储库提供的磁盘大小作为输入。部署共享服务后，必须使用 Virtual Application Console\n                中提供的部署后操作，在共享服务存储库中填充二进制文件。为此，共享服务运行后，选择运行的共享服务实例并单击\n                    <strong>Manage<\/strong> 按钮。Virtual Application Console 将会打开。在 Virtual\n                Application Console 中选择 <strong> Operations &gt; Media\n                Service<\/strong>。您会看到如图 7 所示的两个可用操作。使用第二个操作 <strong>Import file via\n                    HTTP<\/strong> 来填充二进制存储库。如果有多个文件，那么可以运行此操作多次。<\/p><p>要测试共享服务存储库，可根据模式类型 <strong>sample.installsharedservice 1.0<\/strong>\n                来创建和部署一个虚拟应用程序模式，如图 9 所示。上一节已经介绍过，虚拟应用程序模式从注册表获取以下共享服务存储库细节、共享服务存储库 IP 和\n                NFS 挂载点（参见 <a href=\"#listing4\">清单 4<\/a> 中的代码）。客户端可使用此代码挂载端点和下载二进制文件。<\/p><h5 id=\"N1023C\">图 9. 使用 sample.installsharedservice\n                    创建的虚拟应用程序<\/h5><img alt=\"使用 sample.installsharedservice 创建的虚拟应用程序\" src=\"/sunshine_new/images/负233051470/images/figure9.jpg\" width=\"850\" height=\"617\" /><p><a href=\"#N10240\" class=\"ibm-popup-link\" onclick=\"ibmweb.overlay.show('N10240',this);return false;\">点击查看大图<\/a><\/p><div id=\"N10240\" class=\"dw-sidefile-overlay ibm-common-overlay ibm-overlay-alt-two\"><div class=\"ibm-head\"><p><a href=\"#close\" class=\"ibm-common-overlay-close\">关闭 [x]<\/a><\/p><\/div><div class=\"ibm-body\"><div class=\"ibm-main\"><div class=\"ibm-title\"><h2>图 9. 使用 sample.installsharedservice\n                    创建的虚拟应用程序<\/h2><\/div><div class=\"ibm-container ibm-alternate\"><div class=\"ibm-container-body\"><img alt=\"使用 sample.installsharedservice 创建的虚拟应用程序\" src=\"/sunshine_new/images/负233051470/images/figure9.jpg\" width=\"1200\" /><\/div><\/div><\/div><\/div><div class=\"ibm-footer\"><><\/div><\/div><h2 id=\"7.Conclusion|outline\">结束语<\/h2><p>在本文中，您了解了各种管理要在您的虚拟应用程序模式工作负载中使用的二进制文件的技术。您还了解了这些技术的相对优点和限制。基于这些优点和限制，管理二进制文件的最佳选择是使用\n                Storehouse 存储库。将二进制文件上传到 Storehouse 存储库的最佳技术是使用一种仅包含二进制文件的专门的模式类型。<\/p><h3 id=\"N1024C\">致谢<\/h3><p>感谢 IBM 的 <strong>Jim Riordan <\/strong> 帮助完成共享服务存储库技术的概念。<\/p><CMA ID: 975183><Site ID: 10><XSLT stylesheet used to transform this file: dw-document-html-7.0.xsl>\r\n<h2 id=\"download\">下载<\/h2><table class=\"ibm-data-table&#10;                    dw-download-table\" cellpadding=\"0\" cellspacing=\"0\" border=\"0\"><thead><tr><th scope=\"col\">描述<\/th><th scope=\"col\">名字<\/th><th scope=\"col\">大小<\/th><\/tr><\/thead><tbody><tr><th scope=\"row\" class=\"ibm-table-row\">代码样例<\/th><td nowrap=\"nowrap\"><a href=\"http://www.ibm.com/developerworks/apps/download/index.jsp?contentid=975183&amp;filename=code_sample.zip&amp;method=http&amp;locale=zh_CN\">code_sample.zip<\/a><\/td><td nowrap=\"nowrap\">76KB<\/td><\/tr><\/tbody><\/table>\r\n\r\n<\/div>\r\n<\/div>\r\n","createTime":"2014-06-23 00:00:00","deployTime":"2014-06-23 00:00:00","id":0,"intro":"虚拟应用程序模式是 IBM? PureApplication? System、IBM SmartCloud? Orchestrator 和 IBM Workload Deployer 中使用的一种云工作负载部署模型。在开发虚拟应用程序模式插件期间，您会遇到需要管理和安装产品二进制文件的情形。在本文中，您将了解各种管理产品二进制文件的技术。","keyword":"","recommend":false,"source":"http://www.ibm.com/developerworks/cn/cloud/library/cl-ps-aim1401-binariespureapp/index.html","title":"在虚拟应用程序模式工作负载中管理产品二进制文件","typeId":0,"updateTime":"2014-06-23 00:00:00"}
{"author":"","clickNumber":0,"content":"\r\n<div class=\"ibm-columns\">\r\n<div class=\"ibm-col-1-1\">\r\n\r\n<a id=\"OLE_LINK17\"><\/a><h2 id=\"1.背景介绍 |outline\">背景介绍<\/h2><p>前面文章具体介绍了如何使用 Base Clear Case，UCM Clear Case 和 RTC、CQ 等 Rationa CLM 产品通过 CMI 来集成，但这些集成操作都是按照最佳实践并面向单个文件的集成，其实每一步此操作都和其他操作相关联，并且和其他元素的集成信息相关联，这里有着复杂的业务逻辑关系，CMI 的后台也执行了多次的验证来确定此操作满足 CMI 的集成规则。这些规则一部分继承了传统集成方案的业务规则，同时又为了以后扩展到其他产品的集成而新建了一些规则。它们都是通过每个需要集成的 Provider（定义请参考上篇）的各自配置属性，和这些 Provider 如何配置在 Clear Case 端的在开发分支，Vob 库及流上共同来约束集成的操作。对这些规则以及配置方法的数量掌握有利于再出现操作错误时及时更改，保持 Clear Case 端和集成的 Provider Server 的数据一致性。<\/p><h2 id=\"1.Base/UCMClearCaseCMI 集成规则原理 |outline\">Base/UCM Clear Case CMI 集成规则原理<\/h2><p>    软件的开发管理有一套成熟的规则流程，对于软件的集成，在总结和集成产品的特点和最佳实践时也有一套集成规则，对于这些规则每个 CMI 使用者都应该详细了解，并能熟练使用，由于产生了新的 CMI 集成功能，又用的新的方法来实现规则约束，所以就需要在此详细介绍 CMI 的那些属性和配置决定了哪些功能和规则，新 CMI 的规则依据配置信息的具体属性来约束不同的集成操作，并且定义了操作出错后如何处理，回滚和提示信息，如何根据提示信息处理自己的误操作，这些集成规则贯穿于使用 CMI 的集成功能呢的整个生命周期。<\/p><p>本篇文章并没有详细叙述 CMI 的集成方法，而是着重于集成操作规则，通过具体例子来详细介绍使用 CMI 集成所要遵循的规则，以及出错的处理。<\/p><h2 id=\"1.准备工作 |outline\">准备工作<\/h2><p>    在进行例子之前，我们需要安装一些 Rational 的软件，包括 Clear Case 8.0.0.8 以上版本，同时需要已经配置好的 ClearQuest 服务器以及 RTC 服务器，并创建样例数据。在我们引入的例子中，我们使用了的版本如下：<\/p><p><strong>Rational Clear Case<\/strong><strong>以及 ClearQuest 8.0.0.9<\/strong>版本<\/p><p><strong>Rational Jazz Team Server Version: 4.0.4 M1<\/strong>版本<\/p><p><strong>规则 1：<\/strong>对于 Clear Case 7.0 版本默认是不开启 CMI 功能的，而对于 Clear Case 8.0 及以上是默认开启 CMI 功能<\/p><p>对于 Clear Case 7.0 如果要使用新的 CMI 功能，在 windows 操作系统下就需要 Clear Case 的安装目录 CC_Home\\Clear Case\\config 下新建 cmi 文件夹，然后创建文件 cmi.conf 并添加文本：<\/p><p>                             cmiEnabled=true<\/p><p>Windows 下默认的路径是：C:\\Program Files\\IBM\\RationalSDLC\\Clear Case\\config<\/p><p>Linux 下默认路径是：         /opt/ibm/RationalSDLC/Clear Case/config<\/p><p>CMI 功能的开启与关闭采用插拔方式，可以及时通过重置 cmiEnabled 属性来开关，由于 Clear Case 8.0 是默认开启的，如果要关闭需要在上述路径上是\n    cmiEnabled=false。另一种方式是设置所要集成的 Provider（所要集成的产品 Server）的 enable 属性为\n    false，后面会详细描述，不过第二种方式只针对单个集成的 Provider，如果要全部关掉，建议第一种方式，看的出来新的 CMI 功能的开启关闭很灵活，通过命令行更方便。<\/p><p><strong>规则 2<\/strong><strong>：<\/strong>RTC 的一个工作项或 CQ 的一个缺陷只能和 Clear Case 的一个 Activity 活动关联，如果一个 Activity 已经关联此工作项或缺陷，其他 Activity 将无法再关联此工作项或缺陷<strong>。<\/strong><\/p><h5 id=\"N10092\">图 1. 在另一个活动上关联同一个 Task<\/h5><img alt=\"在另一个活动上关联同一个 Task\" src=\"/sunshine_new/images/负1153016377/image003.jpg\" width=\"643\" /><a id=\"OLE_LINK2\"><\/a><a id=\"OLE_LINK1\"><\/a><p>如图 1 所示，lzhao_act2 已经关联这个缺陷CQWAN00000002@CQPROV，如果用 cleartool chact 命令使另外一个活动 lzhao_act1 关联此缺陷将会报错。这说明如果我们修正一个缺陷或完成一个工作项，在 UCM Clear Case 有且仅有一个活动（Activity）和此相关。<\/p><p><strong>规则 3：<\/strong>当使用 Base Clear Case 的集成，如果您在工作的分支上包含了所要集成的 Provider 信息，意味着您在此分支下创建的新的文件版本都必须关联到此 Provider 的一条记录，对于 RTC 就是新的版本必须关联到 RTC 的一个工作项，而对于 CQ，新的版本必须关联到 CQ 的一个缺陷，如图 2 所示：<\/p><p>我们工作的分支 main 上包含了两个 Provider 信息\"rtcprovider\"和\"CQPROV\"，而我们更改的文件 2.c 仅含有关联到 RTC Provider 的工作项 22，当我们修改完此文件要做 check in 操作时，CMI 会检测您在此分支上创建的 Provider 是否都有至少一条信息关联到此文件的新版本，如果没有将提示错误信息。为了解决这个错误，要么不做 CQPROV 的集成即在 Branch 中删除此 Provider 信息，要么在这个更改的文件使用命令来添加一个关联工作项:<\/p><div class=\"codesection\"><pre class=\"displaycode\">    Cleartool chtask -add_task CQWAN00000002@CQPROV 2.c<\/pre><\/div><p>使 2.c 关联到了所有在 Branch 上已有的 Provider 的记录，然后 check in 操作会成功，并且新的 2.c 的版本将在所有关联的 Provider 的页面中显示出来。<\/p><h5 id=\"N100B4\">图 2. Check in\n    验证版本的 Provider 信息<\/h5><img alt=\"Check in 验证版本的 Provider 信息\" src=\"/sunshine_new/images/负1153016377/image005.jpg\" width=\"693\" /><p><strong>规则 4<\/strong>：如果 Clear Case 端工作的流上已经有了集成的 Provider 信息并且 enable 和 validate 都为 true，当我们创建活动时必须有参数-tasks 来设定此活动和流上哪一个 Provider 关联，如果没设置就会报错，如下图所示：在创建活动 lzhao_act2 时由于没有用-tasks 设置关联属性将会提示此活动没有关联 Provider，但此活动仍然被创建。<\/p><h5 id=\"N100C4\">图 3. 活动 Activity 需要关联 Task<\/h5><img alt=\"活动 Activity 需要关联 Task\" src=\"/sunshine_new/images/负1153016377/image007.jpg\" width=\"696\" /><p><strong>规则 5：<\/strong>用 cleartool mkact 创建带有多个 Provider 的关联关系的活动时，如果其中某个 Provider 配置错误无法创建，CMI 将报告此 Provider 错误，其他通过逻辑检查的关联将创建成功，同时活动的创建也成功。<\/p><h5 id=\"N100D4\">图 4.\n    活动 Activity 更改 Task 操作支持多任务<\/h5><img alt=\"活动 Activity 更改 Task 操作支持多任务\" src=\"/sunshine_new/images/负1153016377/image009.jpg\" width=\"660\" /><p>如上所示，我们创建一个活动同时关联 Provider CQPROV 的两个缺陷 CQWAN00000006@CQPROV 和 CQWAN000000099@CQPROV，而后一个缺陷在 Provider 不存在，或者没创建或者已经关闭，CMI 就会提示这个关联无法创建成功，但是活动仍被创建并且关联到了那个已有的缺陷。<\/p><p><strong>规则 6：<\/strong>如果 provider 的 enable 设置为 true，mkact Ctasks 中的 provider 信息是正确的，activity 会被创建然后也会关联，如果 tasks 的 provider 验证未通过如 enable=false，或 provider 的 url 地址验证无效，或者 provider 里不存在此缺陷，则无法创建集成关联关系，但 activity 仍会被创建，只是没有属性\"CMI Associated tasks\"。如果此属性的值为空，CMI 不会显示这个活动上的属性，即您用 cleartool lsactivity 命令将无法得到这个属性值。<\/p><h5 id=\"N100E6\">图 5.\n    创建无法关联 Provider 信息的活动<\/h5><img alt=\"创建无法关联 Provider 信息的活动\" src=\"/sunshine_new/images/负1153016377/image011.jpg\" width=\"652\" /><p>如上图所示，关联的 provider PROV3 并没有在 stream 和 vob 里配置，所以 CMI 找不到此 provider 信息，即使 provider 信息找到了，如果 provider 的 OSLC URL 配置不正确也会报错，但我们发现 CMI 仍提示 activity lzhao_act4 被创建。只是 CMI_Associated_Tasks 属性值为空，并提示没有和 Provider 关联成功，在此 activity 上做的任何操作也不会显示在 CQ Provider 的缺陷中。<\/p><p>设想另外一种场景，如果用户不想和此 provider 在做集成操作，我们可以用-replace -enable false 来\"关掉\"stream 上配置的 provider 信息，即关闭在此 provider 的 CMI 集成功能，再尝试在新创建的 activity 上并关联此 provider，由于此 provider 没有被激活(enable = false)但此 activity 仍然被创建，即使 Provider 配置信息都是正确的但结果仍然和上面一样，没有关联到 provider。<\/p><p><strong>规则 7：<\/strong>如果某个 Provider 的 validate 是 true，就说明某个 activity 必须包含一个关于此 Provider 的一个缺陷，否则 Clear Case 操作命令会报错无法执行。<\/p><h5 id=\"N100FA\">图 6.\n    活动 Activity 上删除唯一的关联 Task<\/h5><img alt=\"活动 Activity 上删除唯一的关联 Task\" src=\"/sunshine_new/images/负1153016377/image013.jpg\" width=\"664\" /><p>如图所示，我们在用 cleartool chact -tasks -remove_task 去删除关联的信息将会报错，告诉此 activity 必须关联一个此 Provider 含有的一个缺陷。属性 validate 可以更好的理解为需要工作的活动 actvity 必须关联此缺陷。这就保证了在 Provider CQ 端肯定能找到关于修正此缺陷所进行的活动及进展。<\/p><p><strong>规则 8：<\/strong>当 provider 的 enable=false 意味着用户不想使用和这个 provider 的集成，则 validate 属性将不再起作用，那么关于这个 provider 的任何集成操作将报错。只有在 enable 为 true 时，validate 的属性设置才有效。如果 validate 为 false 则说明在 CQ Provider 里的缺陷不必在 Clear Case 端找到相应的活动。所以当我们把 enable 为 true 而 validate 为 false 时，就可以删除关联到此活动的 Provider 信息。如下图所示，此 activity 关联了 Task CQWAN00000002@CQPROV，通过 lsprovider 发现此 Provider 配置属性 enable 为 true，validate 为 false，意味着可以删除此 Task，随后运行 chact 删掉此 task 成功，同时因为 enable 为 true，CQ Provider 端关联的 Clear Case 的信息也会被删除。<\/p><h5 id=\"N1010C\">图 7. 配置属性决定操作规则<\/h5><img alt=\"配置属性决定操作规则\" src=\"/sunshine_new/images/负1153016377/image015.jpg\" width=\"693\" /><p><strong>规则 9：<\/strong>对于 chact -tasks -remove_task 命令，当此 activity 关联多个 provider 时, 如果其中某些 provider 的属性 enable 为 true 并且 validate 也为 true 意味着这个 provider 在这个 activity 上不能被删除，用户会得到此 provider 必须在 activity 上存在关联关系的警告。对于一个 activity 关联多个 provider 情况，如果其中某些 provider 的属性配置允许让这个 provider 被删除，那么 CMI 的 chact -tasks -remove_tasks -add_tasks 功能支持兼容性操作，即在一次操作命令中能删除的就删除成功，不能删除将提示具体错误信息。如下图所示：<\/p><p>我们使用了两个 Server 作为集成的 Provider，其中 CQPROV 的 validate 属性为 false，而 rtcprovider 为 true，它们的 enable 都为 true，说明都开启了集成功能。然后我们创建了一个活动包含这两个关联信息，其中 CQPROV 关联到其缺陷 CQWAN00000002 而 rtcprovider 关联到其工作项 4432.当我们尝试删除这个活动的所有关联信息时。由于 rtcprovider 的 validate 属性为真，说明这个活动必须关联此 Provider 的一个工作项，而另一个 CQPROV 的 validate 属性为假，所以可以删除关于此 Provider 的缺陷，从结果得知，CMI 提示了错误信息并且删除了 CQPROV 的缺陷关联。<\/p><h5 id=\"N1011F\">图 8.\n    在活动 Activity 上删除关联的 Task<\/h5><img alt=\"在活动 Activity 上删除关联的 Task\" src=\"/sunshine_new/images/负1153016377/image017.jpg\" width=\"682\" /><p>由于 enable 都是真，两个 Provider Server 端关联 Clear Case 的活动信息也会对应更新。由于 rtcprovider 的关联没有被删除，所以如下图所示 rtcprovider 仍保留这关于此活动的关联信息。<\/p><h5 id=\"N1012D\">图 9. RTC 里验证关联的活动<\/h5><img alt=\"RTC 里验证关联的活动\" src=\"/sunshine_new/images/负1153016377/image019.jpg\" width=\"520\" /><p><strong>规则 10：<\/strong>如果 provider 的属性 enable=true，validate=false，那么 rmprovider 可以删除 Clear Case 的集成属性，并且运行 disassociation 去关联操作，在 provider 端删除代码关联信息并显示命令成功。如果 enable 和 validate 都是 false，rmprovider 将只更新 Clear Case 的集成信息，cq/rtc 的 provider 信息会需要更新，显示命令成功。<\/p><h5 id=\"N1013D\">图 10. 运行删除操作前的属性<\/h5><img alt=\"运行删除操作前的属性\" src=\"/sunshine_new/images/负1153016377/image021.jpg\" width=\"763\" height=\"510\" /><p><a href=\"#N10144\" class=\"ibm-popup-link\" onclick=\"ibmweb.overlay.show('N10144',this);return false;\">点击查看大图<\/a><\/p><div id=\"N10144\" class=\"dw-sidefile-overlay ibm-common-overlay ibm-overlay-alt-two\"><div class=\"ibm-head\"><p><a href=\"#close\" class=\"ibm-common-overlay-close\">关闭 [x]<\/a><\/p><\/div><div class=\"ibm-body\"><div class=\"ibm-main\"><div class=\"ibm-title\"><h2>图 10. 运行删除操作前的属性<\/h2><\/div><div class=\"ibm-container ibm-alternate\"><div class=\"ibm-container-body\"><img alt=\"运行删除操作前的属性\" src=\"/sunshine_new/images/负1153016377/image021.jpg\" width=\"954\" /><\/div><\/div><\/div><\/div><div class=\"ibm-footer\"><><\/div><\/div><p>如上图所示，CQPROV 由于 validate 被改成 false，则不同于规则 5 的情况，删除将不再检验，并提示删除成功，Clear Case 和 CQ provider 端都删掉了互相关联信息。<\/p><p>如果我们通过 replace 操作使 enable 也为 false，Clear Case 端的操作返回速度将很快成功如图所示：<\/p><h5 id=\"N1014E\">图 11. 活动 Activity 的解关联操作<\/h5><img alt=\"活动 Activity 的解关联操作\" src=\"/sunshine_new/images/负1153016377/image023.jpg\" width=\"650\" /><p>由于 provider 没有激活集成即 enable=false，底层操作将不和 provider 通信，所以仅在 Clear Case 本地操作，而 provider cq 上的关联信息仍然没有更改，此 activity 仍然关联在 provider 上。如下图所示：<\/p><h5 id=\"N1015C\">图 12. RTC 里验证操作结果<\/h5><img alt=\"RTC 里验证操作结果\" src=\"/sunshine_new/images/负1153016377/image025.jpg\" width=\"579\" /><p><strong>规则 11：<\/strong>对于 rmactivity 操作，如果使用 CMI，将不同于 chactivity 命令, 此命令总会成功，同时如果配置的 Provider 的属性 enable 为 true 将更新 Clear Case 和 CQ provider 两端的集成信息，如果 enable 为 false 将只更新 Clear Case 端的信息。<\/p><h5 id=\"N1016C\">图 13.\n    活动 Activity 的删除活动 Activity 操作<\/h5><img alt=\"活动 Activity 的删除活动 Activity 操作\" src=\"/sunshine_new/images/负1153016377/image027.jpg\" width=\"728\" height=\"460\" /><p><a href=\"#N10173\" class=\"ibm-popup-link\" onclick=\"ibmweb.overlay.show('N10173',this);return false;\">点击查看大图<\/a><\/p><div id=\"N10173\" class=\"dw-sidefile-overlay ibm-common-overlay ibm-overlay-alt-two\"><div class=\"ibm-head\"><p><a href=\"#close\" class=\"ibm-common-overlay-close\">关闭 [x]<\/a><\/p><\/div><div class=\"ibm-body\"><div class=\"ibm-main\"><div class=\"ibm-title\"><h2>图 13.\n    活动 Activity 的删除活动 Activity 操作<\/h2><\/div><div class=\"ibm-container ibm-alternate\"><div class=\"ibm-container-body\"><img alt=\"活动 Activity 的删除活动 Activity 操作\" src=\"/sunshine_new/images/负1153016377/image027.jpg\" width=\"910\" /><\/div><\/div><\/div><\/div><div class=\"ibm-footer\"><><\/div><\/div><p>    如上图所示，此 activity 关联两个 provider 的 task，其中 CQPROV 的 enable 和 validate 都是 true，如果使用 chact 命令删除此 task 关联，将如规则 5 所示，报错不会被删除，而如果用 rmactivity 命令，将无视规则约束，结果 activity 和此 activity 的 task 都会被删除，同时 CQ provider 也会随之更新。<\/p><h2 id=\"1.结论 |outline\">结论<\/h2><p>本文在您了解了如何使用 Configuration management Interface 来实现 UCM Clear Case 与 ClearQuest 及 RTC 的集成的基础上详细介绍了集成操作中所要遵循的一些规则，这些规则一些来自于 Clear Case UCM 集成的最佳实践，一些来自于 CMI 的一些配置属性，这些配置属性影响了活动（UCM）或分支（Branch）的增删改。Clear Case 集成 CMI 的 log 文件都保存在以下路径的 cmi_log 文件里。<\/p><p>Windows：<\/p><p>C:\\Program Files\\IBM\\RationalSDLC\\Clear Case\\var\\log（Clear Case 默认安装路径）<\/p><p>Linux：  <\/p><p>/var/adm/atria/log<\/p><p>您可以查看此 log 文件了解详细运行日志和报错信息。<\/p><p>希望通过本文，用户在使用 CMI 集成时作为参考，并帮助用户了解操作错误的原因以及如何修复。<\/p><CMA ID: 975222><Site ID: 10><XSLT stylesheet used to transform this file: dw-document-html-7.0.xsl>\r\n\r\n\r\n<\/div>\r\n<\/div>\r\n","createTime":"2014-06-23 00:00:00","deployTime":"2014-06-23 00:00:00","id":0,"intro":"本文总结了 UCM ClearCase CMI 的 11 条常用规则和错误解决方法。在您完成前文的阅读后，了解了 CMI 在 Base/UCM 的使用后，需要注意在使用中必须遵循一些最佳实践的 CMI 规则。这些规则是基于了 Rational ClearCase 等 CLM 产品特性，以及软件生命周期的最佳实践，并描述了 CMI 通过哪些配置属性来约束这些规则，以及这些规则没有被遵从时报错信息和处理。供您在使用 CMI 完成集成功能时作参考。","keyword":"","recommend":false,"source":"http://www.ibm.com/developerworks/cn/rational/1406_zhaoliang_ccclm2/index.html","title":"Rational ClearCase 通过 CMI 和 CLM 产品集成的规则描述","typeId":0,"updateTime":"2014-06-23 00:00:00"}
{"author":"","clickNumber":0,"content":"\r\n<div class=\"ibm-columns\">\r\n<div class=\"ibm-col-1-1\">\r\n\r\n<div class=\"dw-sidebar ibm-inset\"><h2 id=\"N10073\">虚拟化的四个维度<\/h2><p>CPU<br />内存<br />磁盘输入/输出（I/O）及存储<br />网络<\/p><\/div><p>这个由两部分组成的系列文章将通过具体示例探讨虚拟化的优缺点。在<a href=\"http://www.ibm.com/developerworks/cn/rational/smart-virtualization-1/\">第 1 部分<\/a>中，我们将从总体上解释虚拟化，尤其是它与 IBM Rational 软件的关系。我们将覆盖虚拟化的四个维度，CPU、内存、磁盘输入/输出（I/O）及存储、网络等应如何通过关联性（专用资源）被恰当地管理而不会过度承诺。我们所给出的例子展示了被恰当管理的虚拟化是如何彻底影响  IBM&#174; Rational&#174; 产品。尤其是我们所展示的两个案例分析，其中的 IBM&#174; Rational Team Concert&#8482; 及 IBM&#174; Rational&#174; ClearCase&#174; 托管在没有关联性配置的虚拟机中，虚拟环境配置欠佳，从而使之性能糟糕。<\/p><p>在第 2 部分中，我们将更加深入探究针对过度承诺的折中考虑。基于我们在 Rational 产品和曾服务客户身上测试得来的经验，我们将提供建议和技巧，故障排除和特定于供应商的示例来帮助您更好地管理您的虚拟化基础设施。所有提及的故障排除场景和建议都来自 <a href=\"https://jazz.net/wiki/bin/view/Deployment/VirtualizationTroubleshooting\">jazz.net Deployment wiki<\/a>。<\/p><h2 id=\"casestudyno3\">案例分析 3. 结合 ClearCase\n                探索过度承诺（overcommitment）<\/h2><p>案例分析 2 演示了当托管在没有专用资源的虚拟机（VM）上时，IBM Rational ClearCase 是如何糟糕。我们建议要为 IBM Rational 产品配置关联性和专用资源，来避免可能存在的过度承诺。然而，我们也认识到受管理的过度承诺对于虚拟化而言仍然具有显著的价值。案例分析 3 着眼于不同程度的过度承诺。<\/p><p>在我们其中之一的测试中，我们考察了一台拥有 4 个八核 CPU 及 64 GB内存的 Intel Westmere-EX 服务器。这台服务器启用了超线程，对于虚拟机管理程序（hypervisor）而言，这台拥有 32 个核心的服务器就如同拥有 64 个逻辑处理器（64 vCPU）。ClearCase CM 服务器安装在其中一个拥有 4 vCPU 和 8 GB RAM 的 VM 上，但没有专用资源或关联性。<\/p><p>在同一个虚拟机管理程序上我们还创建了 96 个拥有 4 vCPU 和 4 GB RAM 的 VM（64-位 RHEL 5.5）。这些 96 个镜像被用于产生背景负载。这 96 个镜像被组织成六组 16 VM 群组。每一个 16-VM 群组包括 64 vCPU 和 64 GB RAM，这与 Westmere-EX 自身的硬件维度是相符合的。因此每一个 16-VM 群组都 100%　体现了 Westmere-EX 服务器的硬件配给。<\/p><p>为了捕获基线平均响应时间数据（如表 1 a 行所示），我们仿真了 100 个用户的 UCM 负载并传递给 ClearCase CM 服务器。所有六组\n                VM 则处于挂起状态。<\/p><p>在下一个测试（表 1 中 b 行到 g 行），我们使用了六组 16 VM 的群组来创建背景负载。每一个 VM 都托管一个本机程序，运行多线程的平方根数学计算并分配了内存。这一“贪婪”程序确保每一个 VM 客户端将会 100% 消耗为它分配的处理器和内存。每一个测试以 16 个 VM 或 100% 相应的 Westmere-EX 服务器物理硬件为单位增加背景负载。<\/p><p>行 b 显示了 100 个用户 CC CM 服务器测试的平均响应时间数据，以及相应的 100% 的 Westmere-EX 负载（一组 16 VM 都运行“贪婪”程序）。行 c 到行 g 显示了 100 用户 CC CM 服务器测试随着逐步增加每一组 16 VM 的平均响应时间数据（每一步都逐步增加 100% 相应的 Westmere-EX 服务器负载）。<\/p><p>行 g 显示了在所有 96 个 VM 都在运行“贪婪”程序，即 600% 物理 Westmere-EX 服务器容量的情况下，我们的 100 个用户 CC CM 服务器测试的平均响应时间。响应时间非常糟糕。我们过度承诺的服务器无法在合理的响应时间内为 100 个用户 CC 负载提供服务。<\/p><p>让我们的服务器保证合理的性能的唯一办法是运行在一个具有专用资源的 VM 上。行 h 显示了与行 g 相同的测试，但 CC CM 服务器具有关联性和专用资源。在 600% 的负载下，CC CM 服务器以可接受的性能进行了响应。<\/p><h5 id=\"Table1\">表 1：使用 ClearCase 来展示关联性效果的性能测试<\/h5><table border=\"0\" cellpadding=\"0\" cellspacing=\"0\" class=\"ibm-data-table\" summary=\"9 column table with heading row and center-aligned content\"><thead xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"><tr><th>&#160;<\/th><th>a<br />物理机器<\/th><th>b<br />100% 无关联性的负载<\/th><th>c<br />200% 无关联性的负载<\/th><th>d<br />300% 无关联性的负载<\/th><th>e<br />400% 无关联性的负载<\/th><th>f<br />500% 无关联性的负载<\/th><th>g<br />600% 无关联性的负载<\/th><th>h<br />600% 有关联性的负载<\/th><\/tr><\/thead><tbody xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"><tr><td><strong>产生流<\/strong><\/td><td><strong>1.03<\/strong><\/td><td> 1.57 <\/td><td><strong>1.87<\/strong><\/td><td> 3.48 <\/td><td> 29.81 <\/td><td> 39.76 <\/td><td> 153.29 <\/td><td><strong>1.88<\/strong><\/td><\/tr><tr><td><strong>产生活动<\/strong><\/td><td><strong>0.33<\/strong><\/td><td> 0.50 <\/td><td><strong>0.55<\/strong><\/td><td> 1.64 <\/td><td> 24.84 <\/td><td> 44.35 <\/td><td> 176.21 <\/td><td><strong>0.61<\/strong><\/td><\/tr><tr><td><strong>集活动<\/strong><\/td><td><strong>0.59<\/strong><\/td><td> 0.92 <\/td><td><strong>1.04<\/strong><\/td><td> 3.59 <\/td><td> 68.55 <\/td><td> 69.45 <\/td><td> 159.14 <\/td><td><strong>0.99<\/strong><\/td><\/tr><tr><td><strong>产生目录<\/strong><\/td><td><strong>1.98<\/strong><\/td><td> 2.78 <\/td><td><strong>3.04<\/strong><\/td><td> 4.93 <\/td><td> 64.72 <\/td><td> 70.43 <\/td><td> 161.33 <\/td><td><strong>3.35<\/strong><\/td><\/tr><tr><td><strong>检出目录<\/strong><\/td><td><strong>0.72<\/strong><\/td><td> 0.91 <\/td><td><strong>0.97<\/strong><\/td><td> 2.08 <\/td><td> 30.82 <\/td><td> 38.17 <\/td><td> 125.30 <\/td><td><strong>1.12<\/strong><\/td><\/tr><tr><td><strong>检入目录<\/strong><\/td><td><strong>0.61<\/strong><\/td><td> 0.78 <\/td><td><strong>0.82<\/strong><\/td><td> 1.35 <\/td><td> 11.86 <\/td><td> 13.73 <\/td><td> 68.03 <\/td><td><strong>0.91<\/strong><\/td><\/tr><tr><td><strong>产生文件<\/strong><\/td><td><strong>1.40<\/strong><\/td><td> 1.78 <\/td><td><strong>1.93<\/strong><\/td><td> 3.23 <\/td><td> 33.10 <\/td><td> 37.54 <\/td><td> 95.58 <\/td><td><strong>2.28<\/strong><\/td><\/tr><tr><td><strong>检出文件<\/strong><\/td><td><strong>0.91<\/strong><\/td><td> 1.25 <\/td><td><strong>1.45<\/strong><\/td><td> 1.51 <\/td><td> 3.81 <\/td><td> 5.42 <\/td><td> 68.12 <\/td><td><strong>1.47<\/strong><\/td><\/tr><\/tbody><\/table><p>这个例子展示了多个情况。没有关联性，产品的性能会大幅度降低到不可用的程度。更进一步，仅仅拥有 CC CM 服务器访问权限的 ClearCase 管理员无法理解甚至无法猜测究竟发生了什么情况。这个背景负载也许过于极端，但非常清晰地演示了过度承诺的影响。<\/p><p>不过，虚拟化并不是一个无助的命题。比较表 1 中的 c 和 h 行，这两行显示了 CC CM 服务器在没有关联性而虚拟机管理程序承担 200% 负载时，以及 CC CM 服务器有关联性而虚拟机管理程序承担 200% 负载时的情形。两种情形相似的响应时间足以表明，如果不可能有专用资源时虚拟机管理程序的能力无法承担超过 200% 负载，而对于资源有关联性的配置则可以提供可接受的响应时间。这个事实表明，如果管理得当的话，过度承诺可以成为一个切实可行的选择。<\/p><h2 id=\"casestudyno4\">案例分析 4. 过度承诺或低于承诺：性能 vs. 能力<\/h2><p>案例分析 4 比较了两个不同 VM 配置在同一台 ESX 服务器，即一台 32 vCPU 及 32 GB RAM 的 Intel SandyBridge 服务器（E5-2680 @\n                2.70GHz）上时 ClearCase 的响应时间。配置 A 使用了 100% 的 VMware ESX 的能力，而配置 B 则使用了 150%。<\/p><p>在配置 A 中，ESX 服务器托管 VOB 服务器，一个 ClearCase Remote Client（CCRC）服务器以及两个 VM 运行案例 3 中描述的“贪婪”程序。每一个 ESX 服务器上的 VM 运行 RHEL 5.6，并分配了 8 vCPU 和 8 GB RAM。配置 A 拥有  100% 专用的 ESX 硬件资源。<\/p><p>配置 B 使用配置 A 相同的四个 VM；不过，额外的两个 VM 被增加到 ESX 服务器上。这两个额外的 VM 具有 8 vCPU 及 8 GB\n                RAM 来和其他四个 VM 对齐。当所有六个镜像都在使用时（48 vCPU 及 46 GB RAM），ESX 服务器被分配了 150% 的能力。两个额外的 VM 创建了一个二级 CC 区域，并执行在两个 CC 区域之间的活动来创建在 ESX 服务器上的负载。这些活动包括导入、mklabel 及构建操作，并在测试期间持续运行。<\/p><p>在本案例的背景负载中有两台其他的 ClearCase 虚拟机组成：一台 VOB 服务器及一台 ClearCase 客户端来作为视图（view）和构建服务器，也同样执行 mklabel 和导入操作。一个专用的 1 GB 网络连接着这些服务器和其他镜像。<\/p><p>这一 ClearCase 测试环境是实际 ClearCase 开发 VOB 的一个备份。100 VOB 被散布到两台服务器上。10 个最高容量的 VOB 被托管在 VM 镜像（VOB 服务器）上。剩余的 90 个 VOB 被托管在一个分离的物理服务器上，在此服务器上还有许可证服务器（license server）和注册服务器（registry server）。<\/p><p>这一用于比较的工作负载仿真了在一个 12 小时的时间段内大约 250 个并发用户。背景工作负载由以下方面组成：<\/p><ul class=\"ibm-bullet-list\"><li>200 个 CCRC 用户每小时执行 15 次事务<\/li><li>50 个动态视图用户用户每小时执行 15 次事务<\/li><li>38 个持续 clearmake 构建运行在 12 个不同的额外构建主机上（Unix 及 Windows）<\/li><li>1 台独立的 Unix 客户端运行集成任务<\/li><\/ul><h5 id=\"Table2\">表 2. 两个 ESX 服务器配置<\/h5><table border=\"0\" cellpadding=\"0\" cellspacing=\"0\" class=\"ibm-data-table\" summary=\"\"><thead xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"><tr><th>&#160;<\/th><th> 配置 A<br /> （运行 100% 能力的 ESX 服务器）<\/th><th> 配置 B<br /> （运行 150% 能力的 ESX 服务器）<\/th><\/tr><\/thead><tbody xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"><tr><td> ESX 服务器 <br />(32 vCPU，32 GB RAM) <\/td><td> 服务器托管 4 个镜像: <ul class=\"ibm-bullet-list\"><li>1 台 VOB 服务器<\/li><li>1 台 CCRC 服务器<\/li><li>2 台“贪婪”服务器<\/li><\/ul><\/td><td> 服务器托管 6 个镜像: <ul class=\"ibm-bullet-list\"><li>1 台 VOB 服务器<\/li><li>1 台 CCRC 服务器<\/li><li>2 台“贪婪”服务器<\/li><li>2 台 CC 服务器在分离的区域<\/li><\/ul><\/td><\/tr><\/tbody><\/table><p>图 1 比较了两个配置在超过 12 个小时的平均相应时间。相比配置 A，对于基本 ClearCase 操作配置 B 慢了 35%，UCM 操作慢了 25%。构建时间也慢了 22%。<\/p><h5 id=\"fig01\">图 1. 比较两种 ClearCase 环境<\/h5><img alt=\"当 ESX 服务器能力被分配在 150% 时 ClearCase 慢了\" src=\"/sunshine_new/images/1555978846/image001.jpg\" width=\"815\" /><p><strong>进一步探讨关联性和预订<\/strong><\/p><p>在第 1 部分，我们定义了关联性来作为在一台虚拟机上专用一个或更多资源的能力，这些资源来自虚拟机管理程序的相应资源。在一些虚拟机管理程序中，还有预订（reservation）的概念。预订在含义上与我们用来表达关联性的概念相一致。在这些系统中关联性标志着更多的是一个 VM 的 CPU 可以恰好指派给多少个物理核心。如果您指派您的专用 VM 到特定的 CPU，您也应同样分配您其余的 VM 到不同的 CPU 上。具有 CPU 关联性的 VM 或许性能更糟糕，因为他们也许无法被安排到多线程任务上。<\/p><p>我们建议 VM 拥有对虚拟机管理程序专用资源的访问。对于虚拟机管理程序是超线程，或者虚拟机管理程序被设计用于执行资源的自动化加载平衡的情形，还有一些额外的概念需要记住。<\/p><h3 id=\"2.1.CPUaffinityconsiderations|outline\">CPU 关联性注意事项<\/h3><p>如果使用 CPU 关联性，考虑以下问题：<\/p><ul class=\"ibm-bullet-list\"><li>如果您的虚拟机管理程序使用自动化加载平衡，CPU 关联性将会阻止虚拟机管理程序有效地工作。<\/li><li>在一个 VM 上的 CPU 关联性可能会阻止同一个虚拟机管理程序上的其他 VM 虚拟机管理程序。<\/li><li>在从一个虚拟机管理程序上将一个具有 CPU 关联性的 VM 移动到另外一个虚拟机管理程序上时，有可能会需要不同的处理器配置。<\/li><li>在多核或超线程机器上的 CPU 关联性将有可能阻止 VM 安排多线程任务，因为它对指定核心的请求是有限的。<\/li><\/ul><h2 id=\"summaryandconclusions\">总结和结论<\/h2><p>这一由两部分组成的系列文章探讨了虚拟化的优点和缺点，并使用了两个特定于 IBM Rational 产品的示例。<\/p><p>在第 1 部分中，我们覆盖了四个重要的维度，这些参数在使用虚拟化时必须被恰好判断：CPU、内存、磁盘 I/O 和存储，以及网络。我们强调了关联性（专用资源）的重要性，以及演示了当资源被过度承诺时有可能会发生的情况。<\/p><p>我们还提供了关于管理较差的虚拟化可能会大幅影响 IBM Rational 产品性能的示例。我们也展示了两个案例，其中的 IBM Rational Team Concert 和 IBM Rational ClearCase 当它们被托管在没有配置关联性，配置较差的虚拟环境上时性能很糟糕。<\/p><p>在第 2 部分中，我们更深入地了解了对过度承诺的权衡。<\/p><p>根据我们测试 IBM Rational 产品以及我们以往建议客户的经验，我们提供了建议和提示，故障排除策略和特定用户的示例，来帮助管理您的虚拟化基础设施。故障排除情形和建议可以从 <a href=\"https://jazz.net/wiki/bin/view/Deployment/VirtualizationTroubleshooting\">jazz.net Deployment wiki<\/a> 上看到。<\/p><h3 id=\"3.1.Virtualization’skeyadvantages|outline\">虚拟化的关键优势<\/h3><ul class=\"ibm-bullet-list\"><li>当前市场上所提供的硬件倾向于使它们自身更好地被分割和被虚拟机管理程序所使用，来托管多虚拟机。这些新机器节省空间和电力消耗，而且更加有效利用资源。<\/li><li>虚拟化基础设施可以增加部署新 VM 的速度（复制已有的 VM 或新的可立即使用的 VM）。<\/li><li>高可用（High-availability，HA）以及灾难恢复（Disaster Recovery，DR）解决方案可以与虚拟化一起集成，来获得更完整和有效成本的企业级配置。然而，需要注意的是，在一个单独的虚拟机管理程序上托管多个 VM 可能会导致一个单点失败。您可以了解这一特定领域，并使用 SAN 或 NAS 存储来为 VM 镜像和/或在一个备用的虚拟机管理程序上部署已准备要用的 VM。<\/li><li>VM 及它们的虚拟机管理程序可以从任何地点通过终端被管理（而不仅仅是在一个实验室中），从而可以优化和减少管理成本。<\/li><\/ul><p>了解完所给出关于较差管理的虚拟化可能出现的陷阱，您可能仍旧疑问这是否真的值得投资和劳神。但答案是非常值得！虚拟化是一个值得的投资，但我们也强调，虚拟化必须被恰当管理。在一些组织里，虚拟化是必然和永久的。消失的是专用的物理硬件、专用于托管一个单独应用的单台服务器。那些硬件厂商都在趋向于生产能增加更多处理器和内存的平台，切分新的硬件给虚拟机是最佳的方式来确保资源的有效性。<\/p><h3 id=\"3.2.Keyprinciplesdiscussedinthisseries|outline\">这一系列所讨论的关键原则<\/h3><ul class=\"ibm-bullet-list\"><li>尽可能分配 CPU、内存和网络作为专用资源。确保可以通过专用的 I/O 访问充足的共用存储。<\/li><li>只要可能，考虑 CPU 及内存关联性。在某些案例中，这将导致同一台主机上的其他 VM 性能变差。在某些案例中，虚拟机管理程序会作为集群的一部分，牵制资源可能会阻止整个家族的 VM 得以优化运行。这些是针对所有 VM 在 CPU 和内存资源无法被专用或预订时的一些性能权衡策略。<\/li><li>只要可能，通过监管资源消耗来管理您的虚拟化资源。了解有哪些其他的产品被托管在同一台 VM 上，以及那些被同一个虚拟机管理程序所托管的其它 VM 在做些什么。<\/li><li>只要可能，避免资源过度承诺。也就是说，任何 VM 或 VM 组合的资源永远不应超过虚拟机管理程序的物理资源。<\/li><li>如果您怀疑有与虚拟化相关的问题，收集关于 VM 配置、虚拟机管理程序和其他被同一个虚拟机管理程序托管的 VM 的特定数据。避免有偏见的信息，并使用脚本来收集特定，也许是定期的度量信息。<\/li><\/ul><h3 id=\"3.3.SpecialIBMRationalproductconsiderations|outline\">IBM Rational 产品应特别考虑的因素<\/h3><p>不同的软件产品的表现很不同。在某一个 VM 上的某一个产品上使用得很好虚拟化参数不一定对其他的产品有效。在这一系列文章中，我们检验了 Rational Team Concert 及 Rational ClearCase。其他 Rational 产品也许会表现得类似，也或许完全不同，这就是我们强调要理解虚拟化的各个关键维度的原因。<\/p><p>例如复杂多层应用程序，例如 Rational 协作化生命周期管理（Rational Collaborative Lifecycle Management）产品或 Rational ClearCase 要求就近访问专用资源。我们曾一起工作过的客户就曾遇到过由于并未强制执行上诉所列出的关键原则，而导致其在虚拟环境中的 Rational 产品性能很差的情形。<\/p><h2 id=\"creditsandacknowledgements\">致谢<\/h2><p>本文作者感谢我们的同事 Tim Lee、Chetna Warade、David Schlegel、Paul Weiss、Matthias Lee、Samir Shah、Harry Abadi 及 Poornima Seetharamaiah，我们在 Rational 支持和开发团队的同事，以及我们在 Intel、NetApp 和 VMware 的业务合作伙伴。<\/p><CMA ID: 974968><Site ID: 10><XSLT stylesheet used to transform this file: dw-document-html-7.0.xsl>\r\n\r\n\r\n<\/div>\r\n<\/div>\r\n","createTime":"2014-06-19 00:00:00","deployTime":"2014-06-19 00:00:00","id":0,"intro":"如果您目前正在 IBM Rational 软件上使用虚拟化方法，是否一切都像您预期的一样顺利？三位 IBM 专家将介绍 Rational 视角下的虚拟化，以及虚拟化环境从 Rational 应用程序中获取最优性能的关键要求。在第 2 部分，他们将展现更多的案例及和故障排除技巧。","keyword":"","recommend":false,"source":"http://www.ibm.com/developerworks/cn/rational/smart-virtualization-2/index.html","title":"利用虚拟化成就智慧: 第 2 部分 使用 IBM 软件的最佳实践","typeId":0,"updateTime":"2014-06-19 00:00:00"}
{"author":"","clickNumber":0,"content":"\r\n<div class=\"ibm-columns\">\r\n<div class=\"ibm-col-1-1\">\r\n\r\n<p>我习惯于使用 Windows 桌面应用程序跟踪待办事项列表。每次记起一些重要的东西时，我都会打开它，键入一个简短标签，分配一个截止日期，然后保存它。我每次登录到系统中时，该应用程序都会启动，所以我能立刻了解需要注意的事项和完成时间。<\/p><p>这个 Windows 应用程序很好用，但有两个不足之处：在离开计算机后，我不能检查待办事项列表或添加任务。<\/p><div class=\"ibm-pull-quote ibm-inset\"><blockquote><p><em><span class=\"ibm-pullquote-open\">“<\/span>然后我发现了 Google Tasks。它支持在路途中检查我的任务和添加新任务。<span class=\"ibm-pullquote-close\">”<\/span><\/em><\/p><\/blockquote><p class=\"ibm-pullquote-source\"/><\/div><p>\n                Google Tasks 与 Gmail 集成在了一起（但知道这一点的人并不多），而且它支持在线创建和管理待办事项列表。因为可以通过浏览器访问任务列表，所以您可以很容易添加、查看和关闭任务，甚至在路途中也是如此。\n\n                <\/p><p class=\"ibm-button-link-alternate\"><a href=\"https://hub.jazz.net/project/vvaswani/tasks?utm_source=developerWorks&amp;utm_medium=article&amp;utm_content=mo-php-todolist-app&amp;utm_campaign=dW%20CloudOE%20content\">获取代码<\/a><\/p><h2 id=\"N10077\">构建待办事项列表应用程序需要做的准备工作<\/h2><ul class=\"ibm-bullet-list\"><li>一个 Apache/PHP 开发环境<\/li><li>一个用于测试用途的 Google 帐户<\/li><li><a href=\"http://www.slimframework.com/\">Slim<\/a><p>这个 PHP 微型框架将向您的 PHP 代码添加结构。<\/p><\/li><li><a href=\"http://code.google.com/p/google-api-php-client/\">Google APIs Client Library for PHP<\/a><p>这个库提供了一种健全的 OAuth 实现和包装器对象，简化了对所有 Google API 的访问。 \n                        <\/p><\/li><li><a href=\"http://jquerymobile.com\">jQuery Mobile<\/a><p>这个框架能迅速让您应用程序的用户界面投入正常使用，平台和浏览器兼容性问题很少。<\/p><\/li><\/ul><p class=\"dw-article-ps-see-blk\"><span class=\"dw-article-ps-see-head\">阅读：<\/span><a class=\"dw-article-ps-see\" href=\"https://developers.google.com/accounts/docs/OAuth2\">OAuth 2.0 身份验证<\/a><\/p><h2 id=\"N100A3\">您将需要知道的事项<\/h2><p>像其他许多 Google 产品一样，Google Tasks 公开了一个 <a href=\"https://developers.google.com/google-apps/tasks/v1/reference\">Tasks API<\/a>，它允许第三方应用程序连接到它，并围绕它的数据构建自定义应用程序。这个 API（遵循 REST 模型）可通过任何具有 REST 功能的开发工具包进行访问，而且已经拥有针对许多常见编程语言的客户端库，包括我最喜爱的 PHP。<\/p><p>要理解这里给出的 PHP 示例代码，您应当对 PHP 中的类和对象的基本知识有一定的了解，而且习惯使用 REST。您还应当熟悉 HTML、CSS 和 jQuery。<\/p><p>让我们开始吧！<\/p><h2 id=\"N100B5\">配置依赖性库和组件<\/h2><p> 首先设置 Slim。<\/p><p>如果不熟悉 Slim，它是一个用于快速开发 Web 应用程序和 API 的 PHP 微型框架。不要被它的名称所误导：Slim 包含一个复杂的 URL 路由器，而且支持页面模板、flash 消息、加密 cookie 和中间件。它非常容易理解和使用，而且具有优秀的文档和一个热心开发人员社区。<\/p><h3 id=\"N100C2\">第 1 步. 使用 Slim 和 Google OAuth 库创建应用程序目录<\/h3><p>更改到 Web 服务器的文档根目录（通常在 Linux 上为 <code>/usr/local/apache/htdocs<\/code>，在 Windows 上为 <code>C:\\Program Files\\Apache\\htdocs<\/code>），然后为应用程序创建一个新的子目录。将此目录命名为 <code>tasks<\/code>。<\/p><div class=\"codesection\"><pre class=\"displaycode\">shell&gt; cd /usr/local/apache/htdocs\nshell&gt; mkdir tasks<\/pre><\/div><p>此目录在本文中被称为 <code>$APP_ROOT<\/code>。<\/p><p>假设您已经下载了上一节中介绍的 Slim 框架和 Google OAuth 库，并将这些库提取到 <code>$APP_ROOT/vendor<\/code> 中。另外，您已经将 <code>index.php<\/code> 和 <code>.htaccess<\/code> 文件从 Slim 下载压缩文件传输到您的 <code>$APP_ROOT<\/code> 目录，编辑 <code>index.php<\/code> 文件，以便反映 <code>Slim.php<\/code> 文件的正确路径。<\/p><p>您的目录结构现在应类似于：<\/p><img alt=\"项目目录结构\" src=\"/sunshine_new/images/负1526964253/image1.jpg\" width=\"217\" /><h3 id=\"N100F8\">第 2 步. 定义一个虚拟主机<\/h3><p>为了使得应用程序更易于访问，一个不错的想法是定义一个新虚拟主机并将它设置为工作目录。为此，需要编辑 Apache 配置文件（<code>httpd.conf<\/code> 或 <code>httpd-vhosts.conf<\/code>），向其中添加以下行：<\/p><div class=\"codesection\"><pre class=\"displaycode\">NameVirtualHost 127.0.0.1\n&lt;VirtualHost 127.0.0.1&gt;\n    DocumentRoot \"/usr/local/apache/htdocs/tasks\"\n    ServerName tasks.melonfire.com\n&lt;/VirtualHost&gt;<\/pre><\/div><p>这些行定义了一个新虚拟主机，该主机的文档根目录对应于 <code>$APP_ROOT<\/code>。在上面的清单中，此主机的名称为 <code>tasks.melonfire.com<\/code>。请记住，您需要将此名称更改为 <code>localhost<\/code> 或在您控制之下的另一个域。<\/p><p>重新启动 Web 服务器，以便激活这些新设置。请注意，可能有必要更新您网络的本地 DNS 服务器，让它也知道这个新主机。<\/p><p>完成这些操作之后，在浏览器中打开您的新主机。您会看到 Slim 框架欢迎页面：<\/p><img alt=\"Slim 默认欢迎页面\" src=\"/sunshine_new/images/负1526964253/image2.jpg\" width=\"599\" /><h3 id=\"N1011E\">第 3 步. 向 Google Apps Platform 注册您的应用程序<\/h3><p>使用 Google Tasks API 之前，需要向 Google 注册您的 Web 应用程序。为此，需要使用您的 Google Account 凭据登录到 Google 并访问 <a href=\"https://cloud.google.com/console\">Google Cloud Console<\/a>。创建一个新项目，为它分配一个名称，然后开启对 Google Tasks API 的访问权。您的项目在 Google Cloud Console 看起来应类似于：<\/p><img alt=\"Google Cloud Console 中的 API 访问\" src=\"/sunshine_new/images/负1526964253/image3.jpg\" width=\"664\" /><p>接下来，注册您的 Web 应用程序，以获得 OAuth 2.0 客户端 ID 和密钥。记下这些值，Google PHP OAuth 客户端需要使用它们。<\/p><img alt=\"Google Cloud Console 中的 OAuth 凭据\" src=\"/sunshine_new/images/负1526964253/image4.jpg\" width=\"502\" /><p>请记住，您还要在这里设置应用程序重定向 URL。在完成 OAuth 身份验证流程后，Google 会将客户端浏览器重定向到这个 URL。在根示例中，此 URL 被设置为 <code>http://tasks.melonfire.com/login<\/code>：<\/p><img alt=\"Google Cloud Console 中的重定向 URL 设置\" src=\"/sunshine_new/images/负1526964253/image5.jpg\" width=\"467\" /><p>登录后，您还应当访问 Gmail，其中包含一个 <a href=\"https://support.google.com/mail/answer/106237?hl=en\">集成的 Google Tasks 界面<\/a>，向它添加一些示例任务列表和任务。这对检查 PHP 应用程序能否正常工作很有用。Gmail 中的 Google Tasks 界面类似于：\n                <\/p><img alt=\"Gmail 中的 Google Tasks 界面\" src=\"/sunshine_new/images/负1526964253/image6.jpg\" width=\"542\" /><p>看起来像是要完成许多挂钩，好消息是您只需完成一次即可。<\/p><h2 id=\"N10156\">了解 Tasks API<\/h2><p>Google Tasks API 接受对在资源上执行操作的 REST 请求，使用请求的信息作为响应。<em>资源<\/em> 只是一个 URL，引用可对其执行操作的对象或实体，比如 <code>/lists<\/code> 或 <code>/users<\/code>。<em>操作<\/em> 是 4 个 HTTP “动词” 之一，比如 GET（检索）、POST（创建）、PUT（更新）和 DELETE（删除）。<\/p><p>Google Tasks API 包含两种主要资源：任务和任务列表。用户可拥有多个任务列表，每个列表可拥有多个任务。任务始终存在于任务列表中。Google Tasks API 会将用户创建的第一个任务列表视为他或她的 “默认” 任务列表。<\/p><p>Google Tasks API 使用 JSON 格式编码响应。以下是一个 API 响应示例，它向 <code>https://www.googleapis.com/tasks/v1/lists/@default/tasks<\/code> 发出一个经过验证的 GET 请求，这是检索用户的默认任务列表的 API 端点。<\/p><h5 id=\"c1\">清单 1. Google Tasks API 响应示例<\/h5><div class=\"codesection\"><pre class=\"displaycode\">{\n \"kind\": \"tasks#tasks\",\n \"etag\": \"\\\"zhaMOBt\\\"\",\n \"items\": [\n  {\n   \"kind\": \"tasks#task\",\n   \"id\": \"MTc3Mz\",\n   \"etag\": \"\\\"zhaMOBt\\\"\",\n   \"title\": \"Milk\",\n   \"updated\": \"2013-11-11T07:46:09.000Z\",\n   \"selfLink\": \"https://www.googleapis.com/tasks/v1/lists/MTc3Mz/tasks/MTc3MzQ1\",\n   \"position\": \"00000000000637427684\",\n   \"status\": \"needsAction\"\n  },\n  {\n   \"kind\": \"tasks#task\",\n   \"id\": \"MTc3Mz\",\n   \"etag\": \"\\\"zhaMOBt\\\"\",\n   \"title\": \"Bread\",\n   \"updated\": \"2013-11-11T07:46:11.000Z\",\n   \"selfLink\": \"https://www.googleapis.com/tasks/v1/lists/MTc3Mz/tasks/MTc3MzQ6\",\n   \"position\": \"00000000000717532232\",\n   \"status\": \"needsAction\"\n  },\n  {\n       ...\n  }\n ]\n}<\/pre><\/div><p>如清单 1 所示，Tasks API 生成一个 JSON 编码的响应，其中包含一个任务列表。每个任务条目包含一些有用的元数据，比如任务标题、截止日期、自己的 URL 和状态。现在编码此 JSON 并将它转换为适合在 Web 浏览器中显示的 HTML 表示会非常简单。但是，在大部分时间，您都不会向 Tasks API 发出原始的 GET 和 POST 请求。Google PHP OAuth 客户端和它的服务对象围绕这些请求提供了一个便捷的包装器，将所有相关功能封装到 PHP 对象和方法中。<\/p><h2 id=\"N1017A\">列出任务<\/h2><p>清单 2 结合使用了 Google OAuth 库和 Slim 框架来连接、验证任务列表和任务，并显示了它们的摘要。<\/p><h5 id=\"c2\">清单 2. OAuth 身份验证流和任务列表检索<\/h5><div class=\"codesection\"><pre class=\"displaycode\">&lt;?php\nsession_start();\nrequire_once 'vendor/Slim/Slim.php';\nrequire_once 'vendor/google-api-php-client/src/Google_Client.php';\nrequire_once 'vendor/google-api-php-client/src/contrib/Google_TasksService.php';\n\n\\Slim\\Slim::registerAutoloader();\n$app = new \\Slim\\Slim();\n$app-&gt;config(array(\n  'debug' =&gt; true,\n  'templates.path' =&gt; './templates'\n));\n$client = new Google_Client();\n$client-&gt;setApplicationName('Project X');\n$client-&gt;setClientId('YOUR-CLIENT-ID');\n$client-&gt;setClientSecret('YOUR-CLIENT-SECRET');\n$client-&gt;setRedirectUri('http://tasks.melonfire.com/login');\n$client-&gt;setScopes(array(\n  'https://www.googleapis.com/auth/tasks'\n));\n$app-&gt;client = $client;\n$app-&gt;tasksService = new Google_TasksService($app-&gt;client);\n\n\n$app-&gt;get('/login', function () use ($app) {\n  \n    if (isset($_GET['code'])) {\n      $app-&gt;client-&gt;authenticate();\n      $_SESSION['access_token'] = $app-&gt;client-&gt;getAccessToken();\n      $app-&gt;redirect('/index');\n      exit;\n    }  \n\n    // if token available in session, set token in client\n    if (isset($_SESSION['access_token'])) {\n      $app-&gt;client-&gt;setAccessToken($_SESSION['access_token']);\n    }\n\n    if ($app-&gt;client-&gt;getAccessToken()) {\n      if (isset($_SESSION['target'])) {\n        $app-&gt;redirect($_SESSION['target']);\n      } else {\n        $app-&gt;redirect('/index');\n      }\n    } else {\n      $authUrl = $app-&gt;client-&gt;createAuthUrl();\n      $app-&gt;redirect($authUrl);\n    }\n  \n});\n\n$app-&gt;get('/index', 'authenticate', function () use ($app) {\n  $lists = $app-&gt;tasksService-&gt;tasklists-&gt;listTasklists();\n  foreach ($lists['items'] as $list) {\n    $id = $list['id'];\n    $tasks[$id] = $app-&gt;tasksService-&gt;tasks-&gt;listTasks($id);\n  }\n  $app-&gt;render('index.php', array('lists' =&gt; $lists, 'tasks' =&gt; $tasks));\n});\n\n\n$app-&gt;get('/logout', function () use ($app) {\n  unset($_SESSION['access_token']);    \n  $app-&gt;client-&gt;revokeToken();\n});\n\n$app-&gt;run();\n\nfunction authenticate () {\n  $app = \\Slim\\Slim::getInstance();\n  $_SESSION['target'] = $app-&gt;request()-&gt;getPathInfo();\n  if (isset($_SESSION['access_token'])) {\n    $app-&gt;client-&gt;setAccessToken($_SESSION['access_token']);\n  }\n  if (!$app-&gt;client-&gt;getAccessToken()) {\n    $app-&gt;redirect('/login');\n  }\n}<\/pre><\/div><p>清单 2（应保存为 <code>$APP_ROOT/index.php<\/code>）首先加载 Slim 和 Google OAuth 客户端库，以及 Google Tasks 服务对象。它初始化一个新的 Slim 应用程序对象和一个新的 <code>Google_Client<\/code> 对象。不用说，<code>Google_Client<\/code> 对象必须配置之前在 Google Cloud Console 中定义的相同的客户端 ID、客户端密钥和重定向 URL。还会初始化一个 <code>Google_TasksService<\/code> 服务对象，该对象用作通过 PHP 与 Google Tasks API 交互的主要控制点。<\/p><p>Slim 定义 HTTP 方法和端点的路由器回调。完成方式是调用相应的方法（<code>get()<\/code> 用于 GET 请求、<code>post()<\/code> 用于 POST 请求等），并传递 URL 路由，以便匹配为该方法的第一个参数。该方法的第二个参数是一个函数，它指定了在路由与一个传入的请求匹配时应采取的操作。清单 2 设置了 3 个这样的路由器回调：<code>/index<\/code>、<code>/login<\/code> 和 <code>/logout<\/code>。我们将依次看看每个回调：<\/p><ul class=\"ibm-bullet-list\"><li><code>/login<\/code> 回调处理了 OAuth 身份验证流。有关这个流的完整讨论不属于本文的讨论范围，但您可通过 Google API 文档获取有关的详尽细节\n                    。简言之，此回调使用了 <code>Google_Client<\/code> 对象的 <code>createAuthUrl()<\/code> 方法生成 Google 身份验证页面的 URL（参见下图），然后将客户端浏览器重定向到这个 URL。在用户验证应用程序并确认它能够访问的数据后，Google 将客户端重定向回 <code>/login<\/code> URL，此 URL 将会获取一个访问令牌并将该令牌存储在会话中。这个访问令牌为客户端提供了访问 Google Tasks API 的能力。<\/li><li>成功的 OAuth 身份验证会将客户端重定向到应用程序的索引页面，位于 <code>/index<\/code>。此回调使用已配置好的 <code>Google_TasksService<\/code> 对象和它的 <code>listTasklists()<\/code> 方法来获取经过验证的用户的一组任务列。该代码然后迭代这个任务列表集合，对于每个列表，该代码都会调用服务对象的 <code>listTasks()<\/code> 方法来获取该列表中的各个任务。然后将此信息传输给视图，视图负责向用户呈现它。下文将给出视图脚本。<\/li><li><code>/logout<\/code> 方法会销毁会话，进而清空其中存储的访问令牌。为了提高安全性，它还调用了客户端对象的 <code>revokeToken()<\/code> 方法，这也会让 Google 服务器上的令牌失效。<\/li><\/ul><img alt=\"Google API 授权\" src=\"/sunshine_new/images/负1526964253/image7.jpg\" width=\"449\" /><p>您已经看到，<code>/index<\/code> 回调负责获取用户的任务列表和每个列表的任务。此信息存储在 PHP 变量中，并被传输给视图，后者负责将它格式化为容易阅读的列表。视图脚本应位于 <code>$APP_ROOT/templates/index.php<\/code>，它应类似于：<\/p><h5 id=\"c3\">清单 3. 索引页面<\/h5><div class=\"codesection\"><pre class=\"displaycode\">&lt;!DOCTYPE html&gt; \n&lt;html&gt; \n&lt;head&gt; \n  &lt;meta name=\"viewport\" content=\"width=device-width, initial-scale=1\"&gt; \n  &lt;link rel=\"stylesheet\" href=\"http://code.jquery.com/\n    mobile/1.3.2/jquery.mobile-1.3.2.min.css\" /&gt;\n  &lt;script src=\"http://code.jquery.com/jquery-1.9.1.min.js\"&gt;&lt;/script&gt;\n  &lt;script src=\"http://code.jquery.com/mobile/1.3.2/\n    jquery.mobile-1.3.2.min.js\"&gt;&lt;/script&gt;\n&lt;/head&gt; \n&lt;body&gt; \n    &lt;div data-role=\"page\"&gt;\n      &lt;div data-role=\"header\"&gt;\n      Tasks\n      &lt;/div&gt;\n      &lt;div data-role=\"content\"&gt;\n      &lt;div data-role=\"collapsible-set\" data-inset=\"false\"&gt;\n        &lt;?php foreach ($lists['items'] as $list): ?&gt;\n          &lt;?php $id = $list['id']; ?&gt;\n          &lt;div data-role=\"collapsible\"&gt;\n            &lt;h2&gt;&lt;?php echo $list['title']; ?&gt;&lt;/h2&gt;\n            &lt;ul data-role=\"listview\"&gt;\n              &lt;?php if (isset($tasks[$id]['items'])): ?&gt;\n                &lt;?php foreach ($tasks[$id]['items'] as $task): ?&gt;\n                &lt;li&gt;                \n                  &lt;h3&gt;&lt;?php echo $task['title']; ?&gt;&lt;/h3&gt; \n                &lt;/li&gt;\n                &lt;?php endforeach; ?&gt;\n              &lt;?php endif; ?&gt;\n            &lt;/ul&gt; \n          &lt;/div&gt;\n        &lt;?php endforeach; ?&gt;\n        &lt;/div&gt;\n      &lt;/div&gt;\n    &lt;/div&gt;        \n&lt;/body&gt;\n&lt;/html&gt;<\/pre><\/div><p>清单 3 设置了一个依据标准 jQuery Mobile 约定而格式化的列表视图页面。主要页面元素是一个 <code>&lt;div&gt;<\/code> 元素，它有一个 <code>data-role=\"page\"<\/code> 属性。该属性中包含针对页面页眉、页脚和内容的不同 <code>&lt;div&gt;<\/code> 元素。页面内容包含一系列可折叠的 <code>&lt;div&gt;<\/code> 元素，每个元素表示用户的一个任务列表。单击一个列表的标题会展开它的任务。<\/p><p>要查看此功能是如何实现的，您可以在浏览器中访问 <code>http://tasks.melonfire.com/index<\/code>（将该 URL 替换为您自己的虚拟主机的 URL）。您应该看到一个与以下列表类似的任务列表：<\/p><img alt=\"任务列表\" src=\"/sunshine_new/images/负1526964253/image8.jpg\" width=\"320\" /><h2 id=\"N101FD\">创建和删除任务列表<\/h2><p>当然，显示任务只是第一步；您还希望用户能够添加新任务和任务列表。那么让我们在 <code>$APP_ROOT/index.php<\/code> 中定义一个新路由：<\/p><div class=\"codesection\"><pre class=\"displaycode\">&lt;?php\n\n// ... other routes \n\n$app-&gt;get('/add-list', 'authenticate', function () use ($app) {\n  $app-&gt;render('add-list.php');    \n});<\/pre><\/div><p>借助此路由，对 <code>/add-list<\/code> 的请求将生成一个要向用户呈现的 <code>$APP_ROOT/templates/add-list.php<\/code> 模板。下一个清单显示了此模板的内容。<code>authenticate()<\/code> 函数是一个自定义函数，在执行路由回调之前执行；查看 <a href=\"#c2\">清单 2<\/a>，您会看到它检查了一个访问令牌，如果没有找到该令牌，它会将客户端重定向到登录页面，提示重新登录。 <\/p><h5 id=\"c5\">清单 4. 任务列表创建表单<\/h5><div class=\"codesection\"><pre class=\"displaycode\">&lt;!DOCTYPE html&gt; \n&lt;html&gt; \n&lt;head&gt; \n  &lt;meta name=\"viewport\" content=\"width=device-width, initial-scale=1\"&gt; \n  &lt;link rel=\"stylesheet\" href=\"http://code.jquery.com/mobile/1.3.2/\n    jquery.mobile-1.3.2.min.css\" /&gt;\n  &lt;script src=\"http://code.jquery.com/jquery-1.9.1.min.js\"&gt;&lt;/script&gt;\n  &lt;script src=\"http://code.jquery.com/mobile/1.3.2/\n    jquery.mobile-1.3.2.min.js\"&gt;&lt;/script&gt;\n&lt;/head&gt; \n&lt;body&gt; \n    &lt;div data-role=\"page\"&gt;\n      &lt;div data-role=\"header\"&gt;\n      Add List\n      &lt;/div&gt;\n      &lt;div data-role=\"content\"&gt;\n        &lt;div data-role=\"collapsible-set\"&gt;\n          &lt;form method=\"post\" action=\"/add-list\"&gt;\n            &lt;label for=\"title\"&gt;Title:&lt;/label&gt;\n            &lt;input name=\"title\" id=\"title\" data-clear-btn=\"true\" type=\"text\"/&gt;\n            &lt;input name=\"submit\" value=\"Save\" type=\"submit\" \n              data-icon=\"check\" data-inline=\"true\" data-theme=\"a\" /&gt;\n            &lt;a href=\"/index\" data-role=\"button\" data-inline=\"true\" \n              data-icon=\"back\" data-theme=\"a\"&gt;Back&lt;/a&gt;\n          &lt;/form&gt;\n      &lt;/div&gt;\n    &lt;/div&gt;\n&lt;/body&gt;\n&lt;/html&gt;<\/pre><\/div><p>清单 4 包含一个表单，其中只有一个字段，表示新任务列表的标题。提交时，表单数据将 POST 回 <code>/add-list<\/code> 路由，后者现在需要扩展来处理表单输入。以下是额外的代码：<\/p><h5 id=\"c6\">清单 5. 任务列表创建<\/h5><div class=\"codesection\"><pre class=\"displaycode\">&lt;?php\n\n// ... other routes \n\n$app-&gt;post('/add-list', 'authenticate', function () use ($app) {\n  if (isset($_POST['submit'])) {\n    $title = trim(htmlentities($_POST['title']));\n    if (empty($title)) {\n      $title = 'Untitled List';\n    }\n    $tasklist = new Google_TaskList();\n    $tasklist-&gt;setTitle($title);\n    $result = $app-&gt;tasksService-&gt;tasklists-&gt;insert($tasklist);\n    $app-&gt;redirect('/index');\n  } \n});<\/pre><\/div><p>清单 5 清除了通过表单提交的标题，然后创建一个新的 <code>Google_TaskList<\/code> 对象。此对象表示 Google Tasks API 中的一个任务列表资源。该对象的 <code>setTitle()<\/code> 方法用于分配一个标题，然后，该服务对象的 <code>insert()<\/code> 方法将新任务列表保存到 Google Tasks 中。<\/p><p>以下是这个表单，以及提交它的结果：<\/p><img alt=\"任务列表创建\" src=\"/sunshine_new/images/负1526964253/image9.jpg\" width=\"400\" /><p>如果现在检查 Gmail 中的 Google Tasks 界面，您也应该在这里看到新添加的任务列表。您可亲自尝试！<\/p><p>如果已允许用户添加列表，那么您还需要为他们提供一种删除列表的方式。服务对象的 <code>insert()<\/code> 方法的反向方法是 <code>delete()<\/code> 方法，它接受一个任务列表标识符并从 Google Tasks 删除相应的列表。以下是路由定义：<\/p><h5 id=\"c7\">清单 6. 任务列表删除<\/h5><div class=\"codesection\"><pre class=\"displaycode\">&lt;?php\n\n// ... other routes \n\n$app-&gt;get('/delete-list/:lid', 'authenticate', function ($lid) use ($app) {\n  $app-&gt;tasksService-&gt;tasklists-&gt;delete($lid);\n  $app-&gt;redirect('/index');\n});<\/pre><\/div><p>清单 6 设置一个新路由 <code>/delete-list<\/code>，它接受一个列表标识符，使用该标识符作为请求 URL 的一部分。Slim 的路由框架随后会解析这个请求 URL，提取列表标识符，使用服务对象的 <code>delete()<\/code> 方法从 Google Tasks 删除相应的列表。<\/p><p>现在所剩只有更新索引页面列清单，增添添加和删除列表的按钮。以下是修订的索引页面的代码：<\/p><h5 id=\"c8\">清单 7. 索引页面<\/h5><div class=\"codesection\"><pre class=\"displaycode\">&lt;!DOCTYPE html&gt; \n&lt;html&gt; \n&lt;head&gt; \n  &lt;meta name=\"viewport\" content=\"width=device-width, initial-scale=1\"&gt; \n  &lt;link rel=\"stylesheet\" href=\"http://code.jquery.com/mobile/1.3.2/\n    jquery.mobile-1.3.2.min.css\" /&gt;\n  &lt;script src=\"http://code.jquery.com/jquery-1.9.1.min.js\"&gt;&lt;/script&gt;\n  &lt;script src=\"http://code.jquery.com/mobile/1.3.2/\n    jquery.mobile-1.3.2.min.js\"&gt;&lt;/script&gt;\n&lt;/head&gt; \n&lt;body&gt; \n    &lt;div data-role=\"page\"&gt;\n      &lt;div data-role=\"header\"&gt;\n      Tasks\n      &lt;/div&gt;\n      &lt;div data-role=\"content\"&gt;\n      &lt;div data-role=\"collapsible-set\" data-inset=\"false\"&gt;\n        &lt;?php foreach ($lists['items'] as $list): ?&gt;\n          &lt;?php $id = $list['id']; ?&gt;\n          &lt;div data-role=\"collapsible\"&gt;\n            &lt;h2&gt;&lt;?php echo $list['title']; ?&gt;&lt;/h2&gt;\n            &lt;ul data-role=\"listview\"&gt;\n              &lt;?php if (isset($tasks[$id]['items'])): ?&gt;\n                &lt;?php foreach ($tasks[$id]['items'] as $task): ?&gt;\n                &lt;li&gt;                \n                  &lt;?php if ($task['status'] == 'needsAction'): ?&gt;\n                  &lt;h3&gt;&lt;?php echo $task['title']; ?&gt;&lt;/h3&gt; \n                  &lt;?php else: ?&gt;\n                  &lt;h3 style=\"text-decoration:line-through\"\n                    &gt;&lt;?php echo $task['title']; ?&gt;&lt;/h3&gt; \n                  &lt;?php endif; ?&gt;\n                  &lt;?php if (isset($task['due']) &amp;&amp; \n                    ($task['status'] == 'needsAction')): ?&gt;\n                  &lt;p&gt;Due on &lt;?php echo date('d M Y', \n                    strtotime($task['due'])); ?&gt;&lt;/p&gt; \n                  &lt;?php endif; ?&gt;                    \n                  &lt;?php if (isset($task['completed']) \n                    &amp;&amp; ($task['status'] == 'completed')): ?&gt;\n                  &lt;p&gt;Completed on &lt;?php echo \n                    date('d M Y', strtotime($task['completed'])); ?&gt;&lt;/p&gt; \n                  &lt;?php endif; ?&gt;                    \n                &lt;/li&gt;\n                &lt;?php endforeach; ?&gt;\n              &lt;?php endif; ?&gt;\n            &lt;/ul&gt; \n            &lt;a href=\"/delete-list/&lt;?php echo $id; ?&gt;\" \n              data-inline=\"true\" data-role=\"button\" data-icon=\"delete\" \n              data-theme=\"a\"&gt;Remove list&lt;/a&gt;\n          &lt;/div&gt;\n        &lt;?php endforeach; ?&gt;\n        &lt;/div&gt;\n      &lt;/div&gt;\n      &lt;a href=\"/add-list\" data-inline=\"true\" data-role=\"button\" \n        data-icon=\"plus\" data-theme=\"b\"&gt;Add new list&lt;/a&gt; \n    &lt;/div&gt;        \n&lt;/body&gt;\n&lt;/html&gt;<\/pre><\/div><p>除了添加和删除列表的新按钮之外，这个视图脚本版本还添加了一些额外的增强。此时我们显示了任务的截止日期，已完成的任务有一条划过它们的删除线，而仍为完成的任务 (<code>status=\"needsAction\"<\/code>) 则没有删除线。以下是该页面的显示效果。<\/p><img alt=\"任务列表\" src=\"/sunshine_new/images/负1526964253/image10.jpg\" width=\"368\" /><h2 id=\"N1026E\">创建和删除任务<\/h2><p>就像可以添加和删除任务列表一样，也可在列表中添加和删除任务。以下是用于此用途的新 <code>/add-item<\/code> 和 <code>/delete-item<\/code> 路由：<\/p><h5 id=\"c9\">清单 8. 任务添加和删除<\/h5><div class=\"codesection\"><pre class=\"displaycode\">&lt;?php\n\n// ... other routes \n\n$app-&gt;get('/add-task/:tid', 'authenticate', function ($tid) use ($app) {\n  $app-&gt;render('add-task.php', array('id' =&gt; $tid));    \n});\n\n$app-&gt;post('/add-task', 'authenticate', function () use ($app) {\n  if (isset($_POST['submit'])) {\n    $title = trim(htmlentities($_POST['title']));\n    $due = trim(htmlentities($_POST['due']));\n    $id = trim(htmlentities($_POST['id']));\n    if (empty($title)) {\n      $title = 'Untitled Task';\n    }\n    if (empty($due)) {\n      $due = 'tomorrow';\n    }\n    $task = new Google_Task();\n    $task-&gt;setTitle($title);\n    $task-&gt;setDue(date(DATE_RFC3339, strtotime($due)));\n    $result = $app-&gt;tasksService-&gt;tasks-&gt;insert($id, $task);\n    $app-&gt;redirect('/index');\n  } \n});\n\n$app-&gt;get('/delete-task/:lid/:tid', 'authenticate', function ($lid, $tid) use ($app) {\n  $app-&gt;tasksService-&gt;tasks-&gt;delete($lid, $tid);\n  $app-&gt;redirect('/index');\n});<\/pre><\/div><p>每个任务都必须与一个任务列表相关联，所以 <code>/add-task<\/code> 路由回调被设置为接收一个任务列表标识符作为 GET 请求参数。然后，它会呈现 <code>$APP_ROOT/templates/add-task.php<\/code> 模板，其中包含一个添加新任务的表单，该模板如此清单中所述：<\/p><h5 id=\"c10\">清单 9. 任务创建表单<\/h5><div class=\"codesection\"><pre class=\"displaycode\">&lt;!DOCTYPE html&gt; \n&lt;html&gt; \n&lt;head&gt; \n  &lt;meta name=\"viewport\" content=\"width=device-width, initial-scale=1\"&gt; \n  &lt;link rel=\"stylesheet\" href=\"http://code.jquery.com/mobile/1.3.2/\n    jquery.mobile-1.3.2.min.css\" /&gt;\n  &lt;link rel=\"stylesheet\" type=\"text/css\" href=\"http://dev.jtsage.com/cdn/\n    datebox/latest/jqm-datebox.min.css\" /&gt; \n  &lt;script src=\"http://code.jquery.com/jquery-1.9.1.min.js\"&gt;&lt;/script&gt;\n  &lt;script src=\"http://code.jquery.com/mobile/1.3.2/\n    jquery.mobile-1.3.2.min.js\"&gt;&lt;/script&gt;\n  &lt;script src=\"http://dev.jtsage.com/cdn/datebox/latest/\n    jqm-datebox.core.min.js\"&gt;&lt;/script&gt;\n  &lt;script src=\"http://dev.jtsage.com/cdn/datebox/latest/\n    jqm-datebox.mode.calbox.min.js\"&gt;&lt;/script&gt;\n  &lt;script src=\"http://dev.jtsage.com/cdn/datebox/i18n\n    /jquery.mobile.datebox.i18n.en_US.utf8.js\"&gt;&lt;/script&gt;\n&lt;/head&gt; \n&lt;body&gt; \n    &lt;div data-role=\"page\"&gt;\n      &lt;div data-role=\"header\"&gt;\n      Add Task\n      &lt;/div&gt;\n      &lt;div data-role=\"content\"&gt;\n        &lt;div data-role=\"collapsible-set\"&gt;\n          &lt;form method=\"post\" action=\"/add-task\"&gt;\n            &lt;input name=\"id\" type=\"hidden\" value=\"&lt;?php echo $id; ?&gt;\" /&gt;\n            &lt;label for=\"title\"&gt;Title:&lt;/label&gt;\n            &lt;input name=\"title\" id=\"title\" data-clear-btn=\"true\" type=\"text\"/&gt;\n            &lt;label for=\"due\"&gt;Due:&lt;/label&gt;\n            &lt;input name=\"due\" id=\"due\" type=\"date\" data-role=\"datebox\" \n              data-options='{\"mode\": \"calbox\", \"useFocus\": true, \n              \"themeDateToday\": \"e\"}' /&gt;\n            &lt;input name=\"submit\" value=\"Save\" type=\"submit\" \n              data-icon=\"check\" data-inline=\"true\" data-theme=\"a\" /&gt;\n            &lt;a href=\"/index\" data-role=\"button\" data-inline=\"true\" \n              data-icon=\"back\" data-theme=\"a\"&gt;Back&lt;/a&gt;\n          &lt;/form&gt;\n      &lt;/div&gt;\n    &lt;/div&gt;\n&lt;/body&gt;\n&lt;/html&gt;<\/pre><\/div><p>清单 9 包含一个具有两个可见字段的表单，一个字段用于任务标题，另一个字段用于任务截止日期。为了简化日期输入，日期输入字段被配置为使用 <a href=\"http://dev.jtsage.com/jQM-DateBox2/\">jQuery Mobile DateBox<\/a> 插件，该插件显示一个图形化的日期选取器，以便通过单击来输入日期\n                。因为任务必须与一个任务列表有关联，所以作为 GET 参数而收到的任务列表标识符也在表单中被指定为一个隐藏字段。<\/p><p>提交表单后，输入其中的数据就会被清除，并用于初始化一个 <code>Google_Task<\/code> 对象。然后这个对象与隐藏的任务列表标识符一起传递给服务对象的 <code>insert()<\/code> 方法，该方法负责通过 GEST 调用将它添加到 Google Tasks 系统中。最后，像 <code>/add-task<\/code> 回调一样，<code>/delete-task<\/code> 路由回调被配置为同时接收任务列表标识符和任务标识符。然后，它使用服务对象的 <code>delete()<\/code> 方法来从指定的任务列表中删除指定的任务。<\/p><p>在设置了路由和业务登录后，剩下的任务就是更新索引页面、添加任务添加和删除按钮。因为我很快就会介绍如何更新任务的状态，所以现在正好为此功能添加一个按钮。以下是修订后的模板：<\/p><h5 id=\"c11\">清单 10. 索引页面<\/h5><div class=\"codesection\"><pre class=\"displaycode\">&lt;!DOCTYPE html&gt; \n&lt;html&gt; \n&lt;head&gt; \n  &lt;meta name=\"viewport\" content=\"width=device-width, initial-scale=1\"&gt; \n  &lt;link rel=\"stylesheet\" href=\"http://code.jquery.com/mobile/1.3.2/\n    jquery.mobile-1.3.2.min.css\" /&gt;\n  &lt;link rel=\"stylesheet\" type=\"text/css\" \n    href=\"http://dev.jtsage.com/cdn/datebox/latest/jqm-datebox.min.css\" /&gt; \n  &lt;script src=\"http://code.jquery.com/jquery-1.9.1.min.js\"&gt;&lt;/script&gt;\n  &lt;script src=\"http://code.jquery.com/mobile/1.3.2/\n    jquery.mobile-1.3.2.min.js\"&gt;&lt;/script&gt;\n  &lt;script src=\"http://dev.jtsage.com/cdn/datebox/latest/\n    jqm-datebox.core.min.js\"&gt;&lt;/script&gt;\n  &lt;script src=\"http://dev.jtsage.com/cdn/datebox/latest/\n    jqm-datebox.mode.calbox.min.js\"&gt;&lt;/script&gt;\n  &lt;script src=\"http://dev.jtsage.com/cdn/datebox/i18n/\n    jquery.mobile.datebox.i18n.en_US.utf8.js\"&gt;&lt;/script&gt;\n&lt;/head&gt; \n&lt;body&gt; \n    &lt;div data-role=\"page\"&gt;\n      &lt;div data-role=\"header\"&gt;\n      Tasks\n      &lt;/div&gt;\n      &lt;div data-role=\"content\"&gt;\n      &lt;div data-role=\"collapsible-set\" data-inset=\"false\"&gt;\n        &lt;?php foreach ($lists['items'] as $list): ?&gt;\n          &lt;?php $id = $list['id']; ?&gt;\n          &lt;div data-role=\"collapsible\"&gt;\n            &lt;h2&gt;&lt;?php echo $list['title']; ?&gt;&lt;/h2&gt;\n            &lt;ul data-role=\"listview\"&gt;\n              &lt;?php if (isset($tasks[$id]['items'])): ?&gt;\n                &lt;?php foreach ($tasks[$id]['items'] as $task): ?&gt;\n                &lt;li&gt;                \n                  &lt;div class=\"ui-grid-b\"&gt;\n                    &lt;div class=\"ui-block-a\"&gt;\n                      &lt;?php if ($task['status'] == 'needsAction'): ?&gt;\n                      &lt;h3&gt;&lt;?php echo $task['title']; ?&gt;&lt;/h3&gt; \n                      &lt;?php else: ?&gt;\n                      &lt;h3 style=\"text-decoration:line-through\"&gt;\n                        &lt;?php echo $task['title']; ?&gt;&lt;/h3&gt; \n                      &lt;?php endif; ?&gt;\n                      &lt;?php if (isset($task['due']) &amp;&amp; \n                        ($task['status'] == 'needsAction')): ?&gt;\n                      &lt;p&gt;Due on &lt;?php echo date('d M Y', \n                        strtotime($task['due'])); ?&gt;&lt;/p&gt; \n                      &lt;?php endif; ?&gt;                    \n                      &lt;?php if (isset($task['completed']) &amp;&amp;\n                        ($task['status'] == 'completed')): ?&gt;\n                      &lt;p&gt;Completed on &lt;?php echo \n                        date('d M Y', strtotime($task['completed'])); ?&gt;&lt;/p&gt; \n                      &lt;?php endif; ?&gt;                    \n                    &lt;/div&gt;                    \n                    &lt;div class=\"ui-block-b\"&gt;&lt;/div&gt;                    \n                    &lt;div class=\"ui-block-c\"&gt;\n                      &lt;?php if ($task['status'] == 'needsAction'): ?&gt;\n                      &lt;a href=\"/update-task/&lt;?php echo $id; ?&gt;/\n                        &lt;?php echo $task['id']; ?&gt;\" data-inline=\"true\" \n                        data-role=\"button\" data-icon=\"check\" \n                        data-theme=\"a\"&gt;Done!&lt;/a&gt;\n                      &lt;?php endif; ?&gt;\n                      &lt;a href=\"/delete-task/\n                        &lt;?php echo $id; ?&gt;/&lt;?php echo $task['id']; ?&gt;\" \n                        data-inline=\"true\" data-role=\"button\" data-icon=\"delete\" \n                        data-theme=\"a\"&gt;Remove task&lt;/a&gt;\n                    &lt;/div&gt;\n                  &lt;/div&gt;\n                &lt;/li&gt;\n                &lt;?php endforeach; ?&gt;\n              &lt;?php endif; ?&gt;\n            &lt;/ul&gt; &lt;br/&gt;\n            &lt;a href=\"/add-task/&lt;?php echo $id; ?&gt;\" \n              data-inline=\"true\" data-role=\"button\" data-icon=\"plus\" \n              data-theme=\"a\"&gt;Add new task&lt;/a&gt;\n            &lt;a href=\"/delete-list/&lt;?php echo $id; ?&gt;\" \n              data-inline=\"true\" data-role=\"button\" data-icon=\"delete\" \n              data-theme=\"a\"&gt;Remove list&lt;/a&gt;\n          &lt;/div&gt;\n        &lt;?php endforeach; ?&gt;\n        &lt;/div&gt;\n        &lt;a href=\"/add-list\" data-inline=\"true\" data-role=\"button\" \n          data-icon=\"plus\" data-theme=\"b\"&gt;Add new list&lt;/a&gt; \n      &lt;/div&gt;\n    &lt;/div&gt;\n&lt;/body&gt;\n&lt;/html&gt;<\/pre><\/div><p>如清单 10 所示，每个任务列表的标记都已更新，将每个列表转换为一个两列网格。左侧列包含任务标题和截止日期。右侧列包含可为该任务执行的操作，比如更新它还是删除它。最后还有一个新按钮，该按钮支持使用新任务更新此列表。<\/p><p>向任务列表添加新任务的过程类似于：<\/p><img alt=\"任务创建\" src=\"/sunshine_new/images/负1526964253/image11.jpg\" width=\"500\" /><h2 id=\"N102BD\">更新任务状态<\/h2><p>所以，您的应用程序现在支持添加和删除任务和任务列表。您需要添加的最后一项功能是将任务标记为已完成。<a href=\"#c10\">清单 10<\/a> 已包含此功能的按钮，它被链接到 <code>/update-task<\/code> 路由。清单 11 完成了最后的工作，指定了此路由的业务逻辑。<\/p><h5 id=\"c12\">清单 11. 任务更新<\/h5><div class=\"codesection\"><pre class=\"displaycode\">&lt;?php\n\n// ... other routes \n\n$app-&gt;get('/update-task/:lid/:tid', 'authenticate', \n  function ($lid, $tid) use ($app) {\n    $task = new Google_Task($app-&gt;tasksService-&gt;tasks-&gt;get($lid, $tid));\n    $task-&gt;setStatus('completed');\n    $result = $app-&gt;tasksService-&gt;tasks-&gt;update($lid, $task-&gt;getId(), $task);\n    $app-&gt;redirect('/index');\n});<\/pre><\/div><p><code>/update-task<\/code> 路由回调同时接收列表和任务标识符，使用此信息从 Google Tasks API 获取任务信息。然后，使用此信息来填充一个新的 <code>Google_Tasks<\/code> 对象，该对象的 <code>setStatus()<\/code> 方法用于将任务的状态更改为 “completed”。服务对象的 <code>update()<\/code> 方法用于将新任务条目推送到 Google 的服务器。<\/p><p>将任务标记为已完成的过程类似于下图。<\/p><img alt=\"任务状态更新\" src=\"/sunshine_new/images/负1526964253/image12.jpg\" width=\"500\" /><h2 id=\"N102E8\">结束语<\/h2><p>大功告成！您参加了一堂速成课，了解了如何结合使用 jQuery Mobile、Google PHP OAuth 库和 Slim PHP 微型框架，将来自 Google Tasks API 的数据与 PHP 应用程序相集成。本文中的示例介绍了 Google Tasks JSON 格式，展示了如何获取任务列表；添加、修改和删除任务；以及为用户的 Google Account 中的任务列表构建一个自定义界面。<\/p><p>正如这些示例所演示的，在您希望构建新的富有创意的任务管理应用程序时，Google Tasks API 是一个强大且又灵活的工具。使用它一段时间，看看您能想到什么！<\/p><div class=\"ibm-rule dw-article-ps-topic-rule\"><hr/><\/div><p><span class=\"dw-article-ps-topic-head\">相关主题：<\/span><a class=\"dw-article-ps-topic\" href=\"http://www.ibm.com/developerworks/topics/php/\">PHP<\/a><a class=\"dw-article-ps-topic\" href=\"http://www.ibm.com/developerworks/topics/jquery mobile/\">jQuery Mobile<\/a><a class=\"dw-article-ps-topic\" href=\"http://www.ibm.com/developerworks/topics/google tasks/\">Google Tasks<\/a><\/p><CMA ID: 976430><Site ID: 10><XSLT stylesheet used to transform this file: dw-document-html-7.0.xsl>\r\n\r\n\r\n<\/div>\r\n<\/div>\r\n","createTime":"2014-07-03 00:00:00","deployTime":"2014-07-03 00:00:00","id":0,"intro":"想要构建一个简单的移动应用程序，以便创建和管理您的待办事项列表？使用 Slim PHP 微型框架、jQuery Mobile 和 Google Tasks API 很容易完成这项任务。我将展示我是怎么做的。","keyword":"","recommend":false,"source":"http://www.ibm.com/developerworks/cn/mobile/mo-php-todolist-app/index.html","title":"使用 PHP、jQuery Mobile 和 Google Tasks 创建一个移动友好的待办事项列表应用程序","typeId":0,"updateTime":"2014-07-03 00:00:00"}
{"author":"","clickNumber":0,"content":"\r\n<div class=\"ibm-columns\">\r\n<div class=\"ibm-col-1-1\">\r\n\r\n<h2 id=\"major1\">简介<\/h2><p>IBM WebSphere Lombardi Edition(简称 WLE) 是 IBM Business Process Manager(简称 BPM) 产品的前身，WLE 产品的用户为了获得 IBM BPM 的最新功能、服务与支持，需要将 WLE 迁移到 BPM 的最新版本 V8.5，同时迁移源环境的所有用户数据。<\/p><p>从 BPM V8.5 开始，产品配置和迁移的方法较之以前的版本有了较大的变化，本文将以 WLE V7.2 到 BPM V8.5 升级版的迁移为实例，详细介绍从 WLE 到 BPM V8.5 的迁移方法。<\/p><h2 id=\"major2\">源环境版本与拓扑结构<\/h2><p>在本例中，源环境 WLE V7.2 使用的操作系统为 Red Hat Linux 5.5 x86_64，数据库为 Oracle，产品版本信息见表 1。<\/p><h5 id=\"table1\">表 1 源环境产品版本信息<\/h5><table border=\"0\" cellpadding=\"0\" cellspacing=\"0\" class=\"ibm-data-table\"><thead xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"><tr><th><strong>Product/Component<\/strong><\/th><th><strong>Version<\/strong><\/th><\/tr><\/thead><tbody xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"><tr><td>\nIBM WebSphere Lombardi \n<\/td><td>\n7.2.0.4\n<\/td><\/tr><tr><td>\nIBM WebSphere Application Server Network Deployment\n<\/td><td>\n7.0.0.7\n<\/td><\/tr><tr><td>\nOracle database\n<\/td><td>\n11.2.0.2.0\n<\/td><\/tr><\/tbody><\/table><p>WLE V7.2 包括 Process Center（简称 PC）单机环境和 Process Server（简称 PS）网络集群环境。其中 PC 是开发环境，用户使用其部署和测试商业流程应用。PS 是运行环境，在 PC 上测试好的应用可以直接安装到 PS 上以用于实际的工作流程。<\/p><p>具体的产品拓扑结构如图 1 所示。<\/p><h5 id=\"img001\">图 1 WLE V7.2 拓扑结构图<\/h5><img alt=\"图 1 WLE V7.2 拓扑结构图\" src=\"/sunshine_new/images/1778502604/img001.jpg\" width=\"480\" /><h2 id=\"major3\">目标环境版本与拓扑结构<\/h2><p>本例中，目标环境 BPM V8.5 与源环境处于不同的机器上，目标环境使用的操作系统为 Red Hat Linux 6.1 x86_64，数据库为 Oracle，产品版本信息见表 2。<\/p><h5 id=\"table2\">表 2 目标环境产品版本信息<\/h5><table border=\"0\" cellpadding=\"0\" cellspacing=\"0\" class=\"ibm-data-table\"><thead xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"><tr><th><strong>Product/Component<\/strong><\/th><th><strong>Version<\/strong><\/th><\/tr><\/thead><tbody xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"><tr><td>\nIBM Business Process Manager Advanced\n<\/td><td>\n8.5.0.0\n<\/td><\/tr><tr><td>\nIBM WebSphere Application Server Network Deployment\n<\/td><td>\n8.5.0.2\n<\/td><\/tr><tr><td>\nOracle database\n<\/td><td>\n11.2.0.2.0\n<\/td><\/tr><\/tbody><\/table><p>BPM V8.5 包括 Process Center（简称 PC）和 Process Server（简称 PS），都为网络集群环境经典拓扑结构，包含一个 Deployment Manager（简称 Dmgr）和两个 Custom Node，三个 Cluster：AppTarget Cluster, Messaging Cluster 和 Support Cluster 分布在两个 Custom Node 上。<\/p><p>其中 PC 为开发环境，PS 为运行环境，与在 WLE 中的 PC 和 PS 作用相同。<\/p><p>拓扑结构如图 2 所示。<\/p><h5 id=\"img002\">图 2 BPM V8.5 拓扑结构图<\/h5><img alt=\"图 2 BPM V8.5 拓扑结构图\" src=\"/sunshine_new/images/1778502604/img002.jpg\" width=\"447\" /><h2 id=\"major4\">迁移前的准备<\/h2><p>首先，确认源环境是否准备好迁移<\/p><ol type=\"1\"><li>\n源环境可以正确启动，所有应用可以正常运行<\/li><li>\n源环境上有足够的存储空间用户做产品快照<\/li><\/ol><p>其次，确认目标环境是否支持迁移<\/p><ol type=\"1\"><li>\n 目标环境支持 BPM V8.5 安装，包括操作系统，硬件，数据库等<\/li><\/ol><p><a href=\"http://www.ibm.com/software/integration/business-process-manager/advanced/sysreqs/\">IBM Business Process Manager Advanced system requirements<\/a><\/p><ol type=\"1\"><li>\n用户对于目标环境有管理员权限<\/li><li>\n目标环境有足够的存储空间安装 BPM V8.5<\/li><li>\n将要用到的机器 IP 和 Hostname 已经互相加到了 Hosts 文件中<\/li><\/ol><p>最后，确认源环境 WLE V7.2 的产品安装和数据库都已经备份好，以备意外时恢复之用。<\/p><p>对于 WLE V7.2 需要备份其安装目录。<\/p><p>例如： tar -cvf lombardi7204.tar lombardi7204<\/p><p>恢复时 tar -xvf lombardi7204.tar<\/p><p>其中 lombardi7204 为 WLE 的安装目录<\/p><p>对于数据库需要备份使用的相应数据库。<\/p><p>例如：Exp <a href=\"mailto:PC106PS/pwd4insadmin@BPMSCAN1.cn.ibm.com:1521/BPMDB\">PC106PS/pwd4insadmin@BPMSCAN1.cn.ibm.com:1521/BPMDB<\/a> owner=PC106PS file=G:\\Oracle-Database-Backup\\7204back\\PC106PS.dmp<\/p><p>恢复时 imp PC106PS/pwd4insadmin@BPMSCAN1.cn.ibm.com:1521/BPMDB full=y <\/p><p>file=G:\\Oracle-Database-Backup\\7204back\\PC106PS.dmp<\/p><p>其中 BPMDB 为数据库名，PC106PS 为 Process Server 的数据所使用的用户名。<\/p><h2 id=\"major5\">迁移过程<\/h2><p>源环境 WLE V7.2 的 PC 和 PS 需要分别迁移到目标环境 BPM V8.5 中，对于这两个过程，迁移的方法是相同的，所以本章以 PC 为例介绍迁移过程。<\/p><h3 id=\"major6\">安装 BPM V8.5<\/h3><p>在目标环境 PC 所用的每个机器上（包括 Dmgr 和 Node 所在机器）安装 BPM V 8.5 升级版, 可以使用图形界面、命令行或者其他支持的工具来进行 BPM V8.5 安装，在本文中安装不作为的重点介绍，请参考<a href=\"http://bidoc.torolab.ibm.com/review/8500/topic/com.ibm.wbpm.imuc.ebpm.doc/topics/inst_lin.html\">Installing IBM Business Process Manager Advanced on Linux<\/a><\/p><p>在本例中，使用了自动化安装工具（仅用于测试中）进行 BPM V8.5 的安装，自动化所做操作包括：清理目标环境、下载安装文件和安装 BPM V8.5 升级版的产品。<\/p><p>当安装结束后，检查安装是否成功并在 install_root/bin 目录下运行 versionInfo 命令检验产品版本信息是否正确。<\/p><h3 id=\"major7\">生成迁移工具并拷贝到源环境<\/h3><p>由于目标环境与源环境不在同一台机器，迁移为远程迁移，需要生成 BPM V8.5 的迁移工具，并拷贝到源环境中，这个迁移工具用于生成源环境的快照。<\/p><p>在 target_install_root/bin 目录下运行 BPMCreateRemoteMigrationUtilities.sh remoteMigrationUtilities.zip，如图 3 所示。<\/p><h5 id=\"img003\">图 3 运行 BPMCreateRemoteMigrationUtilities 命令<\/h5><img alt=\"图 3 运行 BPMCreateRemoteMigrationUtilities 命令\" src=\"/sunshine_new/images/1778502604/img003.jpg\" width=\"553\" /><p>remoteMigrationUtilities.zip 文件生成在 BPM_home/util/migration/scripts 目录下，在命令行执行结果中显示了这个文件路径。<\/p><p>用 ftp 等工具从目标环境中复制 remoteMigrationUtilities.zip 文件到源环境，然后解压到源环境，并修改解压后的文件夹的权限为可读写。<\/p><p>例如：unzip .remoteMigrationUtilities.zip -d /opt/remoteMigrationUtilities<\/p><p> chmod 755 -R remoteMigrationUtilities<\/p><h3 id=\"major8\">提取源环境的数据库信息<\/h3><p>这部分在迁移过程中是可选择执行的，提取出的源环境数据库信息可以帮助用户生成用于目标环境搭建时的配置文件。<\/p><p>首先需启动源环境 PC 单机环境中的 server1，然后按照源环境的实际信息更新<\/p><p>remote_migration_utility/util/migration/resources/路径下的文件 migration.properties<\/p><p>更新内容包括：admin 用户和密码、WLE 的安装路径和 profile 名称。<\/p><p>在 remote_migration_utility/bin 目录下执行 BPMExtractDBConfiguration.sh -output output_properties_file -propertiesFile migration_properties_file，如图 4 所示。<\/p><h5 id=\"img004\">图 4 运行 BPMExtractDBConfiguration 命令<\/h5><img alt=\"图 4 运行 BPMExtractDBConfiguration 命令\" src=\"/sunshine_new/images/1778502604/img004.jpg\" width=\"554\" /><p>运行命令后，在指定目录查看生成的数据库信息文件，在 remote_migration_utility/logs/migration 目录下查看执行命令的日志文件。<\/p><h3 id=\"major9\">创建并配置 BPM V8.5 网络集群环境<\/h3><p>安装好 BPM V8.5 之后，需要按照参数文件，运行命令 BPMConfig 来创建和配置网络集群环境。<\/p><p>对于要搭建的 BPM V8.5 版本、拓扑环境和数据库的不同，参数文件也各不相同，在 BPM_home/BPM/samples/config/migration/ 目录下存储了针对不同情况的参数文件范例。<\/p><p>需要拷贝相应的参数文件到用户指定目录下，并按照具体情况进行修改。<\/p><p>本例使用的参数文件为 Advanced-PC-ThreeClusters-Oracle.properties<\/p><p>修改内容包括：deadmin、celladmin 用户名密码；数据库 hostname、数据库名称、数据库用户名和密码；Dmgr 和 Custom Node 要安装机器的 hostname 和路径。其他的参数保持默认。<\/p><p>Oracle 对于不同的数据要用不同的用户和 schema，包括 Process Server 数据、Performance data warehouse 数据、common 数据、cell 数据，其中 Process Server 数据和 Performance data warehouse 数据在 WLE V7.2 中存在，所以使用 WLE V7.2 的用户和 schema，common 数据和 cell 数据在 WLE V7.2 中不存在，需创建新的用户和 schema。<\/p><p>修改好参数文件后，在 Dmgr 所在机器 BPM_home/bin 目录下运行 BPMConfig -create -de my_environment.properties 其中 my_environment.properties 为上面修改的参数文件的完整路径。<\/p><p>如图 5 所示 BPMConfig 命令的执行开始，执行结果未在本图显示，需等待命令行输出 BPMConfig completed successfully，表示命令执行成功。<\/p><h5 id=\"img005\">图 5 运行 BPMConfig 命令<\/h5><img alt=\"图 5 运行 BPMConfig 命令\" src=\"/sunshine_new/images/1778502604/img005.jpg\" width=\"553\" /><p>在 Dmgr 所在机器成功执行 BPMConfig 之后，启动 Dmgr，然后拷贝配置文件到与 Dmgr 不在同一台机器的 Custom Node 所在机器，并在这台机器的 BPM_home/bin 目录下再运行 BPMConfig -create -de my_environment.properties，等待命令成功完成，停止 Dmgr。至此 BPM V8.5 的网络集群环境就搭建好了。<\/p><p>在 BPM_home/logs/config 目录下查看 BPMConfig 执行的日志文件。<\/p><h3 id=\"major10\">生成源环境的产品快照<\/h3><p>提取源环境的产品配置和用户定义等信息来生成源环境的产品快照，产品快照将用于接下来的迁移步骤中。<\/p><p>首先需启动源环境 WLE 所有 server，包括 server1、process server、performance server。<\/p><p>使用在提取源环境数据库部分中所更新的 migration.properties 文件。<\/p><p>在 remote_migration_utility/bin 目录下运行 BPMExtractSourceInformation.sh -backupFolder snapshot_folder -propertiesFile migration_properties_file，如图 6 所示。<\/p><h5 id=\"img006\">图 6 运行 BPMExtractSourceInformation 命令<\/h5><img alt=\"图 6 运行 BPMExtractSourceInformation 命令\" src=\"/sunshine_new/images/1778502604/img006.jpg\" width=\"554\" /><p>运行命令后，在指定目录查看生成的产品快照文件夹，并在这个文件夹下查看执行命令的日志文件。执行结果中显示了日志文件的路径。<\/p><p>把产品快照打包，拷贝到目标环境上（BPM V8.5 Dmgr 所在机器），并在目标环境上解压。<\/p><p>生成产品快照后，停止源环境，并继续在目标环境上（BPM V8.5 Dmgr 所在机器）做迁移步骤。<\/p><h3 id=\"major11\">生成数据库升级脚本和配置新数据库<\/h3><p>在这个步骤中，生成用于更新 WLE 原有数据库的脚本，和对新数据库进行配置。<\/p><p>在 BPM_home/util/migration/resources/目录下找到 migration properties 文件，按照实际信息更新文件，包括：admin 用户和密码、BPM V8.5 的安装路径、Dmgr profile 名称、用于 BPMConfig 的配置文件完整路径、原产品 WLE 的版本（例如 7.2.0.4）。<\/p><p>然后在 BPM_home/bin 目录下运行 BPMGenerateUpgradeSchemaScripts.sh -propertiesFile migration_properties_file，如图 7 所示。<\/p><h5 id=\"img007\">图 7 运行 BPMExtractSourceInformation 命令<\/h5><img alt=\"图 7 运行 BPMExtractSourceInformation 命令\" src=\"/sunshine_new/images/1778502604/img007.jpg\" width=\"553\" /><p>查看生成的用于数据库升级的脚本位于 target_deployment_manager_profile/dbscripts/Upgrade 目录下，日志信息位于 target_deployment_manager_profile/logs 目录下。<\/p><p>对于在配置文件中设置的新的数据库，需要对其进行配置和初始化。拷贝 target_deployment_manager_profile/dbscripts/Upgrade 文件夹到数据库服务器上，并执行这个文件夹下每个组件所对应子文件夹下的 create 脚本，包括：<\/p><p>createTable_BusinessSpace.sql<\/p><p>createSchema_CommonDB.sql<\/p><p>createSchema_CommonDBCellOnlyDB.sql<\/p><p>createSchema_ProcessChoreographer.sql<\/p><p>createSchema_Monitor.sql<\/p><p>createSchema_Messaging.sql<\/p><h3 id=\"major12\">升级源环境数据库<\/h3><p>这个步骤升级原 WLE V7.2 所用的数据库，以支持新 BPM V8.5 版本。<\/p><p>需要用到在上一步骤修改过的 BPM_home/util/migration/resources/migration properties 文件和生成的源环境产品快照解压的文件夹。<\/p><p>在 BPM_home/bin 目录下运行 DBUpgrade.sh -propertiesFile migration_properties_file -backupFolder snapshot_folder<\/p><p>如图 8 所示 DBUpgrade 命令的执行开始，执行结果未在本图显示，需等待命令行输出 All upgrade steps have been completed successfully，表示命令执行成功。<\/p><h5 id=\"img008\">图 8 运行 DBUpgrade 命令<\/h5><img alt=\"图 8 运行 DBUpgrade 命令\" src=\"/sunshine_new/images/1778502604/img008.gif\" width=\"658\" /><p>在 target_deployment_manager_profile/logs 目录下查看 BPMConfig 执行的日志文件。<\/p><h3 id=\"major13\">引入源环境产品快照<\/h3><p>这个步骤将源环境产品快照引入到目标环境中。<\/p><p>在做产品快照迁移前需要启动 BPM V8.5 环境，包括 Dmgr、Node angent 和所有的 Cluster，确认环境成功启动。<\/p><p>需要用到之前步骤修改过的 BPM_home/util/migration/resources/migration properties 文件和生成的源环境产品快照解压的文件夹。<\/p><p>在 BPM_home/bin 目录下运行 BPMMigrate.sh -backupFolder snapshot_folder -propertiesFile migration_properties_file<\/p><p>如图 9 所示 BPMMigrate 命令的执行开始，执行结果未在本图显示，需等待命令行输出 All steps of the migration completed successfully，表示命令执行成功。<\/p><h5 id=\"img009\">图 9 运行 BPMMigrate 命令<\/h5><img alt=\"图 9 运行 BPMMigrate 命令\" src=\"/sunshine_new/images/1778502604/img009.jpg\" width=\"553\" /><p>在 snapshot/logs 目录下查看 BPMMigrate 执行的日志文件。<\/p><h3 id=\"major14\">迁移用户配置到目标环境<\/h3><p>如果用户想继续使用源环境的性能优化参数，需手工在目标环境中进行配置。<\/p><p>如果用户修改过源环境的 100Custom.xml 等配置文件，在生成源环境产品快照时，自动把用户配置文件合并成 101CustomMigrated.xml，并在引入源环境产品快照时，引入到了目标环境中，检验<\/p><p>BPM_Home/profiles/deployment_manager_profile/config/cells/cell_name/nodes/node_name/servers/application_cluster_name/process-center/config 目录下的 101CustomMigrated.xml 文件是否生成，其中参数值是否和源环境设置的相同。<\/p><p>在 BPM V8.5 里，有些参数进入到了 WebSphere Common Configuration Model (简称 WCCM) 里，并在 WCCM 生效，所以需要手工将 101CustomMigrated.xml 相应的参数移到 WCCM 中，需要移动的参数请参考<a href=\"http://bidoc.torolab.ibm.com/review/8500/topic/com.ibm.wbpm.admin.doc/topics/csec_config_properties.html\">Security configuration properties<\/a>。<\/p><h3 id=\"major15\">重新启动目标环境 BPM V8.5<\/h3><p>在成功迁移源环境 WLE V7.2 到目标环境 BPM V8.5 之后，重新启动 BPM V8.5，步骤包括：<\/p><p>停止所有 Cluster，停止所有 Node Agent，停止 Dmgr；<\/p><p>启动 Dmgr，启动所有 Node Agent，启动所有 Cluster。<\/p><p>查看 Dmgr、所有 Node Agent 和所有 Cluster 的日志文件 SystemOut.log，检查在这个过程中是否有错误产生。<\/p><h2 id=\"major16\">迁移后的检验<\/h2><p>查看 Process Center console 是否可以显示连接的 Process Server（PS 的迁移需另外执行，步骤与 PC 迁移相同），确认源环境的用户流程应用可以正确显示。<\/p><p>例如：<a href=\"http://9.115.198.203:9080/ProcessCenter\">http://9.115.198.203:9080/ProcessCenter<\/a><\/p><p>查看 Process Portal 是否可以显示在源环境中启动的所有执行中的任务，和执行完成的任务。<\/p><p>例如：<a href=\"http://9.115.198.203:9080/ProcessPortal\">http://9.115.198.203:9080/ProcessPortal<\/a><\/p><p>在 Process Center console 上下载 Process Designer，安装并连接 BPM V8.5 可以查看和编辑 ProcessCenter 中的用户流程应用。<\/p><h2 id=\"major17\">结束语<\/h2><p>本文详细介绍了从 WLE V7.2 到 BPM V8.5 的迁移过程以及注意事项，用户可以参照本文，成功实现从 WLE 各版本到 BPM V8.5 的迁移。<\/p><CMA ID: 976447><Site ID: 10><XSLT stylesheet used to transform this file: dw-document-html-7.0.xsl>\r\n\r\n\r\n<\/div>\r\n<\/div>\r\n","createTime":"2014-07-03 00:00:00","deployTime":"2014-07-03 00:00:00","id":0,"intro":"IBM WebSphere Lombardi Edition(简称 WLE) 是 IBM Business Process Manager(简称 BPM) 产品的前身，WLE 产品的用户为了获得 IBM BPM 的最新功能、服务与支持，需要将 WLE 迁移到 BPM 的最新版本 V8.5，同时迁移源环境的所有用户数据。 从 BPM V8.5 开始，产品配置和迁移的方法较之以前的版本有了较大的变化，本文将以 WLE V7.2 到 BPM V8.5 升级版的迁移为实例，详细介绍从 WLE 到 BPM V8.5 的迁移方法。","keyword":"","recommend":false,"source":"http://www.ibm.com/developerworks/cn/websphere/library/techarticles/1407_wangxh_wlemigration/1407_wangxh_wlemigration.html","title":"WebShpere Lombardi Edition V7.2 到 IBM Business Process Manager V8.5 迁移实例","typeId":0,"updateTime":"2014-07-03 00:00:00"}
{"author":"","clickNumber":0,"content":"\r\n<div class=\"ibm-columns\">\r\n<div class=\"ibm-col-1-1\">\r\n\r\n<h2 id=\"introduction\"> 简介 <\/h2><p> InfoSphere DataStage 提供了一些强大功能，从来源系统提取数据，转换这些数据，并将它加载到目标系统中。许多 DataStage 用户需要获得能够保障数据从来源系统转移到目标系统并且绝不会丢失数据的解决方案。本文将详细介绍您可以在 InfoSphere DataStage 中用于保障数据从来源到目标的传送的各种方法。文中将介绍如何使用 Distributed Transaction Stage (DTS) 和一个事务管理器来处理分布式 XA 事务，并且不使用事务管理器来处理本地数据库事务。文本还将介绍如何使用多个输入链接和一个数据库连接器在一个本地事务内执行多个数据库操作，以及如何在将数据从 InfoSphere Data Replication 移动到 DataStage 时，使用 Change Data Capture Transaction 阶段完成有保障的传送。最后，还将介绍结合使用消息极端和数据库阶段来提供可靠的数据处理和转换服务的最佳实践。 <\/p><h2 id=\"gtwtdts\">全局事务与 DTS<\/h2><p> 本节大体介绍了 XA 2 阶段提交架构，展示了 DTS 如何通过与 WebSphere&#174; MQ 和数据库资源交互来完成全局事务。 <\/p><p> X/Open Group 标准 <em>eXtended Architecture<\/em> (XA) 定义了一个协议，在单个事务内更新多个资源。资源可以是数据库，也可以是消息系统，比如 WebSphere MQ。通过不可靠的网络连接跨多种资源实现原子性、一致性、隔离性和耐久性 (ACID)，这是一个亟待解决的困难问题。XA 使用一种 2 阶段提交 (2PC) 协议来实现此目的。事务管理器管理该协议，与多个管理数据库或消息资源事务的资源管理器进行通信。2PC 协议的两个阶段是： <\/p><ul class=\"ibm-bullet-list\"><li><strong>提交请求<\/strong>：在此阶段中，事务管理器将请求消息发送到每个资源。这些资源将事务准备到提交点，而不实际提交事务。例如，一个资源可将数据写入数据库，但将每个记录标记为未提交。然后，该资源向事务管理器发送回一条状态消息，表明是成功了还是失败了。<\/li><li><strong>提交<\/strong>：如果所有资源在第一阶段中都被报告成功，那么资源管理器会向每个资源都发送一条提交消息。这些资源会完成事务，然后向资源管理器报告它们的最终状态。如果资源管理器从任何资源收到任何失败消息，它会向所有资源发送一条中止消息，该消息会回滚它们未提交的事务。<\/li><\/ul><p> 2PC 之所以有效，是因为如果一个资源在第一阶段报告成功，那么它就为它将要提交数据做出了保证。支撑该协议的是一组握手消息，这些消息可以处理各种不同的清理条件，比如网络故障或事务中涉及的任何组件的故障。 <\/p><p> DTS 使用 WebSphere MQ 事务管理器（WebSphere MQ Server 中的一个标准功能）来协调事务与资源管理器，从而利用 2PC，如 <a href=\"#fig1\">图 1<\/a> 中所示： <\/p><h5 id=\"fig1\">图 1. DTS、MQ 和资源管理器之间的关系<\/h5><img alt=\"该图显示了 DTS、WebSphere MQ 和资源管理器之间的关系\" src=\"/sunshine_new/images/负1308183492/Figure1.png\" width=\"408\" /><p> DTS 首先连接到 WebSphere MQ，告诉事务管理器启动 XA 事务。事务管理器与资源管理器进行通信，以启动事务。DTS 然后利用 DB2、Oracle 或 WebSphere MQ 连接器向资源执行写入操作。最后，DTS 告诉事务管理器提交或回滚 XA 事务。 <\/p><p> DTS 作业通常使用 WebSphere MQ 作为数据源，使用数据库作为目标。通过使用 DTS，从来源队列到目标数据据库的传送就得到了保障：如果事务被成功提交，则会从来源队列中删除来源消息，数据会写入到目标数据库。如果该作业失败，则不会向目标数据库写入任何数据，该消息也会保留在来源队列上。这就提供了保障，因为来源消息的删除是在与目标数据库的更新相同的 XA 事务内执行的，因此两种操作要么都会执行，要么都不执行。 <\/p><p> DTS 作业通常使用<em>工作队列<\/em> 将工作分区为并行管道。工作文件的使用最好借助图表来解释，如图 2 所示： <\/p><h5 id=\"fig2\">图 2. DTS 对工作队列的使用<\/h5><img alt=\"该图显示了 Distributed Transaction DTS 对工作队列的使用\" src=\"/sunshine_new/images/负1308183492/Figure2.png\" width=\"436\" /><p> 这个作业与 WebSphere MQ 一起通过以下方式保障数据的传送： <\/p><ol><li>在本地同步点控制下，MQ Connector 从来源队列读取一条消息，以执行一次破坏性读取（也就是说，它将从队列中删除消息）。<\/li><li>MQ Connector 将该消息写入工作队列。如果并行运行，则会存在多个工作队列，每个并行管道一个工作队列。MQ Connector 随后会提交本地事务。请注意，这里使用的本地事务表明，从来源队列到工作队列移动的消息是<em>受保障的<\/em>。如果移动失败，那么删除操作将会回滚，该消息会还原到来源队列上，该作业也会中止。<\/li><li>DTS 阶段将更新写入目标数据库。<\/li><li>DTS 阶段从工作队列中删除此消息。<\/li><\/ol><p> 通过使用工作队列，MQ 来源连接器能够并行运行。这个阶段的每个实例都从来源队列读取不同的消息，因为它以一种破坏性方式读取数据，而且 WebSphere MQ 可确保多个读取器中只有一个读取器能读取任何特定的来源消息。 <\/p><p> 在提交该事务时，如果一切正常，那么工作队列和数据库更新就会被提交，这些全部在单个 XA 事务中完成。如果出现任何故障，比如数据库写入错误，该 XA 事务将会回滚，这会撤销对目标数据库的任何更改，将 MQ 消息还原到工作队列。如果该作业随后重新启动，MQConnector 首先从工作队列读取消息，并将它们提供给该作业，然后继续从来源队列中读取数据。这意味着在发生故障时，重新启动作业即可继续从上次的位置开始处理消息。 <\/p><h2 id=\"ltwtdts\"> 本地事务与 DTS<\/h2><p> 除了处理符合 XA 的资源（比如 DB2 和 Oracle）之外，DTS 还会处理不符合 XA 的资源。这包括 ODBC 和 Teradata 目标。本节将介绍如何在 DataStage 作业中利用不支持 XA 架构的资源，以及如何仍然实现有保障的传送。还将介绍这种设计模式的缺陷和优势。 <\/p><p> DTS 处理非 XA 资源的方式是，除了 XA 事务之外，创建一个或多个 “本地” 事务。在此上下文中，一个资源由连接属性惟一地定义，比如数据库和用于访问该数据库的用户名。如果有多个访问同一个资源（也就是同一个数据库，使用相同的用户凭据）的链接，那么可以跨这些链接使用单个事务。在提交时，本地事务会在 XA 事务之前提交。这次本地提交可能获得成功，这是最可能发生的情形，也可能会失败，这会导致资源回滚该事务。在提交或回滚本地事务后，就会提交或回滚 XA 事务。在结合使用本地事务和 XA 事务时，可能的提交或回滚场景包括： <\/p><ul class=\"ibm-bullet-list\"><li>本地提交成功，然后 XA 提交成功（正常的情况）。<\/li><li>本地提交成功，但 XA 提交失败（极少发生）。<\/li><li>本地提交失败。在发生这种情况时，DTS 会回滚 XA 事务。如果在回滚 XA 事务之前，DTS 发生崩溃或发生了其他某种系统故障，MQ 事务管理器会自动回滚它。<\/li><\/ul><p>对于回滚：<\/p><ul class=\"ibm-bullet-list\"><li>本地回滚成功，然后发生 XA 回滚。<\/li><li>本地回滚失败。此场景不会实际发生；资源会假设一个回滚位置，除非系统要求提交它们，并且可以成功完成该提交请求。<\/li><\/ul><p> 在这些场景中，惟一要担忧的是第二种场景，也就是本地事务提交成功，但后续 XA 提交失败。在这种情况下，最糟的情形是数据在本地事务下被写入到目标数据库，但消息队列在来源队列上。如果出现这种情形，只要该作业是幂等的，就可以再次运行它。在前面描述的所有可能场景中，都不会丢失数据。下一节将介绍如何创建可在作业失败时重新启动的幂等作业。 <\/p><h2 id=\"iadsj\">幂等性和 DataStage 作业 <\/h2><p> 本节将介绍如何编写作业，以便它们提供幂等的行为；也就是说，它们可在失败时重新启动，而且不会丢失数据。这些作业需要能够接受它们可能已处理的数据，要么再次处理它，要么忽略它。为了帮助解释此概念，可考虑一个非幂等的作业。考虑一个简单的文件到 Oracle 连接器作业，如图 3 所示： <\/p><h5 id=\"fig3\">图 3.  一个简单的文件到 Oracle 连接器作业 <\/h5><img alt=\"该图显示了一个简单的文件到 Oracle 连接器作业\" src=\"/sunshine_new/images/负1308183492/Figure3.jpg\" width=\"301\" /><p> 包含图 4 中指定的 Oracle 连接器的属性： <\/p><h5 id=\"fig4\">图 4.  Oracle 连接器属性 <\/h5><img alt=\"该图显示了 Oracle 连接器阶段的属性\" src=\"/sunshine_new/images/负1308183492/Figure4.jpg\" width=\"442\" /><p> 假设表 TABLE_WITH_PK 拥有一个惟一约束，也就是说，它无法拥有两个具有相同键值的行。可以明显地看到，如果第二次运行此作业，它会失败，因为相同的数据将 “重放” 到 Oracle 连接器，这将导致重复键行错误。可通过多种可能方式克服此问题： <\/p><ul class=\"ibm-bullet-list\"><li>将 Write mode 属性更改为 Insert new rows only、Insert then update 或 Update then insert。第一个选项忽略数据库中已存在的行，第二个选项在该行上执行一次插入操作，如果返回结果表明已存在该行，则会使用相同数据执行一个更新语句。最后一个选项与此类似，但按照相反顺序执行该语句。 <\/li><li>向目标阶段添加一个拒绝链接并配置它，以便导致行错误的记录被发送到该拒绝链接。<\/li><li>使用一个稀疏查找阶段查看一条记录是否已存在于目标中。查找的结果可用于确定是将记录发送到目标阶段、忽略它们，还是将现有记录转移到一个日志文件或其他目标。<\/li><\/ul><p> 具体使用哪种方法取决于特定的用例，以及是否需要对源数据进行处理。如果需要对源数据执行转换或使用其他功能，那么可以在作业中尽早使用一个稀疏查找阶段，以确定某条记录是否已存在，这样做会更有效，可以跳过转换。如果大部分源数据已通过少量中间阶段直接传递到目标，可能允许数据到达目标连接器，并让该连接器拒绝或忽略该数据会更有效。 <\/p><p> 通过使用额外的目标表来存储事务状态，可完成实现幂等性的其他方式。为此，会要求一个目标阶段可在单个事务中写入多个目标表。数据库连接器拥有这样一项功能，此功能将在下一节中介绍。 <\/p><h2 id=\"ltwdc\"> 本地事务与数据库连接器 <\/h2><p> 从 Information Server 8.5 开始，数据库连接器就已提供了支持多个输入链接的能力，每个链接以一个特定的数据库表为目标，拥有自己的一组属性（比如写入模式）。这些链接都在同一个数据库事务中执行，所以需要使用 ACID 功能来提供有保障的传送：要么写入所有表更新，要么全都不写入。 <\/p><p> 该功能有许多用例，包括： <\/p><ul class=\"ibm-bullet-list\"><li>写入相关的记录，比如在一个事务中保持父子关系。<\/li><li>对每个链接使用不同的写入模式，其中每个链接被配置为更新同一个表。例如，链接 1 可能从一个表执行删除，而链接 2 对同一个表执行更新。<\/li><li>存储一个事务标记来保存事务的状态。<\/li><\/ul><p> 后一种方法常常用在<em>检查点重新启动<\/em> 场景中，以避免在一个作业由于某个失败条件而需要重启系统时，将相同的数据再次发送到目标数据库。实现此目的的一种做法是，利用一个目标表来存储最后处理的行的编号。因为这是在与目标更新相同的事务中提交的，所以可保证准确地反映了<em>最后处理的<\/em> 行计数。在同一个作业的早期阶段，一个查找阶段会读取这个<em>最后处理的<\/em> 值，将它传递给一个转换器阶段，该阶段包含一个约束表达式，用于对比该行号与该计数。此阶段将会丢弃任何行计数小于<em>最后处理的<\/em> 值的行，因为这些行已由目标阶段处理。结果是，只有还未被目标阶段处理的记录被传送到该阶段。 <\/p><p> 还需要一个阶段，即 Wave Generator 阶段。在配置了多个输入链接时，数据库连接器仅在每个批行结束时提交该事务。Wave Generator 提供了多种不同方法来确定何时发出一个批次标记。对于本例，一个绝对行计数就足够用了，这样目标连接器就会每隔 N 行提交该事务一次。 <\/p><p> 完整的作业类似于图 5： <\/p><h5 id=\"fig5\">图 5.  检查点重新启动作业 <\/h5><img alt=\"该图显示了一个检查点重新启动作业\" src=\"/sunshine_new/images/负1308183492/Figure5.jpg\" width=\"568\" /><p> 像 <a href=\"#fig5\">图 5<\/a> 中这样的作业可用作幂等性问题的解决方案，而且可确保将数据从来源传送到目标。 <\/p><h2 id=\"odp\">其他设计模式 <\/h2><p> 本节将介绍可对其他资源实现有保障传送的其他一些模式。 <\/p><h3 id=\"N1010B\">使用 InfoSphere Data Replication 执行有保障的传送 <\/h3><p> 将 Change Data Capture Transactional 阶段 (CDCTS) 与 InfoSphere Data Replication (DR) 结合使用，可实时复制和处理任务关键型数据事件。DR 使用一种基于日志的捕获方法来检测对各种数据库系统的更新，然后将这些更新复制到另一个数据库系统，或者将这些更新传送到文件、WebSphere MQ 消息或 CDCTS。CDCTS 通过 TCP/IP 与 DR 进行通信，以接收这些对来源数据库的更新，并传递状态消息。 <\/p><p>图 6 显示了一个简单的 DR DataStage 作业： <\/p><h5 id=\"fig6\">图 6.  数据复制作业 <\/h5><img alt=\"该图显示了一个数据复制作业\" src=\"/sunshine_new/images/负1308183492/Figure6.jpg\" width=\"496\" /><p> 该 CDC 阶段配置了 DR 订阅的名称，必须拥有至少两个输出链接：其中一个或多个链接承载了数据库更新，而只有一个链接负责传递<em>书签<\/em>。书签类似于上一节中介绍的<em>最后处理的<\/em> 计数。它用于识别当前事务的最后提交点。一个 CDCTS 作业使用一个目标数据库连接器，该连接器拥有至少两个输入链接。一个链接承载书签值，它的目标是一个简单表，也就是为了存储书签值而创建的书签表。与前一个例子一样，目标数据库连接器在事务批次结束时提交该事务。这些事务批次的边界由 DR 确定。DR 将提交消息发送到 CDCTS，这些消息与来源数据库的更新事务边界保持一致。在 CDCTS 收到这些提交消息后，它将事务批次标记发送到其输出链接。在目标数据库阶段收到每个链接上的批次标记时，它会提交该事务。因为一个事务同时包含书签表和数据库更新，所以存储的书签值可保证与数据库更新保持同步。 <\/p><p> 在作业运行时，DR 定期要求 CDCTS 报告最后提交的书签值。CDCTS 通过一个 ODBC 连接查询书签值，并向 DR 报告该书签。DR 使用该值清理日志，因为它可以确定一个特定的事务已成功写入到目标表。 <\/p><p> 在作业、网络或系统发生故障时，该作业会保留为不完整状态。在作业重新启动时，CDCTS 向 DR 报告最后提交的书签值，DR 随后使用该信息确定从哪条记录开始。 <\/p><p> 从 DR 到目标数据库的传送再一次受到了保护，而且通过使用书签机制，绝不会有重复的记录发送到目标数据库。 <\/p><h3 id=\"N1012C\"> 使用管道阶段执行有保障的传送 <\/h3><p> 作业还可通过其他有创意的方式写入，以保证有保障的传送。大多数方式都依靠事务批次标记的使用，如前面的示例中所示。这类使用的另一个示例是，数据必须从一个来源队列移动到目标数据库，但消息系统不是 WebSphere MQ。DTS 仅支持 WebSphere MQ，所以要使用其他消息系统（比如 Java Messaging System (JMS)）实现类似功能，还需要使用一个类似图 7 中所示的作业： <\/p><h5 id=\"fig7\">图 7.  管道作业 <\/h5><img alt=\"该图显示了一个使用管道保障传送的作业\" src=\"/sunshine_new/images/负1308183492/Figure7.jpg\" width=\"569\" /><p> SourceMessage 和 DeleteMessage 阶段使用了一个在 Java Integration Stage 基础上编码的 JMS 解决方案。这个 JMS 阶段也定期输出批次标记。该解决方案之所以有效，是因为 Teradata 连接器提供了将成功的记录发送到它的拒绝链接（如图 8 所示）的能力（只要在拒绝链接属性中被配置为这么做）： <\/p><h5 id=\"fig8\">图 8. Teradata 连接器拒绝属性 <\/h5><img alt=\"该图显示了Teradata 连接器的拒绝属性\" src=\"/sunshine_new/images/负1308183492/Figure8.jpg\" width=\"278\" /><p> 该作业执行过程中的事件顺序是： <\/p><ol><li>JMS 阶段读取来源消息，但将它留在来源队列上。这个阶段还按规定的间隔发出批次结束标记。 <\/li><li>来自 JMS 的数据由 Teradata 连接器写入到 Teradata 数据库中。如果写入成功，那么连接器会将该数据转发到它的拒绝链接，该链接被配置为仅转发成功的记录。<\/li><li>在 Teradata 连接器从 JMS 来源阶段收到批次结束标记时，它会提交事务，并将批次结束标记转发给它的输出链接。<\/li><li>当 Remove Duplicates 阶段收到批次结束标记时，它会删除重复数据并将结果（包含一个批次结束标记）发送给它的输出链接。<\/li><li>最后的 JMS 阶段在收到一个批次结束标记时删除来源消息。<\/li><\/ol><p> 请注意，如果没有批次结束标记，前面的解决方案将无法正确工作，因为 Teradata 在数据写入后而不是在提交后将记录发送到它的输出链接。但是，通过使用批次标记并包含 Remove Duplicates 阶段，该顺序得到了保障。 <\/p><p> 在数据库事务提交后，作业可能会失败。在这种情况下，不会执行来源消息的最终删除，该消息会保留在来源队列上。没有数据会丢失，但这种失败可能意味着如果改作业重新启动，Teradata 连接器会看到它已处理的相同数据。出于这个原因，与使用本地事务和 DTS 一样，作业设计需要是幂等的。使用正确构建的幂等性作业，如果作业因为任何原因而被中止，那么可以重新启动它，从离开的位置继续处理。 <\/p><h2 id=\"conclusion\"> 结束语 <\/h2><p> 本文介绍了一些可用来为通过 DataStage 作业将数据从来源系统传送到目标系统提供保障的方法。由于所访问的资源具有不同的性质，一种解决方案可能无法完美地应对所有情形，所以需要结合使用多种技术。确定使用何种方法的因素包括：该资源是否支持 XA 事务、事务数据的大小、延迟需求，以及可重新启动性需求。 <\/p><h2 id=\"acknowledgements\">\n            致谢 <\/h2><p> 衷心感谢同事 Tony Curcio 和 Ernie Ostic 审阅本文，并提供对完善本文大有帮助的宝贵反馈。 <\/p><CMA ID: 976484><Site ID: 10><XSLT stylesheet used to transform this file: dw-document-html-7.0.xsl>\r\n\r\n\r\n<\/div>\r\n<\/div>\r\n","createTime":"2014-07-03 00:00:00","deployTime":"2014-07-03 00:00:00","id":0,"intro":"本文将介绍如何使用 InfoSphere DataStage Distributed Transaction Stage 保障数据的传送。文中还将介绍如何使用 DataStage 数据库阶段中的本地事务。最后将介绍 Change Data Capture Transaction 阶段如何与 InfoSphere Data Replication 结合来保障更改向目标数据库的传送。","keyword":"","recommend":false,"source":"http://www.ibm.com/developerworks/cn/data/library/techarticle/dm-1310datastage/index.html","title":"使用 InfoSphere DataStage 执行有保障的传送","typeId":0,"updateTime":"2014-07-03 00:00:00"}
{"author":"","clickNumber":0,"content":"\r\n<div class=\"ibm-columns\">\r\n<div class=\"ibm-col-1-1\">\r\n\r\n<h2 id=\"major1\">背景介绍<\/h2><h3 id=\"major2\">现状和意义<\/h3><p>\n                越来越多的企业，开始关注其广域网带宽的使用状况。对广域网带宽的使用分析，不仅可以确保企业关键业务得到充分的带宽保障，而且也可以发现带宽使用中最大的威胁来自哪里。由于大部分的企业都已经部署了基于\n                SNMP 或者 Netflow\n                的网管平台，因此对企业而言，带宽当前的使用状况是了解的。然而，为了解决业务发展对带宽增长的需求，就需要及时预测未来带宽的需求状况，从而为升级带宽提供依据。<\/p><p>\n                由于广域网带宽非常昂贵，因此，当企业决定升级广域网带宽时，对升级后的带宽会有严格的要求。既要保证企业业务对带宽增长的需求，又不能升级过多，出现投资浪费的情况。<\/p><h3 id=\"major3\">问题描述<\/h3><p>\n                目前，对带宽的预测主要有以下几种方法。第一种方法，通过计算得到。该方法通过累加关键业务所占用带宽，然后乘以同时在线的概率。第二种方法，通过企业现有网管数据做简单推演。第三种方法，通过企业现有网管数据建立数学模型，从而预测未来带宽需求。<\/p><p>\n                上述前两种方法误差较大，无法满足企业升级带宽时，对准确性的要求。而本文所要讨论的，正是从企业网管数据着手建立数学模型，准确地预测未来带宽需求。<\/p><h2 id=\"major4\">带宽分析方法<\/h2><h3 id=\"major5\">数据生成方法<\/h3><p><strong>企业网管工具介绍<\/strong><\/p><p> 目前，面向大中型企业的网管产品主要是基于 SNMP 协议或者思科的 Netflow 技术。基于 SNMP\n                协议的网管产品，优势在于捕获链路的利用率，用来生成利用率基线以及捕获网络设备的性能参数，比如 CUP、MEM 等。非常著名的 Orion NPM\n                就是这类网管产品；另外一类是基于 Netflow 的网管产品。它的优势在于对 IP 地址和流量协议的分析，如 Orion\n                NTA。近年来，网管产品也出现对两种技术融合的趋势。<\/p><p><strong>实例：AT&amp;T 工具获取数据<\/strong><\/p><p> 本文所使用的网管平台，来自基于 Netflow 的网管产品 Application Traffic Analyzer，如下图 1\n                所示。生成报表时，可以定义的主要字段主要有：<\/p><p>Function：该字段用来定义报表的功能，比如，可以生成以协议、会话、目的 IP、服务分类为主要内容的报表；<\/p><p>Report Type：该字段用来定义生成报表的类型，比如图表、柱状图、饼状图等；<\/p><p>Granularity：该字段用来定义生成报表的颗粒度，比如 5 分钟、10 分钟、1 小时、1 天、1 星期等；<\/p><p>Traffic Direction：该字段定义流量的方向，是入流量还是出流量；<\/p><p>Statistic：该字段定义了统计方法，比如：求和、求平均值、求最大值、求 95% 等；<\/p><p>Scaling：该字段定义了流量单位，比如：Mbps、Megabytes、Kilobytes 等。<\/p><h5 id=\"img001\">图 1. Application Traffic\n                    Analyzer<\/h5><img alt=\"图 1. Application Traffic Analyzer\" src=\"/sunshine_new/images/负466927517/img001.png\" width=\"477\" /><p> 本文所使用的报表，以 5 分钟为采样单位，每天生成一张单独的报表。定义的主要字段如下：<\/p><p>Time range：9:00 am C 19:00 pm<\/p><p>Scaling：Mbps<\/p><p>Statistic：Sum<\/p><p>Traffic direction：inbound（由于 Inbound 流量远大于 Outbound\n                流量，所以在这里我们选取较大方向的流量）<\/p><p>Function：destinations（在这里，我们以目的地 IP 来排序所有的 inbound 流量）<\/p><h3 id=\"major6\">数据预处理<\/h3><p>\n                并不是所有的原始数据都能直接用来构建预测模型。通过对待解决的问题进行一个明确清晰的定义，来确定原始数据是否能直接支持解决方案的构建。如果不能，则需要对一些字段进行处理，生成间接数据建模。这样既可以提供足够的信息支持，也能保证预测结果是可衡量、可理解的，从而便于评估解决方案的结果。<\/p><p><strong>数据分析和定义<\/strong><\/p><p> 从 IT 部门拿到的原始数据，在预处理前首先要进行数据分析。根据解决方案的目标定义表之间的关系、表的结构（目标变量和因变量）。<\/p><p>本文中，IT 部门提供了从 2012 年 11 月到 2013 年 1 月的网络流量数据。这些数据按照每天的网络流量独立制表，半年共计 92\n                张表（EXCEL 格式），每张表格式统一。现在以 2012 年 11 月 17 日为例，介绍原始表的结构。<\/p><h5 id=\"img002\">图 2. 原始表结构<\/h5><img alt=\"图 2. 原始表结构\" src=\"/sunshine_new/images/负466927517/img002.png\" width=\"580\" /><p> 如图 2 所示：原始表的行变量是日网络流量进入前 100 名的 IP 集合，其中包括网络环境下的服务器（Server）和 PC\n                终端机器（Client）。表的列变量是每个 IP 每隔 5 分钟（时间点）记录的网络流量值。从早 9 点到晚 7 点共计 119 列。<\/p><p>本文的目标是要找到影响某企业网络总流量的因素。原始数据提供的信息有记录时间、Server 流量和 Client\n                流量。根据数据分析结果，我们定义了用于建模的终表结构，如图 3 所示。<\/p><h5 id=\"img003\">图 3. 终表结构<\/h5><img alt=\"图 3. 终表结构\" src=\"/sunshine_new/images/负466927517/img003.png\" width=\"680\" /><p> 我们定义的目标变量是网络总流量 COS_Total，因变量有记录日期 Date，前 10~70 个服务器网络流量总和从\n                Top10Server_sum 到 Top70Server_sum，前 10~70 个终端机器网络流量总和从 Top10Client_sum 到\n                Top70Client_sum。每一张原始表的信息作为终表的一个行记录存在。<\/p><p><strong>Python 编程接口，数据预处理自动化<\/strong><\/p><p> 从终表和原始表的结构可以看出，原始表的变量不能直接作为终表的变量。这就需要把每张原始表的时间点流量信息转换为日流量信息。我们认为能够满\n                95%用户网络流量需求的流量值可以作为企业当天的网络流量总和值。<\/p><p> 转换的思路是：1）每个 IP 每天的网络流量值 total_per_IP，等于升序排列该 IP 当天所有时间点网络流量值后，取第 95%的值。根据\n                total_per_IP 值选取排名前 10~70 的服务器和终端。2）每天前 10~70 个服务器/终端产生的网络总流量\n                topNClient/Server_sum，取前 10~70 个服务器/终端产生的网络流量均值。3）网络总流量值 COS_Total，等于将所有\n                IP 在每个时间点产生的网络流量总和升序排列后，取第 95%的值。定义如下：<\/p><p>total_per_IP=Percentage(Sort(Time1,Time2,Time3,…,Time119)ascending)95%<\/p><p>topNClient/Server_sum=Mean(SumTime1,SumTime2,SumTime3,…,SumTime119)<\/p><p>COS_Total=\n                Percentage(Sort(SumTime1,SumTime2,SumTime3,…,SumTime119)ascending)95%<\/p><p> 统计分析软件 IBM SPSS Statistics\n                在拥有的强大的数据处理能力的同时，也提供了丰富的编程接口（Python、R、.Net）。本文运用 Statistics 的\n                Compute、Aggregate、Transpose、OMS、Merge 等功能对原始数据进行操作并整合，最后通过编写 Python\n                脚本批处理大量数据表，实现数据预处理自动化。关于如何在 Statistics 中运行 Python 脚本，请参见 Statistics\n                产品帮助文档。<\/p><p>这里需要提到的是，原始表中的没有区分服务器和 PC 终端的 IP 地址，Python 封装的 Netaddr 包能够根据客户设定的规则对 IP\n                分类。处理过程如下图 4 所示。<\/p><h5 id=\"img004\">图 4. IP 分类脚本<\/h5><img alt=\"图 4. IP 分类脚本\" src=\"/sunshine_new/images/负466927517/img004.png\" width=\"580\" /><h2 id=\"major7\">建模及分析<\/h2><h3 id=\"major8\">线性模型的建立<\/h3><p>通过 IBM SPSS Statistics 提供的线性回归分析模块，设置界面如下图 5 所示，可以针对 3 个月的数据，寻找 COS_Total\n                与各个输入变量之间的关系。<\/p><h5 id=\"img005\">图 5. 线性回归分析<\/h5><img alt=\"图 5. 线性回归分析\" src=\"/sunshine_new/images/负466927517/img005.png\" width=\"343\" /><p> 通过表 1 和表 2 可以看出可以利用 Top40Server_sum、Top50Client_sum 建立线性模型来预测\n                COS_Total，预测准确度达到 86.2%，说明 COS_Total 与 Top40Server_sum、Top50Client_sum\n                的关系最为紧密，并可以建立线性模型的方程来预测 COS_Total。<\/p><p>COS_Total = 2.264+ 2.774 * Top40Server_sum + 2.976 * Top50Client_sum<\/p><h5 id=\"img006\">表 1. 模型概要<\/h5><img alt=\"表 1. 模型概要\" src=\"/sunshine_new/images/负466927517/img006.png\" width=\"400\" /><h5 id=\"img007\">表 2. 系数<\/h5><img alt=\"表 2. 系数\" src=\"/sunshine_new/images/负466927517/img007.png\" width=\"401\" /><h3 id=\"major9\">蒙特卡洛仿真分析<\/h3><p> 蒙特卡洛仿真分析是 IBM SPSS Statistics 21\n                版本后新增加的功能，其原理是当问题或对象本身具有概率特征时，可以用计算机模拟的方法产生抽样结果，根据抽样计算统计量或者参数的值。随着模拟次数的增多，可以通过对各次统计量或参数的估计值求平均的方法得到稳定结论，蒙特卡洛分析在金融、医药等多个行业有着广泛的应用。<\/p><p> 因为在这里只有 3 个月的网络流量数据，并且有预测 COS_Total\n                线性模型方程，因此我们可以根据三个个月数据的分布特征，用模拟功能生成大量模拟数据，并根据模拟数据分析出 COS_Total\n                的分布特征，从而对公司的合理带宽使用提供依据。<\/p><p> 在 IBM SPSS Statistics 22 中选择分析菜单下的模拟模块，打开如下图 6 界面，选择“输入方程”。<\/p><h5 id=\"img008\">图 6. 模拟模块<\/h5><img alt=\"图 6. 模拟模块\" src=\"/sunshine_new/images/负466927517/img008.png\" width=\"383\" /><p>在“方程编辑器”对话框中（图 7），将前面用来预测 COS_Total 的线性方程输入到下面的“数字表达式”中，单击“继续”按钮确认。<\/p><h5 id=\"img009\">图 7. 方程编辑器<\/h5><img alt=\"图 7. 方程编辑器\" src=\"/sunshine_new/images/负466927517/img009.png\" width=\"556\" /><p>在“模拟”页面，单击“拟合全部”按钮，Statistics 软件就会根据已有的 3 个月数据中的 Top40Server_sum 和\n                Top50Client_sum 变量自动的计算其相应的分布，可以发现 Top40Server_sum 符合 Weibull 分布，而\n                Top50Client_sum 符合正态分布。单击“运行”按钮，就会根据这个两个变量的分布和已有的线性方程，对 COS_Total\n                的概率分布进行仿真计算。<\/p><h5 id=\"img010\">图 8. 模拟构建器<\/h5><img alt=\"图 8. 模拟构建器\" src=\"/sunshine_new/images/负466927517/img010.png\" width=\"567\" /><p>蒙特卡洛仿真分析得到的 COS_Total 的概率分布如下图 9 所示。图中的横轴表示 COS_Total 的取值范围从-100M 到\n                500M，纵轴表示了在每一个 COS_Total 值上的概率密度，相应的表中分别给出了覆盖 5% 的 COS_Total 值，5%-95% 的\n                COS_Total 值和 95% 的 COS_Total 值。因此说明，公司采购带宽如果设定为 332.95M 时，可以满足\n                95% 的情况下的使用，如果采购带宽设定为 54.52%，则只能满足 5% 的情况使用。<\/p><h5 id=\"img011\">图 9. 概率密度<\/h5><img alt=\"图 9. 概率密度\" src=\"/sunshine_new/images/负466927517/img011.png\" width=\"447\" /><h2 id=\"major10\">业务决策<\/h2><h3 id=\"major11\">企业带宽现状评估<\/h3><h5 id=\"img012\">图 10. 网管报告<\/h5><img alt=\"图 10. 网管报告\" src=\"/sunshine_new/images/负466927517/img012.png\" width=\"303\" /><p> 从上述网管报告（图 10）可以看到，企业带宽的实际使用情况已用不同颜色区分。绿色表示链路占用率小于\n                50%，说明链路处于健康状态。黄色表示链路占用率处于\n                50%-70%，当处于这种状态时，说明网络处于拥塞状态，丢包时有发生，需要做带宽的升级准备了。红色表示链路占用率大于\n                70%，当处于这种状态时，业务性能会严重下降，无法保障业务的正常使用。我们可以得出结论，企业需要尽快升级带宽了。那么，升级到多少合适呢？<\/p><h3 id=\"major12\">企业带宽升级决策<\/h3><p> 根据我们前面预测分析的结果，在 95%的情况下，企业带宽位于 332.95Mbps\n                以内，这和网管报告中的带宽实际使用情况是一致的。合理的带宽升级方式，是既要保证良好的用户体验（带宽使用率&lt;70%），又能够尽量节省成本。因此我们建议带宽升级的升级范围是\n                475.6Mbps（332.95/0.7）~665.9Mbps（332.95/0.5）。将带宽升级到 475.6Mbps\n                是一个合理的方案，它可以满足企业绝大多数情况下对网络的使用要求（绿色），即使全网资源被占用也不会出现性能严重下降（红色）的问题。当然，如果企业对网络性能要求很高并且愿意投入成本，选择升级到\n                665.9Mbps 后，企业的网络处于会长期处于健康状态（绿色），从而对关键业务性能有更可靠的保证。<\/p><h2 id=\"major13\">结束语<\/h2><p> 本文通过 IBM SPSS Statistics 中的 Python 编程模块对原始 AT&amp;T\n                网络数据进行预处理，然后结合线性模型和蒙特卡洛仿真分析，可以在原始少量数据的基础上大量仿真模拟企业的真实网络带宽使用情况，从而为企业的带宽升级决策提供量化的结果，为企业\n                IT 决策部门提供分析智慧的洞察能力。<\/p><CMA ID: 976114><Site ID: 10><XSLT stylesheet used to transform this file: dw-document-html-7.0.xsl>\r\n\r\n\r\n<\/div>\r\n<\/div>\r\n","createTime":"2014-07-03 00:00:00","deployTime":"2014-07-03 00:00:00","id":0,"intro":"本文为读者提供了一种 IT 部门网络带宽分析方法。使读者能借助统计分析软件 IBM SPSS Statistics 提供的 python 编程接口, 线性模型和蒙特卡洛仿真分析方法，评估企业带宽使用现状并为企业的带宽升级决策提供量化的结果，从而为企业 IT 决策部门提供分析洞察能力。","keyword":"","recommend":false,"source":"http://www.ibm.com/developerworks/cn/data/library/bd-1407-spss-statistics-insightsbroadband/index.html","title":"IBM SPSS Statistics 仿真分析获得洞察--为企业 IT 部门评估合理的带宽宽度","typeId":0,"updateTime":"2014-07-03 00:00:00"}
{"author":"","clickNumber":0,"content":"\r\n<div class=\"ibm-columns\">\r\n<div class=\"ibm-col-1-1\">\r\n\r\n<p> 我们如何使用不同场景中的不同安全测试概念，将平台即服务 (PaaS)\n                用作一个漏洞测试平台。在本文中，我将介绍如何评估、集成和定义任何安全测试概念，然后通过将概念与场景建立链接来进一步解释这些概念。<\/p><p>但开始了解难懂的概念之前，让我们看看一种<em>用户 PaaS 模型结构<\/em>，以熟悉这一主题。 <\/p><h2 id=\"N1003E\">用户 PaaS 模型结构<\/h2><p> 用户 PaaS 模型结构分为 3 种类型： <\/p><ul class=\"ibm-bullet-list\"><li><em>应用程序开发生命周期<\/em> 流程跟踪 PaaS 上的应用程序，从需求到设计、编码和安全测试，再到部署阶段。<\/li><li><em>风险管理生命周期<\/em>\n                    跟踪缓解风险的过程，从识别资产到实施富有成本效益的保护措施。风险是威胁作用物将利用一个或多个漏洞的可能性。<\/li><li><em>业务流程生命周期<\/em> 允许开发人员在每个 PaaS\n                    阶段控制和保护应用程序。开发人员在此周期中会使用电子表格、文字处理器、结算和其他业务工具。 <\/li><\/ul><p> 我们简单看看，这些生命周期如何在安全测试中彼此关联： <\/p><ul class=\"ibm-bullet-list\"><li>在风险管理生命周期中，PaaS 测试人员识别应用程序开发风险，然后创建基于风险的安全测试方法。<\/li><li>在应用程序开发生命周期中，测试人员应用该基于风险的方法。<\/li><li>在业务流程生命周期中，测试人员使用电子表格和文档来记录基于风险的安全测试的结果，包括漏洞评估。<\/li><\/ul><p>下面我们看看一种通用的安全测试模型。 <\/p><h2 id=\"N1005D\">安全测试模型<\/h2><p> 识别最脆弱的链接，执行渗透测试，以及依赖于标准和框架，都不足以发现和检测这 3 种类型的安全问题： <\/p><ul class=\"ibm-bullet-list\"><li>PaaS 应用程序设计级别上的安全缺陷<\/li><li>PaaS 应用程序实现级别上的安全漏洞 <\/li><li>PaaS 平台级别上的资源短缺<\/li><\/ul><p> 更好的解决方案将是，以 PaaS 作为漏洞测试平台来建立一个安全测试模型。该模型包含以下阶段：<\/p><ul class=\"ibm-bullet-list\"><li>发现阶段<\/li><li>自动化的漏洞扫描<\/li><li>漏洞评估流程<\/li><li>安全评估流程<\/li><li>渗透测试<\/li><li>安全审核<\/li><li>安全评审<\/li><\/ul><p><em>发现阶段<\/em>\n                是安全测试模型的基础；它是各连续阶段的构建基块。通过使用此模型，可发现并分析任何阶段中的缺口，然后再进入下一个阶段。此流程会反复执行，直至到达安全评审阶段。<\/p><p>如果测试人员在任何阶段中找到安全测试问题，她可返回到一个早期阶段，使用新信息重复测试过程，然后再进入下一个阶段。<\/p><p>测试人员应对她应返回到任何以前阶段的次数设置自己的上限。她应记录每个阶段中新的或改进的安全测试的结果，直至达到上限。<\/p><p>下面我们看看每个阶段，结合场景对它们进行分析。 <\/p><h2 id=\"N10086\">发现阶段：SaaS 升级<\/h2><p>将 PaaS 用作漏洞测试平台时，发现阶段是安全测试中的第一个阶段。 <\/p><h3 id=\"N1008D\">工作原理<\/h3><p> 您首先识别要在 PaaS 上开发和测试哪些应用程序。然后尝试检测或发现应用程序的潜在漏洞，比如： <\/p><ul class=\"ibm-bullet-list\"><li>应用程序中的逻辑缺陷<\/li><li>对用户查询的缓慢响应<\/li><li>数据库连接的不当配置<\/li><\/ul><p> 您常常会在文档（包括代码和日志）中找到此信息。 <\/p><h3 id=\"N1009C\">问题场景<\/h3><p> 您发现一个在内部良好运行的应用程序，无法作为软件即服务 (SaaS)\n                应用程序很好地运行。在云中运行该应用程序时，它的攻击注入漏洞（由对无效数据的处理导致）就会显现出来。 <\/p><h3 id=\"N100A2\">解决方案场景<\/h3><p> 对该内部部署应用程序中的代码进行评审，然后在 PaaS 测试环境中执行模拟的攻击注入。 <\/p><h2 id=\"N100A8\">自动化的漏洞扫描：IaaS 升级<\/h2><p> 经过发现阶段之后，使用一个（或多个）自动化漏洞扫描工具来匹配各种条件与已知漏洞，查找已知的安全问题。 <\/p><h3 id=\"N100AF\">工作原理<\/h3><p>\n                这种类型的工具自动设置风险级别，无需人为干预来验证或解释各个级别。该工具可以辅以基于凭据的扫描，使用提供的凭据来向一个本地帐户服务进行身份验证，帮助消除一些常见的误报。 <\/p><h3 id=\"N100B5\">问题场景<\/h3><p> PaaS 运行所在的基础架构即服务 (IaaS) 经过升级，增添了可能带有隐藏漏洞的虚拟机。<\/p><p>在虚拟化的环境中，可创建使用防火墙、路由器、交换机和 IPS 设备启用的隔离和安全区。麻烦在于，虚拟机 (VM) 在 IaaS\n                内游荡，可能很难让系统的安全规则不断跟踪这些机器。 <\/p><h3 id=\"N100BD\">解决方案场景<\/h3><p> 获取安全策略管理工具，确定控制 VM 管理的流程已就绪。这可以保证，更改 VM 的位置会触发将需要的安全功能复制到新位置的过程。<\/p><p>寻找虚拟化感知的解决方案。<em>虚拟化感知<\/em> 或<em> VM 感知<\/em> 的系统和网络组件可识别\n                VM，使用正确且不断改变的策略帮助您的集中管理控制台工具跟踪、监视和更新这些 VM。这进而帮助您管理网络安全策略，通过 VMM/Hypervisor\n                加强可视化和可控化。 <\/p><h2 id=\"N100CB\">漏洞评估流程：多个主机漏洞<\/h2><p> 漏洞评估流程阶段基于发现流程和漏洞扫描阶段，用于识别安全漏洞。 <\/p><h3 id=\"N100D2\">工作原理<\/h3><p> 漏洞评估流程将发现的安全漏洞放入所测试的 PaaS 环境中。例如，从报告中消除常见的误报，确定应该应用到每个报告发现结果的风险级别。 <\/p><h3 id=\"N100D8\">问题场景<\/h3><p> PaaS 开发人员的云资源优化应用程序导致了报告中的误报，报告显示用户已成功访问 PaaS，而事实上应用程序出现故障。这一故障导致 PaaS\n                平台完全关闭。该应用程序没有识别出故障或实现较短的超时。这对确定服务水平协议 (SLA) 可用性保证所需的性能数据产生了负面影响。<\/p><p>PaaS\n                开发人员没有构建包含单台主机的简单服务；这台主机允许她创建可幸免于主机故障的复制的服务实例。相反，她构建了包含多台相互依赖的主机的服务，她发现这些服务无法在主机故障中幸免遇难。<\/p><p>我们看看开发人员如何构建包含多台相互依赖的主机的服务。如果开发人员有一个包含业务逻辑组件（A、B 和\n                C）的结算应用程序，她可以创建一个像这样的服务组：<\/p><p>In (A1, B1, C1)、(A2, B2, C2)、(An, Bn, Cn)，其中 <em>n<\/em> 是表示服务组类别编号的组件类型编号： <\/p><ul class=\"ibm-bullet-list\"><li>对于服务类别 1： \n<ul class=\"ibm-bullet-list\"><li>A1 是查找服务编码的逻辑。<\/li><li>B1 是将服务类别插入账单中的逻辑。<\/li><li>C1 是检查 ZIP 编码准确性的逻辑。<\/li><\/ul><\/li><li>对于服务类别 2： \n<ul class=\"ibm-bullet-list\"><li>A2 是查找服务编码的逻辑。<\/li><li>B2 是将服务类别插入账单中的逻辑。<\/li><li>C2 是检查 ZIP 编码准确性的逻辑。<\/li><\/ul><\/li><li>对于服务类别 n： \n<ul class=\"ibm-bullet-list\"><li>An 是查找服务编码的逻辑。<\/li><li>Bn 是将服务类别插入账单中的逻辑。<\/li><li>Cn 是检查 ZIP 编码准确性的逻辑。<\/li><\/ul><\/li><\/ul><p> 由于较长的超时，用户在系统出现健康问题时能够访问系统。 <\/p><h3 id=\"N10105\">解决方案场景<\/h3><p> 为了修复该问题，使系统不会发生故障，开发人员将这些组件分解为独立的池，比如：(A1, A2,...An )、(B1, B2...Bn )、(C1,\n                C2, ...Cn)。<\/p><p>这使她能够在健康的数据中心中创建多个冗余的服务副本。这意味着，如果组件 A1 发生故障或变慢，同一个独立的池中从 A2 到 An\n                的所有其他组件不会发生故障。类似地，第二个独立的组件池 (B1-Bn) 和第三个组件池 (C1-Cn) 不会发生故障。<\/p><p>因此用户能够访问健康的系统。在漏洞评估过程的结果报告中不会出现误报。 <\/p><h2 id=\"N1010F\">安全评估流程：阈值级注入漏洞<\/h2><p> 安全评估流程基于漏洞评估流程，它添加了手动验证来确认可能在生产阶段中发生的风险暴露级别。 <\/p><h3 id=\"N10116\">工作原理<\/h3><p>\n                安全评估流程不包含利用漏洞来获取进一步的访问权。它可以通过对系统的授权访问形式来确认系统设置，涉及检查日志、系统响应、错误消息、代码和数值分析验证。<\/p><p>安全评估拓宽了被测试系统的范围。它未涵盖一个特定的漏洞可能导致的风险暴露深度。 <\/p><h3 id=\"N1011E\">问题场景<\/h3><p>\n                当假期购物季来临时，系统检测到更高的工作负载需求。作为响应，系统快速创建了更多资源实例来动态平衡工作负载需求。这需要更多用户和更多的数据请求来访问系统。<\/p><p>由于阈值级的注入，不需要的资源从未被释放，最终导致系统崩溃。访问系统来手动确认生产阶段中可能发生的风险暴露级别，从未完成过。 <\/p><h3 id=\"N10126\">解决方案场景<\/h3><p>\n                手动检查日志、系统响应、错误消息和代码，验证对系统的访问是否获得授权。手动验证是否存在阈值策略，列出云计算服务使用者和提供者在制定以下策略的过程中应执行的操作： <\/p><ul class=\"ibm-bullet-list\"><li>资源阈值策略，用于确保动态平衡了应用程序在云中的使用，控制在该阈值水平或之下。<\/li><li>用户阈值策略，用于确保用户能够并发地访问应用程序，并发量最高上限为提供商的用户许可规定的限制数，控制在阈值水平或之下。<\/li><li>数据请求阈值策略，用于确保对应用程序的数据请求可立即得到处理，控制在该阈值水平或之下。<\/li><\/ul><h2 id=\"N10133\">渗透测试：LDAP/AD 注入漏洞<\/h2><p> 渗透测试模拟遭受攻击的 PaaS。它基于以前的阶段，测试利用发现的漏洞来获取 PaaS 和 IaaS 的进一步访问权的过程。 <\/p><h3 id=\"N1013A\">工作原理<\/h3><p> 渗透测试对攻击者获取机密信息、影响数据完整性或服务可用性以及对 PaaS 带来各种影响的能力进行测试。<\/p><p>每项测试还会比较测试人员的问题解决能力，即采用众多渗透测试工具来查找自动化工具无法识别的漏洞的能力。渗透测试还会测试防御者检测攻击并做出适当响应的能力。<\/p><p>依据 NIST SP 800-115（<a href=\"#resources\">参考资料<\/a>），渗透测试利用的大部分漏洞包括： <\/p><ul class=\"ibm-bullet-list\"><li>错误配置<\/li><li>缓冲区溢出<\/li><li>错误的输入验证<\/li><li>争用条件<\/li><li>错误的文件和目录权限<\/li><\/ul><p> 渗透测试人员应能够确定何时停止渗透，避免进一步操作损害 PaaS 和底层系统。它可能导致系统失去可用性或暴露敏感数据。 <\/p><h3 id=\"N10155\">问题场景<\/h3><p> LDAP/AD 注入漏洞被利用，会导致系统崩溃。攻击者利用应用程序的故障来让在 LDAP 中具有特殊含义的字符失效。<\/p><p>LDAP 注入非常类似于 SQL 注入，会在使用未在应用程序中验证的用户提供的数据构造 LDAP\n                语句时发生。这会导致执行任意命令，比如为未授权的查询授予权限和修改 LDAP 树中的内容。<\/p><h3 id=\"N1015D\">解决方案场景<\/h3><p> 探索使用一流的外部渗透测试工具来测试 LDAP 和 SQL 注入漏洞。该工具应涵盖其他类型的安全漏洞，比如跨站点脚本攻击\n                (XSS)、不当的身份验证协议，以及不当的数据库连接配置。寻找好的内部渗透测试工具，测试 LDAP 和安全策略是否足以防御 LDAP/AD\n                注入的意外引入。<\/p><p>另外，寻找不错的无线站点渗透测试工具，测试<em>驾驶攻击 (wardriving)<\/em>（在移动的车辆中搜索脆弱的 WiFi\n                网络）和中间人攻击。确保无线安全协议足够安全，接入点和客户端（移动设备、笔记本电脑）得到正确配置。可使用适当的配置来预防仿冒行为异常的笔记本电脑，尝试拦截可用于注入\n                LDAP/AD 恶意软件的客户端接入点通信。使用您的移动笔记本电脑或固定的台式机来发现属于您的不安全的无线网络。 <\/p><h2 id=\"N10168\"> 安全审核流程：阈值不一致性<\/h2><p> 安全审核是对公司的信息系统安全性的一种系统性评估，度量它对一组既定的性能标准的遵守程度。 <\/p><h3 id=\"N1016F\">工作原理<\/h3><p>\n                安全审核常常用于确定信息系统对法律制度、行业标准和安全策略的遵守程度。安全审核使用我们介绍的早期的安全工具方法，评估信息系统、信息处理流程（机密或非机密）和用户实践的安全性。 <\/p><h3 id=\"N10175\">问题场景<\/h3><p> 审核揭示，尽管早期的安全工具方法已更正了问题，但还没有合适的阈值水平。审核发现，阈值水平未设置时，开发人员无法知道： <\/p><ul class=\"ibm-bullet-list\"><li>资源是否被过度使用。<\/li><li>尝试访问 PaaS 的开发人员数量是否达到了用户许可中指定的限制。<\/li><li>开发人员发送的数据请求是否超出了阈值水平。<\/li><\/ul><h3 id=\"N10182\">解决方案场景<\/h3><p> 审核人员应推荐开发人员在制定以下策略的过程中应执行的操作： <\/p><ul class=\"ibm-bullet-list\"><li>资源阈值策略，用于确保动态平衡了应用程序在云中的资源使用情况，控制在该阈值水平或之下。<\/li><li>用户阈值策略，用于确保用户能够并发地访问应用程序，并发量最高上限为提供商的用户许可规定的限制数，控制在阈值水平或之下。<\/li><li>数据请求阈值策略，用于确保对应用程序的数据请求可立即得到处理，控制在该阈值水平或之下。<\/li><\/ul><p>\n                阈值策略应解决数值分析漏洞以及如何处理它们。简言之，如果截断和舍入错误超出了可接受的界限，获取的指标将失去意义。在开发可解决适定性问题的数值稳定的算法上，PaaS\n                开发人员拥有的经验很可能比提供商更多。这将确保阈值策略将在您到达安全评审阶段之前建立。 <\/p><h2 id=\"N10191\">安全评审流程：合规性验证<\/h2><p> 安全评审涉及到验证行业或内部安全策略是否已应用到系统组件或产品上的流程。 <\/p><h3 id=\"N10198\">工作原理<\/h3><p> 安全评审通常通过差距分析或代码评审来完成，或者通过评审设计文档和架构图来完成。它不使用其他安全工具方法（漏洞评估、安全评估、渗透测试或安全审核）。 <\/p><h3 id=\"N1019E\">问题场景<\/h3><p> 在安全评审过程中，一个组织部门没有完全遵守信息安全测试和评估技术指南上的 NIST Special Publication 800-115\n                的一些方面。 <\/p><h3 id=\"N101A4\">解决方案场景<\/h3><p> 审阅文档以确定策略和规程的技术和安全方面是否最新，审查日志以确保安全控件记录了 PaaS\n                使用信息，以及组织是否遵守其日志管理策略。日志信息示例包括： <\/p><ul class=\"ibm-bullet-list\"><li>有关成功和失败的身份验证尝试的身份验证服务器或系统日志<\/li><li>有关恶意活动和不当使用的入侵检测和防御系统日志<\/li><li>记录已知脆弱服务和应用程序的信息的安全日志<\/li><li>记录用户阈值、数据请求和资源阈值的水平的阈值日志<\/li><\/ul><p> 自动审核工具应该可以减少大多数日志类型的评审时间。 <\/p><h2 id=\"N101B5\">结束语<\/h2><p>\n                在计划执行安全测试的过程中，请考虑解决该模型各个阶段的安全测试问题的最佳实践。在进入下一个阶段之前，您需要对可返回到前一个阶段来解决测试问题的次数设置限制。组建一个包含开发人员、管理人员和业务分析师的团队，让他们能更轻松地完成在生命周期的每个阶段执行安全测试的工作。<\/p><CMA ID: 976104><Site ID: 10><XSLT stylesheet used to transform this file: dw-document-html-7.0.xsl>\r\n\r\n\r\n<\/div>\r\n<\/div>\r\n","createTime":"2014-07-03 00:00:00","deployTime":"2014-07-03 00:00:00","id":0,"intro":"在不同场景中评估、集成和定义各种安全测试概念。探索一个示例用户 PaaS 测试环境结构，它是安全测试模型的基础。","keyword":"","recommend":false,"source":"http://www.ibm.com/developerworks/cn/cloud/library/cl-paas-testing/index.html","title":"将 PaaS 作为漏洞测试平台","typeId":0,"updateTime":"2014-07-03 00:00:00"}
{"author":"","clickNumber":0,"content":"\r\n<div class=\"ibm-columns\">\r\n<div class=\"ibm-col-1-1\">\r\n\r\n<h2 id=\"1.问题描述 |outline\">问题描述<\/h2><p>随着 Web2.0 技术的发展，大家对于网站功能和易使用性的要求越来越高，网站的制作也越来越复杂。JavaScript 是基于 Web 的用户界面开发必不可少的脚本语言，为 Web 界面开发提供了很多便利。伴随着 Web 用户界面的受重视程度提升，对 JavaScript 代码的测试要求也越来越高，例如，针对不同的浏览器进行单元测试，并且希望更进一步得到这些测试代码覆盖率以便判断测试是否足够。可惜的是，相对于 Java 领域各种强大的单元测试工具，在 JavaScript 领域这方面的研究才起步不久，目前业界虽然有一些工具可以帮助进行 JavaScript 单元测试，也有工具可以做到代码覆盖率的统计，但是还处于各自为政状态。要把他们整合到一起协同工作并不容易。本文先就 JavaScript 单元测试和覆盖率做一简单介绍，然后用一个例子重点展现怎样整合这些工具达到强大的测试功能。<\/p><h2 id=\"2.用户界面的自动化测试和单元测试 |outline\">用户界面的自动化测试和单元测试<\/h2><p>一个网站的用户界面是非常易于变化的，当我们对于用户界面进行改动后，同样也需要有足够的测试来保证这个改动符合我们的预期，在理想状态下，开发人员在提交代码之前就能够进行这种测试并及时得到反馈，如果测试没有通过就不能提交代码。改正发现的问题后继续测试，并最终通过和提交。<\/p><p>然而即使在今天大多数的网站仍然是通过手工测试来保证用户界面的正确性，手工测试会占用到大量的人力物力，成本很高。而且手工测试花费的时间也多，很难在开发人员提交代码前给予及时的测试反馈，导致开发人员在没有足够测试的支持下提交代码，并造成潜在的代码质量问题。因此，我们需要自动化测试来保证代码的质量。<\/p><p>除了自动化之外，我们还需要单元测试，因为前端开发工程师要保证用户界面的正确性，但是如果进行传统的端到端测试，测试结果很大程度上会依赖于后端的运行结果。比如后端的一个错误会影响到前端界面不能按照预期来显示。所以在测试的时候需要把后端给替换成 mock，在测试用例中模拟后端的行为。<\/p><p>然而，对用户界面进行单元测试的难度，相对于其他模块的单元测试来说也更高。这通常是因为用户界面的代码总是和整个环境以及其他模块紧密相关，很难将它分离做单独的测试。好在大部分 JavaScript 开发框架都能够对于网站的用户界面和其背后的业务逻辑进行一定程度的解耦，另外还有很多测试工具在单元测试上提供支持。主流的 JavaScript 测试工具，如 DOH，QUnit，JSTestDriver，JSUnit 等，都提供了单元测试的可能性。<\/p><p>值得一提的是，虽然名义上使用哪个测试工具对于你使用哪个开发框架没有严格的依赖，但是部分测试工具是某些开发框架的扩展，它对于该框架有着天然的支持。比如 Qunit 之于 jQuery，以及 DOH 之于 Dojo。因此如果使用了 jQuery 或者 Dojo 开发用户界面，应该首选与之对应的 Qunit 或 DOH 来进行测试。<\/p><h2 id=\"3.测试 JavaScript 代码覆盖率 |outline\">测试 JavaScript 代码覆盖率<\/h2><ol type=\"1\"><li>有了自动化单元测试还不够，获取和分析代码覆盖率是确保测试质量的重要手段。代码覆盖率描述的是代码被测试的比例和程度。简单地说，光是编写用例来测试代码，而不检查究竟哪些代码被测试过，哪些还没有测试过，很容易形成测试的漏洞。代码覆盖率是一种白盒测试方法，因为它需要对代码本身进行理解和分析。通过测试代码覆盖率可以得知哪些代码未被覆盖，从而进一步补足测试用例。<\/li><li/><li>对于 Java 编写的代码，我们已经有很成熟的覆盖率测试方案，例如开源工具库 EMMA 和 JoCoCo.然而对于 JavaScript 代码来说,无论是工具的成熟度还是人们对代码覆盖率的关注程度,都远不如 Java。这更需要我们对现有工具进行组合和定制。<\/li><\/ol><p>目前业界主要的代码覆盖率工具是 JSCoverage，以及其后续版本 JSCover。另外一些新兴测试框架也逐渐加入了对于覆盖率的支持，比如 Intern。<\/p><h2 id=\"4.协同工作：在 DOH 单元测试中使用 JScoverage 计算代码覆盖率 |outline\">协同工作：在 DOH 单元测试中使用 JScoverage 计算代码覆盖率<\/h2><p>对于以上提到的每一种开发框架和测试工具，网上都能找到很多实例来教你怎样使用它们。但是要在一个大型工程中把它们整合到一起来发挥最大功用却并不那么容易。需要不断的尝试和总结，下面我们就使用我们项目中的一个例子，来展示怎样使他们更好的协同工作。我们的方法可能不是唯一的方法，但是是经过项目实践行之有效的最佳实践。<\/p><p>在我们的项目中，我们大量使用了 Dojo 工具库来开发我们的前端代码，因此我们使用 Dojo 的自带测试框架 DOH 来进行自动化单元测试，但是 DOH 并不能提供测试覆盖率的支持，于是我们借助 JSCoverage 来帮助我们计算覆盖率。<\/p><ol type=\"1\"><li>确定要测试的 JavaScript 代码并整理到独立的文件夹中\n<p>为了使代码整洁和可测试性，我们需要尽可能把 JavaScript 文件与 html 文件分开，做成单独的 JavaScript 文件，写在 HTML 中间的 JavaScript 代码是没法进行覆盖率分析的。另外为了后续工作的方便，尽量把需要测试的 JavaScript 代码放在一个独立的文件夹下面。<\/p><p>在我们的项目中，我们把要测试的 JavaScript 代码放在了 iaas 目录之下。<\/p><\/li><li>编写 DOH 测试代码\n<p>在明确了需要测试的 JavaScript 代码后，就可以开始针对他们编写 DOH 测试代码了。同样，这些测试代码也放到一个目录下便于管理。一般来说我们会针对每一个 JavaScript 文件或者模块编写一个测试文件，然后使用一个单独文件作为测试入口来加载所有的测试用例。<\/p><p>在我们的项目中，所有的 DOH 测试代码放到 iaas/doh 的目录之下，然后在这个目录下建立 iaasDOHTest.js 文件作为入口，并在这个文件中加载其他所有测试用例，见清单 1<\/p><h5 id=\"N100A4\">清单 1. iaasDOHTest.js 代码<\/h5><div class=\"codesection\"><pre class=\"displaycode\">require(dojoConfig,[\n\t\"iaas/doh/wizard/Wizard\",\n\n\t//iaas/util  util 模块的测试用例\n\t\"iaas/doh/util/image\",\n\t\"iaas/doh/util/instance\",\n\t\"iaas/doh/util/key\",\n\t\n\t//iaas/singleton   singleton 模块的测试用例\n\t\"iaas/doh/singleton/imageListStore\",\n\t\"iaas/doh/singleton/instanceListStore\",\n\t\"iaas/doh/singleton/keyListStore\"\n]);<\/pre><\/div><p>这时，我们就能通过在浏览器输入以下地址直接运行这个 DOH 测试并察看测试结果了。<\/p><div class=\"codesection\"><pre class=\"displaycode\">https://localhost/framework/doh/runnerCoverage.html?test=iaas/doh/iaasDOHTest<\/pre><\/div><p>由于本文的重点在于整合使用测试工具的最佳实践，对于如何编写 DOH 测试本身并不作展开介绍，读者可以通过登陆参考文献中的 DOH 官网来学习这部分知识。<\/p><\/li><li><code>使用<\/code> JSCoverage <code>来生成测试代码<\/code><p>JSCoverage 是现有的 JavaScript 代码的覆盖率测试工具之一，其原理是先对待分析的 JavaScript 代码进行注入修改，生成新的代码，让其有能力对执行过的代码进行记录，然后在测试的时候运行新的代码。新代码在语义上完全包含了老的代码，从而保证测试的正确性，又能通过代码执行的记录算出覆盖率。<\/p><p>首先我们要安装 JSCoverage 软件，在我们项目中把该软件装到了/jscoverage 目录下，这个目录和 iaas 目录同级。<\/p><p>然后我们就要进行代码的注入修改了，JSCoverage 软件有几种使用方式，如服务器模式，代理模式和文件模式等。在我们的实例中，我们选用文件模式，因为我们觉得这种模式最为灵活，可以和 DOH 集成更好。以文件模式使用 JSCoverage 时，在 jscoverage 的目录下按照清单 2 执行命令<\/p><h5 id=\"N100BF\">清单 2. 案例中使用 jscoverage 的命令<\/h5><div class=\"codesection\"><pre class=\"displaycode\">sudo ./jscoverage --encoding=UTF-8 --no-instrument= doh ./iaas ./instrumented<\/pre><\/div><p>在这行代码中，jscoverage 是一个可执行命令，紧跟其后的是我们在命令中用到的两个可选参数：<\/p><ul class=\"ibm-bullet-list\"><li>--encoding 选项: 制定编码方式，若不指定，默认为 ISO-8859-1。我们的 JavaScript 文件编码方式为 utf-8，所以这里也要改为 utf-8<\/li><\/ul><ul class=\"ibm-bullet-list\"><li>--no-instrument 选项：不分析位于指定文件夹下的 JavaScript 文件。有时候在我们的 JavaScript 源代码中也有些不需要进行覆盖率统计的文件，比如第三方编写的代码库。在上述示例中，我们并不对 doh 目录下的文件进行注入，因为我们需要的是待测文件的覆盖率，而不是测试文件本身的覆盖率。<\/li><\/ul><p>之后两个参数是命令的必须参数：<\/p><ul class=\"ibm-bullet-list\"><li>代码源目录：待测试代码的目录，JSCoverage 会读取这个目录下的文件进行注入分析。<\/li><\/ul><ul class=\"ibm-bullet-list\"><li>目标目录：JSCoverage 生成新的代码后会放到这个目录之中，在统计覆盖率的时候需要运行这个目录下的代码，另外，覆盖率分析结果报表也会放在这个目录之中。<\/li><\/ul><p>在我们的例子中，JSCoverage 将分析 iaas 这个目录下的文件，进行注入后把生成的文件放到 instrumented 目录下面。<\/p><p><code>这时，如果我们运行<\/code> instrumented <code>目录下面的代码，<\/code>JSCoverage<code>\n就会进行代码覆盖率的统计了，生成的结果会放在 <\/code>instrumented<code> 目录下面的 <\/code>jscoverage.html<code>\n文件中，可以使用浏览器直接打开这个 <\/code>HTML<code> 文件，就能看到覆盖率分析结果了。<\/code><\/p><\/li><li>定制 DOH 的 runner.html 文件，以同时进行 DOH 的测试和统计代码覆盖率。\n<p>接下来我们就要使 DOH 能够运行到生成的新的代码，而不是原来的代码了。同时，我们也希望 DOH 可以直接连到测试的覆盖率结果页面。<\/p><p>按照清单 3 所示，定制 DOH 的 runner.html 文件，增加访问 JSCoverage 结果的按钮，引用 JSCoverage 的测试结果。<\/p><h5 id=\"N100F1\">清单 3. 案例中增加按钮访问 JSCoverage 结果<\/h5><div class=\"codesection\"><pre class=\"displaycode\">&lt;button style=\"margin-top: 5px; float: left;\" \nonclick=\"window.open('../../contributions/iaas/1.0/shared/instrumented/jscoverage.html');\"&gt;\nCoverage Report&lt;/button&gt;<\/pre><\/div><p>为了避免把原来的 DOH 自带文件覆盖，将新定制过的 runner.html 文件改名，比如 runnerCoverage.html，放到 DOH 的 runner.html 相同的目录。<\/p><p>在选择执行代码的问题上，DOH 可以通过在 url 后面通过 path 参数，来指定模块的加载路径，因此，现在执行单元测试并且计算代码覆盖的 url 是<\/p><div class=\"codesection\"><pre class=\"displaycode\">https://localhost/framework/doh/runnerCoverage.html?test=iaas/doh/iaasDOHTest&amp;\npaths=iaas,../../instrumented<\/pre><\/div><p>可以看到 DOH 把 iaas 模块映射到了 instrumented 目录，这样实际测试的就是经过注入的代码了。访问该 url 后，运行结果如图 1 所示：<\/p><h5 id=\"N10101\">图 1. DOH 运行结果<\/h5><img alt=\"DOH 运行结果\" src=\"/sunshine_new/images/174405026/image003.png\" width=\"509\" /><p>点击 Coverage Result，我们可以看到如下代码覆盖率统计结果，如图 2 所示<\/p><h5 id=\"N1010F\">图 2 代码覆盖率统计结果<\/h5><img alt=\"图 2 代码覆盖率统计结果\" src=\"/sunshine_new/images/174405026/image005.png\" width=\"566\" /><p>需要注意的是，注入后的代码要计算覆盖率，比原始代码要大得多，运行时在性能上会有损失，执行速度大致是原来的一半。因此这种方法主要是为了得到单元测试的覆盖率。有时候我们也会需要性能测试，了解执行这些测试所需要的时间，这个时候就要用原来的代码了。<\/p><p>如果还是要运行原始的 DOH 测试，可以通过如下的链接进行访问：<\/p><div class=\"codesection\"><pre class=\"displaycode\">https://localhost/framework/doh/runner.html?test=iaas/doh/iaasDOHTest&amp;paths=iaas,../../iaas<\/pre><\/div><p>注意这两个链接的两个不同之处，一个是 DOH 的主文件，我们仍然使用 runner.html。另外就是参数 path，仍然指向原始的文件 iaas 目录。上面两个链接可以同时工作，也便于测试时的自由选用。<\/p><\/li><\/ol><h2 id=\"5.结论 |outline\">结论<\/h2><p>综上所述， 在大型网站开发中，往往需要对于用户界面做自动化单元测试，并计算代码覆盖率。DOH 单元测试框架作为 Dojo 工具库的单元测试工具，是测试 Dojo 最好的工具，JSCoverage 是一款计算覆盖率的利器。在我们的实例中，我们运用 DOH 定制 JavaScript 的测试，并组合使用了 JSCoverage，能够同时获得 DOH 测试结果和代码覆盖率，提高了测试的效率和准确性。<\/p><CMA ID: 976001><Site ID: 10><XSLT stylesheet used to transform this file: dw-document-html-7.0.xsl>\r\n\r\n\r\n<\/div>\r\n<\/div>\r\n","createTime":"2014-07-03 00:00:00","deployTime":"2014-07-03 00:00:00","id":0,"intro":"在很多情况下我们需要自动化用户界面的单元测试，以提高代码的准确性和测试的效率。现今对 Java 代码的自动化测试和单元测试已经非常成熟，然而用户界面经常使用 JavaScript 而不是 Java 来开发。能够对 JavaScript 进行自动化单元测试，并能计算代码覆盖率的工具并不成熟。本文先简单介绍 JavaScript 测试的一些工具，然后重点实例展示在项目中整合使用 Dojo+DOH+Jscoverage 的一个最佳实践。","keyword":"","recommend":false,"source":"http://www.ibm.com/developerworks/cn/web/1406_niugang_webtest/index.html","title":"Web 页面自动化测试及代码覆盖率分析","typeId":0,"updateTime":"2014-07-03 00:00:00"}
{"author":"","clickNumber":0,"content":"\r\n<div class=\"ibm-columns\">\r\n<div class=\"ibm-col-1-1\">\r\n\r\n<a id=\"OLE_LINK17\"><\/a><h2 id=\"1.背景介绍 |outline\">背景介绍<\/h2><p>前面文章具体介绍了如何使用 Base Clear Case、UCM Clear Case 和 RTC、CQ 等 Rationa CLM 产品通过 CMI 来实现 OSLC 的集成，以及集成操作中所要遵循的一些操作规则。本文将介绍 CMI 的查询功能。<\/p><p>对于产品之间的集成操作，查询功能必不可少，它可以帮助用户在不需要任何客户端和登录另一端产品的服务器的情况下了解另一端产品的某个关注焦点的状态、进度。不但要了解自身产品关于另一个产品某条目录的关联信息，也要了解另一个产品其他目录的状态，以便更改或作出随时改变。<\/p><p>对于 Clear Case 和 CLM 产品例如 Clear Quest（以下简称 CQ）和 Rational Team Concert （以下简称 RTC）集成来说，查询的功能不仅包括查询当前分支或活动的集成信息，也包括 CLM 产品 Server 端其他有关的信息，如 CQ 的其他缺陷的描述和 ID 和 RTC 其他该工作项的描述和 ID。这样我们就可以在查找的结果上更改现有的集成信息，如把此版本或活动关联到另一个工作项或缺陷。而不用再登录到 CQ，RTC 上查询现有的缺陷或工作项。本身的 Clear Case 的集成查询也支持命令行的形式，这样可以使得查询所要集成的 Provider 信息更方便。<\/p><h2 id=\"1.准备工作 |outline\">准备工作<\/h2><p>在进行例子之前，我们需要安装一些 Rational 的软件，包括 Clear Case8.0.0.8 以上版本，同时需要已经配置好的 Clear Quest 服务器以及 RTC 服务器，并创建样例数据。在我们引入的例子中，我们使用了的版本如下：<\/p><ul class=\"ibm-bullet-list\"><li>Rational Clear Case 以及 Clear Quest 8.0.0.9 版本<\/li><li>Rational Jazz Team Server Version: 4.0.4 M1 版本<\/li><\/ul><h2 id=\"1.BaseClearCase 通过 CMI 和 CLM 产品集成查询的原理 |outline\">Base Clear Case 通过 CMI 和 CLM 产品集成查询的原理<\/h2><p>Clear Case 的查询功能集成到了 Clear Case 的本身命令行里，这使得命令行用户只要多加一个查询参数就可以实现查询功能，下面则是 Base Clear Case 的集成在分支 branch 上实现查询的具体功能简单描述：<\/p><div class=\"codesection\"><pre class=\"displaycode\">cleartool settask -help\nUsage: settask -find [-provider provider_name] {-pname pname |\n               -brtype brtype_name}\n       settask [-view view_tag] {task-selector | -none |\n               [-add_task task-selector[,...]]\n               [-remove_task [task-selector[,...]]]}<\/pre><\/div><p>-find        参数来告诉 CMI 要实现查询操作。<\/p><p>-provider    参数来指定要查的集成 Provider 的名字。<\/p><p>    -pname       从某个具体的 Clear Case 端更改的版本来提取集成的 Provider Server              的信息来查询此 Provider 的所有记录信息。<\/p><p>-brtype      从某个分支上提取具体的集成 Provider Server 的信息，来查询此 Provider 上的所有记录信息。<\/p><p>在查询之前，我们仍然要配置 Provider 基本 Server 地址和查询地址。由于 Rational CLM 软件生命周期管理工具的很多产品都提供了 OSLC 接口，这就使得 Clear Case 的集成查询功能的配置和使用很方便。后面将详细介绍如何在通过命令好的形式完成查询功能，这将对于了解 CMI 查询功能的基本原理很有帮助。<\/p><h2 id=\"1.BaseClearCase 和 CLMCQ，RTC 集成的查询功能 |outline\">Base Clear Case 和 CLM CQ，RTC 集成的查询功能<\/h2><h3 id=\"N1008A\">配置 Base Clear Case CMI 查询功能<\/h3><p>为了实现 CMI 的查询功能，首先要把集成的 Provider 关联到工作的 Vob，然后再把此 Provider 关联到所要工作的分支上，并在此步配置 queryuri 属性即要查找的 Provider Server 的查询 OSLC 地址。命令行如下所示：<\/p><p><a href=\"#N10093\" class=\"ibm-popup-link\" onclick=\"ibmweb.overlay.show('N10093',this);return false;\">点击查看代码清单<\/a><\/p><div id=\"N10093\" class=\"dw-sidefile-overlay ibm-common-overlay ibm-overlay-alt-two\"><div class=\"ibm-head\"><p><a href=\"#close\" class=\"ibm-common-overlay-close\">关闭 [x]<\/a><\/p><\/div><div class=\"ibm-body\"><div class=\"ibm-main\"><div class=\"ibm-container ibm-alternate\"><div class=\"ibm-container-body\"><div class=\"codesection\"><pre class=\"displaycode no-auto-overflow\">cleartool mkcmprovider -vob . -type cmrtc -version v1_0 -desc \"RTC provider\" -connection baseUrl:https://qwin182.ratl.swg.usma.ibm.com:9443/ccm rtcprovider\n\n cleartool mkcmprovider -brtype main -context \"queryUri:/web/projects/Best%20Project%20Ever#action=com.ibm.team.workitem.runSavedQuery&amp;id=_GRZlst9CEeKsxr9ds6iT8Q\" rtcprovider<\/pre><\/div><\/div><\/div><\/div><\/div><div class=\"ibm-footer\"><><\/div><\/div><p>然后通过 cleartool des brtype:main 来检测 queryUri 属性是否配置正确配置到此分支上。具体 Clear Case 命令行操作如图所示：<\/p><h5 id=\"N10098\">图 1. 配置查询参数<\/h5><img alt=\"配置查询参数\" src=\"/sunshine_new/images/负2012465084/image003.jpg\" width=\"636\" /><p>我们所做的查询操作省略了搭建 Clear Case 和 Rational Team Concert 的集成环境的步骤以及创建 VOB，View 和配置 CMI 功能方法，具体可参考此 CMI 前面系列的文章。<\/p><p>如上图所示我们在 VOB 上配置了 RTC Provider 的信息其中包括 baseuri 即要集成的 Server 地址。然后将此 Provider 信息配置到了具体将要工作的分支上，在分支的上下文里，指定了查询操作的 queryUri。CMI 将会合成 baseUrl 和 queryUri 来完成整个查询的 OSLC 地址。两者缺一不可，如果条件可以，你可以尝试把 baseUrl 和 queryUri 拼接起来在浏览器里验证 RTC Server 是否正常访问。<\/p><h3 id=\"N100A7\">Base Clear Case CMI 的基本查询功能<\/h3><p>CMI 查询的命令如下：<\/p><div class=\"codesection\"><pre class=\"displaycode\">settask -find [-provider provider_name] {-pname pname | -brtype brtype_name}<\/pre><\/div><p>从命令行解释可以看出，provider 参数是可选的，而-pname 和-brtype 两者必须选一。<\/p><p>如果设定了 provider 就从该 provider 的 baseUrl 和 queryUri 属性查找服务器的内容并返回到 Clear Case 端。如果没有设定将遍历查找分支上所有 Provider，并把结果依次返回到 Clear Case 端。返回的格式是：id@provider 名字：provider 描述。对应的 RTC Provider 和 CQ Provider 就是<\/p><p>工作项 id@RTCprovider 名字：工作项描述<\/p><p>  缺陷 id@CQprovider 名字：缺陷描述<\/p><p>查询会返回所有此 provider 的所有信息，但在 CMI 后台处理中为了防止给服务器和本地内存很大压力每次查询和 Provider Server 的通信仅返回 25 条信息，如果查询了多个 Provider，而第一个 Provider 的返回信息少于 25 个，CMI 后台会继续访问第二个 Provider 直到返回的记录有 25 个，随后返回前台，保存在 Clear Case 的缓存里，再继续查询满足查询条件的其他 Provider 的关联缺陷或工作项信息。数字 25 只是后台为了提高查询性能而设定的默认一次查询返回的最高条数，而不是返回到前台客户最多能看到的条目数。由于查询使用了缓存技术，同样的查询语句如果再次运行，查询返回速度比第一次查询速度要快得多。<\/p><p>pname 和 brtype_name 两个参数必须设定一个，pname 是某个包含集成信息的版本的文件路径，brtype_name 是分支的名字，CMI 根据你设置的 pname 或 brtype_name 来得到分支配置的 Provider 信息，以防用户没有通过-provider 设定具体要查找的 Provider 信息。<\/p><p>如果其中某个 provider 失败，将提示报错但并不影响其他 provider 查找的结果，如下图所示：<\/p><p>我们通过上面提到的命令设置了 provider 的 queryuri，然后用 lsprovider 命令确认设置的 queryUri 已经正确，然后用 settask 命令查找这个 provider 的所有内容，返回的内容包括 Server 的一个 Task 的 id 跟着@后的 server 名字，最后是这个 Task 的名字 summary。<\/p><p>如下图所示，我们在分支上关联了两个要集成的 Provider，CQPROV 和 rtcprovider，通过设定具体要查询的 Provider 可以查到这个分支上关联的 Provider 的所有工作项。根据查询结果，用户可以使用 CMI 后面的关联操作，或者关联到某个文件更改版本，或者关联到完成此工作项的活动。<\/p><h5 id=\"N100C5\">图 2. 通过命令行查看查询结果<\/h5><img alt=\"通过命令行查看查询结果\" src=\"/sunshine_new/images/负2012465084/image005.jpg\" width=\"682\" /><p>通过配置的 baseUrl 和 queryUri 来访问 RTC Provider 页面如图所示：<\/p><p>查询的结果包括 Provider 的 Id 和 Summary 信息,和在 Clear Case 通过 CMI 查询的结果一致。<\/p><h5 id=\"N100D5\">图 3. RTC 里验证查询结果一致<\/h5><img alt=\"RTC 里验证查询结果一致\" src=\"/sunshine_new/images/负2012465084/image007.jpg\" width=\"576\" /><h3 id=\"N100E0\">Base Clear Case 通过 CMI 和 CQ 集成的查询功能<\/h3><p>上面是对于 RTC provider 的查询，如果是 CQ Provider，只需设置-provider CQPROV<\/p><p>CQPROV 是 CQ provider 的名字，查询结果如下：<\/p><h5 id=\"N100EA\">图 4. 通过 Provider 参数进行查询<\/h5><img alt=\"通过 Provider 参数进行查询\" src=\"/sunshine_new/images/负2012465084/image009.jpg\" width=\"576\" /><p>而对应的 CQ provider 的 web 页面为：<\/p><h5 id=\"N100F8\">图 5. RTC 里验证待查询的信息<\/h5><img alt=\"RTC 里验证待查询的信息\" src=\"/sunshine_new/images/负2012465084/image011.jpg\" width=\"576\" /><p>如果我们不设置具体要查询的 provider 信息而是通过具体文件版本的路径或分支来查询，由于他们都是为了帮助来查找分支上关联的 Provider 信息所以会遍历分支上的所有 Provider 并把记录全打出来，如果这个文件所在的分支和你指定的分支一样，他们的查询结果将一致。如下图所示：<\/p><p>文件 1.c 关联了两个 Provider 的两个 task，这是必须的，因为在前面同系列文章介绍关联规则 3 中指出，文件 1.c 必须关联所有配置在所工作分支上的 Provider。然后我们通过两个不同的参数会查出此分支上所有 Provider 的记录。这两个参数是互斥的，有且仅能制定一个，如图 7 所示<\/p><h5 id=\"N10108\">图 6. 在分支上查询帮助命令<\/h5><img alt=\"在分支上查询帮助命令\" src=\"/sunshine_new/images/负2012465084/image013.jpg\" width=\"673\" /><h5 id=\"N10114\">图 7. 通过设定查询参数进行查询<\/h5><img alt=\"通过设定查询参数进行查询\" src=\"/sunshine_new/images/负2012465084/image014.jpg\" width=\"547\" height=\"659\" /><p><a href=\"#N1011B\" class=\"ibm-popup-link\" onclick=\"ibmweb.overlay.show('N1011B',this);return false;\">点击查看大图<\/a><\/p><div id=\"N1011B\" class=\"dw-sidefile-overlay ibm-common-overlay ibm-overlay-alt-two\"><div class=\"ibm-head\"><p><a href=\"#close\" class=\"ibm-common-overlay-close\">关闭 [x]<\/a><\/p><\/div><div class=\"ibm-body\"><div class=\"ibm-main\"><div class=\"ibm-title\"><h2>图 7. 通过设定查询参数进行查询<\/h2><\/div><div class=\"ibm-container ibm-alternate\"><div class=\"ibm-container-body\"><img alt=\"通过设定查询参数进行查询\" src=\"/sunshine_new/images/负2012465084/image014.jpg\" width=\"684\" /><\/div><\/div><\/div><\/div><div class=\"ibm-footer\"><><\/div><\/div><h3 id=\"N10120\">Base Clear Case 的查询错误处理<\/h3><p>如图下图所示，如果我们的 queryuri 设置错误，如把 queryuri 设置成空，运行查询功能将提示错误信息。如果尝试不设置具体要查询的 provider，CMI 将遍历分支上所有 provider 的查询，成功的就打印出来结果，不成功的打印出具体的报错信息。从而看得出来，新的查询功能有很好的容错性。<\/p><h5 id=\"N10128\">图 8.查询遇到错误<\/h5><img alt=\"查询遇到错误\" src=\"/sunshine_new/images/负2012465084/image016.jpg\" width=\"685\" /><h2 id=\"1.UCMClearCase 通过 CMI 和 CLM 产品集成查询的原理 |outline\">UCM Clear Case 通过 CMI 和 CLM 产品集成查询的原理<\/h2><p>有了上面对 Base Clear Case 的查询知识，就很容易了解 UCM Clear Case 的查询原理。同 Base Clear Case 查询一样，UCM 的查询也是集成在已有 Clear Case 命令中：<\/p><div class=\"codesection\"><pre class=\"displaycode\">cleartool lsact -h\nUsage: lsactivity [-short | -long | -fmt format |\n                   -ancestor [-fmt format] [-depth depth] ] [-obsolete]\n                  [-invob vob-selector | -in stream-selector [-recurse] |\n                   activity-selector ... |\n                  [[-cact | -me | -user username] [-view view-tag | -cview]] ]\n       lsactivity -contrib activity-selector ...\n       lsactivity -find [-provider provider_name]\n                  [-in stream-selector | -view view-tag | -cview |\n                   activity-selector]<\/pre><\/div><p>在 UCM 里实现查找的功能集成到了 cleartool lsactivity 命令中<\/p><p>-provider 和 Base Clear Case 查询一样。同样可选的 Provider 参数。<\/p><p>-in stream-selector 类似于分支的 brtype。<\/p><p>-view view-tag 由于 UCM 中每个 stream 都包含用户使用的视图 View, 所以多了 view-tag 来通过视图找到工作的流，然后在流上找到关联的 Provider 信息。<\/p><p>-cview 即当前工作的视图，从而找当前工作的默认流，从流上找到配置的 Provider 查询地址<\/p><p>Activity-selector 通过 activity 找到此 activity 工作的流，从而找到流上的 Provider 的查询地址。<\/p><p>通过上面的命令行说明发现，和 Base 集成上查询的不同之处是 除了-find，其他参数都是可选的。<\/p><p><strong>UCM <\/strong><strong>Clear Case 和 CLM CQ<\/strong><strong>，<\/strong><strong>RTC 集成的查询功能<\/strong><\/p><h3 id=\"N10155\">配置 UCM Clear Case CMI 查询功能<\/h3><p>为了实现 CMI 的查询功能，首先要把集成的 Provider 关联到正在工作的 Vob，然后再把此 Provider 关联到所要工作的分支上，并配置 queryuri 属性，此属性为要查找的 Provider Server 的查询 OSLC 地址。命令行如下所示：<\/p><p><a href=\"#N1015E\" class=\"ibm-popup-link\" onclick=\"ibmweb.overlay.show('N1015E',this);return false;\">点击查看代码清单<\/a><\/p><div id=\"N1015E\" class=\"dw-sidefile-overlay ibm-common-overlay ibm-overlay-alt-two\"><div class=\"ibm-head\"><p><a href=\"#close\" class=\"ibm-common-overlay-close\">关闭 [x]<\/a><\/p><\/div><div class=\"ibm-body\"><div class=\"ibm-main\"><div class=\"ibm-container ibm-alternate\"><div class=\"ibm-container-body\"><div class=\"codesection\"><pre class=\"displaycode no-auto-overflow\">cleartool mkcmprovider -vob . -type cmrtc -version v1_0 -desc \"RTC provider\"\n-connection baseUrl:https://qwin182.ratl.swg.usma.ibm.com:9443/ccm rtcprovider\n\n cleartool mkcmprovider -stream lzhao_int_stream@/usr/vobs/lzhao_ucm_pvob   \n-context \"queryUri:web/projects/CC%20Bridge%20Test%20Project%20Area#action=com.ibm.team.workitem.runSavedQuery\n&amp;id=_d4fW4CiXEeKSXN2AyCuolg\" -enable true -options activityFormat:ACT_%task-id_%stream-name,\nvalidate:true rtcprovider<\/pre><\/div><\/div><\/div><\/div><\/div><div class=\"ibm-footer\"><><\/div><\/div><p>然后通过以下命令：来检测 queryUri 属性是否配置正确<\/p><div class=\"codesection\"><pre class=\"displaycode\">cleartool lsprovider Cstream lzhao_dev_stream@/usr/vobs/lzhao_ucm_pvob<\/pre><\/div><p>  具体 Clear Case 命令行操作如图所示：<\/p><h5 id=\"N10169\">图 9. RTC 里验证关联的活动<\/h5><img alt=\"RTC 里验证关联的活动\" src=\"/sunshine_new/images/负2012465084/image018.jpg\" width=\"651\" /><h3 id=\"N10174\">UCM Clear Case CMI 的基本查询功能<\/h3><p>UCM Clear Case 的后台查询步骤，缓存的处理，性能的提升都，以及查询的返回结果和 Base Clear Case 的查询一致，这里不再敖述。如下图所示：<\/p><p>我们在流 lzhao_int_stream 上配置了两个 Provider，通过 lsprovider 命令可以看到 baseUrl 和 queryUri 已经正确的配置到了各自 Provider 上。<\/p><h5 id=\"N1017E\">图 10. UCM 集成时用命令行进行查询<\/h5><img alt=\"UCM 集成时用命令行进行查询\" src=\"/sunshine_new/images/负2012465084/image020.jpg\" width=\"648\" /><p>如果我们不指定具体的查询 provider 信息，将会遍历所有的 Provider，并输出查询结果，如果其中某个 Provider 查询报错，将和 Base Clear Case 查询一样，输出错误信息，同时打印出正确的 Provider 返回的结果。<\/p><p>如下图所示：<\/p><p>由于 CQ Provider cqprov 的 query 查询条件没有通过验证，将打印出错误信息，但 RTC 的 provider 查询结果仍然正确的打印了出来，CMI 查询 Provider 的遍历顺序和 lsprovider 显示的从上到下的 Provider 排列的顺序一致。我们可以像 Base Clear Case 一样通过 web 页面访问 Provider Server 验证查询结果是否和 Provider 端一致。<\/p><h5 id=\"N10190\">图 11. 不设置参数的默认查询<\/h5><img alt=\"不设置参数的默认查询\" src=\"/sunshine_new/images/负2012465084/image022.jpg\" width=\"687\" /><h2 id=\"1.结论 |outline\">结论<\/h2><p>本文在读者了解了如何使用 Configuration management Interface 来实现 Base/UCM Clear Case 与 Clear Quest 及 RTC 的集成的基础上详细介绍了集成操作中的查询功能，由于基于新的 CMI 架构。查询功能集成到了 settask 命令里，给传统 Clear Case 用户带来了方便，同时次查询功能支持多个集成产品的交互查询以及良好的容错机制，使得我们很容易通过查询的结果选择关联的工作项或缺陷。如果是在 GUI 界面每次操作将弹出所要集成的 Task 列表供你选择集成，此操作后台仍然调用的查询功能。从而可见，查询功能在集成操作时被广泛的使用。<\/p><CMA ID: 975221><Site ID: 10><XSLT stylesheet used to transform this file: dw-document-html-7.0.xsl>\r\n\r\n\r\n<\/div>\r\n<\/div>\r\n","createTime":"2014-07-03 00:00:00","deployTime":"2014-07-03 00:00:00","id":0,"intro":"在对前面文章 Base/UCM Clear Case 和 CLM 产品集成的了解的基础上，本文着重讲解 CMI 的集成查询功能，CMI 的查询功能使用很方便，由于本身 CMI 的基本功能架构的良好，使得基于 Clear Case 版本控制功能而开发的查询不但有了更好的查询性能，而且有很好的扩展性。熟练的掌握 CMI 的查询功能不但有利于方便操作想要集成到具体产品的记录，也有助于了解集成的产品的其他记录信息，有利于对操作错误的诊断和修正。","keyword":"","recommend":false,"source":"http://www.ibm.com/developerworks/cn/rational/1406_zhaoliang_ccclm3/index.html","title":"通过 CMI 实现 ClearCase 和 CLM 产品的集成查询","typeId":0,"updateTime":"2014-07-03 00:00:00"}
{"author":"","clickNumber":0,"content":"\r\n<div class=\"ibm-columns\">\r\n<div class=\"ibm-col-1-1\">\r\n\r\n<h2 id=\"1.什么是 Init 系统,init 系统的历史和现状 |outline\">什么是 Init 系统,init 系统的历史和现状<\/h2><p>Linux 操作系统的启动首先从 BIOS 开始，接下来进入 boot loader，由 bootloader 载入内核，进行内核初始化。内核初始化的最后一步就是启动 pid 为 1 的 init 进程。这个进程是系统的第一个进程。它负责产生其他所有用户进程。<\/p><p>init 以守护进程方式存在，是所有其他进程的祖先。init 进程非常独特，能够完成其他进程无法完成的任务。<\/p><p>Init 系统能够定义、管理和控制 init 进程的行为。它负责组织和运行许多独立的或相关的始化工作(因此被称为 init 系统)，从而让计算机系统进入某种用户预订的运行模式。<\/p><p>仅仅将内核运行起来是毫无实际用途的，必须由 init 系统将系统代入可操作状态。比如启动外壳 shell 后，便有了人机交互，这样就可以让计算机执行一些预订程序完成有实际意义的任务。或者启动 X 图形系统以便提供更佳的人机界面，更加高效的完成任务。这里，字符界面的 shell 或者 X 系统都是一种预设的运行模式。<\/p><p>大多数 Linux 发行版的 init 系统是和 System V 相兼容的，被称为 sysvinit。这是人们最熟悉的 init 系统。一些发行版如 Slackware 采用的是 BSD 风格 Init 系统，这种风格使用较少，本文不再涉及。其他的发行版如 Gentoo 是自己定制的。Ubuntu 和 RHEL 采用 upstart 替代了传统的 sysvinit。而 Fedora 从版本 15 开始使用了一个被称为 systemd 的新 init 系统。<\/p><p>可以看到不同的发行版采用了不同的 init 实现，本系列文章就是打算讲述三个主要的 Init 系统：sysvinit，UpStart 和 systemd。了解它们各自的设计特点，并简要介绍它们的使用。<\/p><p>在 Linux 主要应用于服务器和 PC 机的时代，SysVinit 运行非常良好，概念简单清晰。它主要依赖于 Shell 脚本，这就决定了它的最大弱点：启动太慢。在很少重新启动的 Server 上，这个缺点并不重要。而当 Linux 被应用到移动终端设备的时候，启动慢就成了一个大问题。为了更快地启动，人们开始改进 sysvinit，先后出现了 upstart 和 systemd 这两个主要的新一代 init 系统。Upstart 已经开发了 8 年多，在不少系统中已经替换 sysvinit。Systemd 出现较晚，但发展更快，大有取代 upstart 的趋势。<\/p><p>本文的第一部分先简要介绍 sysvinit。<\/p><h2 id=\"2.Sysvinit 概况 |outline\">Sysvinit 概况<\/h2><p>sysvinit 就是 system V 风格的 init 系统，顾名思义，它源于 System V 系列 UNIX。它提供了比 BSD 风格 init 系统更高的灵活性。是已经风行了几十年的 UNIX init 系统，一直被各类 Linux 发行版所采用。<\/p><h3 id=\"N1006A\">运行级别<\/h3><p>Sysvinit 用术语 runlevel 来定义\"预订的运行模式\"。Sysvinit 检查 '/etc/inittab' 文件中是否含有 'initdefault' 项。 这告诉 init 系统是否有一个默认运行模式。如果没有默认的运行模式，那么用户将进入系统控制台，手动决定进入何种运行模式。<\/p><p>sysvinit 中运行模式描述了系统各种预订的运行模式。通常会有 8 种运行模式，即运行模式 0 到 6 和 S 或者 s。<\/p><p>每种 Linux 发行版对运行模式的定义都不太一样。但 0，1，6 却得到了大家的一致赞同：<\/p><ul class=\"ibm-bullet-list\"><li>0 关机<\/li><li>1 单用户模式<\/li><li>6 重启<\/li><\/ul><p>通常在 /etc/inittab 文件中定义了各种运行模式的工作范围。比如 RedHat 定义了 runlevel 3 和 5。运行模式 3 将系统初始化为字符界面的 shell 模式；运行模式 5 将系统初始化为 GUI 模式。无论是命令行界面还是 GUI，运行模式 3 和 5 相对于其他运行模式而言都是完整的正式的运行状态，计算机可以完成用户需要的任务。而模式 1，S 等往往用于系统故障之后的排错和恢复。<\/p><p>很显然，这些不同的运行模式下系统需要初始化运行的进程和需要进行的初始化准备都是不同的。比如运行模式 3 不需要启动 X 系统。用户只需要指定需要进入哪种模式，sysvinit 将负责执行所有该模式所必须的初始化工作。<\/p><h3 id=\"N10080\">sysvinit 运行顺序<\/h3><p>Sysvinit 巧妙地用脚本，文件命名规则和软链接来实现不同的 runlevel。首先，sysvinit 需要读取/etc/inittab 文件。分析这个文件的内容，它获得以下一些配置信息：<\/p><ul class=\"ibm-bullet-list\"><li>系统需要进入的 runlevel<\/li><li>捕获组合键的定义<\/li><li>定义电源 fail/restore 脚本<\/li><li>启动 getty 和虚拟控制台<\/li><\/ul><p>得到配置信息后，sysvinit 顺序地执行以下这些步骤，从而将系统初始化为预订的 runlevel X。<\/p><ul class=\"ibm-bullet-list\"><li>/etc/rc.d/rc.sysinit<\/li><li>/etc/rc.d/rc 和/etc/rc.d/rcX.d/   (X 代表运行级别 0-6)<\/li><li>/etc/rc.d/rc.local<\/li><li>X Display Manager（如果需要的话）<\/li><\/ul><p>首先，运行 rc.sysinit 以便执行一些重要的系统初始化任务。在 RedHat 公司的 RHEL5 中(RHEL6 已经使用 upstart 了)，rc.sysinit 主要完成以下这些工作。<\/p><ul class=\"ibm-bullet-list\"><li>激活 udev 和 selinux<\/li><li>设置定义在/etc/sysctl.conf 中的内核参数<\/li><li>设置系统时钟<\/li><li>加载 keymaps<\/li><li>使能交换分区<\/li><li>设置主机名(hostname)<\/li><li>根分区检查和 remount<\/li><li>激活 RAID 和 LVM 设备<\/li><li>开启磁盘配额<\/li><li>检查并挂载所有文件系统<\/li><li>清除过期的 locks 和 PID 文件<\/li><\/ul><p>完成了以上这些工作之后，sysvinit 开始运行/etc/rc.d/rc 脚本。根据不同的 runlevel，rc 脚本将打开对应该 runlevel 的 rcX.d 目录(X 就是 runlevel)，找到并运行存放在该目录下的所有启动脚本。每个 runlevel X 都有一个这样的目录，目录名为/etc/rc.d/rcX.d。<\/p><p>在这些目录下存放着很多不同的脚本。文件名以 S 开头的脚本就是启动时应该运行的脚本，S 后面跟的数字定义了这些脚本的执行顺序。在/etc/rc.d/rcX.d 目录下的脚本其实都是一些软链接文件，真实的脚本文件存放在/etc/init.d 目录下。如下所示：<\/p><h5 id=\"N100BA\">清单 1.rc5.d 目录下的脚本<\/h5><div class=\"codesection\"><pre class=\"displaycode\">[root@www ~]# ll /etc/rc5.d/\nlrwxrwxrwx 1 root root 16 Sep  4  2008 K02dhcdbd -&gt; ../init.d/dhcdbd\n....(中间省略)....\nlrwxrwxrwx 1 root root 14 Sep  4  2008 K91capi -&gt; ../init.d/capi\nlrwxrwxrwx 1 root root 23 Sep  4  2008 S00microcode_ctl -&gt; ../init.d/microcode_ctl\nlrwxrwxrwx 1 root root 22 Sep  4  2008 S02lvm2-monitor -&gt; ../init.d/lvm2-monitor\n....(中间省略)....\nlrwxrwxrwx 1 root root 17 Sep  4  2008 S10network -&gt; ../init.d/network\n....(中间省略)....\nlrwxrwxrwx 1 root root 11 Sep  4  2008 S99local -&gt; ../rc.local\nlrwxrwxrwx 1 root root 16 Sep  4  2008 S99smartd -&gt; ../init.d/smartd\n....(底下省略)....<\/pre><\/div><p>当所有的初始化脚本执行完毕。Sysvinit 运行/etc/rc.d/rc.local 脚本。<\/p><p>rc.local 是 Linux 留给用户进行个性化设置的地方。您可以把自己私人想设置和启动的东西放到这里，一台 Linux Server 的用户一般不止一个，所以才有这样的考虑。<\/p><h3 id=\"N100C3\">Sysvinit 和系统关闭<\/h3><p>Sysvinit 不仅需要负责初始化系统，还需要负责关闭系统。在系统关闭时，为了保证数据的一致性，需要小心地按顺序进行结束和清理工作。<\/p><p>比如应该先停止对文件系统有读写操作的服务，然后再 umount 文件系统。否则数据就会丢失。<\/p><p>这种顺序的控制这也是依靠/etc/rc.d/rcX.d/目录下所有脚本的命名规则来控制的，在该目录下所有以 K 开头的脚本都将在关闭系统时调用，字母 K 之后的数字定义了它们的执行顺序。<\/p><p>这些脚本负责安全地停止服务或者其他的关闭工作。<\/p><h3 id=\"N100D0\">Sysvinit 的管理和控制功能<\/h3><p>此外，在系统启动之后，管理员还需要对已经启动的进程进行管理和控制。原始的 sysvinit 软件包包含了一系列的控制启动，运行和关闭所有其他程序的工具。<\/p><p><strong>halt<\/strong><\/p><p>停止系统。<\/p><p><strong>init<\/strong><\/p><p>这个就是 sysvinit 本身的 init 进程实体，以 pid1 身份运行，是所有用户进程的父进程。最主要的作用是在启动过程中使用/etc/inittab 文件创建进程。<\/p><p><strong>killall5<\/strong><\/p><p>就是 SystemV 的 killall 命令。向除自己的会话(session)进程之外的其它进程发出信号，所以不能杀死当前使用的 shell。<\/p><p><strong>last<\/strong><\/p><p>回溯/var/log/wtmp 文件(或者-f 选项指定的文件)，显示自从这个文件建立以来，所有用户的登录情况。<\/p><p><strong>lastb<\/strong><\/p><p>作用和 last 差不多，默认情况下使用/var/log/btmp 文件，显示所有失败登录企图。<\/p><p><strong>mesg<\/strong><\/p><p>控制其它用户对用户终端的访问。<\/p><p><strong>pidof<\/strong><\/p><p>找出程序的进程识别号(pid)，输出到标准输出设备。<\/p><p><strong>poweroff<\/strong><\/p><p>等于 shutdown -h Cp，或者 telinit 0。关闭系统并切断电源。<\/p><p><strong>reboot<\/strong><\/p><p>等于 shutdown Cr 或者 telinit 6。重启系统。<\/p><p><strong>runlevel<\/strong><\/p><p>读取系统的登录记录文件(一般是/var/run/utmp)把以前和当前的系统运行级输出到标准输出设备。<\/p><p><strong>shutdown<\/strong><\/p><p>以一种安全的方式终止系统，所有正在登录的用户都会收到系统将要终止通知，并且不准新的登录。<\/p><p><strong>sulogin<\/strong><\/p><p>当系统进入单用户模式时，被 init 调用。当接收到启动加载程序传递的-b 选项时，init 也会调用 sulogin。<\/p><p><strong>telinit<\/strong><\/p><p>实际是 init 的一个连接，用来向 init 传送单字符参数和信号。<\/p><p><strong>utmpdump<\/strong><\/p><p>以一种用户友好的格式向标准输出设备显示/var/run/utmp 文件的内容。<\/p><p><strong>wall<\/strong><\/p><p>向所有有信息权限的登录用户发送消息。<\/p><p>不同的 Linux 发行版在这些 sysvinit 的基本工具基础上又开发了一些辅助工具用来简化 init 系统的管理工作。比如 RedHat 的 RHEL 在 sysvinit 的基础上开发了 initscripts 软件包，包含了大量的启动脚本 (如 rc.sysinit) ，还提供了 service，chkconfig 等命令行工具，甚至一套图形化界面来管理 init 系统。其他的 Linux 发行版也有各自的 initscript 或其他名字的 init 软件包来简化 sysvinit 的管理。<\/p><p>只要您理解了 sysvinit 的机制，在一个最简的仅有 sysvinit 的系统下，您也可以直接调用脚本启动和停止服务，手动创建 inittab 和创建软连接来完成这些任务。因此理解 sysvinit 的基本原理和命令是最重要的。您甚至也可以开发自己的一套管理工具。<\/p><h3 id=\"OLE_LINK2\">Sysvinit 的小结<\/h3><p>Sysvinit 的优点是概念简单。Service 开发人员只需要编写启动和停止脚本，概念非常清楚；将 service 添加/删除到某个 runlevel 时，只需要执行一些创建/删除软连接文件的基本操作；这些都不需要学习额外的知识或特殊的定义语法(UpStart 和 Systemd 都需要用户学习新的定义系统初始化行为的语言)。<\/p><p>其次，sysvinit 的另一个重要优点是确定的执行顺序：脚本严格按照启动数字的大小顺序执行，一个执行完毕再执行下一个，这非常有益于错误排查。UpStart 和 systemd 支持并发启动，导致没有人可以确定地了解具体的启动顺序，排错不易。<\/p><p>但是串行地执行脚本导致 sysvinit 运行效率较慢，在新的 IT 环境下，启动快慢成为一个重要问题。此外动态设备加载等 Linux 新特性也暴露出 sysvinit 设计的一些问题。针对这些问题，人们开始想办法改进 sysvinit，以便加快启动时间，并解决 sysvinit 自身的设计问题。<\/p><p>Upstart 是第一个被广泛应用的新一代 init 系统。我们在接下来的第二部分介绍 UpStart。<\/p><CMA ID: 976052><Site ID: 10><XSLT stylesheet used to transform this file: dw-document-html-7.0.xsl>\r\n\r\n\r\n<\/div>\r\n<\/div>\r\n","createTime":"2014-07-02 00:00:00","deployTime":"2014-07-02 00:00:00","id":0,"intro":"近年来，Linux 系统的 init 进程经历了两次重大的演进，传统的 sysvinit 已经淡出历史舞台，新的 init 系统 UpStart 和 systemd 各有特点，而越来越多的 Linux 发行版采纳了 systemd。本文简要介绍了这三种 init 系统的使用和原理，每个 Linux 系统管理员和系统软件开发者都应该了解它们，以便更好地管理系统和开发应用。本文是系列的第一部分，主要讲述 sysvinit 的特点和使用。","keyword":"","recommend":false,"source":"http://www.ibm.com/developerworks/cn/linux/1407_liuming_init1/index.html","title":"浅析 Linux 初始化 init 系统，第 1 部分: sysvinit","typeId":0,"updateTime":"2014-07-02 00:00:00"}
{"author":"","clickNumber":0,"content":"\r\n<div class=\"ibm-columns\">\r\n<div class=\"ibm-col-1-1\">\r\n\r\n<div class=\"dw-sidebar ibm-inset\"><h2 id=\"N10058\">关于本系列<\/h2><p>Java 传承的是平台，而不是语言。有超过 200 种语言可以在 JVM 上运行，它们之中不可避免地会有一种语言最终取代 Java\n                    语言，成为编写 JVM 程序的最佳方式。本系列将探讨三种下一代 JVM 语言：Groovy、Scala 和\n                    Clojure，比较并对比新的功能和范例，让 Java 开发人员对自己近期的未来发展有大致的了解。<\/p><\/div><p> 本系列的初衷是对三种较新的 JVM 语言进行比较，帮助您评估其中哪一种语言是 Java 语言最有可能的继任者。但与此同时，Java\n                语言经历了它自从增加范型以来最为重要的一次变革。现在，Java 本身展示出了众多 Groovy、Scala 与 Clojure\n                语言中最令人满意的特性。在本文中，我将 Java 8 视为 Java\n                下一代语言，并给出了一些示例来说明该语言的编程范型已经被有效增强到了何种程度。<\/p><h2 id=\"N1005F\">最后的高阶函数<\/h2><p> 高阶函数使用其他函数作为参数，并返回其他函数作为结果。Java 最终以 <em>lambda 表达式<\/em>\n                的形式拥有了高阶函数，它或许是流行语言中最后一个拥有高阶函数的语言。Java 8\n                工程师不仅将高阶函数收入语言中，而且还聪明地支持老式接口，以便利用函数功能。<\/p><p> 在 \"<a href=\"http://www.ibm.com/developerworks/cn/java/j-jn10/index.html\">函数式编码风格<\/a>\" 一文中，我演示了如何使用 Java\n                下一代语言实现来解决一个通常要求强制解决的问题。该问题假设要在一个输入的姓名清单中删除单字符的项，并返回一个以逗号隔开的清单，并将其中的每个姓名都被转换为大写。清单\n                1 中给出了这个强制性的 Java 解决方案。<\/p><h5 id=\"listing1\">清单 1. 强制性的姓名转换<\/h5><div class=\"codesection\"><pre class=\"displaycode\">public String cleanNames(List&lt;String&gt; listOfNames) {\n    StringBuilder result = new StringBuilder();\n    for(int i = 0; i &lt; listOfNames.size(); i++) {\n        if (listOfNames.get(i).length() &gt; 1) {\n            result.append(capitalizeString(listOfNames.get(i))).append(\",\");\n        }\n    }\n    return result.substring(0, result.length() - 1).toString();\n}\n\npublic String capitalizeString(String s) {\n    return s.substring(0, 1).toUpperCase() + s.substring(1, s.length());\n}<\/pre><\/div><p> 在以前的 Java 版本中，迭代属于规范，但在 Java 8 中，这项任务将由<em>流（stream）<\/em> 更好地完成 &#8212;\n                流是一种抽象概念，就像是在集合与 UNIX&#174; 管道之间搭起了一座桥梁。清单 2 使用了流。<\/p><h5 id=\"listing2\">清单 2. Java 8\n                中的姓名转换<\/h5><div class=\"codesection\"><pre class=\"displaycode\">public String cleanNames(List&lt;String&gt; names) {\n    return names\n            .stream()\n            .filter(name -&gt; name.length() &gt; 1)\n            .map(name -&gt; capitalize(name))\n            .collect(Collectors.joining(\",\"));\n}\n\nprivate String capitalize(String e) {\n    return e.substring(0, 1).toUpperCase() + e.substring(1, e.length());\n}<\/pre><\/div><p><a href=\"#listing1\">清单 1<\/a> 中的迭代版本必须将过滤器、转换与连接合并到一个 <code>for<\/code>\n                循环中，因为针对每个任务在集合上进行循环的效率非常低。借助 Java 8\n                    中的流，您可以连接函数并将它们组合在一起，直到调用生成输出的函数（称为<em>终端操作<\/em>）为止，比如\n                <code>collect()<\/code> 或 <code>forEach()<\/code>。<\/p><div class=\"dw-sidebar ibm-inset\"><p>我使用了一些语法糖来创建 <a href=\"#listing2\">清单 2<\/a> 中的 lambda\n                    表达式。<code>.filter(name -&gt; name.length() &gt; 1)<\/code> 是\n                    <code>filter((name) -&gt; name.length() &gt; 1<\/code>\n                    的简写形式。对于单个参数而言，那一对括号是多余的。<\/p><\/div><p><a href=\"#listing2\">清单 2<\/a> 中的 <code>filter()<\/code> 方法与函数式语言中常见的 filter\n                方法是一样的（参见 \"<a href=\"http://www.ibm.com/developerworks/cn/java/j-jn11/index.html\">Java 下一代：克服同义词干扰<\/a>\"）。<code>filter()<\/code> 方法接受一个返回 Boolean\n                值的高阶函数，该值被用作一个过滤标准：<code>true<\/code> 表示包含在已过滤的集合中，而 <code>false<\/code>\n                表示在已过滤的集合中找不到它。<\/p><p><code>filter()<\/code> 方法接受一个 <code>Predicate&lt;T&gt;<\/code> 类型，这是一个返回\n                Boolean 值的方法。如果愿意的话，您可以显式地创建谓词实例，如清单 3 中所示。<\/p><h5 id=\"listing3\">清单 3. 手动创建一个谓词<\/h5><div class=\"codesection\"><pre class=\"displaycode\">Predicate&lt;String&gt; p = (name) -&gt; name.startsWith(\"Mr\");\nList&lt;String&gt; l = List.of(\"Mr Rogers\", \"Ms Robinson\", \"Mr Ed\");\nl.stream().filter(p).forEach(i -&gt; System.out.println(i));<\/pre><\/div><p> 在 <a href=\"#listing3\">清单 3<\/a> 中，通过将过滤的 lambda 表达式指定给它，我创建了一个谓词。当我在第三行调用\n                <code>filter()<\/code> 方法时，我将谓词作为期望的参数进行传递。<\/p><p> 在 <a href=\"#listing2\">清单 2<\/a> 中，<code>map()<\/code> 方法按照预期将\n                <code>capitalize()<\/code> 方法应用于集合中的每个元素。最后，我调用了 <code>collect()<\/code>\n                方法，这是一个终端操作 &#8212; 一个从流中生成值的方法。<code>collect()<\/code> 方法执行类似的\n                    <em>reduce<\/em> 操作：组合元素，以便生成一个（通常）更小的结果，有时候只生成了一个值（例如，一次 <em>sum<\/em>\n                操作）。Java 8 有一个 <code>reduce()<\/code> 方法，但在这个例子中，<code>collect()<\/code>\n                方法更适用，因为它对可变容器（比如 <code>StringBuilder<\/code>）的处理更加高效。<\/p><p> 通过向现有的类和集合添加函数式结构，比如<em>映射（map）<\/em> 和<em>缩减（reduce）<\/em> 操作，Java\n                需要面对高效更新集合的问题。例如，如果您不能在典型的 Java 集合（如 <code>ArrayList<\/code>）上使用<em>缩减<\/em>\n                操作，它的作用就会要小很多。Scala 与 Clojure 中的很多集合库在默认情况下都是不可变的，这让运行时能够产生高效的操作。Java 8\n                不能强迫开发人员修改集合，而且 Java 中很多现有的集合类都是可变的。因此，Java 8 中包含对诸如\n                <code>ArrayList<\/code> 与 <code>StringBuilder<\/code> 之类集合执行<em>可变缩减（mutable\n                    reduction）<\/em>操作的方法，这些方法将会更新现有元素，而不是更新每次替换结果。尽管 <code>reduce()<\/code>\n                也能用在 <a href=\"#listing2\">清单 2<\/a> 中，但 <code>collect()<\/code>\n                对于这个实例中返回的集合更加高效。<\/p><p>我在 \"<a href=\"http://www.ibm.com/developerworks/cn/java/j-jn13/index.html\">对比并发性<\/a>\" 一文中谈到的函数式语言的优势之一就是，通常只要添加一个修饰符就能轻松地并行处理集合。Java 8\n                也提供同样的优势，如清单 4 中所示。<\/p><h5 id=\"listing4\">清单 4. Java 8\n                中的并行处理<\/h5><div class=\"codesection\"><pre class=\"displaycode\">public String cleanNamesP(List&lt;String&gt; names) {\n    return names \n            .parallelStream() \n            .filter(n -&gt; n.length() &gt; 1) \n            .map(e -&gt; capitalize(e)) \n            .collect(Collectors.joining(\",\"));\n}<\/pre><\/div><p> 和在 Scala 中一样，只需添加一个 <code>parallelStream()<\/code> 修饰符，便可在清单 4\n                中并行完成流操作。函数式编程将实现细节交给运行时来完成，这样它就可以在更高的抽象层上工作。可将线程轻松地应用于集合就是这种优势的一种证明。<\/p><p>Java 8 中的 reducer 类之间存在差异，这使得向现有的语言构件添加深度范型变得非常困难。Java 8\n                团队做了大量的工作，才能以基本无缝的方式添加函数式结构。这种集成的一个良好示例是添加函数式接口。<\/p><h2 id=\"N10124\">函数式接口<\/h2><p> 一种常见的 Java 模式是附带一个方法的接口，该接口也被称为 <em>SAM<\/em>（单一抽象方法）接口，比如\n                <code>Runnable<\/code> 或 <code>Callable<\/code>。在多数情况下，SAM\n                主要被用作可移植代码的一种传送机制。Java 8 使用 lambdas 表达式这种方式实现了可移植代码。一种叫做<em>函数式接口<\/em>\n                的聪明机制支持 lambdas 与 SAM 以有用的方式进行交互。每个函数式接口都包含一个抽象方法（并可以包含几个<a href=\"#dm\">默认方法<\/a>）。函数式接口增强了现有的 SAM 接口，支持使用 lambda\n                表达式代替传统的匿名内部类。例如，<code>Runnable<\/code> 接口现在可以使用\n                <code>@FunctionalInterface<\/code> 注释进行标记。这种可选的注释用于告诉编译器检查\n                <code>Runnable<\/code> 是一个接口（不是类或枚举），而且被注释的类型满足函数式接口的要求。<\/p><p> 作为 lambda 表达式可替代性的一个例子，我通过传递一个 lambda 表达式来代替 <code>Runnable<\/code> 匿名内部类，在\n                Java 8 中创建了一个新线程：<\/p><div class=\"codesection\"><pre class=\"displaycode\">new Thread(() -&gt; System.out.println(\"Inside thread\")).start();<\/pre><\/div><p> 在很多有用的地方，函数式接口可以与 lambda 表达式无缝集成。函数式接口是一项重大创新，因为它与已有的 Java 模式能够完美融合。<\/p><h4 id=\"dm\">默认方法<\/h4><p> 借助 Java 8，您还可以在接口上声明<em>默认方法<\/em>。默认方法就是公共的非抽象非静态方法（有方法体），在接口类型中进行声明，并使用\n                <code>default<\/code> 关键字进行标记。每个默认方法都自动被添加给实现接口的类 &#8212;\n                一种使用默认功能修饰类的便捷方法。例如，<code>Comparator<\/code> 接口现在包含的默认方法超过一打。如果使用 lambda\n                表达式创建一个比较器，我可以轻松创建反转比较器，如清单 5 中所示。<\/p><h5 id=\"listing5\">清单 5. <code>Comparator<\/code>\n                    的默认方法<\/h5><div class=\"codesection\"><pre class=\"displaycode\">List&lt;Integer&gt; n = List.of(1, 4, 45, 12, 5, 6, 9, 101);\nComparator&lt;Integer&gt; c1 = (x, y) -&gt; x - y;\nComparator&lt;Integer&gt; c2 = c1.reversed();\nSystem.out.println(\"Smallest = \" + n.stream().min(c1).get());\nSystem.out.println(\"Largest = \" + n.stream().min(c2).get());<\/pre><\/div><p> 在清单 5 中，我创建了一个 <code>Comparator<\/code> 实例，并使用 lambda 表达式来封装它。然后，我可以通过调用\n                <code>reversed()<\/code> 默认方法来创建一个反转比较器。将默认方法附加给接口的能力模仿了 <em>mixins<\/em>\n                的通常用法（参见 \"<a href=\"http://www.ibm.com/developerworks/cn/java/j-jn8/index.html\">混入和特征<\/a>\" 一文），这是对 Java 语言的一种有益补充。<\/p><h4 id=\"N10177\">可选<\/h4><p> 请注意，在 <a href=\"#listing5\">清单 5<\/a> 中的终端调用中，最后调用了 <code>get()<\/code>。对\n                <code>min()<\/code> 这种内置方法的调用返回一个 <code>Optional<\/code> 而非值。这种行为模仿了 Java\n                下一代的 <em>option<\/em> 特性，正如 \"<a href=\"http://www.ibm.com/developerworks/cn/java/j-jn4/index.html\">Groovy、Scala 与 Clojure 的共性，第 3 部分<\/a>\" 一文的 Scala\n                中一样。<code>Optional<\/code> 可防止方法返回将 <code>null<\/code> 作为错误与\n                <code>null<\/code> 作为合法值进行合并。例如，只有合法结果存在时，Java 8 才可以使用\n                <code>ifPresent()<\/code> 方法来执行代码块。例如，这段代码只会在有值存在时才打印结果：<\/p><div class=\"codesection\"><pre class=\"displaycode\">n.stream()\n    .min((x, y) -&gt; x - y)\n    .ifPresent(z -&gt; System.out.println(\"smallest is \" + z));<\/pre><\/div><p>如果希望执行其他的操作，那么还可以使用 <code>orElse()<\/code> 方法。浏览 Java 8 中的\n                <code>Comparator<\/code> 接口对您了解默认方法有多么强大有很好的启发作用。<\/p><h2 id=\"N101A9\">关于流的更多信息<\/h2><div class=\"ibm-pull-quote ibm-inset\"><blockquote><p><em><span class=\"ibm-pullquote-open\">“<\/span>Java 8 中的流接口及其相关功能是一套经过深思熟虑的扩展集合，可以将 Java\n                    语言带上一个新的层面。<span class=\"ibm-pullquote-close\">”<\/span><\/em><\/p><\/blockquote><p class=\"ibm-pullquote-source\"/><\/div><p> Java 8 中的<em>流<\/em> 抽象概念让很多高级的功能特性变为可能。流在很多方面与集合很像，但也存在关键区别：<\/p><ul class=\"ibm-bullet-list\"><li>流不存储值，更像是从输入源通过终端操作到达目的地的一条管道。<\/li><li>流被设计为是函数式的，而不是状态式的。例如，<code>filter()<\/code>\n                    操作返回经过过滤的值的流，同时不会修改底层集合。<\/li><li>流操作正在尝试尽量变懒（参见 \"<a href=\"http://www.ibm.com/developerworks/cn/java/j-jn12/index.html\"><em>Java 下一代<\/em>：内存化和函数式协同<\/a>\" 和 \"<a href=\"http://www.ibm.com/developerworks/cn/java/j-ft18/index.html\"><em>函数式思维<\/em>：惰性计算，第 1 部分<\/a>\"）。惰性集合仅在必须检索值的时候才会执行操作。<\/li><li>流可以是无限制的。例如，您可以构造一个流来返回所有数字，然后使用诸如 <code>limit()<\/code> 和\n                    <code>findFirst()<\/code> 之类的方法来收集子集。<\/li><li>与 <code>Iterator<\/code> 类似，流在使用时才被充满，在后续再次使用之前，必须重新生成它。<\/li><\/ul><p> 流操作要么是<em>中间<\/em>操作，要么是<em>终端<\/em> 操作。中间操作返回一个新流，并始终是懒惰的。例如，在流上使用\n                <code>filter()<\/code> 操作并不会真正过滤流，而是创建一个只在<em>终端<\/em>\n                操作进行遍历时返回过滤后值的流。终端操作会遍历流，产生值或副作用（如果您编写的函数存在副作用，这会让人气馁）。<\/p><p> 流已经包含很多有用的终端操作。例如，我在<a href=\"https://www.ibm.com/developerworks/cn/views/global/libraryview.jsp?sort_by=&amp;show_abstract=true&amp;show_all=&amp;search_flag=&amp;contentarea_by=Java+technology&amp;search_by=函数式思维&amp;topic_by=-1&amp;type_by=所有类别&amp;ibm-search=搜索\"><em>函数式思维<\/em><\/a> 系列文章中举的数字分类器例子（这个例子也出现在前面的两篇 <a href=\"https://www.ibm.com/developerworks/cn/views/global/libraryview.jsp?sort_by=&amp;show_abstract=true&amp;show_all=&amp;search_flag=&amp;contentarea_by=Java+technology&amp;search_by=Java+下一代&amp;product_by=-1&amp;topic_by=-1&amp;type_by=所有类别&amp;ibm-search=搜索\"><em>Java 下一代<\/em><\/a> 文章中）。清单 6 使用 Java 8 实现了该分类器。<\/p><h5 id=\"listing6\">清单 6. Java 8\n                中的数字分类器<\/h5><div class=\"codesection\"><pre class=\"displaycode\">public class NumberClassifier {\n\n    public static IntStream factorsOf(int number) {\n        return range(1, number + 1)\n                .filter(potential -&gt; number % potential == 0);\n    }\n\n    public static boolean isPerfect(int number) {\n        return factorsOf(number).sum() == number * 2;\n    }\n\n    public static boolean isAbundant(int number) {\n        return factorsOf(number).sum() &gt; number * 2;\n    }\n\n    public static boolean isDeficient(int number) {\n        return factorsOf(number).sum() &lt; number * 2;\n    }\n\n}<\/pre><\/div><p> 如果熟悉我使用其他语言实现的数字分类器版本（参见 \"<a href=\"http://www.ibm.com/developerworks/cn/java/j-ft1/\"><em>函数式思维<\/em>：从功能的角度思考<\/a>\"），您就会注意到清单 6 缺少一个 <code>sum()<\/code>\n                方法声明。在这段代码使用其他语言的所有实现中，我不得不自己编写 <code>sum()<\/code> 方法。Java 8 中提供了一个作为终端操作的\n                <code>sum()<\/code> 方法，这样我就不必再编写它了。通过隐藏可变部分，函数式编程降低了开发人员犯错的可能性。如果我不需要实现\n                <code>sum()<\/code>，也就不会在实现过程中犯错。Java 8 中的流接口及其相关功能是经过深思熟虑的扩展集合，将 Java\n                语言提升到了一个新的层面。<\/p><p> 在数字分类器的其他版本中，我显示了 <code>factors()<\/code>\n                方法的一个优化版本，它只会遍历寻找等于平方根的可能因子，并生成对称的因子。Java 8 <code>factors()<\/code>\n                方法的优化版本如清单 7 中所示。<\/p><h5 id=\"listing7\">清单 7. Java 8\n                中经过优化的分类器<\/h5><div class=\"codesection\"><pre class=\"displaycode\">    public static List fastFactorsOf(int number) {\n        List&lt;Integer&gt; factors = range(1, (int) (sqrt(number) + 1))\n                .filter(potential -&gt; number % potential == 0)\n                .boxed()\n                .collect(Collectors.toList());\n        List factorsAboveSqrt = factors\n                .stream()\n                .map(e -&gt; number / e).collect(toList());\n        factors.addAll(factorsAboveSqrt);\n        return factors.stream().distinct().collect(toList());\n    }<\/pre><\/div><p>即便支持对流进行合并 ，<a href=\"#listing7\">清单 7<\/a> 中的 <code>factorsOf()<\/code>\n                方法无法将两个流合并为一个结果。然而，一旦某个流被遍历，被耗尽资源（这一点与 <code>Iterator<\/code>\n                相同），在再次使用之前，必须重新生成该流。在 <a href=\"#listing7\">清单 7<\/a>\n                中，我使用流创建了两个集合并将结果连接在一起，还添加了对 <code>distinct()<\/code>\n                的调用，以便处理由整数平方根引起的边缘情况。Java 8 中流的强大功能令人印象深刻，包括构建流的能力。 <\/p><h2 id=\"N1022F\">结束语<\/h2><p> 在这篇文章中，我经过研究将 Java 8 称作 Java 下一代语言，而它确实当之无愧。精心设计的流库和聪明的扩展机制（比如默认方法）让大量现有的\n                Java 代码通过极小的代价便能从新功能中获益。<\/p><p> 在下一篇文章中，我将讲述一些在选择语言方面的想法。<\/p><CMA ID: 976004><Site ID: 10><XSLT stylesheet used to transform this file: dw-document-html-7.0.xsl>\r\n\r\n\r\n<\/div>\r\n<\/div>\r\n","createTime":"2014-06-30 00:00:00","deployTime":"2014-06-30 00:00:00","id":0,"intro":"这一期的 Java 下一代文章将通过调查了解 Java 8 版本是否是您的下一个编程语言的合理候选。本文将介绍 lambda 代码块和 streaming API 如何将 Java 升级为一种现代语言。","keyword":"","recommend":false,"source":"http://www.ibm.com/developerworks/cn/java/j-jn15/index.html","title":"Java\n            下一代: 使用 Java 8 作为 Java 下一代语言","typeId":0,"updateTime":"2014-06-30 00:00:00"}
{"author":"","clickNumber":0,"content":"\r\n<div class=\"ibm-columns\">\r\n<div class=\"ibm-col-1-1\">\r\n\r\n<h2 id=\"N1006B\">简介<\/h2><p>IBM&#174; PureApplication&#174; System 随带了一组授权的 Virtual Application\n                Patterns\n                (VAPs)，可用于创建新\n                VAP，并为现有模式库做贡献。这些模式的用户可能需要自定义它们，让它们适合特定的用例，他们可能需要在不更改底层模式实现的情况下执行这种自定义，因为他们可能无法访问模式代码，他们的模式许可可能不允许更改模式定义，或者此模式的其他用户可能想要这种自定义。<\/p><p>在其他情况下，您可能需要自定义多种模式类型，注入与特定模式类型实现无关的跨功能代理。例如，您可能需要将一个剖析代理注入到所有部署在应用服务器上的模式类型中。<\/p><p>本文将展示如何在不接触模式插件代码或更改模式定义的情况下扩展现有 VAPs。文中将展示如何构建一个插件，在 VAP\n                实例上注入和执行自定义代码，以及如何过滤该代码将插入其中的 VAP 实例。本文包含一个示例插件，用于将自定义代码插入到包含\n                WebSphere&#174; Application Server 角色的 VAP 实例中。<\/p><h2 id=\"N1007D\">场景<\/h2><p>本文使用 Web Application Pattern Type VAP 作为插件注入技术的目标。该场景假设 Web Application\n                Pattern 想要在安装 WebSphere Application Server\n                的同一个虚拟机上安装一些额外的二进制文件，然后在应用服务器启动后在它之上执行一些额外的配置。假设这些二进制文件需要将 50 GB 的额外磁盘附加到\n                WebSphere Application Server 虚拟机上，并挂载到文件夹 /dataStorageForAgent\n                上。该示例将展示如何编写一个 TopologyProcessor 实现来重写未解决的拓扑结构模型（vm-templates\n                部分）。TopologyProcessor 实现将过滤掉除包含 WebSphere Application Server 角色的部署外的所有 VAP\n                部署。在包含 WebSphere Application Server 角色的部署上，该实现将添加示例插件脚本包，并注入一个示例插件角色。<\/p><p>通过将示例插件角色 SInstall 添加到 WebSphere Application Server 角色所在的同一个 vm-template\n                节中，插件的生命周期被注入到 WebSphere Application Server 角色所在的相同虚拟机中。因此将调用示例插件部分\n                install.py，而且在插件部分安装步骤中，将从 Storehouse 存储库下载插件二进制文件。示例插件 configure.py\n                脚本将在配置步骤中调用。示例 configure.py 等待应用服务器启动，然后运行一个包含插件二进制文件的示例 shell\n                脚本。该示例还展示了如何使用 TopologyProcessor 注入需要的额外磁盘空间，并将其挂载到指定的文件夹中。<\/p><h2 id=\"N10086\">构建一个 VAP\n                插件，将自定义代码注入到现有模式中<\/h2><p>以下各节将展示如何构建一个 VAP 插件，根据特定的条件将您自己的代码注入到运行的 VAP 实例中。此技术利用了 VAP 转换框架和\n                com.ibm.maestro.model.transform.TopologyProcessor 接口的一个实现，该实现可用于在部署之前处理和转换\n                VAP 拓扑结构。构建 VAP 插件：<\/p><ol type=\"1\"><li>创建一个 VAP 插件和相应的模式类型来捕获自定义代码实现。<\/li><li>在插件配置文件 config.json 中，为辅助模式类型定义个通配符值 “*”，使得该插件能够添加到任何 VAP 部署中。该插件将包含常规\n                    VAP 部分和角色生命周期脚本，比如 install.py、configure.py、start.py 和 stop.py。<\/li><li>创建一个 TopologyProcessor 实现，它将定义一个过滤条件来识别要自定义的 VAP 实例。<\/li><li>对于选择要自定义的实例，更新为解决的拓扑结构 JSON 模型，并包含插件的脚本包和角色。<\/li><li>修改未解决的拓扑结构 JSON 模型，并添加您的代码需要的其他任何定制。例如，您可以修改拓扑结构 JSON\n                    模型，添加一个存储卷，然后将它挂载到一个本地文件夹。<\/li><\/ol><h3 id=\"N10099\">TopologyProcessor<\/h3><p>本文中讨论的代码注入技术是使用 com.ibm.maestro.model.transform.TopologyProcessor\n                接口来实现的，本节将介绍这个接口。后面的几节将介绍插件生命周期脚本，以及包含模式类型二进制文件的插件执行脚本。在 VAP 部署期间，任何参与 VAP\n                和实现 com.ibm.maestro.model.transform.TopologyProcessor\n                接口的插件都可处理和修改拓扑结构定义，使该插件能够将任何自定义配置、角色或包注入到 VAP 拓扑结构中，无需对 VAP\n                模式执行代码更改或更改虚拟应用程序生成器中的模式定义。<\/p><p>在部署期间，PureApplication System 部署框架调用插件的 TopologyProcessor 实现中提供的公共\n                JSONObject processTopology(JSONObject topology)\n                方法。该拓扑结构对象方法签名表示要部署的实例的未解决的拓扑结构模型 TopologyProcessor 的插件实现可更改这个未解决的 JSON\n                模型，然后将更新的模型返回到部署框架。该框架使用返回的已更新拓扑结构 JSON 模型来部署实例。<\/p><p>本文提供了示例用例的 TopologyProcessor 实现。如清单 1 所示，processTopology(JSONObject\n                topology) 方法中的代码首先寻找拓扑结构对象中的 vm-templates 节，以验证部署的实例是否拥有 WebSphere\n                Application Server 角色：<\/p><h5 id=\"N100A5\">清单 1. 验证 WebSphere Application Server\n                    角色是否包含在部署中<\/h5><div class=\"codesection\"><pre class=\"displaycode\">private final String[] agentInjectToRoles = new String[] {\"WAS\"};\nJSONArray templates = (JSONArray)topology.get(\"vm-templates\");\nfor (Object obj : templates) {\t\n   if( injectPlugin(template) ) {\n      .... inject the sample plug-in role and package here ....\n      .... also add new disk and mount to vm folder here ....\n      }\n}\n/** \n * Return true here if you want the plug-in to attach to this type of role \n */\nprotected boolean injectPlugin(JSONObject template)\n{\n   JSONArray rolesArray = (JSONArray)template.get(\"roles\");\n   if (rolesArray == null) {\n      return false;    \n   }    \n   for (Object roleObj : rolesArray) { \n      JSONObject role = (JSONObject) roleObj;\n      if(role.get(\"type\") != null) { \n         String roleType = role.get(\"type\").toString(); \n         for(String agentInjectRole : agentInjectToRoles) {\n            if( roleType.equals(agentInjectRole))\n               return true;\t\n          }\n      } \n   }  \n   return false;  \n}<\/pre><\/div><p>然后，如果 vm-template 包含 WebSphere Application Server 角色，那么该代码会添加示例插件角色和脚本包，如清单\n                2 所示。 示例插件生命周期脚本在实例激活期间调用。<\/p><h5 id=\"N100AD\">清单 2.\n                添加角色和脚本包<\/h5><div class=\"codesection\"><pre class=\"displaycode\">addRoles(template, new JSONObject[] { sagentRole });\naddPackages(template, new String[] { \"SInstall\" });<\/pre><\/div><p>该代码还修改了拓扑结构模型定义，以便添加一个新磁盘，并将它挂载到 /dataStorageForAgent 挂载点上，如清单 3 所示：<\/p><h5 id=\"N100B5\">清单 3.\n                添加新磁盘<\/h5><div class=\"codesection\"><pre class=\"displaycode\">JSONArray vmStorage = null;\nif(template.get(\"storage\") == null) {\n   vmStorage = new JSONArray();\n   template.put(\"storage\", vmStorage);\n}\nelse {\n   vmStorage = (JSONArray) template.get(\"storage\");\n} \naddVMStorage(vmStorage, \"ext-sagentSt1\", \"/dev/sdb\",\n   \"/dataStorageForAgent\");<\/pre><\/div><h2 id=\"N100BA\">示例 VAP 插件<\/h2><p>除了 TopologyProcessor 实现之外，示例插件还定义了以下生命周期脚本和配置文件。有关 VAP\n                生命周期脚本和如何使用它们的更多信息，请参阅文章底部的 <a href=\"#resources\">参考资料<\/a>。<\/p><h3 id=\"N100C5\">config.json<\/h3><p>此配置文件定义了此插件所属的模式类型。清单 4 显示了示例的配置文件。该插件将 SimpleInstallAgent\n                定义为主要的模式类型。此模式类型用于将插件导入 PureApplication System 中，并在必要时刷新插件。该配置还定义了一个辅助模式\n                “*”，则会意味着此插件可由系统中的任何模式类型使用。通过拥有一个辅助模式 “*”，插件可附加到任何已部署的 VAP 实例。<\/p><h5 id=\"N100CD\">清单 4.\n                示例插件配置文件<\/h5><div class=\"codesection\"><pre class=\"displaycode\">\"name\": \"sagent\",\n\"version\": \"1.0.0.0\",\n\"patterntypes\": {\n   \"primary\": {\n      \"SimpleInstallAgent\": \"1.0\"\n   },\n   \"secondary\":[\n      {\n      \"*\":\"*\"\n      }\n   ] \n}<\/pre><\/div><h3 id=\"N100D2\">install.py<\/h3><p>部分安装脚本从 Storehouse 存储库下载插件二进制文件并解压该文件，然后将它们转移到 /home/virtuser 文件夹下，如清单 5\n                所示：<\/p><h5 id=\"N100DA\">清单 5.\n                部分安装脚本<\/h5><div class=\"codesection\"><pre class=\"displaycode\"># Copy your binary from storehouse into /tmp/downloads\ndownloadPath = '/tmp/downloads'\nlogger.debug('creating directory: ' + downloadPath);\nmaestro.trace_call(logger, ['mkdir', downloadPath])\nstorehousePath = 'SAgentBinaries/SampleContent.tar.gz'\nlogger.debug('start downloading AGENT install binaries from storehouse:\n   %s to local folder: %s' % (storehousePath, downloadPath))\n# Maestro unzip your binary into the location (downloadPath) you specified\ninstallerUrl = urlparse.urljoin(maestro.filesurl, storehousePath)\t\nmaestro.downloadx(installerUrl, downloadPath)\nlogger.debug('AGENT binaries download completed complete')\n# move myproductInstall.sh script to /home/idcuser/ProductFolder\nlogger.debug('move scripts from /tmp/downloads to /home/virtuser ')\nargs=['mv', '/tmp/downloads/ProductFolder', '/home/virtuser']\nlogger.debug(args)\nrc = maestro.trace_call(logger, args)\nmaestro.check_status(rc, 'Failed to move ProductFolder folder')<\/pre><\/div><h3 id=\"N100DF\">configure.py<\/h3><p>此脚本在 /opt/IBM 文件夹下寻找 WebSphere Application Server\n                startServer.log，并等待一个可用的日志。在找到该文件后，该脚本每隔 60 秒检查是否在文件中找到了消息 “Open for\n                e-business”。找到此消息后，该脚本会使用 WebSphere Application Server 管理员用户凭据调用插件配置脚本\n                /home/virtuser/ProductFolder/productConfigure.sh。productConfigure.sh\n                简单地列出了可用的 Java 虚拟机 WebSphere Application Server API。清单 6 显示了 confgure.py\n                中的代码：<\/p><h5 id=\"N100E7\">清单 6.\n                角色配置脚本<\/h5><div class=\"codesection\"><pre class=\"displaycode\">template = maestro.node['template']\nuser_id=''\nuser_pwd=''\nif 'roles' in template:\n   roles = template['roles']\n   for role in roles:\n      if 'name' in role and role['name'] == 'DMGR' and 'parms' in role:\n         logger.debug('DMGR parms are %s' % role['parms'])\n         for key in role['parms']:\n            roleParms = role['parms'][key]\n            if key == 'dmgr_user':\n               user_id = roleParms\n            elif key == 'dmgr_pwd':\n               user_pwd = str(maestro.decode(roleParms))\n            elif 'name' in role and role['name'] == 'WAS' and 'parms' in role:\n               logger.debug('WAS parms are %s' % role['parms'])\n               for key in role['parms']:\n                  roleParms = role['parms'][key]\n                  if key == 'USERID':\n                     user_id = roleParms\n                  elif key == 'PASSWORD':\n                     user_pwd = str(maestro.decode(roleParms))\nlogPath=''\nmatches = []\nwhile len(matches) == 0:\n   for root, dirnames, filenames in os.walk('/opt/IBM'):\n      for filename in fnmatch.filter(filenames, 'startServer.log'):\n         matches.append(os.path.join(root, filename))\n   time.sleep(60)\nif len(matches) &gt; 0:\n   logPath = '%s' % matches[0]\nwasInstalled = False\nwhile wasInstalled == False:\n   logger.debug('wait for the WAS server to start')\n   if os.path.isfile(logPath):\n      logger.debug('startServer.log file found, check status')\n      with open(logPath, 'r') as content_file:\n          content = content_file.read()\n          if content.rfind('open for e-business') != -1:\n             wasInstalled = True\n          else:\n             logger.debug('WAS start log content does not contain open\n                 for e-business message, wait')          \n   else:\n      logger.debug('%s file not found, wait' % logPath)\n   if wasInstalled == False:\n      time.sleep(60)\nlogger.debug(\"WAS server is running, configure the agent now\")\nconfigscript = '/home/virtuser/ProductFolder/productConfigure.sh'\n# run productConfigure.sh script\nargs=[configscript, user_id, user_pwd]\nlogger.debug('user_id is %s ' % user_id)\nrc = maestro.trace_call(logger, args)\nmaestro.check_status(rc, 'Failed to run install scripts')<\/pre><\/div><h2 id=\"N100EC\">示例 VAP 模式类型<\/h2><p>模式类型 exportSimpleInstallAgent-1.0.0.0.tgz 将示例二进制文件包装在\n                files/SampleContent.tar.gz 下。如果下载附加的示例并使用任何有效的解压工具打开此文件，您就会看到该 tar\n                归档文件包含以下文件：<\/p><ul class=\"ibm-bullet-list\"><li><strong>productInstall.sh<\/strong>：该示例 shell 脚本展示如何使用脚本来从 parts\n                    install.py 生命周期脚本安装产品二进制文件。此脚本将在示例角色 SInstall 配置步骤之前执行。<\/li><li><strong>productConfigure.sh<\/strong>：该示例 shell\n                    脚本展示如何使用应用服务器管理员凭据执行应用服务器配置。此 shell 脚本由 SInstall 角色 configure.py\n                    生命周期脚本调用。此脚本接受两个参数：WebSphere Application Server 管理员用户 ID 和密码。此脚本调用\n                    listJvm.py 来列出 JVM。清单 7 演示了 productConfigure.sh 脚本。<\/li><\/ul><h5 id=\"N100FD\">清单 7.\n                示例应用服务器配置<\/h5><div class=\"codesection\"><pre class=\"displaycode\">#!/bin/sh\nUSER_ID=$1\nUSER_PWD=$2\necho \"Configure the product \"\nWAS_BIN=`find /opt/IBM -name wsadmin.sh`\necho \"WAS_BIN=$WAS_BIN\"\necho \"Configure agent\"\nDIR_NAME=$(dirname $0)\necho $DIR_NAME\npushd $DIR_NAME\necho \"List JVM \"\n$WAS_BIN/wsadmin.sh -user $USER_ID -password $USER_PWD -f /home/virtuser/ProductFolder/listJvm.py\necho \"End List JVM \"\npopd<\/pre><\/div><p>将模式类型导入 PureApplication System 中时，二进制文件的 tar 归档文件将被上传到 Storehouse\n                存储库。Storehouse for PureApplication System 是一个包含系统和 VAP 工作负载工件的存储库。<\/p><p>要查看存储在 Storehouse 存储库中的工件，可导航到 <strong>Workload console =&gt; System =&gt;\n                    Storehouse Browser<\/strong>。 请注意，只有能够访问 System 菜单的用户才能查看 Storehouse\n                Browser。<\/p><p>Storehouse 存储库可用于存储产品二进制文件，可在实例激活期间通过 VAP 实例进行访问。在以下段略中，您将看到如何使用 Storehouse\n                存储库存储示例插件二进制文件。<\/p><h2 id=\"N1010B\">将插件二进制文件上传到 Storehouse\n                存储库<\/h2><p>产品二进制文件可上传到 Storehouse 存储库，方法是将该二进制文件与包含 VAP 插件的模式类型包装在一起。我们将使用这种方法将示例二进制文件\n                SampleContent.tar.gz 上传到以下 Storehouse\n                存储库位置：/admin/files/SAgentBinaries/。<\/p><p>要将二进制文件 SampleContent.tar.gz 与模式类型包装在一起，首先需要定义模式类型中的文件夹格式，如图 1 所示。请注意，根据执行\n                Ant 脚本 addStorehouseFiles.xml 的需要，二进制归档文件位于文件夹\n                \\patterntype.sagent\\storehouse\\files\\SAgentBinaries 下，稍后将会解释这一点。 <\/p><h5 id=\"fig01\">图 1. 模式类型结构<\/h5><img alt=\"模式类型结构\" src=\"/sunshine_new/images/2020050871/images/fig01.jpg\" width=\"264\" /><p>放置二进制归档文件后，执行以下步骤来创建模式类型归档文件\n                \\patterntype.sagent\\exportSimpleInstallAgent-1.0.0.0.tgz：<\/p><ol><li>构建模式类型和插件代码。要构建模式类型和插件而不使用二进制文件，请右键单击 patterntype.sagent 并选择\n                        <strong>IBM Pattern Toolkit =&gt; Build<\/strong>。<\/li><li>运行 \\patterntype.sagent\\addStorehouseFiles.xml：右键单击\n                    \\patterntype.sagent\\addStorehouseFiles.xml 并选择 <strong>运行 As =&gt; Ant\n                        Build<\/strong>，将二进制文件添加到模式类型归档文件中。执行这个 Ant\n                    脚本将生成一个具有合适的文件夹结构的模式类型，从而将二进制文件上传到 Storehouse 存储库位置\n                    /admin/files/SAgentBinaries/。执行此步骤后，如果使用任何归档文件解压工具打开构建的模式类型，效果如图 2\n                    所示。该归档文件包含一个 files 文件夹，其中包含二进制文件 SampleContent.tar.gz。 <h5 id=\"fig02\">图 2. 包含 Storehouse\n                            二进制文件的模式类型归档文件<\/h5><img alt=\"包含 Storehouse 二进制文件的模式类型归档文件\" src=\"/sunshine_new/images/2020050871/images/fig02.jpg\" width=\"297\" /><\/li><li>构建模式类型后，就可以将它导入 PureApplication System 中。转到 Workload Console，然后选择\n                        <strong>Cloud =&gt; Pattern Types<\/strong> 链接。使用\n                        <strong>plus<\/strong> 操作导入模式类型 tar 文件，该文件位于\n                    /patterntype.sagent\\export\\SimpleInstallAgent-1.0.0.0.tgz\n                    下。如果导入成功，那么您会在 Storehouse Browser 中看到 SampleContent.tar.gz，如图 3 所示。 <h5 id=\"fig03\">图 3. 导入模式类型后的 Storehouse 内容<\/h5><img alt=\"导入模式类型后的 Storehouse 内容\" src=\"/sunshine_new/images/2020050871/images/fig03.jpg\" width=\"339\" /><\/li><\/ol><h2 id=\"N10144\">使用示例<\/h2><p>本文提供了以下示例模式类型（包含源代码）：patterntype.sagent-1.0.0.0.tgz<\/p><p>将 patterntype.sagent-1.0.0.0.tgz 导入 IBM PureApplication System 中后，您会看到一个文件\n                /admin/files/SAgentBinaries/SampleContent.tar.gz 被添加到 Storehouse Browser\n                中，如图 3 所示。您还应该在 <strong>Workload Console =&gt; Cloud =&gt; Pattern\n                    Types<\/strong> 下看到名为 sample.sagent-1.0 的模式类型。<\/p><p>导入并启用模式类型 sample.sagent-1.0 后，部署 Web Application 模式类型的一个实例。部署 Web\n                Application 模式类型后，执行以下步骤，验证示例插件角色 SInstall 是否已附加到运行 WebSphere Application\n                Server 的虚拟机上：<\/p><ol><li>在部署的实例的<strong>虚拟机透视图<\/strong>上，单击 Web Application 虚拟机的\n                        <strong>Middleware Status<\/strong> 列下的 <strong>Show more<\/strong>\n                    链接。您将会看到 SInstall 角色，如图 4 所示，它是示例插件定义的角色。 <h5 id=\"fig04\">图 4. 附加到 WebSphere Application Server\n                            实例的示例角色<\/h5><img alt=\"附加到 WebSphere Application Server 实例的示例角色\" src=\"/sunshine_new/images/2020050871/images/fig04.jpg\" width=\"715\" /><\/li><li>在同一个虚拟机上，单击 <strong>Log<\/strong> 链接。验证是否有一个针对 SInstall 角色的\n                    trace.log。打开此日志（如图 5 所示）并检查示例插件代码是否已按预期调用。 <h5 id=\"fig05\">图 5.示例插件跟踪日志<\/h5><img alt=\"示例插件跟踪日志\" src=\"/sunshine_new/images/2020050871/images/fig05.jpg\" width=\"499\" /><\/li><li>在 WebSphere Application Server 实例上，使用 <strong>Manage =&gt; Operations\n                        =&gt; ssh<\/strong> 链接添加一个 ssh 密钥，然后使用 virtuser 作为用户名通过 ssh\n                    登录到系统中。执行如图 6 所示的命令 df -h，验证是否能看到一个 50GB 的额外磁盘被附加到\n                    /dataStorageForAgent。 <h5 id=\"fig06\">图 6. 示例挂载文件夹<\/h5><img alt=\"示例挂载文件夹\" src=\"/sunshine_new/images/2020050871/images/fig06.jpg\" width=\"732\" /><\/li><\/ol><h2 id=\"N10183\">结束语<\/h2><p>本文介绍了一种自定义现有 VAP 模式并注入您的自定义代码的技术，它不需要更改现有模式插件代码或模式定义。此技术涉及到创建一个实现\n                TopologyProcessor 接口的新插件，以及创建合适的辅助模式配置，以便可以将该插件用于所有 VAP 模式部署。通过使用\n                TopologyProcessor 扩展，您了解了如何在部署期间更新任何 VAP 实例的拓扑结构定义，以及如何注入新插件角色和磁盘。<\/p><CMA ID: 976095><Site ID: 10><XSLT stylesheet used to transform this file: dw-document-html-7.0.xsl>\r\n\r\n\r\n<\/div>\r\n<\/div>\r\n","createTime":"2014-06-30 00:00:00","deployTime":"2014-06-30 00:00:00","id":0,"intro":"本文将介绍如何构建一个 Virtual Application Pattern (VAP) 插件，在模式部署时将自定义代码注入现有 VAP 中。此技术支持自定义或扩展 VAP，无需更改模式代码或定义，并在 VAP 实例上运行您的自定义代码。","keyword":"","recommend":false,"source":"http://www.ibm.com/developerworks/cn/cloud/library/cl-ps-aim1402-ipasvap/index.html","title":"使用 IBM PureApplication System 将自定义代码注入 Virtual Application Patterns\n            中","typeId":0,"updateTime":"2014-06-30 00:00:00"}
{"author":"","clickNumber":0,"content":"\r\n<div class=\"ibm-columns\">\r\n<div class=\"ibm-col-1-1\">\r\n\r\n<h2 id=\"1.简介 |outline\">简介<\/h2><p>AngularJS 是一款来自 Google 的前端 JavaScript 框架，也是\n    SPA（single-page-application，单页应用）框架。AngularJS 框架的体积非常小，但是设计理念和功能却非常强大，极大地简化前端开发的负担，它快速成为了 JavaScript 的主流框架，帮助开发者从事 web 开发。<\/p><h3 id=\"1.1.SPA，MVC|outline\">SPA 和 MVC<\/h3><p>SPA：单页面应用是指用户通过浏览器加载独立的 HTML 页面并且无需离开此导航页面。对用户操作来说，一旦加载和执行单个页面应用程序通常会有更多的响应，这就需要返回到后端 Web 服务器，而单页面应用为用户提供了一个更接近本地移动或桌面应用程序的体验，这就是单页面应用的优势所在。<\/p><p>MVC：模型(model)－视图(view)－控制器(controller)的缩写，一种软件设计典范，用一种业务逻辑、数据、界面显示分离的方法组织代码，将业务逻辑聚集到一个部件里面，在改进和个性化定制界面及用户交互的同时，不需要重新编写业务逻辑。MVC 被独特的发展起来用于映射传统的输入、处理和输出功能在一个逻辑的图形化用户界面的结构中。<\/p><h3 id=\"1.2.基本概念 |outline\">基本概念<\/h3><p>针对客户端应用开发的 AngularJS 吸收了传统的 MVC 基本原则，但并不只是传统意义上的 MVC，更接近于 MVVM（Model-View-ViewModel)。<\/p><p>Model：是应用中的数据，一般是简单的 JavaScript 对象。<\/p><p>ViewModel：是一个用来提供特别数据和方法从而维护指定 View 的对象。<\/p><p>View：是 AngularJS 解析后渲染和绑定后生成的 HTML，它能帮助您创建 web 应用的架构。<\/p><p>$scope(作用域)：是 AngularJS 中的一个 JavaScript 对象，这个对象使用简单的 API 来侦测和广播状态变化。在这里就是要将域模型暴露给视图<code>(<\/code>模板<code>),<\/code>只需把属性设置给$scope 实例，就可以在模板渲染时得到这个值。<\/p><p>$scope 也可以针对特定的视图来扩展数据和特定的功能，只要在$scope 实例上定义一些函数就能将特定的 UI 逻辑暴露给模板。<\/p><p>Controller（控制器）：控制器的首要任务就是初始化$scope 对象。在实践中，初始化的逻辑由下面的这些责任组成：提供模型初始化的值；扩展$scope UI 行为（方法）。<\/p><p>控制器都是普通的 JavaScript 函数，它们并不必去继承一些框架特定提供的类，也不必去调用任何特定的 AngularJS API 才能去正确地执行它们的任务。<\/p><p>Directive(指令)：指令可以用来创建自定义的标签，它们可以用来装饰元素或者操作 DOM 属性，也可以作为标签、属性、注释和类名使用。<\/p><h3 id=\"1.3.使用 AngularJs 的几个理由 |outline\">使用 AngularJs 的几个理由<\/h3><p>简单容易上手，将会由下个章节的几个例子来证明 AngularJs 的简单易用。<\/p><p>有谷歌团队支持的开源框架。<\/p><p>非常全面，涵盖了 Unit Test、HTML 模板、数据绑定等性质，是一个非常快速的前端开发解决方案。<\/p><h2 id=\"2.实践教程 |outline\">实践教程<\/h2><h3 id=\"2.1.在 HTMLpage 里面加入 AngularJS|outline\">在 HTML page 里面加入 AngularJS<\/h3><p>在您的 JavaScript 文件中加入以下代码，即可使用 AngularJS。<\/p><h5 id=\"2.1.1.清单 1.加入 AngularJS 引用 |outline\">清单 1.加入 AngularJS 引用<\/h5><div class=\"codesection\"><pre class=\"displaycode\">&lt;script type=\"text/javascript\" src=\"https://ajax.googleapis.com/ajax/libs/angularjs/1.2.3/angular.min.js\"\n&gt;&lt;/script&gt;<\/pre><\/div><h3 id=\"2.2.从双向数据绑定开始 |outline\">从双向数据绑定开始<\/h3><p>双向数据绑定是 AngularJS 的一个重要特性，它提供了一个简单的机制，能够让您通过{{ 表达式 }}这个形式轻松地绑定数据到 HTML 上，请看下面这个简单的数据绑定的例子。<\/p><a id=\"OLE_LINK13\"><\/a><h5 id=\"2.2.1.清单 2.双向数据绑定 |outline\">清单 2.双向数据绑定<\/h5><div class=\"codesection\"><pre class=\"displaycode\"><strong>index.html<\/strong>\n!DOCTYPE html&gt;&lt;html&gt;\n&lt;head&gt;\n&lt;/head&gt;\n&lt;body&gt;\n  &lt;div ng-app=\"\"&gt;\n    &lt;input type=\"text\" ng-model=\"data.message\"&gt;\n    &lt;h1&gt;{{data.message + \" world\"}}&lt;/h1&gt;\n  &lt;/div&gt;\n  &lt;script type=\"text/javascript\" \nsrc=\"https://ajax.googleapis.com/ajax/libs/angularjs/1.2.3/angular.min.js\"&gt;&lt;/script&gt;\n&lt;/body&gt;\n&lt;/html&gt;<\/pre><\/div><p>在最外层的 div 中设置了一个 ng-app 属性(少了这个属性，AngularJS 就没办法工作)， 一般这个属性表明这个元素已经这个元素内部的所有元素都是属于设定的这个 app 的。在后面我们会详细说到 ng-app 这个属性。<\/p><p>在这个 div 内部，设置了一个 input，并对 data.message 这个 Model 做双向数据绑定。最后，使用{{data.message}}告诉 AngularJS 在指定的 HTML 处显示 data.message 这个 Model 的数据，也就是用户输入的数据。<\/p><p>就这么几句话，就已经是完成了一个本来要耗费多得多的时间和代码来开发的动态应用。在这里，我们不需要给双向数据绑定写任何规则，不需要给更新 Model 和 View 写任何代码，甚至不需要编写任何 Model。事实上，我们根本都还没开始碰 JavaScript。我们不需要写代码，直到我们想开发更个性化的应用行为为止。<\/p><h3 id=\"2.3.controller 和$scope 的使用 |outline\">controller 和$scope 的使用<\/h3><p>controller 在 AngularJS 里面也是非常重要的，它把数据和前端显示内容联系在一起，这里将会提供一个例子演示 controller 和$scope 的基本用法。<\/p><h5 id=\"2.3.1.清单 3.controller 和$scope|outline\">清单 3.controller 和$scope<\/h5><div class=\"codesection\"><pre class=\"displaycode\"><strong>index.html<\/strong>\n&lt;!DOCTYPE html&gt;\n&lt;html&gt;\n&lt;head&gt;\n   &lt;script type=\"text/javascript\" src=\"main.js\"&gt;&lt;/script&gt;\n&lt;/head&gt;\n&lt;body&gt;\n  &lt;div ng-app=\"\"&gt;\n    &lt;div ng-controller=\"MyFirstCtrl\"&gt;\n      &lt;h1&gt;{{data.message + \" world\"}}&lt;/h1&gt;      \n    &lt;/div&gt;\n&lt;/div&gt;\n     &lt;script type=\"text/javascript\" \nsrc=\"https://ajax.googleapis.com/ajax/libs/angularjs/1.2.3/angular.min.js\"&gt;&lt;/script&gt;\n&lt;/body&gt;\n&lt;/html&gt;\n<strong>main.js<\/strong>\nfunction MyFirstCtrl($scope){\n  $scope.data = {message: \"Hello\"};\n}<\/pre><\/div><a id=\"OLE_LINK2\"><\/a><a id=\"OLE_LINK1\"><\/a><p>使用 ng-controller 这个属性替代上个例子中的 ng-model 属性。\"MyFirstCtrl\"这个 controller 的作用域是当前 div 以及其所有子元素。<\/p><p>在新建的 main.js 中，定义一个叫 FirstCtrl 的处理函数，传入$scope(这个$scope 关联于当前 div 元素及其所有子元素)。<\/p><p>现在我们可以在有 ng-controller= MyFirstCtrl 属性的 DOM 元素的任何子元素里访问这个 data 对象，因为它在$scope 上。<\/p><p>$scope 实际上就是一个 JavaScript 对象，controller 和 view 都可以访问它，所以我们能利用它在两者间传递信息。在这个$scope 对象里，我们既存储数据，又存储将要运行在 view 上的函数。<\/p><h3 id=\"2.4.多个 controller 之间共享数据 |outline\">多个 controller 之间共享数据<\/h3><p>本例将会使用 Service factory 来处理多个 controller 共享数据的问题<\/p><h5 id=\"2.4.1.清单 4.Controller 之间的共享数据 |outline\">清单 4.Controller 之间的共享数据<\/h5><div class=\"codesection\"><pre class=\"displaycode\"><strong>index.html<\/strong>\n&lt;!DOCTYPE html&gt;\n&lt;html&gt;\n&lt;head&gt;\n&lt;/head&gt;\n&lt;body&gt;\n  &lt;div ng-app=\"myApp\"&gt;\n    &lt;div ng-controller=\"MyFirstCtrl\"&gt;\n      &lt;input type=\"text\" ng-model=\"data.message\"&gt;\n      &lt;h1&gt;{{data.message}}&lt;/h1&gt;\n    &lt;/div&gt;\n    &lt;div ng-controller=\"MySecondCtrl\"&gt;\n      &lt;input type=\"text\" ng-model=\"data.message\"&gt;\n      &lt;h1&gt;{{data.message}}&lt;/h1&gt;\n    &lt;/div&gt;\n  &lt;/div&gt;\n  &lt;script type=\"text/javascript\" \nsrc=\"https://ajax.googleapis.com/ajax/libs/angularjs/1.2.3/angular.min.js\"&gt;&lt;/script&gt;\n  &lt;script type=\"text/javascript\" src=\"main.js\"&gt;&lt;/script&gt;\n&lt;/body&gt;\n&lt;/html&gt;\n<strong>main.js<\/strong>\nvar myApp = angular.module('myApp', []);\nmyApp.factory('Data', function() {\n    return {message: \"I'm data from a service\"}\n})\nfunction FirstCtrl($scope, Data){\n  $scope.data = Data;\n}\nfunction SecondCtrl($scope, Data){\n  $scope.data = Data;\n}<\/pre><\/div><p>现在我们定义第一个 app 命名为\"myApp\",它其实就是一个 AngularJS 的模块。[] 代表这个定义的模块没有任何依赖模块。注意，在 HTML 中的名字需要跟 JavaScript 中定义的 app 的名字一致。<\/p><p>有个这个 myApp,我们可以创建一个 factory 来提供我们需要的 service。在这个例子中，我们的 service 名字叫 Data,它返回了一个字符串\"I'm Data from a service\"。刷新页面，可以看到从 service 返回的数据。<\/p><h5 id=\"2.4.2.图 1.运行结果 |outline\">图 1.\n    运行结果<\/h5><img alt=\"运行结果\" src=\"/sunshine_new/images/994663078/image003.jpg\" width=\"239\" /><p>创建一个 service 就是简单的返回一个函数，这个函数返回一个对象。这个对象是在创建应用实例的时候创建的（记住，这个对象是单例对象）。<\/p><p>从这个例子可以看到，两个 controller 之间是完全独立的，并没有 root controller 或者 controller 直接的继承关系，仅仅是把 service 和这个对象传入两个 controller 中。<\/p><h3 id=\"2.5.使用 Filter|outline\">使用 Filter<\/h3><p>过滤器（filter）正如其名，作用就是接收一个输入，通过某个规则进行处理，然后返回处理后的结果。主要用在数据的格式化上，例如获取一个数组中的子集，对数组中的元素进行排序等。ng 内置了一些过滤器，它们是：currency(货币)、date(日期)、filter(子串匹配)、json(格式化 json 对象)、limitTo(限制个数)、lowercase(小写)、uppercase(大写)、number(数字)、orderBy(排序)。总共九种。下面例子是一个自定义的 filter。<\/p><a id=\"2.5.1.清单 5.使用 Filter|outline\"><\/a><p><strong>清单 5. 使用 Filter<\/strong><\/p><div class=\"codesection\"><pre class=\"displaycode\">index.html\n&lt;!DOCTYPE html&gt;\n&lt;html&gt;\n&lt;head&gt;\n&lt;/head&gt;\n&lt;body&gt;\n  &lt;div ng-app=\"myApp\"&gt;\n    &lt;div ng-controller=\"MyFirstCtrl\"&gt;\n      &lt;input type=\"text\" ng-model=\"data.message\"&gt;\n      &lt;h1&gt;{{data.message}}&lt;/h1&gt;\n    &lt;/div&gt;\n    &lt;div ng-controller=\"MySecondCtrl\"&gt;\n      &lt;input type=\"text\" ng-model=\"data.message\"&gt;\n      &lt;h1&gt;{{data.message|reverse}}&lt;/h1&gt;\n    &lt;/div&gt;\n  &lt;/div&gt;\n  &lt;script type=\"text/javascript\" \n  src=\"https://ajax.googleapis.com/ajax/libs/angularjs/1.2.3/angular.min.js\"&gt;&lt;/script&gt;\n  &lt;script type=\"text/javascript\" src=\"main.js\"&gt;&lt;/script&gt;\n&lt;/body&gt;\n&lt;/html&gt;\nmain.js\nvar myApp = angular.module('myApp', []);\nmyApp.factory('Data', function() {\n    return {message: \"I'm data from a service\"}\n})\nmyApp.filter('reverse', function(Data) {\n    return function(text) {\n      return text.split(\"\").reverse().join(\"\") + Data.message;\n  }\n})\nfunction FirstCtrl($scope, Data){\n  $scope.data = Data;\n}\nfunction SecondCtrl($scope, Data){\n  $scope.data = Data;\n  }\n}<\/pre><\/div><p>在 main.js 中加入对 filter 的定义，我们定义了一个名为\"reverse\"的 filter，它的功能是把字符反转然后再加上从上一个清单中讲的 service 中得到的字符串。<\/p><p>我们对 MySecondCtrl 中的文字应用了\"reverse\"这个 filter，&lt;h1&gt;{{data.message|reverse}}&lt;/h1&gt;, 所以在第二个 div 中的文字有了图中所示的效果。<\/p><h5 id=\"2.5.2.图 2.运行结果 |outline\">图 2.运行结果<\/h5><img alt=\"运行结果\" src=\"/sunshine_new/images/994663078/image005.jpg\" width=\"369\" /><h3 id=\"2.6.ng-repeat 指令属性 |outline\">ng-repeat 指令属性<\/h3><p>ng-repeat：在处理一组数据的时候，经常需要把同一个 UI 重复很多次，AngularJS 提供了 ng-repeat 属性来帮助您解决这个问题。<\/p><p>ng-repeat 指令遍历一个数据集合中的每个数据元素，加载 HTML 模版把数据渲染出来。被重复使用的模版元素，就是我们绑定了这个指令属性的 DOM 元素。每一个使用模版渲染的 DOM 元素都有自己的 scope。请看下面这个例子：<\/p><h5 id=\"2.6.1.清单 6.使用 ng-repeat|outline\">清单 6. 使用 ng-repeat<\/h5><div class=\"codesection\"><pre class=\"displaycode\"><strong>i<\/strong><strong>ndex.html<\/strong>\n&lt;!DOCTYPE html&gt;\n&lt;html&gt;\n&lt;head&gt;\n&lt;/head&gt;\n&lt;body&gt;\n  &lt;div ng-app=\"myApp\"&gt;\n      &lt;div ng-controller=\"SecondCtrl\"&gt;\n      &lt;ul&gt;\n      &lt;li ng-repeat=\"person in roommates\" &lt;/li&gt;\n      &lt;/ul&gt;\n  &lt;/div&gt;\n  &lt;/div&gt;\n  &lt;script type=\"text/javascript\" \nsrc=\"https://ajax.googleapis.com/ajax/libs/angularjs/1.2.3/angular.min.js\"&gt;&lt;/script&gt;\n  &lt;script type=\"text/javascript\" src=\"main.js\"&gt;&lt;/script&gt;\n&lt;/body&gt;\n&lt;/html&gt;\n<strong>main.js<\/strong>\nvar myApp = angular.module('myApp', []);\nmyApp.controller('SecondCtrl', function ($scope){\n    $scope.isRed = true;\n    $scope.isGreen = false;\n    $scope.roommates = [\n     { name: 'Lucy'}, \n     { name: 'Lily'},\n     { name: 'Sean'},\n     { name: 'Adam'}\n ];\n});<\/pre><\/div><p>在 HTML 中的 ul 标签上设置 ng-repeat 属性，并用\"person in roomates\"指明集合并做遍历，就可以加载 HTML 模板把集合中的元素都轻松渲染出来。结果如下：<\/p><h5 id=\"2.6.2.图 3.运行结果 |outline\">图 3.\n    运行结果<\/h5><img alt=\"运行结果\" src=\"/sunshine_new/images/994663078/image007.jpg\" width=\"142\" /><h3 id=\"2.7.ng-class 指令属性 |outline\">ng-class 指令属性<\/h3><p>ng-class 可以用来标记某个 class 是否被应用，通常用来处理是否加载某个 css 样式。请看下面这个例子。<\/p><p>更换之前例子中代码的 HTML Body 部分如下：在 HTML 中将每个 li 都设置上 ng-class 属性，且 ng-class=\"{'black':isBlack,'red':isRed}\"，意思是当 isBlack 的值为 true 时，加载 black class，相反 isBlack 的值为 false，不加载 black class。<\/p><h5 id=\"2.7.1.清单 7.使用 ng-class 例子的 html 和 css 部分 |outline\">清单 7. 使用\n    ng-class 例子的 HTML 和 CSS 部分<\/h5><div class=\"codesection\"><pre class=\"displaycode\"><strong>i<\/strong><strong>ndex.html<\/strong>\n&lt;!DOCTYPE html&gt;\n&lt;html&gt;\n&lt;head&gt;\n  &lt;title&gt;AngularJS Tutorials&lt;/title&gt;\n   &lt;link rel=\"stylesheet\" type=\"text/css\" href=\"Style.css\" &gt;\n&lt;/head&gt;\n&lt;body&gt;\n  &lt;div ng-app=\"myApp\"&gt;\n      &lt;div ng-controller=\"SecondCtrl\"&gt;\n      &lt;ul&gt;\n      &lt;li ng-repeat=\"person in roommates\" ng-class=\"{'black':isBlack,'red':isRed}\"&gt;{{person.name}}&lt;/li&gt;\n      &lt;/ul&gt;\n     &lt;button ng-click=\"changeColor()\"&gt;Click Here&lt;/button&gt;\n    &lt;/div&gt;\n  &lt;/div&gt;\n  &lt;script type=\"text/javascript\" \n   src=\"https://ajax.googleapis.com/ajax/libs/angularjs/1.2.3/angular.min.js\"&gt;&lt;/script&gt;\n  &lt;script type=\"text/javascript\" src=\"main.js\"&gt;&lt;/script&gt;  \n&lt;/body&gt;\n&lt;/html&gt;\n<strong>Style.css<\/strong>\n.red {\n color: red;\n}\n.black {\n color: black;\n}<\/pre><\/div><p>isBlack 的值为 true 还是 false，是在 JavaScript 里面决定的。如下所示，我们在初始化时给一个默认值，就是 isBlack 为 true，而 isRed 为 false。当点击了 button 之后触发 changeColor 函数，把 isBlack 的值设为！isBlack, 这样在每次点击 button 后 isBlack 的值都会发生改变，从而 html 上&lt;li&gt;的样式也跟着改变。<\/p><h5 id=\"2.7.2.清单 8.使用 ng-class 例子的 js 部分 |outline\">清单 8. 使用 ng-class\n    例子的 JS 部分<\/h5><div class=\"codesection\"><pre class=\"displaycode\"><strong>main.js<\/strong>\nvar myApp = angular.module('myApp', []);\nmyApp.controller('SecondCtrl', function ($scope){\n       $scope.isBlack = true;\n       $scope.isRed = false;\n  $scope.roommates = [\n   { name: 'Lucy'},\n   { name: 'Lily'},\n   { name: 'Sean'},\n   { name: 'Adam'}\n ];\n $scope.changeColor = function () {\n  $scope.isRed = !$scope.isRed;\n  $scope.isBlack = !$scope.isBlack; \n}\n});<\/pre><\/div><h3 id=\"2.8.ng-click 指令属性 |outline\">ng-click 指令属性<\/h3><p>ng-click：ng-click 指令属性给 DOM 元素注册了一个点击事件的监听器。当此 DOM 元素上有点击事件发生（即当此 button 或 link 被点击时），AngularJS 就会执行表达式的内容，并相应地更新 view。ng-click 指令属性给 DOM 元素注册了一个点击事件的监听器。当此 DOM 元素上有点击事件发生（即当此 button 或 link 被点击时），AngularJS 就会执行表达式的内容，并相应地更新 view。在上面那个例子里，我们给 button 绑定了一个 changColor()的处理函数。 &lt;button ng-click=\"changeColor()\"&gt;Click Here&lt;/button&gt;， 并且在 controller 里面实现了这个函数，这样在 click 这个 button 的时候就会调用对应的 changeColor 函数。<\/p><p>我们也可以用 ng-click 来调用在 controller 里写好并绑定在$scope 上的函数，例如：<\/p><h5 id=\"2.8.1.清单 9.使用 ng-click|outline\">清单 9. 使用 ng-click<\/h5><div class=\"codesection\"><pre class=\"displaycode\">index.html\n&lt;button ng-click=\"sayHello()\"&gt;Say hello&lt;/button&gt;\n<strong>main.js<\/strong> \napp.controller('MyController', function($scope) {\n   $scope.sayHello = function() {\n   alert(\"hello!\");\n   }\n });<\/pre><\/div><h3 id=\"2.9.ng-init 指令属性 |outline\">ng-init 指令属性<\/h3><p>ng-init：它其实是在启动时运行的函数，让我们能够在程序运行前设定初始变量的值。如下例所示，我们初始化了 name 为\"tester\"字符串。<\/p><h5 id=\"2.9.1.清单 10.使用 ng-init|outline\">清单 10. 使用 ng-init<\/h5><div class=\"codesection\"><pre class=\"displaycode\">&lt;b ng-init='name = \"tester\"'&gt;Hello, {{ name }}&lt;/b&gt;<\/pre><\/div><h3 id=\"2.10.第一个 Directive――使用自定义指令属性 |outline\">第一个 Directive――使用自定义指令属性<\/h3><p>Directive 可以让我们创建自定义的指令属性，它可以让用户把自定义的行为绑定在某个 DOM 元素上，或者可以把这个 DOM 元素或其子元素变型。在这里例子中，我们创建了一个自定义指令属性 super。它的行为是返回的是一个 template，就是一个 html 代码段，把这个指令限制在\"E\",也就是元素。<\/p><h5 id=\"2.10.1.清单 11.使用自定义指令属性 Directive|outline\">清单 11. 使用自定义指令属性 Directive<\/h5><div class=\"codesection\"><pre class=\"displaycode\"><strong>index.html\n<\/strong>&lt;!DOCTYPE html&gt;\n&lt;html&gt;\n&lt;head&gt;&lt;/head&gt;\n&lt;body&gt;\n &lt;div ng-app=\"myApp\"&gt;\n &lt;super&gt;&lt;/super&gt;\n &lt;/div&gt;\n &lt;script type=\"text/javascript\"\nsrc=\"https://ajax.googleapis.com/ajax/libs/angularjs/1.2.3/angular.min.js\"&gt;&lt;/script&gt;\n&lt;script type=\"text/javascript\" src=\"main.js\"&gt;&lt;/script&gt;\n&lt;/body&gt;\n&lt;/html&gt;\n<strong>main<\/strong><strong>.js\n<\/strong>var app = angular.module(\"myApp\", []);\napp.directive(\"super\", function() {\n return {\n restrict: \"E\",\n        template: \"&lt;div&gt;This is my first Directive &lt;/div&gt;\"\n }\n})<\/pre><\/div><p>点开网页，可以看到从 Directive 返回的 HTML 段，因为我们设置了 restrict:\"E\",所以看到下图中 super 的子节点元素就是 Directive 返回的 div<\/p><h5 id=\"2.10.2.图 4.运行结果 |outline\">图 4.\n    运行结果<\/h5><img alt=\"运行结果\" src=\"/sunshine_new/images/994663078/image009.jpg\" width=\"381\" /><h3 id=\"2.11.限制您的 Directive――使用 Restrict|outline\">限制您的 Directive――使用 Restrict<\/h3><p>Restrict 用来限制只有满足条件的才可以使用自定义的指令属性，也就是 Directive。一共可以用于以下的四类，E-元素，A-属性，C-样式类，M-注释。下面是一个限制为 A(属性)的例子。<\/p><p>把上例中的&lt;body&gt;内的 div 替换成下面代码<\/p><h5 id=\"2.11.1.清单 12.在您的 Directive 上使用 Restrict|outline\">清单 12. 在您的 Directive 上使用 Restrict<\/h5><div class=\"codesection\"><pre class=\"displaycode\"><strong>i<\/strong><strong>ndex.html<\/strong>\n&lt;div ng-app=\"myApp\"&gt;\n &lt;!-- directive:man --&gt;\n &lt;div super class=\"flash\"&gt;&lt;/div&gt;\n&lt;/div&gt;\n<strong>main.js\n<\/strong>var app = angular.module(\"myApp\", []);\napp.directive(\"super\", function() {\n return {\n restrict: \"A\",\n link: function() {\n alert(\"I'm working stronger\")\n }\n }\n})\n\napp.directive(\"flash\", function() {\n return {\n restrict: \"C\",\n link: function() {\n alert(\"I'm working faster\")\n }\n }\n})\napp.directive(\"man\", function() {\n return {\n restrict: \"M\",\n link: function() {\n alert(\"I'm comment\")\n }\n }\n})<\/pre><\/div><h5 id=\"2.11.2.图 5.运行结果 |outline\">图 5.\n    运行结果<\/h5><img alt=\"运行结果\" src=\"/sunshine_new/images/994663078/image011.jpg\" width=\"232\" /><p>从 HTML 中可以看到 super 是 div 的用户自定义属性，flash 是一个样式类，&lt;!-- directive:man --&gt; 是一段注释，注释必须遵守这个格式。在 JavaScript 里面我们写了三个 directive，分别对应处理 link 后面对应的是处理函数。第一个 directive 限定的是 A（属性），第二个 directive 限定的是 C（样式类），第三个限定的是 M(注释)，用对应的处理函数来处理。可以自己把 JavaScript 中的 restrict A 和 C，M 对调，会看到三个 alert 都不出现。<\/p><h2 id=\"3.总结 |outline\">总结<\/h2><p>我们已经看到了 AngularJS 最基本的用法以及一些简单的例子，还有很多 AngularJS 的精美特性没有提到，感兴趣的请阅读我提供的参考资源。<\/p><CMA ID: 975700><Site ID: 10><XSLT stylesheet used to transform this file: dw-document-html-7.0.xsl>\r\n\r\n\r\n<\/div>\r\n<\/div>\r\n","createTime":"2014-06-26 00:00:00","deployTime":"2014-06-26 00:00:00","id":0,"intro":"AngularJS 是一款来自 Google 的前端 JavaScript 框架，它的设计理念和功能却非常强大，它快速成为了 JavaScript 的主流框架，简化了前端开发的负担，来帮助开发者从事 web 开发。本文将介绍 AnjularJS 中的几个重要概念，并提供简单易懂的例子深入学习 AngularJS。","keyword":"","recommend":false,"source":"http://www.ibm.com/developerworks/cn/web/1406_rentt_angularjs/index.html","title":"Angular.js 介绍及实践教程","typeId":0,"updateTime":"2014-06-26 00:00:00"}
{"author":"","clickNumber":0,"content":"\r\n<div class=\"ibm-columns\">\r\n<div class=\"ibm-col-1-1\">\r\n\r\n<p>Java 8 的最大变化在于添加了对 <em>lambda 表达式<\/em> 的支持。Lambda\n                    表达式是可按引用传递的代码块。它们类似于一些其他编程语言中的<em>闭包<\/em>：它们是实现某项功能的代码，可接受一个或多个输入参数，而且可返回一个结果值。闭包是在一个上下文中定义的，可访问（对于\n                lambda 表达式而言是只读访问）来自上下文的值。<\/p><p>如果您不熟悉闭包，不用害怕。Java 8 lambda 表达式其实是匿名内部类的一种特殊化，而几乎所有 Java\n                开发人员都熟悉匿名内部类。匿名内部类提供了一个接口的内联实现，或者一个基类的子类，我们一般只会在代码中的一个地方使用它。Lambda\n                表达式的使用方式一样，但它有一个简写的语法，使得它们比标准内部类定义更简洁。<\/p><p>在本文中，您将了解如何在各种情形下使用 lambda 表达式，还将了解 Java 语言 <code>interface<\/code>\n                定义的相关扩展。参见 <a href=\"http://www.ibm.com/developerworks/cn/views/java/libraryview.jsp?sort_by=&amp;show_abstract=true&amp;show_all=&amp;search_flag=&amp;contentarea_by=Java+technology&amp;search_by=JVM+%E5%B9%B6%E5%8F%91%E6%80%A7&amp;topic_by=-1&amp;type_by=%E6%89%80%E6%9C%89%E7%B1%BB%E5%88%AB&amp;ibm-search=%E6%90%9C%E7%B4%A2\"><em>JVM\n                        并发性<\/em><\/a> 系列下的姊妹篇 “<a href=\"http://www.ibm.com/developerworks/cn/java/j-jvmc2/index.html\">Java\n                            8 并发性基础<\/a>”，查看使用 lambdas 的更多示例，包括将它们与 Java 8 <em>streams<\/em>\n                特性一起使用的示例。<\/p><h2 id=\"N1006A\">了解 lambdas<\/h2><p>Lambda 表达式始终是 Java 8 称为<em>函数式接口<\/em> 的一个对象的实现：定义单一抽象方法的\n                <code>interface<\/code> 类。对单一抽象方法的限制很重要，因为 lambda 表达式语法不使用方法名。相反，该表达式使用了\n                    <em>duck typing<\/em>（匹配参数和返回类型，就像在许多动态语言中所做的那样）来确保所提供的 lambda\n                与预期的接口方法相兼容。<\/p><p>在清单 1 中的简单示例中，使用了 lambda 来对 <code>Name<\/code> 实例进行排序。<code>main()<\/code>\n                方法中的第一个代码块使用了一个匿名内部类来实现 <code>Comparator&lt;Name&gt;<\/code> 接口，第二个代码块使用了\n                lambda 表达式。（参见 <a href=\"#resources\">参考资料<\/a>，获取本文完整样例代码的链接。）<\/p><h5 id=\"listing1\">清单 1. 匿名内部类与 Lambda\n                表达式的对比<\/h5><div class=\"codesection\"><pre class=\"displaycode\">public class Name {\n    public final String firstName;\n    public final String lastName;\n\n    public Name(String first, String last) {\n        firstName = first;\n        lastName = last;\n    }\n\n    // only needed for chained comparator\n    public String getFirstName() {\n        return firstName;\n    }\n\n    // only needed for chained comparator\n    public String getLastName() {\n        return lastName;\n    }\n\n    // only needed for direct comparator (not for chained comparator)\n    public int compareTo(Name other) {\n        int diff = lastName.compareTo(other.lastName);\n        if (diff == 0) {\n            diff = firstName.compareTo(other.firstName);\n        }\n        return diff;\n    }\n    ...\n}\n\npublic class NameSort {\n    \n    private static final Name[] NAMES = new Name[] {\n        new Name(\"Sally\", \"Smith\"),\n        ...\n    };\n    \n    private static void printNames(String caption, Name[] names) {\n        ...\n    }\n\n    public static void main(String[] args) {\n\n        // sort array using anonymous inner class\n        Name[] copy = Arrays.copyOf(NAMES, NAMES.length);\n        Arrays.sort(copy, new Comparator&lt;Name&gt;() {\n            @Override\n            public int compare(Name a, Name b) {\n                return a.compareTo(b);\n            }\n        });\n        printNames(\"Names sorted with anonymous inner class:\", copy);\n\n        // sort array using lambda expression\n        copy = Arrays.copyOf(NAMES, NAMES.length);\n        Arrays.sort(copy, (a, b) -&gt; a.compareTo(b));\n        printNames(\"Names sorted with lambda expression:\", copy);\n        ...\n    }\n}<\/pre><\/div><p>在 <a href=\"#listing1\">清单 1<\/a> 中，lambda 用于替代一个惯用匿名内部类。这种惯用内部类在实践中都很常见，因此\n                lambda 表达式立即赢得了 Java 8 程序员的器重。（在本例中，内部类和 lambda 都使用在 <code>Name<\/code>\n                类中实现的一个方法来执行比较工作。如果 <code>compareTo()<\/code> 方法代码内联在 lambda\n                中，那么表达式就不怎么简洁了。） <\/p><h2 id=\"N1009B\">标准函数式接口<\/h2><p>新的 <code>java.util.function<\/code> 包定义旨在使用 lambdas 的广泛函数式接口。这些接口分为几大类：<\/p><ul class=\"ibm-bullet-list\"><li>Function：接受一个参数，基于参数值返回结果<\/li><li>Predicate：接受一个参数，基于参数值返回一个布尔值<\/li><li>BiFunction：接受两个参数，基于参数值返回结果<\/li><li>Supplier：不接受参数，返回一个结果<\/li><li>Consumer：接受一个参数，无结果 (<code>void<\/code>)<\/li><\/ul><p>这些类别中大部分都包含几个用于处理基本原始参数或返回类型的变量。许多接口定义可用于组合实例的方法，如清单 2 中所示。<\/p><h5 id=\"listing2\">清单 2. 组合谓词<\/h5><div class=\"codesection\"><pre class=\"displaycode\">// 使用谓词组合删除匹配的名称\nList&lt;Name&gt; list = new ArrayList&lt;&gt;();\nfor (Name name : NAMES) {\n    list.add(name);\n}\nPredicate&lt;Name&gt; pred1 = name -&gt; \"Sally\".equals(name.firstName);\nPredicate&lt;Name&gt; pred2 = name -&gt; \"Queue\".equals(name.lastName);\nlist.removeIf(pred1.or(pred2));\nprintNames(\"Names filtered by predicate:\", list.toArray(new Name[list.size()]));<\/pre><\/div><p><a href=\"#listing2\">清单 2<\/a> 中的代码定义了一对\n                <code>Predicate&lt;Name&gt;<\/code>，一个与名 <em>Sally<\/em> 匹配，第二个与姓\n                    <em>Queue<\/em> 匹配。<code>pred1.or(pred2)<\/code>\n                方法调用构建所定义的组合谓词，方法是依次应用两个谓词，如果两个谓词之一等于 <code>true<\/code>（与 Java 中的逻辑\n                <code>||<\/code> 运算符一样），则返回 <code>true<\/code>。<code>List.removeIf()<\/code>\n                方法应用这个组合谓词从列表中删除匹配的名称。<\/p><p>Java 8 定义了 <code>java.util.function<\/code>\n                接口的许多有用的组合，但组合不一致。谓词变量（<code>DoublePredicate<\/code>、<code>IntPredicate<\/code>、<code>LongPredicate<\/code>\n                和\n                <code>Predicate&lt;T&gt;<\/code>）都定义了相同的组合和修改方法：<code>and()<\/code>、<code>negate()<\/code>\n                和 <code>or()<\/code>。但 <code>Function&lt;T&gt;<\/code>\n                的原始变量不定义任何组合或修改方法。如果您有使用函数式编程语言的经验，那么您可能会发现这些差异和遗漏很古怪。<\/p><h3 id=\"N100F5\">更改 <code>interfaces<\/code><\/h3><p><code>interface<\/code> 类的结构（比如 <a href=\"#listing1\">清单 1<\/a> 中使用的\n                <code>Comparator<\/code>）在 Java 8 中有了变化，部分原因是为了让 lambda 表达式更可用。Java 8\n                之前的接口只能定义常量和稍后必须实现的抽象方法。Java 8 增加了在接口中同时定义 <code>static<\/code> 和\n                <code>default<\/code>\n                方法的能力。一个接口中的静态方法实际上与一个抽象类中的静态方法相同。默认方法更像是旧式的接口方法，但有一个附带的实现，只有在重写方法时才会使用该实现。<\/p><p>默认方法的一个重要特性是，可以将它们添加到一个现有的 <code>interface<\/code>\n                中，同时不会破坏与使用该接口的其他代码的兼容性（除非您的现有代码正好出于另一个目的使用相同的方法名）。这是一个强大的特性，Java 8\n                设计人员使用它来改进对许多预置 Java 库的 lambda 表达式的支持。清单 3 显示一个示例，采用第三种方式对添加到 <a href=\"#listing1\">清单 1<\/a> 代码中的名称进行排序。<\/p><h5 id=\"listing3\">清单 3. 串连 key-extractor\n                    Comparator<\/h5><div class=\"codesection\"><pre class=\"displaycode\">// sort array using key-extractor lambdas\ncopy = Arrays.copyOf(NAMES, NAMES.length);\nComparator&lt;Name&gt; comp = Comparator.comparing(name -&gt; name.lastName);\ncomp = comp.thenComparing(name -&gt; name.firstName);\nArrays.sort(copy, comp);\nprintNames(\"Names sorted with key extractor comparator:\", copy);<\/pre><\/div><p><a href=\"#listing3\">清单 3<\/a> 中的代码首先展示了如何使用新的\n                <code>Comparator.comparing()<\/code> 静态方法来基于您定义的 key-extraction lambda 创建一个\n                Comparator（从技术上来讲，key-extraction lambda 是\n                <code>java.util.function.Function&lt;T,R&gt;<\/code> 接口的一个实例，其中生成的\n                Comparator 的类型在分配时与 <code>T<\/code> 兼容，而且所提取的键类型 <code>R<\/code> 实现了\n                <code>Comparable<\/code> 接口。）另外还展示如何使用新的\n                <code>Comparator.thenComparing()<\/code> 默认方法组合 Comparator，在 <a href=\"#listing3\">清单 3<\/a> 中，该方法返回了一个新\n                comparator，它按照姓氏对第一个数组进行排序，按照名字对第二个数组进行排序。<\/p><p>您可能认为您可以将 comparator 构造函数内联为：<\/p><div class=\"codesection\"><pre class=\"displaycode\">Comparator&lt;Name&gt; comp = Comparator.comparing(name -&gt; name.lastName)\n    .thenComparing(name -&gt; name.firstName);<\/pre><\/div><p>遗憾的是，这对于 Java 8 类型推断不管用。您需要使用以下任意一种形式为编译器提供有关静态方法所返回结果的预期类型的更多信息：<\/p><div class=\"codesection\"><pre class=\"displaycode\">Comparator&lt;Name&gt; com1 = Comparator.comparing((Name name1) -&gt; name1.lastName)\n    .thenComparing(name2 -&gt; name2.firstName);\nComparator&lt;Name&gt; com2 = Comparator.&lt;Name,String&gt;comparing(name1 -&gt; name1.lastName)\n    .thenComparing(name2 -&gt; name2.firstName);<\/pre><\/div><p>第一种形式将 lambda 参数的类型添加到 lambda\n                表达式：<code>(Name name1) -&gt; name1.lastName<\/code>。有了这一协助，编译器就可以了解其余要做的工作是什么。第二种形式将传递给\n                <code>comparing()<\/code> 方法的函数式接口（在本例中由 lambda 实现）的类型 <code>T<\/code> 和\n                <code>R<\/code> 告诉编译器。<\/p><p>轻松构造和串连 comparator 的能力是 Java 8 的一个有用功能，但其代价是增加了复杂性。Java 7\n                <code>Comparator<\/code> 接口定义了两个方法（<code>compare()<\/code> 和保证要为每个对象定义的无处不在的\n                <code>equals()<\/code>）。Java 8 版本定义了 18 个方法（原始的 2 个方法，加上 9 个新静态方法和 7\n                个新的默认方法）。您会发现，为使用 lambdas 而产生的这一大规模接口膨胀模式会在 Java 标准库的相当一部分中重复出现。<\/p><h2 id=\"N1015A\">使用 lambdas 这样的现有方法<\/h2><p>如果有一个现有的方法已经满足了您的需要，那么您可以使用<em>方法引用<\/em> 来直接传递该方法。清单 4 展示了该方法。<\/p><h5 id=\"listing4\">清单 4. 使用 lambdas\n                这样的现有方法<\/h5><div class=\"codesection\"><pre class=\"displaycode\">...\n// sort array using existing methods as lambdas\ncopy = Arrays.copyOf(NAMES, NAMES.length);\ncomp = Comparator.comparing(Name::getLastName).thenComparing(Name::getFirstName);\nArrays.sort(copy, comp);\nprintNames(\"Names sorted with existing methods as lambdas:\", copy);<\/pre><\/div><p><a href=\"#listing4\">清单 4<\/a> 与 <a href=\"#listing3\">清单 3<\/a>\n                中实现的功能一样，不同的是使用了现有的方法。您可以使用 Java 8 <code>ClassName::methodName<\/code>\n                方法引用语法，像使用 lambda 表达式一样使用任意方法。这与定义调用该方法的 lambda 具有完全相同的效果。您可以对静态方法、lambda\n                的特定对象或输入类型的实例方法（如 <a href=\"#listing4\">清单 4<\/a> 所示，其中\n                <code>getFirstName()<\/code> 和 <code>getLastName()<\/code> 方法是所比较的\n                <code>Name<\/code> 的实例方法）以及构造函数使用方法引用。<\/p><p>方法引用不仅使用方便，比起使用 lambda 表达式它们可能更有效，而且对于编译器（这就是为什么在清单 4 最后一部分对比 lambdas 出现问题而使用方法引用工作正常的原因）也提供了更好的类型信息。如果您在使用一个已经存在的方法引用和使用一个 lambda 之间做出选择，您应该总是更倾向于使用方法引用。<\/p><h2 id=\"N10185\">捕获的和非捕获的 lambdas<\/h2><p>本文中您看到的 lambda 示例都是<em>非捕获的<\/em>，也就是说，它们是简单的表达式，仅使用作为接口方法参数的等效值传递进来的值。Java\n                8 中<em>捕获的<\/em> lambdas 使用了所包含的上下文中的值。捕获的 lambdas 类似于其他一些 JVM 语言（包括\n                Scala）中使用的闭包，但不同之处在于，在 Java 8 中，所包含的上下文中的任何值必须是 <em>effectively\n                final<\/em>。即该值必须是真正的 <code>final<\/code>（因为引用自匿名内部类的值必须在早期 Java\n                    版本中）<em>或者<\/em> 在上下文中从未被修改过。这一标准同时适用于 lambda 表达式和匿名内部类使用的值。<\/p><p>您可以使用一些解决方法来应对 effectively final 限制。例如，如果要在一个 lambda\n                表达式中仅使用某些变量的当前值，那么您可以添加一个新方法，接受这些值作为参数，并为 lambda\n                表达式（以适当接口引用的形式）返回捕获的值。如果想要一个 lambda 表达式来修改封闭的上下文中的值，那么可以将该值包装到一个可变容器中。<\/p><p>与捕获的 lambdas 相比，非捕获的 lambdas 可以得到更高效的处理，因为编译器可以将它们生成为包含类中的静态方法，而且运行时可以直接内联调用。捕获的 lambdas 可能效率稍差一点，但在相同的上下文中它的性能应至少与匿名内部类一样。<\/p><h2 id=\"N1019F\">Lambdas 幕后揭秘<\/h2><p>Lambda 表达式看起来非常像匿名内部类，但实现方式不同。Java\n                内部类是庞大的构造函数；一直到字节码级别，每个内部类都有一个独立的类文件。很多数据是重复的（主要采用常量池项的形式），类加载增加了相当大的运行时开销，这一切都只是为了支持少量增加的代码。<\/p><p>Java 8 没有为 lambdas 使用独立的类文件，而是依赖 Java 7 中添加的 <code>invokedynamic<\/code>\n                字节码指令。<code>invokedynamic<\/code> 以一个 bootstrap 方法为目标，该方法在首次被调用时创建 lambda\n                表达式实现。随后，返回的实现被直接调用。这样就避免了独立类文件的空间开销以及加载类的大量运行时开销。lambda 函数究竟是<em>如何<\/em>\n                实现的就交由 bootstrap 来决定。Java 8 当前生成的 bootstrap 代码在运行时为 lambda\n                构建了一个新类，但未来的实现可自由使用不同的方法。<\/p><p> Java 8 结合了一些优化措施，使得通过 <code>invokedynamic<\/code> 进行的 lambdas\n                实现在实践中行之有效。其他大部分 JVM 语言，包括 Scala (2.10.x)，为闭包使用编译器生成的内部类。这些语言的未来版本可能转向\n                <code>invokedynamic<\/code> 方法，以便利用 Java 8（和更高版本）的优化。<\/p><h2 id=\"N101B9\">Lambda 的限制<\/h2><p>正如我在文章开头所提到的，lambda 表达式几乎是一些特殊函数接口的实现。您只可以通过 lambdas 作为接口引用和其他接口的实现，您只可使用一个 lambda 作为将要创建的具体接口。清单 5\n                通过一对相同（除了名称）的函数式接口展示了这一限制。Java 8 编译器接受 <code>String::length<\/code>\n                方法作为两个接口的 lambda 实现。但在将 lambda 定义为第一个接口的实例之后，就不能将其用作第二个接口的实例。<\/p><h5 id=\"listing5\">清单 5. Lambda\n                的限制<\/h5><div class=\"codesection\"><pre class=\"displaycode\">private interface A {\n    public int valueA(String s);\n}\nprivate interface B {\n    public int valueB(String s);\n}\npublic static void main(String[] args) {\n    A a = String::length;\n    B b = String::length;\n\n    // compiler error!\n    // b = a;\n\n    // ClassCastException at runtime!\n    // b = (B)a;\n\n    // works, but ugly (wraps in a new lambda)\n    b = (x) -&gt; a.valueA(x);\n    System.out.println(b.valueB(\"abc\"));\n}<\/pre><\/div><p>Scala 等函数式编程语言使用函数类型（而不是接口）来定义变量。在这种语言中使用<em>高阶函数<\/em>\n                是很常见的事情：高阶函数是将函数作为参数传递或将函数作为值返回的函数。其编程风格要比 lambdas 灵活得多，包括能够将函数作为构建块来组建其他函数。由于 Java 8 没有定义函数类型，所以您不能以这种方式创建 lambdas。您可以创建<em>接口<\/em>（如 <a href=\"#listing3\">清单 3<\/a>\n                所示），但编写的代码仅用于处理所涉及到的特定接口。仅仅在新的 <code>java.util.function<\/code> 程序包中，就专门创建了\n                43 个用于 lambdas 的接口。将这些接口添加到上百个现有接口中，您可以看到构建接口的方式总是受到极大的限制。<\/p><p>在进行使用接口（而不是添加函数类型到 Java）的选择时，一定要深思熟虑。这样做会排除对 Java 库进行重大变动的需要，同时支持对现有的库使用\n                lambda 表达式。这样做的弊端在于，它将 Java 8 限定为所谓的 “接口编程” 或类似函数式的编程，而非真正的函数式编程。但随着 JVM\n                上开始支持其他多种语言，包括函数式语言，这一限制就没那么严重了。<\/p><h2 id=\"N101DA\">结束语<\/h2><p>Lambdas 是 Java 语言的一个重大扩展，而且随着所有 Java 人员将其应用程序迁移到 Java 8，Lambda\n                表达式很快将成为他们不可缺少的一个工具。在与 Java 8 <em>streams<\/em> 结合使用时，Lambdas 特别有用。参阅 “<a href=\"http://www.ibm.com/developerworks/cn/java/j-jvmc2/index.html\">JVM\n                    并发性：Java 8 并发性基础<\/a>”，了解 lambdas 与 Java 8\n                streams 如何共同简化并发编程和提高应用程序性能。<\/p><CMA ID: 975193><Site ID: 10><XSLT stylesheet used to transform this file: dw-document-html-7.0.xsl>\r\n\r\n\r\n<\/div>\r\n<\/div>\r\n","createTime":"2014-06-26 00:00:00","deployTime":"2014-06-26 00:00:00","id":0,"intro":"Java 8 包含一些重要的新的语言功能，为您提供了构建程序的更简单方式。Lamba 表达式为内联代码块定义了一种新语法，其灵活性与匿名内部类一样，但样板文件要少得多。接口更改使得接口可以添加到现有接口中，同时又不会破坏与现有代码的兼容性。本文将了解这些更改是如何协同工作的。","keyword":"","recommend":false,"source":"http://www.ibm.com/developerworks/cn/java/j-java8lambdas/index.html","title":"Java 8 语言变化","typeId":0,"updateTime":"2014-06-26 00:00:00"}
{"author":"","clickNumber":0,"content":"\r\n<div class=\"ibm-columns\">\r\n<div class=\"ibm-col-1-1\">\r\n\r\n<h2 id=\"major1\">从一个传说讲起<\/h2><p>这是一个耳熟能详的传说：传说中，凤凰是人世间幸福的使者，每五百年，它就要背负着积累于人世间的所有不快和仇恨恩怨，投身于熊熊烈火中自焚，以生命和美丽的终结换取人世的祥和和幸福。在肉体经受了巨大的痛苦和轮回后它们才能获得更美好的躯体得以重生。佛教徒把这个故事称为“涅”。<\/p><p>的确，一切苦难和磨砺的尽头也是新的希望开始的地方。作为 IT 从业人员，特别是程序员的你，是否也想过或者期望经历这样的涅呢？如果你曾经或者现在正在经历如下的痛苦，那么 Bluemix 就是为你而准备的。<\/p><ul class=\"ibm-bullet-list\"><li>\n不停的安装各种运行时，容器以及繁杂的第三方依赖包<\/li><li>\n安装并配置一切必须的服务（数据库，移动服务等）<\/li><li>\n将所需的服务与应用进行关联，配置端口/IP/防火墙等<\/li><li>\n建立动态路由以及负载均衡机制<\/li><li>\n保证从底层到应用层各个层次的高可用性<\/li><li>\n确保日志的完整收集和高效分析<\/li><li>\n日常要做好应用的性能监控<\/li><li>\n保证应用可以根据负载的大小进行灵活的伸缩<\/li><li>\n最后，不断的重复着 开发》测试》上线 的轮回<\/li><\/ul><h2 id=\"major2\">Bluemix 带来了什么<\/h2><p>Bluemix 致力于解决上述在软件开发过程中遇到的问题，旨在帮助程序员更快速的开发，测试，部署和运维云平台应用。<\/p><h3 id=\"major3\">什么是 Bluemix？<\/h3><p>简单的讲，Bluemix 就是一个开放的公有云平台，允许程序员在上面运行几乎所有类型的应用，而不用为硬件，软件，网络等其他因素分心。如上文提到，Bluemix 处于云世界的中间层，也就是 PaaS 层。如下图所示：<\/p><h5 id=\"img001\">图 1. Bluemix 扮演的角色<\/h5><img alt=\"图 1. Bluemix 扮演的角色\" src=\"/sunshine_new/images/负1736471717/img001.png\" width=\"429\" /><p>通常来讲，所谓 PaaS 指的是运行在 Iaas 层上的一系列软件服务，并把服务器平台或开发环境作为一种服务提供给用户，也就是“平台即服务”。Bluemix 运行在 IBM 的 IaaS 层产品 Softlayer 之上。Softlayer 在 2013 年被 IBM 收购，其主要为用户提供企业级的 IT 基础设施的建设和解决方案，无论是在性能还是在安全性上都有很高的质量保证，有兴趣的读者可以参考文章最后的资源链接进一步学习。用户的应用程序通过很简单的操作（大部分场景只需要一条简单的命令即可）就能部署应用到 Bluemix 环境里，程序员不需要去关心底层的操作系统，运行时，网络等等一切和 code 本身无关的东西，而可以把全部的精力放到程序的设计和优化上。<\/p><h3 id=\"major4\">选择 Bluemix 的理由<\/h3><p>Bluemix 作为 PaaS 层产品给程序员带来了很多的优势：第一，节省时间和精力，程序员可以把所有的心思都放在应用程序的编写和调优上，而不用去担心繁杂的平台基础架构和设施，更有利于发掘程序员的创造力，开发出更高质量，高性能的应用；第二，加速应用程序上线，在实际的操作中，只需要简单的几条命令或者 UI 界面的几次点击操作就能轻松的完成各种应用程序的部署，而完全不用去担心硬件采购，软件安装等等这些先期准备工作；第三，很容易的满足应用程序对各种新功能和新服务的需求，IBM 及其合作伙伴负责提供优质的服务，程序员只需要简单的“绑定”操作就能将服务加入到应用程序中；第四，Bluemix 支持的语言，运行时，框架等都是程序员已经熟知的，采用 Bluemix 平台几乎不需要增加新的学习成本；最后一点是，Bluemix 底层采用 IaaS 是可以提供企业级需求的 Softlayer，可以有效的保证平台的高性能和高安全性。<\/p><p>目前，Bluemix 正处于公开测试阶段，程序员只需要简单的注册就能轻松的使用 Bluemix 提供的平台云服务。在测试阶段，每个注册账号可以获得 8G 的内存空间用来部署和运行足够多的应用，其中还包括多达 20 个云服务的使用权，注册网址是：www.bluemix.net<\/p><h3 id=\"major5\">Bluemix 运行时和 Buildpacks<\/h3><p>在 Bluemix 中程序运行时是以 Buildpacks 的形式提供给用户的，通过下面这张图，可以了解运行时和 Buildpack 的关系。<\/p><h5 id=\"img002\">图 2. 图解 Buildpack<\/h5><img alt=\"图 2. 图解 Buildpack\" src=\"/sunshine_new/images/负1736471717/img002.png\" width=\"581\" /><p>在 Bluemix 中自带四种 Bludpacks，分别是 Liberty for Java，Node.js，Ruby on Rails，Ruby Sinatra。如果部署的应用是上面四种语言之一，那么在部署应用的时候就不需要指定相应的 Buildpack，平台自身会根据部署的应用类型选择对应的 Buildpack。在本文开始的部分，我们提到 Bluemix 支持几乎所有类型的应用，那么除了上面四种应用，其他类型的应用又是通过什么方法进行部署呢？答案就是在部署应用的时候，明确的指定应用所需的 Buildpack 类型，这些 Buildpack 有的来自社区，有的来自程序员自己的开发，因为 Bluemix 是一个开放的云平台架构，允许第三方根据其标准去做一些客制化的拓展。下图所列的就是目前 Bluemi 支持的运行时类型。<\/p><h5 id=\"img003\">图 3. 运行时（Runtimes）<\/h5><img alt=\"图 3. 运行时（Runtimes）\" src=\"/sunshine_new/images/负1736471717/img003.png\" width=\"582\" /><h3 id=\"major6\">Bluemix 提供的服务（Services）和功能插件（Add-Ons）<\/h3><p>应用程序往往不是单独存在的，它需要额外的附加一些新的价值才能使其丰富起来，在 Bluemix 中这些应用程序的附加值是通过服务（Services）和功能插件（Add-Ons）来实现的。在 Bluemix 中，为程序员提供了分门别类的多种服务，这些服务主要包括：Web 和应用服务，移动开发服务，数据管理服务，大数据，DevOps 服务等等。Bluemix 可以做到以最小的代价将相应的服务添加到应用程序中，以此来丰富应用程序，这些操作既可以通过命令行，也可以通过基于浏览器的 UI 来完成。在使用过程中，用户可以创建多个服务的实例，同样多个应用也可以同时使用同一个服务实例。<\/p><p>功能插件（Add-Ons）可以理解成一种特殊的服务，这些功能插件是为运行时来提供更高层次的附加功能。用户可以根据自己的需求，选择应用是否连接到一个或者多个功能插件上，以此来丰富运行的应用程序。功能插件与服务的不同之处在于，同一个 Space 里，只能有一个功能插件实例，多个应用去连同一种功能插件的时候，实际上连的是同一个插件实例，共享同一份服务资源。<\/p><p>对于服务和功能插件来说，当某一个服务绑定到应用中，或者当应用连接到某一个功能插件上时，关于这个服务和功能插件的相关服务信息就会被写进一个成为“VCAP_SERVICES”的系统环境变量中，用户可以在代码里通过调用 System.getenv(“VCAP_SERVICES”) 来获取具体的信息，这些信息是遵循一定的格式的 JSON 字符串，例如对于某一个数据库的服务，读到的环境变量里主要就是数据库的连接信息，用户可以在应用程序里获取并建立与数据库的连接。<\/p><h2 id=\"major7\">如何使用 Bluemix Java 运行时<\/h2><p>BlueMix 为程序员提供了多种方法开发，测试应用并最终运行在 Bluemix 运行时中，本文主要关注 Bluemix Java 运行时，并向读者介绍最常用的几种方法，其他运行时的使用方法和本文介绍的类似，读者可以自行使用。<\/p><h3 id=\"major8\">使用命令行工具部署和管理应用<\/h3><p>命令行工具一直受大多数程序员欢迎，高效并且高性能，你想在 Bluemix 上做的任何事情，都可以通过命令行工具来完成。比如下面所列，是我们和应用打交道时用到的最频繁的操作。<\/p><ul class=\"ibm-bullet-list\"><li>\n应用的部署，启动，停止，重启以及删除、<\/li><li>\n服务的创建，绑定，以及解除绑定等操作<\/li><li>\n查看和监控应用程序的日志<\/li><\/ul><p>命令行工具的安装也很简便，请首先阅读文章末尾的参考资源安装命令行工具。使用 Bluemix 之前，需要首先注册 Bluemix 账号，访问 www.bluemix.net 注册 Bluemix 账号，当这些都完成以后，让我们开始你的平台云之旅吧！<\/p><p>当使用命令行部署 Java EE 的应用到 Bluemix 的时候，Bluemix 支持三种格式应用的部署，分别是：WAR，EAR 以及直接上载一个 Liberty server 到 Bluemix。除了支持这三种格式的打包文件外，还支持将打包文件解压成目录结构，通过命令行将整个目录结构上传并部署到 Bluemix 环境。我们这里将以一个 WAR 应用为例子来详细讲解每一步的操作，关于其他两种格式的应用的部署与 WAR 应用的部署几乎是一样的，详细介绍请阅读参考资源――部署 Liberty 应用到 Bluemix。<\/p><p><strong>登录 Bluemix<\/strong><\/p><p>使用之前注册的用户名和密码登录到 Bluemix，为部署应用做准备：<\/p><p>首先，使用“cf api”建立于 Bluemix 的连接，连接地址是 https://api.ng.bluemix.net<\/p><h5 id=\"listing1\">清单 1. 连接 Bluemix<\/h5><div class=\"codesection\"><pre class=\"displaycode\">USAGE:\n cf api [URL]\n\nC:\\Users\\IBM_ADMIN&gt;<strong>cf api https://api.ng.bluemix.net<\/strong>\nSetting api endpoint to https://api.ng.bluemix.net...\nOK\n\nAPI endpoint: https://api.ng.bluemix.net (API version: 2.2.0)\nNot logged in. Use 'cf login' to log in.<\/pre><\/div><p>其次，运行“cf login”登录到 Bluemix 并选择所要工作的组织和空间<\/p><h5 id=\"listing2\">清单 2. 登录 Bluemix<\/h5><div class=\"codesection\"><pre class=\"displaycode\">USAGE:\n cf login [-a API_URL] [-u USERNAME] [-p PASSWORD] [-o ORG] [-s SPACE]\n\nC:\\Users\\IBM_ADMIN&gt;cf login\nAPI endpoint: https://api.ng.bluemix.net\n\nUsername&gt; xiuleizh@cn.ibm.com\n\nPassword&gt;\nAuthenticating...\nOK\n\nSelect an org (or press enter to skip):\n1. xiuleizh@cn.ibm.com\n2. OE_Runtimes_SVT\n\nOrg&gt; 1\nTargeted org xiuleizh@cn.ibm.com\n\nTargeted space dev\n\nAPI endpoint: https://api.ng.bluemix.net (API version: 2.2.0)\nUser: xiuleizh@cn.ibm.com\nOrg: xiuleizh@cn.ibm.com\nSpace: dev<\/pre><\/div><p><strong>部署应用到 Bluemix<\/strong><\/p><p>本文提供一个例子应用供大家下载部署使用，这个应用是 HelloWithMongo.war，里面包含了一个简单的 servlet 以及一些对 Non-SQL 数据库 Mongo 的基本操作，在 Bluemix 提供的数据库服务里包含了 Mongo 数据库，我们直接拿来使用。<\/p><p>运行“cf push”命令来部署应用到 Bluemix：<\/p><h5 id=\"listing3\">清单 3. 部署应用到 Bluemix<\/h5><div class=\"codesection\"><pre class=\"displaycode\">USAGE:\n Push a single app (with or without a manifest):\n cf push APP [-b BUILDPACK_NAME] [-c COMMAND] [-d DOMAIN] [-f MANIFEST_PATH]\n [-i NUM_INSTANCES] [-m MEMORY] [-n HOST] [-p PATH] [-s STACK] [-t TIMEOUT]\n [--no-hostname] [--no-manifest] [--no-route] [--no-start]\n\nC:\\Users\\IBM_ADMIN&gt;cf push HelloMongoDW -p C:\\A_Workspace\\apps\\HelloWithMongo.war\nCreating app HelloMongoDW in org xiuleizh@cn.ibm.com / space dev as xiuleizh@cn.\nibm.com...\nOK\n\nUsing route hellomongodw.ng.bluemix.net\nBinding hellomongodw.ng.bluemix.net to HelloMongoDW...\nOK\n\nUploading HelloMongoDW...\nUploading from: C:\\A_Workspace\\apps\\HelloWithMongo.war\n53.4K, 14 files\nOK\n\nStarting app HelloMongoDW in org xiuleizh@cn.ibm.com / space dev as xiuleizh@cn.\nibm.com...\n-----&gt; Downloaded app package (484K)\nOK\n\n\nBuildpack Version: 20140527-0132\n-----&gt; Downloading IBM 1.7.0 JRE from http://file.icap.cdl.ibm.com/icapShared/jr\ne/ibm-java-jre-7.0-6.0-linux-x86_64-small-footprint-uncompressed-jar-20140116.ta\nr.gz (0.0s)\n Expanding JRE to .java (1.2s)\nDownloading from output/wlp/com.ibm.ws.liberty-2014.4.0.0-201405270132.tar.gz ..\n. (0.0s).\nInstalling archive ... (0.6s).\n\n\n\n-----&gt; Uploading droplet (93M)\n\n0 of 1 instances running, 1 starting\n1 of 1 instances running\n\nApp started\n\nShowing health and status for app HelloMongoDW in org xiuleizh@cn.ibm.com / spac\ne dev as xiuleizh@cn.ibm.com...\nOK\n\nrequested state: started\ninstances: 1/1\nusage: 1G x 1 instances\nurls: hellomongodw.ng.bluemix.net\n\n state since cpu memory disk\n#0 running 2014-05-30 06:45:02 PM 0.6% 329.8M of 1G 179.1M of 1G<\/pre><\/div><p>部署成功以后可以运行“cf apps”查看应用的运行状态。在这里有几点需要说明：第一，&lt;app_name&gt;最好要做到唯一，不和部署在 Bluemix 上的其他应用重复，因为默认情况下这个&lt;app_name&gt;会和 domain 组成应用的访问连接，即：&lt;app_name&gt;.ng.bluemix.net，每一个应用的访问连接应该是唯一的，如果不是唯一，部署的过程中会报错提醒，我们只要换一个不一样的名字即可；第二，cf push 命令默认会将当前目录下的所有内容 push 到云端，除非我们显示的使用 Cp 参数显示的指定要部署的内容；第三，从上面的输出中可以看到，应用的访问路径是“urls: hellomongodw.ng.bluemix.net”，即“http:// hellomongodw.ng.bluemix.net”，这也是默认的 Bluemix 中应用的访问路径的统一格式“appname.domain”。<\/p><p><strong>绑定 MongoDB 服务到例子应用<\/strong><\/p><p>这个例子应用使用了 Mongo 数据库，在访问应用之前需要将 Mongo 数据库绑定到已经部署成功的应用中，在 Bluemix 中使用数据库也非常简单，无需安装，无需做任何配置，只需要简单的执行几条命令：<\/p><p>首先，创建一个 Mongo 数据的实例<\/p><h5 id=\"listing4\">清单 4. 创建 Mongo 数据库实例<\/h5><div class=\"codesection\"><pre class=\"displaycode\">USAGE:\n cf create-service SERVICE PLAN SERVICE_INSTANCE\n\nC:\\Users\\IBM_ADMIN&gt;cf create-service mongodb 100 mongo_demo\nCreating service mongo_demo in org xiuleizh@cn.ibm.com / space dev as xiuleizh@c\nn.ibm.com...\nOK<\/pre><\/div><p>如果想要得到某一种服务的 SERVICE PLAN，可以单独运行“cf marketplace”进行查看，当然，也可以查看每个服务的说明文档，这些信息都会在服务提供者提供的使用文档里进行说明。<\/p><p>其次，当创建好数据库实例后，需要运行一个绑定的命令将数据库实例和应用程序进行绑定，比如上面创建的 Mongo 数据库实例 mongo_demo，使用如下命令进行绑定<\/p><h5 id=\"listing5\">清单 5. 绑定 Mongo 数据库和应用程序<\/h5><div class=\"codesection\"><pre class=\"displaycode\">USAGE:\n cf bind-service APP SERVICE_INSTANCE\n\nC:\\Users\\IBM_ADMIN&gt;cf bind-service HelloMongoDW mongo_demo\nBinding service mongo_demo to app HelloMongoDW in org xiuleizh@cn.ibm.com / spac\ne dev as xiuleizh@cn.ibm.com...\nOK\nTIP: Use 'cf push' to ensure your env variable changes take effect<\/pre><\/div><p>当执行完绑定命令后，有的时候我们需要重新运行“cf push”使得数据库的绑定操作生效，操作很简单，仅仅是把之前部署应用的命令重新执行一遍，即：<\/p><h5 id=\"listing6\">清单 6. 重新部署应用<\/h5><div class=\"codesection\"><pre class=\"displaycode\">C:\\Users\\IBM_ADMIN&gt;cf push HelloMongoDW -p C:\\A_Workspace\\apps\\HelloWithMongo.war\n\nUpdating app HelloMongoDW in org xiuleizh@cn.ibm.com / space dev as xiuleizh@cn.\nibm.com...\nOK\n\nUploading HelloMongoDW...\nUploading from: C:\\A_Workspace\\apps\\HelloWithMongo.war\n53.4K, 14 files\nOK\n\nStopping app HelloMongoDW in org xiuleizh@cn.ibm.com / space dev as xiuleizh@cn.\nibm.com...\nOK\n\nStarting app HelloMongoDW in org xiuleizh@cn.ibm.com / space dev as xiuleizh@cn.\nibm.com...\n-----&gt; Downloaded app package (484K)\n-----&gt; Downloaded app buildpack cache (4.0K)\nOK\n\n\nBuildpack Version: 20140527-0132\n-----&gt; Downloading IBM 1.7.0 JRE from http://file.icap.cdl.ibm.com/icapShared/jr\ne/ibm-java-jre-7.0-6.0-linux-x86_64-small-footprint-uncompressed-jar-20140116.ta\nr.gz (0.0s)\n Expanding JRE to .java (1.1s)\nDownloading from output/wlp/com.ibm.ws.liberty-2014.4.0.0-201405270132.tar.gz ..\n. (0.0s).\nInstalling archive ... (0.6s).\nDownloading from output/wlp/com.ibm.ws.liberty.ext-2014.4.0.0-201405270132.tar.g\nz ... (0.0s).\nInstalling archive ... (0.3s).\n-----&gt; Installing client jar(s) from output/serviceClient/mongo-2.10.1.jar (0.0s\n)\n-----&gt; Uploading droplet (119M)\n\n0 of 1 instances running, 1 starting\n0 of 1 instances running, 1 starting\n1 of 1 instances running\n\nApp started\n\nShowing health and status for app HelloMongoDW in org xiuleizh@cn.ibm.com / spac\ne dev as xiuleizh@cn.ibm.com...\nOK\n\nrequested state: started\ninstances: 0/1\nusage: 1G x 1 instances\nurls: hellomongodw.ng.bluemix.net\n\n state since cpu memory disk\n#0 running 2014-06-01 06:35:01 PM 0.7% 331.2M of 1G 212.9M of 1G<\/pre><\/div><p>对比第一次部署应用到 Bluemix 的输出，最明显的变化是多了一些关于 Mongo 数据库的输出，在重新部署的时候，Bluemix 自动安装了 Mongo 数据库的驱动程序，这样应用就可以正常运行了。<\/p><p>在浏览器中输入“http://hellomongodw.ng.bluemix.net”，将会看成如下页面：<\/p><h5 id=\"img004\">图 4. 访问应用主页<\/h5><img alt=\"图 4. 访问应用主页\" src=\"/sunshine_new/images/负1736471717/img004.png\" width=\"581\" /><p>读者可以可以看到有两个连接，点击第一个连接，程序会首先向 Mongo 数据库中插入几条数据，然后将这几条数据检索出来，并在页面进行展现，点击 MongoServlet，应用成功返回如下页面，则说明应用成功运行了。<\/p><h5 id=\"img005\">图 5. 操作 Mongo 数据库<\/h5><img alt=\"图 5. 操作 Mongo 数据库\" src=\"/sunshine_new/images/负1736471717/img005.png\" width=\"356\" /><p>点击第二个连接，程序会打印出环境变量的相关信息，从中，读者可以查看有关 Mongo 数据的连接信息，如下图：<\/p><h5 id=\"img006\">图 6. 打印环境变量<\/h5><img alt=\"图 6. 打印环境变量\" src=\"/sunshine_new/images/负1736471717/img006.png\" width=\"582\" /><p>到这里我们已经成功的在 Bluemix 上部署并运行了一个示例应用，接下来再介绍几个常用的和应用程序相关的命令：<\/p><p><strong>清单 7. 其他常用命令<\/strong><\/p><p>1. 停止，启动以及重启应用<\/p><p>停止：<\/p><div class=\"codesection\"><pre class=\"displaycode\">USAGE:\n cf stop APP\n\nC:\\Users\\IBM_ADMIN&gt;cf stop HelloMongoDW\nStopping app HelloMongoDW in org xiuleizh@cn.ibm.com / space dev as xiuleizh@cn.\nibm.com...\nOK<\/pre><\/div><p>启动：<\/p><div class=\"codesection\"><pre class=\"displaycode\">USAGE:\n cf start APP\n\nC:\\Users\\IBM_ADMIN&gt;cf start HelloMongoDW\nStarting app HelloMongoDW in org xiuleizh@cn.ibm.com / space dev as xiuleizh@cn.\nibm.com...\nOK\n\n0 of 1 instances running, 1 starting\n0 of 1 instances running, 1 starting\n1 of 1 instances running\n\nApp started\n\nShowing health and status for app HelloMongoDW in org xiuleizh@cn.ibm.com / spac\ne dev as xiuleizh@cn.ibm.com...\nOK\n\nrequested state: started\ninstances: 1/1\nusage: 1G x 1 instances\nurls: hellomongodw.ng.bluemix.net\n\n state since cpu memory disk\n#0 running 2014-06-01 09:28:56 PM 0.6% 338.5M of 1G 212.9M of 1G<\/pre><\/div><p>重启：<\/p><div class=\"codesection\"><pre class=\"displaycode\">USAGE:\n cf restart APP\n\nC:\\Users\\IBM_ADMIN&gt;cf restart HelloMongoDW\nStopping app HelloMongoDW in org xiuleizh@cn.ibm.com / space dev as xiuleizh@cn.\nibm.com...\nOK\n\nStarting app HelloMongoDW in org xiuleizh@cn.ibm.com / space dev as xiuleizh@cn.\nibm.com...\nOK\n\n0 of 1 instances running, 1 starting\n0 of 1 instances running, 1 starting\n0 of 1 instances running, 1 starting\n1 of 1 instances running\n\nApp started\n\nShowing health and status for app HelloMongoDW in org xiuleizh@cn.ibm.com / spac\ne dev as xiuleizh@cn.ibm.com...\nOK\n\nrequested state: started\ninstances: 1/1\nusage: 1G x 1 instances\nurls: hellomongodw.ng.bluemix.net\n\n state since cpu memory disk\n#0 running 2014-06-01 09:34:03 PM 0.7% 334.8M of 1G 212.9M of 1G<\/pre><\/div><p>2. 解绑定，删除服务实例<\/p><p>解绑定：<\/p><div class=\"codesection\"><pre class=\"displaycode\">USAGE:\n cf unbind-service APP SERVICE_INSTANCE\n\nC:\\Users\\IBM_ADMIN&gt;cf unbind-service HelloMongoDW mongo_demo\nUnbinding app HelloMongoDW from service mongo_demo in org xiuleizh@cn.ibm.com /\nspace dev as xiuleizh@cn.ibm.com...\nOK<\/pre><\/div><p>删除：<\/p><div class=\"codesection\"><pre class=\"displaycode\">USAGE:\n cf delete-service SERVICE_INSTANCE [-f]\n\nOPTIONS:\n -f Force deletion without confirmation\n\nC:\\Users\\IBM_ADMIN&gt;cf delete-service mongo_demo\n\nAre you sure you want to delete the service mongo_demo ? y\nDeleting service mongo_demo in org xiuleizh@cn.ibm.com / space dev as xiuleizh@c\nn.ibm.com...\nOK<\/pre><\/div><p>3. 查看应用日志<\/p><div class=\"codesection\"><pre class=\"displaycode\">USAGE:\n cf logs APP\n\nOPTIONS:\n --recent Dump recent logs instead of tailing<\/pre><\/div><p>4. 删除应用<\/p><div class=\"codesection\"><pre class=\"displaycode\">USAGE:\n cf delete APP [-f]\n\nOPTIONS:\n -f Force deletion without confirmation\n\nC:\\Users\\IBM_ADMIN&gt;cf delete HelloMongoDW\n\nReally delete HelloMongoDW?&gt; y\nDeleting app HelloMongoDW in org xiuleizh@cn.ibm.com / space dev as xiuleizh@cn.\nibm.com...\nOK<\/pre><\/div><p><strong>巧用 Manifest.yml 文件<\/strong><\/p><p>当我们使用“cf push”命令部署应用的时候，这个命令有可能会变的非常冗长，在清单 3 中我们给出了其用法，这条命令有很多的参数可以选择，只要我们设置好相应的参数，就可以在一条命令里执行多个操作，例如：<\/p><p>cf push appName Cp myapp.war Cb https://github.com/ryanjbaxter/mybuildpack -i 5 Cm 512M --no-start<\/p><p>在上述命令中，除了部署应用外，我们还额外指定了应用要使用的 Buildpack，以及应用实例的数量，分配的内存大小以及部署后是否选择启动，在开发调试的时候，每次都输入这么长的命令会显的很麻烦，为了解决这个问题，我们可以使用 manifest.yml 文件，如下是一个示例：<\/p><h5 id=\"listing8\">清单 8. Manifest 示例<\/h5><div class=\"codesection\"><pre class=\"displaycode\">applications:\n\n- name: appName\npath: HelloWorldDW.war\n memory: 512M\n instances: 5 \n buildpack: https://github.com/ryanjbaxter/mybuildpack\nservices:\n - todo-mongo-db<\/pre><\/div><p>在如上示例中，我们定义了一些在部署应用的时候应该做的操作，当我们需要部署的时候，只需简单的在命令行里运行“cf push”即可，不再需要在后面跟很多的参数，需要注意的是：第一，当运行完“cf push”后，命令行会默认加载当前路径下的 manifest.yml，如果当前路径下没有 manifest.yml 文件，需要在“cf push”后加“-f”参数，指向一个全路径。<\/p><h3 id=\"major9\">通过 Bluemix 控制台管理应用<\/h3><p>命令行工具为程序员提供了很多命令来完成各种工作，同时，Bluemix 也提供了一个基于浏览器的 UI 界面，结合使用，会更高的提供应用程序的开发效率，在 UI 上同样也提供了一些更加丰富的功能。要使用 UI 进行应用管理，首先我们需要先部署一个应用到 Bluemix，继续之前，请读者自行完成上节中的清单 1，清单 2 以及清单 3。<\/p><p>Bluemix UI 的访问连接是：https://ace.ng.bluemix.net，输入注册的 Bluemix 账号进行登录，登陆后点击仪表盘（DASHBOARD）并在右上角选择要进入的 Organization 和 Space，如下图：<\/p><h5 id=\"img007\">图 7. 登录 Bluemix UI<\/h5><img alt=\"图 7. 登录 Bluemix UI\" src=\"/sunshine_new/images/负1736471717/img008.png\" width=\"581\" /><p>如果您已经完成了清单 1 到清单 3 就会在 Applications 旁边看到一个已经部署好的应用，应用的名字是 HelloMongoDW，单击这个应用，进入应用的管理界面：<\/p><h5 id=\"img008\">图 8. 应用管理界面<\/h5><img alt=\"图 8. 应用管理界面\" src=\"/sunshine_new/images/负1736471717/img008.png\" width=\"581\" /><p>在这个界面里向程序员展示了一些关于应用的基本信息，并提供了一些关于应用的操作链接。在这里我们单击 ADD A SERVICE 为示例程序绑定一个 Mongo 数据库：<\/p><h5 id=\"img009\">图 9. 创建 Mongo 数据库<\/h5><img alt=\"图 9. 创建 Mongo 数据库\" src=\"/sunshine_new/images/负1736471717/img009.png\" width=\"578\" /><p>当点击 CREATE 后，UI 会提示是否要重启应用，来使得数据库的操作生效，点击 OK，UI 会自动重启应用。应用重启后，会在应用管理界面看到一个新的 Mongo 示例，显示 Mongo 被成功的绑定了。<\/p><h5 id=\"img010\">图 10. 成功绑定 Mongo 数据库<\/h5><img alt=\"图 10. 成功绑定 Mongo 数据库\" src=\"/sunshine_new/images/负1736471717/img010.png\" width=\"581\" /><p>点击上面的 Routes 连接，我们就可以访问应用了，整个过程只需要点击几个按钮，就完成了应用的部署和服务的绑定。接下来我们再介绍几个 UI 里常用的功能：<\/p><p>点击上图中的 Liberty，进入运行时管理页面：<\/p><h5 id=\"img011\">图 11. 运行时管理页面<\/h5><img alt=\"图 11. 运行时管理页面\" src=\"/sunshine_new/images/负1736471717/img011.png\" width=\"582\" /><p>在这个页面里，我们可以：1，查看关于程序和运行时的基本信息；2，修改程序运行实例的数量以及分配内存的大小。3，点击左侧的 Files and Logs 可以查看应用的日志输出，如下图：<\/p><h5 id=\"img012\">图 12. 查看应用日志输出<\/h5><img alt=\"图 12. 查看应用日志输出\" src=\"/sunshine_new/images/负1736471717/img012.png\" width=\"581\" /><p>同时，我们还可以点击 CATALOG 去查看 Bluemix 提供的运行时和服务的详细列表和使用说明，如下图：<\/p><h5 id=\"img013\">图 13. Bluemix 功能一览<\/h5><img alt=\"图 13. Bluemix 功能一览\" src=\"/sunshine_new/images/负1736471717/img013.png\" width=\"581\" /><p>点击 DOCS 可以查看 Bluemix 的所有文档，点击 COMMUNITY，进入 Bluemix 的开发者社区，在使用 Bluemix 的过程中碰到的任何疑问都能在这里找到合适的答案。在这里我们就不再一一介绍，有兴趣的读者可以自行研读，并做一些实际的操作。<\/p><h3 id=\"major10\">安装 Eclipse 插件开发和部署应用<\/h3><p>一个应用从无到有需要借助开发工具来完成应用的开发，大多数 Java 程序员的选择都是 Eclipse，Bluemix 同样提供了丰富的插件来帮助程序员使用 Eclipse 与 Bluemix 进行联合开发，装上了 Bluemix 插件的 Eclipse 可以连接到 Bluemix 平台上，在 Eclipse 里只需一个简单的拖拽动作就能将应用快速的部署到 Bluemix 上，同时插件还提供了完成的应用生命周期的管理功能。在 Eclipse Marketplace 中搜索 Bluemix 并安装插件到 Eclipse 中就能方便的使用这些功能：<\/p><h5 id=\"img014\">图 14. 使用 Eclipse 插件开发 Bluemix 应用<\/h5><img alt=\"图 14. 使用 Eclipse 插件开发 Bluemix 应用\" src=\"/sunshine_new/images/负1736471717/img014.png\" width=\"582\" /><p>除了可以进行应用开发外，Bluemix 还提供了一种称为 Dev Ops 的服务，通过该服务，可以实现应用的持续集成，敏捷开发，除了这些，Dev Ops 还提供了一个基于 Web 页面的 IDE，程序员只需要打开浏览器就能进行应用程序的开发，并将开发完成的应用一键部署到云端，这些对于开发人员来说都是非常高效有用的工具。详细的使用方法都可以在参考资源里找到。<\/p><h2 id=\"major11\">总结<\/h2><p>Bluemix 给程序员带来的便利还有很多，在这里我们只能窥见一斑，不能做到事事巨细，希望通过本文的介绍让更多的程序员了解平台云带给 IT 的变化。云计算已经正在改变着人们的生活方式，作为程序员的我们，也同样在经历着这些变化，一种新的工具或者平台的出现，必定有其存在的理由，更要有其适合发展的土壤，IBM Bluemix 就是这样一个平台，虽然目前提供的功能还不是特别完善，但是随着云计算的不断发展，Bluemix 也将会不断演进，不断的提供更多的功能来服务程序员，并引领云计算带给 IT 的变化。<\/p><CMA ID: 975709><Site ID: 10><XSLT stylesheet used to transform this file: dw-document-html-7.0.xsl>\r\n\r\n\r\n<\/div>\r\n<\/div>\r\n","createTime":"2014-06-26 00:00:00","deployTime":"2014-06-26 00:00:00","id":0,"intro":"云计算在近年来不断发展，并越来越多的转化成实际的产品被企业级的客户接受并采纳，特别是云计算中的“平台即服务”（简称 PaaS）已经在云计算的发展浪潮中逐步站稳脚跟，Pivotal Cloud Foundry 的异军突起，逐步建立了 PaaS 在云计算的地位，使得平台公有云发展迅猛. 正是基于这样的趋势，IBM 发布了自己的公有云产品，产品名称是 IBM Bluemix，目前正处在公开测试阶段。Bluemix 建立在 Apache 开源项目 Cloud Foundry 之上，并提供了 IBM 及其合作伙伴开发的高质量的服务（Services）供 IT 从业人员使用。本文以 Bluemix 平台的核心组件 - Bluemix Java 运行时为主线，来向读者介绍 IBM 公有云产品 Bluemix，和读者一起去领略平台云给 IT 带来的变化。","keyword":"","recommend":false,"source":"http://www.ibm.com/developerworks/cn/websphere/library/techarticles/1406_zhuxl_bluemix/1406_zhuxl_bluemix.html","title":"初探 IBM Bluemix","typeId":0,"updateTime":"2014-06-26 00:00:00"}
{"author":"","clickNumber":0,"content":"\r\n<div class=\"ibm-columns\">\r\n<div class=\"ibm-col-1-1\">\r\n\r\n<h2 id=\"1.Introduction|outline\">简介<\/h2><p>IBM PureApplication System（W1500 和 W1700 v1.0 及\n                v1.1）是一个盒装云计算系统，配有用来在云中部署和执行工作负载的硬件和软件，拥有将私有云环境添加到企业数据中心所需的一切功能。本文将概述\n                PureApplication System 中包含的硬件，并使用系统控制台来查看各个组件。<\/p><p>本文是由三篇文章组成的文章系列的第 1 部分，该文章系列将介绍 PureApplication System\n                为了托管应用程序运行时环境而提供的硬件和软件基础：<\/p><ul class=\"ibm-bullet-list\"><li><strong>硬件<\/strong>：您正在阅读的这篇文章介绍了组成 PureApplication System 的硬件。<\/li><li><strong>虚拟化硬件<\/strong>：<a href=\"http://www.ibm.com/developerworks/cn/cloud/library/cl-aim1301-bestpractices-iaas-pureapp/\">在 IBM PureApplication System 中使用基础架构即服务的最佳实践<\/a> 会向您介绍\n                    PureApplication System 如何虚拟化其硬件，从而实现基础架构即服务 (IaaS)。<\/li><li><strong>运行时环境<\/strong>：<a href=\"http://www.ibm.com/developerworks/cn/websphere/library/techarticles/1210_woolf/1210_woolf.html\">在 IBM PureApplication System 中管理应用程序运行时环境<\/a> 介绍了 PureApplication\n                    System 中的虚拟化硬件如何用于实现工作负载所部属到的应用程序运行时环境。<\/li><\/ul><p>每篇文章都以前一篇文章为基础，以便全面地解释这一基础知识。<\/p><h2 id=\"2.ClassesofPureApplicationSystem|outline\">PureApplication System 的类型<\/h2><p>PureApplication System 目前有四种类型：<\/p><ul class=\"ibm-bullet-list\"><li><strong>W1500 Small Rack<\/strong>：矮机架 W1500，配备 32、64、96 或者 128 个\n                    Intel&#174; CPU 核心。<\/li><li><strong>W1500 Large Rack<\/strong>：高机架 W1500，配备\n                    64、96、128、160、192、224、384 或者 608 个 Intel CPU 核心。<\/li><li><strong>W1700 Small Rack<\/strong>：矮机架 W1700，配备 32、64、96 或者 128 个\n                    Power&#174; CPU 核心。<\/li><li><strong>W1700 Large Rack<\/strong>：高机架 W1700，配备\n                    64、96、128、160、192、224、384 或者 608 个 Power CPU 核心。<\/li><\/ul><p>表 1 显示了这些硬件类型的快速比较。表 1 中的管理节点缩写如下面所示（请参阅 <a href=\"#management_nodes\">管理节点<\/a> 部分，了解有关的详细信息）：<\/p><ul class=\"ibm-bullet-list\"><li><strong>PSM<\/strong>：PureSystems Manager<\/li><li><strong>VSM<\/strong>：Virtualization System Manager<\/li><li><strong>FSM<\/strong>：PureFlex System Manager<\/li><\/ul><h5 id=\"N1009D\">表 1. PureApplication System 硬件分类<\/h5><table border=\"0\" cellpadding=\"0\" cellspacing=\"0\" class=\"ibm-data-table\" summary=\"Table using a heading tag for the caption, all columns left-aligned, 4 columns with 3 column headings showing PureApplication System classes hardware\"><thead xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"><tr><th/><th>W1500 小机架<\/th><th>W1700 小机架<\/th><th>W1500 大机架<\/th><th>W1700 大机架<\/th><\/tr><\/thead><tbody xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"><tr><td style=\"text-align:left; vertical-align:top\"><strong>机架<\/strong><\/td><td>25U - 1.3 M 19\"<\/td><td>25U - 1.3 M 19\"<\/td><td>42U - 2.0 M 19\"<\/td><td>42U - 2.0 M 19\"<\/td><\/tr><tr><td style=\"text-align:left; vertical-align:top\"><strong>节点机箱<\/strong><\/td><td>1 个 Flex 机箱<\/td><td>1 个 Flex 机箱<\/td><td>3 个 Flex 机箱<\/td><td>3 个 Flex 机箱<\/td><\/tr><tr><td style=\"text-align:left; vertical-align:top\"><strong>处理器<\/strong><\/td><td>Intel Xeon E5-2670 8 核<\/td><td>POWER7+ 8 核<\/td><td>Intel Xeon E5-2670 8 核<\/td><td>POWER7+ 8 核<\/td><\/tr><tr><td style=\"text-align:left; vertical-align:top\"><strong>计算节点<\/strong><\/td><td>2、4、6 或者 8<\/td><td>2、3 或者 4<\/td><td>4、6、8、10、12、14、24 或者 38<\/td><td>2、3、4、5、6、7、12 或者 19<\/td><\/tr><tr><td style=\"text-align:left; vertical-align:top\"><strong>CPU\n                                核心<\/strong><\/td><td>32、64、96 或者 128<\/td><td>32、64、96 或者 128<\/td><td>64、96、128、160、192、224、384 或者 608<\/td><td>64、96、128、160、192、224、384 或者 608<\/td><\/tr><tr><td style=\"text-align:left; vertical-align:top\"><strong>内存<\/strong><\/td><td>0.5、1.0、1.5 或者 2.0 TB RAM<\/td><td>0.5、1.0、1.5 或者 2.0 TB RAM<\/td><td>1.0、1.5、2.0、2.5、3.0、3.5、6.0 或者 9.5 TB RAM<\/td><td>1.0、1.5、2.0、2.5、3.0、3.5、6.0 或者 9.5 TB RAM<\/td><\/tr><tr><td style=\"text-align:left; vertical-align:top\"><strong>存储节点<\/strong><\/td><td>1 个 V7000 控制器<br />1 个 V7000 扩展<\/td><td>1 个 V7000 控制器<br />1 个 V7000 扩展<\/td><td>2 个 V7000 控制器<br />2 个 V7000 扩展<\/td><td>2 个 V7000 控制器<br />2 个 V7000 扩展<\/td><\/tr><tr><td style=\"text-align:left; vertical-align:top\"><strong>存储驱动器<\/strong><\/td><td>6 个 400 GB SSD<br />40 个 600 GB HDD<\/td><td>6 个 400 GB SSD<br />40 个 600 GB HDD<\/td><td>16 个 400 GB SSD<br />80 个 600 GB HDD<\/td><td>16 个 400 GB SSD<br />80 个 600 GB HDD<\/td><\/tr><tr><td style=\"text-align:left; vertical-align:top\"><strong>存储容量<\/strong><\/td><td>2.4 TB SSD<br />24.0 TB HDD<\/td><td>2.4 TB SSD<br />24.0 TB HDD<\/td><td>6.4 TB SSD<br />48.0 TB HDD<\/td><td>6.4 TB SSD<br />48.0 TB HDD<\/td><\/tr><tr><td style=\"text-align:left; vertical-align:top\"><strong>管理节点<\/strong><\/td><td>2 个 PSM<br />2 个 VSM<\/td><td>2 个 PSM<br />2 个 FSM<\/td><td>2 个 PSM<br />2 个 VSM<\/td><td>2 个 PSM<br />2 个 FSM<\/td><\/tr><tr><td style=\"text-align:left; vertical-align:top\"><strong>网络<\/strong><\/td><td colspan=\"4\" style=\"text-align:center; vertical-align:top\">2 个\n                            IBM RackSwitch 64 端口 10 Gb 以太网交换机<\/td><\/tr><tr><td style=\"text-align:left; vertical-align:top\"><strong>电源<\/strong><\/td><td colspan=\"4\" style=\"text-align:center; vertical-align:top\">4 个\n                            配电单元 (PDU)<\/td><\/tr><\/tbody><\/table><p>每个型号在其类型内都是可升级的，最大可分别升级至 W1500-128、W1700-128、W1500-608 和\n                W1700-608。无需断电即可执行升级。<\/p><h2 id=\"3.PureApplicationSystemhardwarecapabilities|outline\">系统硬件<\/h2><p>让我们首先来探讨一下整个 PureApplication System 机架中适用于每个系统类型的硬件。<\/p><h3 id=\"4.Rackinfrastructure|outline\">基础架构图<\/h3><p>您可以在集成控制台中查看特定 PureApplication System 中的硬件实时视图。为此，请打开 Infrastructure Map。选择\n                    <strong>System Console &gt; Hardware &gt; Infrastructure\n                Map<\/strong>，如图 1 所示。要访问 Hardware 菜单，需要为用户授予 Hardware administration 角色，如\n                    <a href=\"http://www.ibm.com/developerworks/websphere/library/techarticles/1211_woolf/1211_woolf.html\">Managing administrative access in IBM PureApplication System<\/a>\n                中所述。<\/p><h5 id=\"fig1\">图 1. 系统硬件菜单<\/h5><img alt=\"系统硬件菜单\" src=\"/sunshine_new/images/533659640/images/figure1.jpg\" width=\"580\" /><p>Infrastructure Map 可视作一个交互式图片，如图 2 所示，并可作为组件的层级树状结构。如需了解更多信息，请查看\n                PureApplication System 信息中心的 <a href=\"http://pic.dhe.ibm.com/infocenter/psappsys/v1r1m0/topic/com.ibm.puresystems.appsys.1500.doc/systemconsole/t_infragraphic.html\">Viewing the hardware infrastructure<\/a> 主题。<\/p><h5 id=\"fig2\">图 2. W1500-96 Infrastructure Map -\n                    图形视图<\/h5><img alt=\"W1500-96 Infrastructure Map - 图形视图\" src=\"/sunshine_new/images/533659640/images/figure2.jpg\" width=\"580\" /><h3 id=\"N10192\">硬件基础架构<\/h3><p>与图 2 中所示的 Infrastructure Map 图形视图类似，图 3 演示了 W1500 Large Rack\n                系统机架中的硬件组件布局。<\/p><h5 id=\"fig3\">图 3. IBM PureApplication System\n                    W1500-608 硬件<\/h5><img alt=\"IBM PureApplication System W1500-608 硬件\" src=\"/sunshine_new/images/533659640/images/figure3.gif\" width=\"578\" /><p>如 Infrastructure Map 和图 3 中所示，W1500 Large Rack 系统是一个大机架（一个 42U 机柜，高 2.015\n                米，宽 644 毫米，纵深 1100 毫米，全负荷情况下总重 1088 千克），从上到下包含以下主要组件：<\/p><ul class=\"ibm-bullet-list\"><li><strong>位于顶部的机架交换机 (ToR)<\/strong>：这是一对 IBM System Networking\n                    RackSwitch&#8482; G8264 64 端口 10 Gb 以太网交换机。 <ul class=\"ibm-bullet-list\"><li>要查看这些信息，请转至 <strong>System Console<\/strong> &gt;\n                                <strong>Hardware<\/strong> &gt; <strong>Network\n                                Devices<\/strong>。网络设备页面还列出了各个机箱的网络和 SAN 交换机。<\/li><li>要查看网络配置的详细信息，请转至 <strong>System Console &gt; System &gt;\n                                Customer Network Configuration<\/strong>。<\/li><\/ul><\/li><li><strong>存储节点<\/strong>：这是一对 IBM Storwize&#174; V7000\n                    存储单元，每个单元都是一个控制器节点与一个扩展节点的配对，并与一个将两个单元作为单个 SAN 进行管理的控制器聚合。 <ul class=\"ibm-bullet-list\"><li>要想查看这些信息，请转至 <strong>System Console<\/strong> &gt;\n                                <strong>Hardware<\/strong> &gt; <strong>Storage\n                                Devices<\/strong>。<\/li><\/ul><\/li><li><strong>Flex 机箱<\/strong>：系统包含三个 IBM Flex System&#8482; Enterprise\n                    Chassis Type 7893 机箱，高度均为 10U（编号为 3、2 和 1，编号 1\n                    的机箱位于底部）。机箱相当于计算节点的扩展插口。将计算节点放入机箱就像将抽屉放入文件柜一样。在将节点插入到托架时，节点中的相应连接器和托架就会组合在一起。这一设计有助于在系统运行期间更换计算节点。 <ul class=\"ibm-bullet-list\"><li>要想查看这些信息，请转至 <strong>System Console &gt; Hardware &gt; Flex\n                                Chassis<\/strong>。<\/li><\/ul><\/li><li><strong>服务笔记本电脑<\/strong>：一台连接到系统的笔记本电脑被存放在机架中编号为 2 和 3 的机箱之间的一个 1U\n                    抽屉中。IBM 用它来管理系统。<\/li><li><strong>配电单元 (PDU)<\/strong>：机架包含四个\n                    PDU，分别插在外部电源上。这几个单元依次将电源分配到机箱的电源模块、交换机和存储节点。<\/li><\/ul><p>每个 Flex 机箱都包含几个组件：<\/p><ul class=\"ibm-bullet-list\"><li><strong>计算节点<\/strong>：每个机箱包含十四个计算节点托架，分七行两列排列。每个托架都支持一个 Intel\n                    计算节点。如果使用的是 W1700，那么两个并列的托架能够支持一个 Power 计算节点。参见 <a href=\"#fig4\">图\n                        4<\/a>。 <ul class=\"ibm-bullet-list\"><li>要查看系统的计算节点，请转至 <strong>System Console &gt; Hardware &gt;\n                                Compute Nodes<\/strong>。<\/li><\/ul><\/li><li><strong>管理节点<\/strong>：Chassis 1 和 Chassis 2 各使用两个托架来托管管理节点： <ul class=\"ibm-bullet-list\"><li><strong>Virtualization System Manager<\/strong>\n                                (<strong>VSM<\/strong>)：在节点托架 1 中托管，管理计算节点的虚拟机管理程序。如果使用的是\n                            W1700，那么该节点就是 PureFlex System Manager (FSM)。参阅 <a href=\"#fig4\">图 4<\/a> 和 <a href=\"#management_nodes\">管理节点<\/a> 一节。<\/li><li><strong>PureSystems Manager<\/strong>\n                            (<strong>PSM<\/strong>)：托管在节点托架 2 中，它托管了 IBM Workload Deployer\n                            (IWD)。<\/li><li>要查看系统的管理节点，请转至 <strong>System Console &gt; Hardware &gt;\n                                Management Nodes<\/strong>。<\/li><\/ul><\/li><li><strong>网络交换机<\/strong>：每个机箱包含一对 66 端口 IBM Flex System Fabric EN4093\n                    10Gb Scalable Switch 以太网交换机，用于连接它的计算节点。机箱交换机通过一个 40 Gbps 以太网主干（4 个 10\n                    GB 以太网电缆）连接到顶部机架交换机。<\/li><li><strong>SAN 交换机<\/strong>：每个机箱包含一对 48 端口的 IBM Flex System FC5022 16Gb\n                    SAN Scalable Switch 光纤通道交换机，用于将其计算节点连接到系统的共享存储。 <ul class=\"ibm-bullet-list\"><li>要查看机箱的网络和 SAN 交换机，请转至 <strong>System Console &gt; Hardware\n                                &gt; Network Devices<\/strong>。<\/li><\/ul><\/li><li><strong>电源模块<\/strong>：每个机箱包含 6 个电源，每侧 3\n                    个。电源是冗余提供的，所以即使一个电源模块失效，也能保持机箱及其计算节点继续工作。<\/li><li><strong>继续冷却设备<\/strong>：这些设备是 10 个用于控制硬件温度的风扇。<\/li><\/ul><h3 id=\"N1022A\">Power 型号<\/h3><p>W1700 Large Rack 中的硬件与对应的 W1500 类型机箱中的硬件非常相似。图 4 显示了 W1700 Large Rack\n                系统机架中的硬件组件布局。<\/p><h5 id=\"fig4\">图 4. IBM PureApplication System\n                    W1700-608 硬件<\/h5><img alt=\"IBM PureApplication System W1700-608 硬件\" src=\"/sunshine_new/images/533659640/images/figure4.gif\" width=\"578\" /><p>这个硬件与 W1500 Large Rack 中的硬件非常相似，主要区别是 W1700 包含 Power 计算节点，而不是 Intel 计算节点。与\n                Intel 计算节点相比，Power\n                计算节点包含两倍多的核心以及两倍多的内存。放置该硬件的盒子是两倍宽，所以它占用机箱中的两个水平托架，这样每个机箱会支持一半的 Power\n                计算节点。除了计算节点外，存储和网络也是相同的。<\/p><p>另一个区别是，虚拟化管理节点是 PureFlex System Manager (FSM)，而不是 Virtualization System\n                Manager (VSM)。请参阅 <a href=\"#management_nodes\">管理节点<\/a> 一节。<\/p><h3 id=\"N10243\">较小的机架<\/h3><p>W1500 Small Rack 中的这个硬件是 W1500 Large Rack 中的硬件的一个子集。图 5 显示了 W1500 Small\n                Rack 系统机架中的硬件组件布局。<\/p><h5 id=\"fig5\">图 5. IBM PureApplication System W1500-64\n                    硬件<\/h5><img alt=\"IBM PureApplication System W1500-64 硬件\" src=\"/sunshine_new/images/533659640/images/figure5.gif\" width=\"567\" /><p>如图 5 所示，W1500 Small Rack 是一个小机架（25U 机柜，高 1.267 米，宽 605 毫米，纵深 997\n                毫米，全负荷状态下重量为 385 千克），包含与较大的同类机架相同的主要组件类型：<\/p><ul class=\"ibm-bullet-list\"><li>2 个顶部机架交换机<\/li><li>1 个服务笔记本电脑<\/li><li>4 个电源模块<\/li><li>1 个存储单元（一个控制器/扩展对）<\/li><li>1 个 Flex 机箱： <ul class=\"ibm-bullet-list\"><li>4 个管理节点<\/li><li>多达 10 个计算节点的托架<\/li><\/ul><\/li><\/ul><p>这个硬件与 W1500 Large Rack 中的硬件非常相似，但略有不同：<\/p><ul class=\"ibm-bullet-list\"><li>较矮，略窄于机柜（25U 而不是 42U）<\/li><li>1 个机箱，而不是三个<\/li><li>最多 10 个计算节点<\/li><li>1 个存储单元，而不是两个<\/li><li>4 个电源模块，水平堆放在存储和服务笔记本之间<\/li><\/ul><p>所有 W1500 中的计算节点都是相同的，并且存储和联网的方式也是相同的。<\/p><p>W1700 Small Rack 中的硬件（即 Power 小机架）与 W1500 Small Rack 中的硬件（即 Intel\n                小机架）非常类似。主要区别是不包含 Intel 计算节点，单个机箱的空间可存放最多 5 个 Power 计算节点。<\/p><h3 id=\"5.Hardwareresiliency|outline\">硬件弹性<\/h3><p>系统硬件的基本主题就是，为了实现弹性，各个节点往往是冗余的，以避免出现单点故障。系统不仅包含多个计算节点，还包含两对管理节点、两个系统网络交换机、两个存储单元，以及四个\n                PDU。Large Rack 机箱系统包含三个 Flex 机箱。每个机箱包含一对网络交换机、一对 SAN 交换机和六个电源。计算节点中的网络和\n                SAN 适配器有多个端口，用于增加带宽和弹性。<\/p><p>硬件还将系统的管理和用户工作负载隔离开。管理节点 - PureSystems&#8482; Manager 和 Virtualization\n                System Manager 或 PureFlex&#8482; System Manager -\n                都托管在其自身的计算节点中。这会将它们和用户工作负载隔离开，这样，系统管理功能就可以在自己的专用硬件中运行。这样做还消除了标准计算节点的大多数管理开销，使其资源可以专供用户工作负载使用。如果出现故障，有两对管理节点应对故障，其中一对处于待命状态，是另一对的备用。<\/p><h2 id=\"N10284\">系统组件<\/h2><p>让我们更详细地探讨一下各个硬件组件。<\/p><h3 id=\"6.W1500computenodes|outline\">W1500\n                计算节点<\/h3><p>计算节点通常也称为集成技术元素 (ITE)，有时也被称为 “刀片”，专指那些尚未被专门化为管理节点的节点，计算节点是非常小巧的计算机。W1500\n                系统包含许多 Intel 计算节点，特别是 IBM Flex System x240 计算节点，这些节点各自包含以下组件：<\/p><ul class=\"ibm-bullet-list\"><li><strong>CPU<\/strong>：一个 Intel 计算节点包含一个双处理器、16 核芯片组。这些芯片是两个 8 核 2.6 GHz\n                    Intel&#174; Xeon&#174; E5-2670 115W 处理器，一共有 16 个物理核心，虚拟机管理程序将其用作 32\n                    个逻辑核心（也就是说，虚拟机管理程序能够在这 16 个核心中运行 32 个并发线程）。在这 32 个逻辑核心中，28\n                    个核心可供用户工作负载使用。<\/li><li><strong>内存<\/strong>：一个 Intel 计算节点包含 256&#160;GB 的 RAM：8 2x16 GB、1333\n                    MHz、DDR3、LP RDIMMS (1.35 V)。<\/li><li><strong>存储<\/strong>：计算节点的 SAN 接口卡是一个 IBM Flex System FC3172 2-port 8\n                    GB FC Adapter 光纤通道适配器。节点还包含两个 250 GB 2.5\n                    英寸的硬盘驱动器，它们往往不被系统采用，常被忽略。<\/li><li><strong>网络<\/strong>：计算节点的网络接口卡是一个 4 端口的 IBM Flex System CN4054 10 GB\n                    Virtual Fabric Adapter 以太网适配器。<\/li><li><strong>外壳<\/strong>：Intel\n                    计算节点的外壳只有一半的宽度，这意味着每个计算节点能够放置到单个机箱托架上，而且两个计算节点能够能够并排放置在相邻的托架上（参见 <a href=\"#fig3\">图 3<\/a> 和 <a href=\"#fig5\">图 5<\/a>）。<\/li><\/ul><p>图 6 说明了计算节点中的这些组件。<\/p><h5 id=\"fig6\">图 6. 计算节点组件<\/h5><img alt=\"计算节点组件\" src=\"/sunshine_new/images/533659640/images/figure6.jpg\" width=\"479\" /><h3 id=\"7.W1700computenodes|outline\">W1700\n                计算节点<\/h3><p>W1700 系统包含许多 Power 计算节点，特别是 IBM Flex System p460 计算节点，它包含以下组件：<\/p><ul class=\"ibm-bullet-list\"><li><strong>CPU<\/strong>：Power 计算节点包含一个四核处理器，32 核芯片组。这些芯片是四个 8 核 3.61 GHz\n                    POWER7+ 处理器，一共有 32 个物理核心，虚拟机管理程序将它们用作 128 个逻辑核心（也就是说，128 个并发线程）。在这 128\n                    个逻辑核心中，116 个核心课用于用户工作负载。<\/li><li><strong>内存<\/strong>：Power 计算节点包含 512&#160;GB 的 RAM：16 2x16 GB、1066\n                    MHz、DDR3、LP RDIMMS (1.35 V)。<\/li><li><strong>存储<\/strong>：这和 Intel 计算节点中包含的适配器相同，但它包含两个适配器。计算节点的 SAN 接口卡是两个\n                    IBM Flex System FC3172 2-port 8 GB FC Adapter 光纤通道适配器。节点还包含两个 250 GB\n                    2.5 英寸的硬盘驱动器，它们往往不被系统采用，常被忽略。<\/li><li><strong>网络<\/strong>：这和 Intel 计算节点张包含的适配器类似，但它包含两个适配器。计算节点的网络接口卡是两个 IBM\n                    Flex System EN4054 4-port 10 GB 以太网适配器。<\/li><li><strong>外壳<\/strong>：Power 计算节点的外壳是全宽度，这意味着它是 Intel 计算节点的两倍宽。每个 Power\n                    计算节点占用一对水平放置的机箱托架（参见 <a href=\"#fig4\">图 4<\/a>）。<\/li><\/ul><p>与 W1500 计算节点相比，W1700 计算节点包含其两倍的核心和内存。由于在体积上也是两倍，所以机架支持一半的数量。<\/p><p>每个计算节点都可以访问所有计算节点共享的系统资源：存储和网络。<\/p><h3 id=\"8.Sharedresources|outline\">共享资源：存储<\/h3><p>PureApplication System 高机架提供 6.4 TB 的固态驱动器 (SSD) 存储，以及 48 TB 的硬盘驱动器 (HDD)\n                存储；其中，4.8 TB 和 43.2 TB 是可用的：<\/p><ul class=\"ibm-bullet-list\"><li>这个存储器被放置在由两个 IBM Storwize V7000\n                    存储单元组成的集群中。每个单元包含一个与扩展节点配对的控制器节点（也称为附件）。<\/li><li>每个节点包含两个节点容器，被配置为活动/备用容器。活动的容器控制了对节点存储的访问。<\/li><li>四个联合节点中的磁盘是 16 * 400 GB 2.5\" SSD 和 80 * 600 GB 2.5\" HDD。<\/li><li>控制器包括 IBM System Storage&#174; Easy Tier&#174; 存储管理系统软件。<\/li><li>存储被组织成独立磁盘冗余阵列 (RAID)，其中 5 个阵列用于冗余。每个存储单元包含 40 个 HDD 和 8 个 SSD。 <ul class=\"ibm-bullet-list\"><li>在 40 个 HDD 中，一个作为热备件预留，余下的 39 个硬盘被组织到三个由 13 个磁盘组成的阵列中，其中包括 12\n                            个数据段和 1 个奇偶校验段的条带。<\/li><li>8 个 SDD 是一个热备件，以及由 7 个磁盘组成的阵列，其中包括 6 个数据段和 1 个奇偶校验段的条带。<\/li><\/ul><\/li><li>计算节点通过 2 端口的 8 GB 光纤通道适配器访问作为 SAN 的存储器。<\/li><\/ul><h3 id=\"N10304\">共享资源：网络<\/h3><p>PureApplication System 的内部物理网络通过两个顶部机架交换机 (ToR)、两个 IBM System Networking\n                RackSwitch G8264 64 端口的以太网交换机来访问，其中交换机和外部网络之间的最大带宽为 320 Gbps。它们的配置显示在\n                Customer Network Configuration 页面上（请转至 <strong>System Console &gt; System\n                    &gt; Customer Network Configuration<\/strong>）。以下是端口的使用方法：<\/p><ul class=\"ibm-bullet-list\"><li>每个交换机上的端口 41-56（一共 16 个端口）用于连接数据中心网络： <ul class=\"ibm-bullet-list\"><li>每个端口都是 10/1 GB 以太网。内置的连接器类型是铜线，但是每个端口也可以和光纤连接器相连，或者直接接入连接\n                            (DAC)。<\/li><li>两个交换机中的各对端口应该是链路聚合的，以实现高可用性。<\/li><\/ul><\/li><li>端口 63（在任一交换机上）连接服务笔记本电脑，IBM 也用这个端口来引导和管理系统。<\/li><li>端口 64（链路聚合）是管理 LAN 端口。<\/li><li>系统交换机上的其他端口提供了用于应用程序和管理网络的三个机架的网络交换机之间的以太网连接，并相互连接两个 ToR 交换机。<\/li><\/ul><h3 id=\"management_nodes\">管理节点<\/h3><p>PureSystems Manager (PSM) 不仅托管了可以部署模式的 Workload\n                Deployer，还托管了系统的管理服务。这些服务可通过以下三个接口进行访问：<\/p><ul class=\"ibm-bullet-list\"><li><strong>控制台<\/strong>：集成控制台，一个 Web GUI。<\/li><li><strong>REST API<\/strong>：具象状态传输应用程序编程接口。<\/li><li><strong>CLI<\/strong>：命令行接口。<\/li><\/ul><p>这些接口通过其 IP 地址来访问 PSM，该地址是 Customer Network Configuration 页面上显示的浮动管理 IP\n                    地址（<strong>System Console &gt; System &gt; Customer Network\n                    Configuration<\/strong>）。在这个 IP 地址上打开 Web 浏览器将会打开系统的集成控制台。<\/p><p>虚拟化管理节点 - Virtualization System Manager（VSM，位于 W1500 上）和 PureFlex System\n                Manager（FSM，位于 W1700 上） - 管理虚拟机管理程序。W1500 和 W1700\n                上的虚拟机管理程序管理相同，但在这两种型号上的工作方式略有不同。两种型号的不同芯片组、Intel&#174; 与 Power\n                运行不同的虚拟机管理程序软件：VMware 与 PowerVM。VSM 和 FSM 运行相同的硬件，但分别运行不同的虚拟机管理程序管理软件\n                VMware vCenter 与 PowerVM。<\/p><p>表 2 总结了两种虚拟化管理节点类型中的区别。<\/p><h5 id=\"N10341\">表 2. 虚拟化管理节点对比<\/h5><table border=\"0\" cellpadding=\"0\" cellspacing=\"0\" class=\"ibm-data-table\" summary=\"3 column table with 2 column headings, table uses a heading tag for the caption, text in table shows virtualization management comparison\"><thead xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"><tr><th style=\"vertical-align:top\"/><th style=\"text-align:left; vertical-align:top\">W1500 Intel<\/th><th style=\"text-align:left; vertical-align:top\">W1700 Power<\/th><\/tr><\/thead><tbody xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"><tr><td style=\"text-align:left; vertical-align:top\">处理器<\/td><td style=\"text-align:left; vertical-align:top\">Intel Xeon<\/td><td style=\"text-align:left; vertical-align:top\">POWER7+<\/td><\/tr><tr><td style=\"text-align:left; vertical-align:top\">虚拟机管理程序软件<\/td><td style=\"text-align:left; vertical-align:top\">VMware vSphere\n                            Hypervisor (ESXi)<\/td><td style=\"text-align:left; vertical-align:top\">IBM PowerVM<\/td><\/tr><tr><td style=\"text-align:left; vertical-align:top\">虚拟化管理节点<\/td><td style=\"text-align:left; vertical-align:top\">Virtualization\n                            System Manager (VSM)<\/td><td style=\"text-align:left; vertical-align:top\">PureFlex System\n                            Manager (FSM)<\/td><\/tr><tr><td style=\"text-align:left; vertical-align:top\">虚拟机管理程序管理软件<\/td><td style=\"text-align:left; vertical-align:top\">VMware vCenter\n                            Server<\/td><td style=\"text-align:left; vertical-align:top\">PowerVM\n                            VMControl<\/td><\/tr><\/tbody><\/table><p>尽管存在这些差异，但是 PureSystems Manager (PSM) 在两种型号中使用该虚拟机管理程序管理软件的方式相同。<\/p><h3 id=\"N1037A\">Management LAN 端口<\/h3><p>管理 LAN 端口使管理员能够连接到 PureSystems Manager (PSM)，包括集成控制台。Customer Network\n                Configuration 页面指定了管理端口，该端口始终为顶部机架上的端口 64（链路聚合）。这个管理端口是客户管理网络的一员，在表 3\n                中列出。顶部机架交换机配置有 VLAN ID，用于 Aggregate Port 64 配置的 VLAN 域中的客户管理网络。<\/p><h5 id=\"N10387\">表 3. 客户管理网络<\/h5><table border=\"0\" cellpadding=\"0\" cellspacing=\"0\" class=\"ibm-data-table\" summary=\"3 column table with 2 column headings, table uses a heading tag for the caption, text in table shows Customer management network comparison\"><thead xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"><tr><th style=\"vertical-align:top\">名称<\/th><th style=\"text-align:left; vertical-align:top\">网络名称<\/th><th style=\"text-align:left; vertical-align:top\">VLAN ID<\/th><\/tr><\/thead><tbody xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"><tr><td style=\"text-align:left; vertical-align:top\">客户管理<\/td><td style=\"text-align:left; vertical-align:top\">CUSTMGMT<\/td><td style=\"text-align:left; vertical-align:top\">指定客户<\/td><\/tr><\/tbody><\/table><p>这个客户管理网络可使用网络管理员指定的任何可用 VLAN ID。VLAN 需要在外部网络上进行定义来支持管理员访问 PSM。<\/p><h3 id=\"N103A3\">管理网络<\/h3><p>系统需要三个 VLAN 来从内部管理其组件。Customer Network Configuration 将其作为 Internal Network\n                VLAN 列出。每个管理 VLAN 也在 Virtual Networks 页面上与其他 VLAN 一起列出（<strong>System\n                    Console &gt; Hardware &gt; Virtual Network<\/strong>）。表 4 列出了这些管理\n                VLAN。<\/p><h5 id=\"N103B4\">表 4. 管理网络<\/h5><table border=\"0\" cellpadding=\"0\" cellspacing=\"0\" class=\"ibm-data-table\" summary=\"3 column table with headers, table uses a heading tag for the caption. Text in table shows Management networks\" width=\"60%\"><thead xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"><tr><th style=\"text-align:left; vertical-align:top\">名称<\/th><th style=\"text-align:left; vertical-align:top\">网络名称<\/th><th style=\"text-align:left; vertical-align:top\">VLAN ID<\/th><\/tr><\/thead><tbody xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"><tr><td style=\"text-align:left; vertical-align:top\">移动性<\/td><td style=\"text-align:left; vertical-align:top\">VMOTION<\/td><td style=\"text-align:left; vertical-align:top\">1358<\/td><\/tr><tr><td style=\"text-align:left; vertical-align:top\">控制台<\/td><td style=\"text-align:left; vertical-align:top\">CONSOLE<\/td><td style=\"text-align:left; vertical-align:top\">3201<\/td><\/tr><tr><td style=\"text-align:left; vertical-align:top\">管理<\/td><td style=\"text-align:left; vertical-align:top\">MERION<\/td><td style=\"text-align:left; vertical-align:top\">4091<\/td><\/tr><\/tbody><\/table><p>为了确保这三个 VLAN ID 在网络上是惟一的，应该在网络上保留它们，让其他所有 VLAN 都不会使用它们。至少，具有这些 ID 的网络 VLAN\n                将无法连接到系统，因为顶部机架交换机会阻塞流量。<\/p><p>除了这些系统范围内的管理网络外，每个云组（PureApplication System 的虚拟化特性）还需要自己的管理 VLAN。这些 VLAN ID\n                也应进行保留，或者至少将由顶部机架交换机进行阻塞。<\/p><h3 id=\"N103E6\">应用程序网络<\/h3><p>Customer Network Configuration 页面还使管理员能够定义 VLAN，客户工作负载将用其来彼此通信，并将每个应用程序\n                VLAN 与顶部机架交换机中的端口或链路聚合关联。当添加或删除交换机中已配置的 VLAN\n                时，系统会花几分钟时间来重新配置其顶部机架和网络交换机，然后，系统将识别 VLAN 更改。<\/p><p>这些应用程序 VLAN 必须在网络上进行定义，以支持不在系统上运行的部分应用程序（例如，客户端 GUI\n                和企业数据库）与在系统上作为工作负载运行的部分应用程序之间的通信。<\/p><h2 id=\"9.Conclusion|outline\">结束语<\/h2><p>本文回顾了 PureApplication System\n                中包含的硬件。介绍了主要的硬件组件，描述了各个组件的详细信息和关系，并展示了如何在集成控制台中找到它们。了解了这些信息之后，您现在就对\n                PureApplication System 中的硬件有了更高的理解。<\/p><h3 id=\"N103F6\">致谢<\/h3><p>作者衷心感谢以下 IBM 工作人员，感谢他们对本文提供的帮助：<strong>Hendrik van\n                    Run<\/strong>、<strong>Jose Altuve<\/strong>、<strong>Jim\n                    Robbins<\/strong>、<strong>Ajay Apte<\/strong> 和 <strong>James\n                    Kochuba<\/strong>。<\/p><CMA ID: 957439><Site ID: 10><XSLT stylesheet used to transform this file: dw-document-html-7.0.xsl>\r\n\r\n\r\n<\/div>\r\n<\/div>\r\n","createTime":"2014-06-26 00:00:00","deployTime":"2014-06-26 00:00:00","id":0,"intro":"IBM PureApplication System 是一个盒装云计算系统，配有用来在云中部署和执行工作负载的硬件和软件 - 拥有将私有云环境添加到企业数据中心所需的一切功能。本文将概述 PureApplication System 中包含的硬件和软件。","keyword":"","recommend":false,"source":"http://www.ibm.com/developerworks/cn/cloud/library/cl-ps-aim1302-hardwarepureapp/index.html","title":"IBM PureApplication System 中的硬件之旅","typeId":0,"updateTime":"2014-06-26 00:00:00"}
{"author":"","clickNumber":0,"content":"\r\n<div class=\"ibm-columns\">\r\n<div class=\"ibm-col-1-1\">\r\n\r\n<h2 id=\"major1\">Javacore 与 WebSphere Commerce 性能问题<\/h2><p>近年来，依据 WebSphere Commerce（以下简称为 WC）搭建的电子商务网站系统日益增多。由于系统本身的复杂性，一旦系统出现问题，尤其是性能问题，问题诊断和定位就会非常困难。下图所示为由 WC 系统为核心搭建的电子商务网站的一般逻辑架构 , 如图 1 所示：<\/p><h5 id=\"img001\">图 1. 电子商务网站的一般逻辑架构<\/h5><img alt=\"图 1 电子商务网站的一般逻辑架构\" src=\"/sunshine_new/images/负934160391/img001.png\" width=\"404\" /><p>在整个系统架构中，核心应用逻辑运行在 WebSphere 应用服务器上。当系统出现性能问题时，虽然实际问题的根源可能分布在各个节点上，但是通过在应用服务器上的线程运行状态分析，都有助于对整个系统的当前状态以及可能的问题根源进行快速定位。WebSphere 应用服务器运行在 JVM（Java 虚拟机）之上。所以掌握通过 Javacore 进行 Java 线程分析，对于解决 WC 系统中的性能问题至关重要。<\/p><p>本文介绍如何通过 Javacore 文件分析线程运行状态，以及辅助分析工具的使用。并通过实例讲解如何利用 Java 线程分析解决 WC 系统中的性能问题。本文所介绍的分析方法对于其他基于 JavaEE 构建的企业应用也有借鉴意义。<\/p><h2 id=\"major2\">如何通过 Javacore 了解线程运行状况<\/h2><p>Javacore 是一个当前 JVM 运行状态的快照。通过对 Javacore 的分析，可以了解在 JVM 中运行的应用程序的当前状态，比如是否“卡”在某一点上，或在某些代码上运行时间太长。<\/p><h3 id=\"major3\">Javacore 的基本内容<\/h3><p>Javacore，也可以称为“threaddump”或是“javadump”，它是 Java 提供的一种诊断特性，能够提供一份可读的当前运行的 JVM 中线程使用情况的快照。即在某个特定时刻，JVM 中有哪些线程在运行，每个线程执行到哪一个类，哪一个方法。<\/p><p>应用程序如果出现不可恢复的错误或是内存泄露，就会自动触发 Javacore 的生成。而为了性能问题诊断的需要，我们也会主动触发生成 Javacore。在 AIX、Linux、Solaris 环境中，我们通常使用 kill -3 &lt;PID&gt; 产生该进程的 Javacore。IBM Java6 中产生 Javacore 的详细方法可以参考文章 [1]。<\/p><p>对于 IBM JVM，AIX 平台上的 Javacore 会被写到 javacore.&lt;date&gt;.&lt;time&gt;.&lt;PID&gt;.&lt;sequence&gt;.txt 中。对于 Oracle JVM，Javacore 被附加到 native_stdout.txt。Javacore 的内容有两列，第一列是“类型”，第二列表示“数据”，如清单 1 所示：<\/p><h5 id=\"listing1\">清单 1<\/h5><div class=\"codesection\"><pre class=\"displaycode\">1TISIGINFO Dump Event \"user\" (00004000) received \n 1TIDATETIME Date: 2013/12/22 at 23:05:18 \n 1TIFILENAME Javacore filename: \n /usr/WebSphere/AppServer/profiles/demo_solr/javacore.20131222.230518.7995516.0004.txt<\/pre><\/div><p>通常情况下，Javacore 中除了线程信息外，还能提供关于操作系统，应用程序环境，线程，程序调用栈，锁，监视器和内存使用等相关信息。<\/p><p>为了便于分析，Javacores 的每一段的开头，都会用“----------”和上一信息块区分开来。每一信息块的标题会以“=========”来标识，很容易找到，如清单 2 所示：<\/p><h5 id=\"listing2\">清单 2<\/h5><div class=\"codesection\"><pre class=\"displaycode\">NULL ------------------------------------------------------------------------ \n 0SECTION GPINFO subcomponent dump routine \n NULL ================================ \n 2XHOSLEVEL OS Level : AIX 7.1 \n 2XHCPUS Processors - \n 3XHCPUARCH Architecture : ppc64 \n 3XHNUMCPUS How Many : 8 \n 3XHNUMASUP NUMA is either not supported or has been disabled by user \n NULL \n 1XHERROR2 Register dump section only produced for SIGSEGV, SIGILL or SIGFPE. \n NULL<\/pre><\/div><p>Javacore 文件中，每行都包含一个标签，这个标签最多由 15 个字符组成。第一位数字表示信息的详细级别，级别越高代表信息越详细。接着的两个字符是段标题的缩写，例如：“CI”表示 Command line interpreter，“CL”表示 Class loader，“LK”表示 Locking，“ST”表示 Storage，“TI”表示 Title，“XE”表示 Execution engine 等。余下的字符表示信息的概述。如下清单 3 所示：<\/p><h5 id=\"listing3\">清单 3<\/h5><div class=\"codesection\"><pre class=\"displaycode\">3XMTHREADINFO \"Thread-18\" J9VMThread:0x00000000308DA900, \n j9thread_t:0x0000010016C4F2E0, java/lang/Thread:0x000000004136E3E8, state:P, prio=5<\/pre><\/div><p>虽然不同版本的 JVM 所产生的 Javacore 的格式会稍有不同，但基本都包含下面几个内容：<\/p><p><strong>TITLE 信息块：<\/strong>描述 Javacore 产生的原因，时间以及文件的路径。常见的 Javacore 产生的原因可以参考文章 [2]。最常见的有下面三种：<\/p><p>user：SIGQUIT 信号<\/p><p>gpf：程序一般保护性错误导致系统崩溃<\/p><p>systhrow：JVM 内部抛出的异常<\/p><p><strong>GPINFO 信息块：<\/strong>GPF（一般保护性错误）信息<\/p><p><strong>ENVINFO 信息块：<\/strong>系统运行时的环境和 JVM 参数<\/p><p><strong>MEMINFO 信息块：<\/strong>内存使用情况和垃圾回收情况<\/p><p><strong>LOCKS 信息块：<\/strong>用户监视器（monitor）和系统监视器（monitor）情况<\/p><p><strong>THREADS 信息块：<\/strong>所有 java 线程的状态信息和执行堆栈<\/p><p><strong>CLASSES 信息块：<\/strong>类加载信息<\/p><p>Javacore 中的线程可分为以下几种状态：<\/p><ul class=\"ibm-bullet-list\"><li>\n死锁（Deadlock）【重点关注】：一般指多个线程调用间，进入相互资源占用，导致一直等待无法释放的情况。<\/li><li>\n执行中（Runnable）【重点关注】：一般指该线程正在执行状态中，该线程占用了资源，正在处理某个请求，有可能在对某个文件操作，有可能进行数据类型等转换等。<\/li><li>\n等待资源（Waiting on condition）【重点关注】：等待资源，如果堆栈信息明确是应用代码，则证明该线程正在等待资源，一般是大量读取某资源、且该资源采用了资源锁的情况下，线程进入等待状态。又或者，正在等待其他线程的执行等。<\/li><li>\n等待监控器检查资源（Waiting on monitor）<\/li><li>\n暂停（Suspended）<\/li><li>\n对象等待中（Object.wait()）<\/li><li>\n阻塞（Blocked）【重点关注】：指当前线程执行过程中，所需要的资源长时间等待却一直未能获取到，被容器的线程管理器标识为阻塞状态，可以理解为等待资源超时的线程。这种情况在应用的日志中，一般可以看到 CPU 饥渴，或者某线程已执行了较长时间的信息。<\/li><li>\n停止（Parked）<\/li><\/ul><p>通过对 Javacore 数据的分析经验，结合对具体应用代码逻辑的理解，有经验的工程师可以直接通过文本编辑器查看原始 Javacore 文件来分析当前应用程序的运行状态。一般初学者则需要通过一些工具进行更直观的分析。<\/p><h3 id=\"major4\">图形化分析工具 TMDA<\/h3><p>有很多图形化工具可以用于 Javacore 的分析。笔者常用的工具为：IBM Thread and Monitor Dump Analyzer for Java 工具，简称 TMDA。TMDA 提供以下功能：<\/p><ul class=\"ibm-bullet-list\"><li>\n提供一个简洁的 Javacore 内容的总结，包括一些初步的预警信息，线程柱状图，内存使用情况信息等等。<\/li><li>\n方便地分析线程栈和监视器（monitor）的用户接口<\/li><li>\n方便地进行多个 Javacore 中的线程栈和监视器进行比较的用户接口<\/li><\/ul><p>无论是初学者还是性能分析专家都可以使用 TMDA 进行 Javacore 的快速分析。关于 TMDA 的更多介绍可以参考它的社区：参考文献 [3]<\/p><h3 id=\"major5\">WC 线程执行堆栈分析<\/h3><p>不论是否利用 TMDA 工具进行分析，对 Javacore 的分析最终都会落实在具体线程的执行堆栈上。如果对具体应用的代码不熟悉，那么看着一个个长长的执行堆栈，可能会觉得无从下手。本部分介绍 WC 线程执行堆栈的常见代码和对应的功能模块。初学者可以根据这些示例推测某个线程的当前运行状态。需要注意的是，WC 的不同版本，同样的功能模块的具体代码可能会发生变化，经过用户定制的代码就更是千差万别。本部分提供的只是依据 WC FEP7 版本代码的一些示例，读者需要根据自己所处理的系统的实际代码情况灵活掌握，不可拘泥。<\/p><p>通常一个 Javacore 里面会有上百个线程，这些线程的地位并不一样。有些线程是系统运行的“入口线程”，而其他一些线程只是由这些线程派生出来的辅助线程。所以 Javacore 分析过程中一定要抓住这些主要线程。<\/p><p>WC 的核心是一个 Web 应用，所以大部分 WC 的 Javacore 以应用服务器的 Web 容器为入口。用来处理前台商店或后台管理端的 JVM 基本类似，但专门运行定时任务的 JVM 会有所区别。下图 2 所示为以 Web 容器为入口线程的一般调用结构：<\/p><h5 id=\"img002\">图 2. 调用结构<\/h5><img alt=\"图 2 调用结构\" src=\"/sunshine_new/images/负934160391/img002.gif\" width=\"582\" /><p>从 Web 容器入口开始，一般会进入 Servlet 执行。如果有缓存而且命中的话，则会进入 DynaCache 的相关代码。如果无缓存或缓存不命中，如果是 JSP 页面，则会执行 JSP 的相关代码，否则会执行相应的逻辑。代码逻辑处理过程中，经常会访问到数据库（通过 DSL 或 EJB）或 Solr 搜索（通过 BOD 或 REST），还有可能访问到外部系统集成接口（通过 HTTP 同步调用或消息队列）。如果数据库服务器 / 搜索服务器 / 系统集成服务器分布在其他节点上，那么这些调用最终都会转化为网络访问。<\/p><p>以下为一个正在处理 JSP 页面中的数据库请求的执行堆栈示例，如图 3、4、5：<\/p><h5 id=\"img003\">图 3. 堆栈实例（1）<\/h5><img alt=\"图 3 堆栈实例（1）\" src=\"/sunshine_new/images/负934160391/img003.png\" width=\"581\" /><h5 id=\"img004\">图 4. 堆栈实例（2）<\/h5><img alt=\"图 4 堆栈实例（2）\" src=\"/sunshine_new/images/负934160391/img004.png\" width=\"582\" /><h5 id=\"img005\">图 5. 堆栈实例（3）<\/h5><img alt=\"图 5 堆栈实例\" src=\"/sunshine_new/images/负934160391/img005.png\" width=\"582\" /><p>自下而上的关键代码：<\/p><ol type=\"1\"><li>Web 容器处理请求\n\t\t\t\t <p>Package 名 / 类名 . 方法名：com.ibm.ws.webcontainer/WebContainer.handleRequest<\/p><\/li><li>RuntimeFilter \n\t\t\t\t <p>Package 名 / 类名 . 方法名：com.ibm.commerce.webcontroller/RuntimeServletFilter.doFilterAction<\/p><\/li><li>Servlet 处理\n                   <p>Package 名 / 类名 . 方法名：com.ibm.commerce.struts/ECActionServlet.doGet<\/p><p>或者<\/p><p>Package 名 / 类名 . 方法名：com.ibm.commerce.struts/ECActionServlet.doPost<\/p><\/li><li><strong>JSP 处理<\/strong><p>Package 名 / 类名 . 方法名：com.ibm._jsp/_(JSP 文件名 )._jspService<\/p><\/li><li>Command 执行（图例为 BOD command）\n\t\t\t\t <p>Package 名 / 类名 . 方法名：com.ibm.commerce.*/Abstract(*)CmdImpl.performExecute<\/p><\/li><li>DSL \n\t\t\t\t  <p>Package 名 / 类名 . 方法名：com.ibm.commerce.foundation.server.services.dataaccess/AbstractDataServiceFacade.*<\/p><\/li><li>JDBC \n                    <p>查询<\/p><p>Package 名 / 类名 . 方法名：com.ibm.ws.rsadapter.jdbc/WSJdbcPreparedStatement.executeQuery<\/p><p>或 Package 名 / 类名 . 方法名：com.ibm.ws.rsadapter.cci/WSResourceAdapterBase.executeQuery<\/p><p>更新<\/p><p>Package 名 / 类名 . 方法名：com.ibm.ws.rsadapter.jdbc/WSJdbcPreparedStatement.executeUpdate<\/p><p>或 Package 名 / 类名 . 方法名：com.ibm.ws.rsadapter.cci/WSResourceAdapterBase.executeUpdate<\/p><\/li><li>数据库驱动代码\n                     <p>DB2<\/p><p>Package 名：com.ibm.db2.*<\/p><p>Oracle<\/p><p>Package 名 / 类名 . 方法名：oracle.jdbc.driver/OraclePreparedStatement.executeInternal<\/p><\/li><li><strong>外部网络访问<\/strong><p>（网络读）Package 名 / 类名 . 方法名：java.net/SocketInputStream.socketRead0<\/p><p>（网络写）Package 名 / 类名 . 方法名：java.net/SocketOutputStream.socketWrite0<\/p><\/li><\/ol><p>其他常见的执行堆栈举例：<\/p><ul class=\"ibm-bullet-list\"><li><strong>空闲（Idle）<\/strong><p>这样的堆栈表示当前线程处于空闲状态（对于 Web 容器而言，即当前线程没有接收到 Web 请求）。其调用栈为：<\/p><p>Package 名 / 类名 . 方法名：java.lang/Object/wait<\/p><p>…<\/p><p>Package 名 / 类名 . 方法名：com.ibm.ws.util/ThreadPool$Worker. run<\/p><p>或者<\/p><p>Package 名 / 类名 . 方法名：com.ibm.io.async/AsyncLibrary. aio_getioev*<\/p><p>…<\/p><p>Package 名 / 类名 . 方法名：com.ibm.ws.util/ThreadPool$Worker. run<\/p><h5 id=\"img006\">图 6 示例截图<\/h5><img alt=\"图 6 示例截图\" src=\"/sunshine_new/images/负934160391/img006.png\" width=\"573\" /><\/li><li>事务（Transaction）处理\n\t\t\t <p>提交（Commit）<\/p><p>Package 名 / 类名 . 方法名：com.ibm.commerce.server/TransactionManager.commit<\/p><p>回滚（Rollback）<\/p><p>Package 名 / 类名 . 方法名：com.ibm.commerce.server/TransactionManager.rollback<\/p><\/li><li>缓存（DynaCache）读取\n\t\t\t <p>Package 名 / 类名 . 方法名：com.ibm.ws.cache/Cache.getEntry（或 getCacheEntry）<\/p><p>基于 WXS 的缓存则为<\/p><p>Package 名 / 类名 . 方法名：com.ibm.ws.objectgrid.dynacache/RemoteCoreCacheImpl.get<\/p><\/li><li>MultiClick 处理\n\t\t\t <p>Package 名 / 类名 . 方法名：com.ibm.commerce.webcontroller.doubleclick/MultiClickRequestHandler. waitForResponse<\/p><\/li><li>消息处理（MQ）\n\t\t\t <p>Package 名 / 类名 . 方法名：com.ibm.mq.jmqi.remote.internal/RemoteRcvThread.run<\/p><\/li><li>搜索（Solr）处理\n\t\t\t <p>Package 名 / 类名 . 方法名：org.apache.solr.client.solrj/SolrServer.query<\/p><\/li><li>REST 处理\n\t\t\t <p>Package 名 / 类名 . 方法名：com.ibm.commerce.foundation.internal.client.util/RESTHandler.execute<\/p><\/li><\/ul><p>前面作者已经强调，不同版本的 WC 代码或者经过定制的代码会有不同。读者必须在实际系统开发运维过程中积累经验，形成自己的代码样例“库”。这样才能在长长的执行堆栈中迅速抓住关键信息。<\/p><h2 id=\"major6\">案例分析<\/h2><p>本部分通过两个具体实例讲解如何通过 Javacore 分析来分析解决 WC 系统中的性能问题。当系统出现性能问题的时候，通常系统的工作状态会发生某些异常。我们的任务就是通过 Javacore 分析来找出系统关键线程的运行状态变化。这里一般都需要获取多次 Javacore 并进行比较，发现哪些是“变”的部分，哪些是“不变”的部分。所以，谁和谁比，比什么，是分析问题的关键。<\/p><h3 id=\"major7\">逻辑死锁问题<\/h3><p>Javacore 分析经常用于解决逻辑死锁问题。使用 TMDA 工具，可以在图形界面中快速找出不同线程之间的等待关系，如图 7 所示：<\/p><h5 id=\"img007\">图 7. TMDA 工具图形界面<\/h5><img alt=\"图 7 TMDA 工具图形界面\" src=\"/sunshine_new/images/负934160391/img007.png\" width=\"485\" /><p>如果在同一个 JVM 内部出现了线程之间循环等待的状况，就会进入线程之间的死锁（Deadlock）状态。对于未定制的 WC 系统而言，直接出现这样的死锁问题的可能性比较小。较常见的是在整个系统的不同节点之间出现的逻辑死锁问题，这种问题一般不能直接在 Javacore 中识别出来。本节通过一个 WC 内部测试过程中遇到的案例介绍如何分析解决这种逻辑死锁问题。<\/p><p>这是一个随机浏览产品目录的测试场景。在这个场景中，WC 应用服务器接收请求，并调用搜索服务器上的索引进行处理。简化后的系统架构图（省略了 Web 服务器）如图 8 所示：<\/p><h5 id=\"img008\">图 8. 简化的系统架构图<\/h5><img alt=\"图 8 简化的系统架构图\" src=\"/sunshine_new/images/负934160391/img008.png\" width=\"308\" /><p>这里，搜索服务器在处理过程中会有一次回调到应用服务器，通过应用服务器获取某些搜索所需的数据。<\/p><p>我们对这个测试场景进行了用户数递增的压力测试，正常情况下，我们期望看到的结果是随着用户数的增加，系统的吞吐量逐渐上升，最后达到一个平稳状态（达到 CPU 瓶颈）。但是实际测试过程中看到的现象却是，当并发用户数增加到某个数值的时候，系统吞吐率突然下降，最终降低到 0，如图 9、10。<\/p><h5 id=\"img009\">图 9. 并发用户数<\/h5><img alt=\"图 9 并发用户数\" src=\"/sunshine_new/images/负934160391/img009.jpg\" width=\"199\" /><h5 id=\"img010\">图 10. 吞吐率<\/h5><img alt=\"图 10 吞吐率\" src=\"/sunshine_new/images/负934160391/img010.jpg\" width=\"226\" /><p>此时，我们监控两个节点上的 CPU 使用状况。发现吞吐量降低为 0 的同时，CPU 使用率也几乎降低为 0。因此，初步可以判断系统出现了逻辑死锁问题。反之，如果某个节点上的 CPU 使用率（或其他资源使用率）很高，则有可能是逻辑死循环或其他代码实现问题。<\/p><p>要想进一步分析就需要通过 Javacore 分析获取当前 JVM 的运行状态信息。这里我们需要分别在应用服务器和搜索服务器端获取 Javacore（采样的时间点要同步）。采样点可以做三次，在吞吐率下降前采样一次，下降后采样两次（中间间隔 30 秒以上）。然后对这三次 Javacore 进行对比分析。<\/p><p>在 TMDA 中打开采样到的 Javacore 文件。TMDA 提供的“Compare Threads”功能可以用来比较这些 Javacore 文件：<\/p><h5 id=\"img011\">图 11. TMDA 比较菜单<\/h5><img alt=\"图 11 TMDA 比较菜单\" src=\"/sunshine_new/images/负934160391/img011.png\" width=\"164\" /><p>先来看 WC 应用服务器端的 Javacore 文件。前文已经解释过 Web 容器通常是整个应用的入口，所以我们重点关注 Web 容器相关线程的状态。TMDA 比较的结果如图 12 所示：<\/p><h5 id=\"img012\">图 12. TMDA 比较结果<\/h5><img alt=\"图 12 TMDA 比较结果\" src=\"/sunshine_new/images/负934160391/img012.png\" width=\"366\" /><p>用黄底色表示（TMDA 的不同版本显示效果可能略有区别）的线程表示在两次采样中的状态相同（执行堆栈相同）。这里可以很清楚地看到在第二次和第三次采样点上，所有 Web 容器的线程执行状态都相同，系统已经进入了假死（HANG）状态（注意这两次采样发生在系统吞吐率降为 0 之后）。<\/p><p>这里需要注意，在第一个采样点（系统吞吐率下降之前），还有很多线程处于“阻塞”（Blocked）状态。而在第二、第三个采样点上，除了个别线程处于阻塞状态外，多数线程都处于“执行中”（Runnable）状态。由此可见，不能完全依赖 Javacore 中标明的线程状态来判断当前系统的状态，关键还是要看执行堆栈中实际在执行的代码。处于“执行中”状态的线程可能实际在等待，而处于“等待资源”（Waiting on condition）状态的线程可能实际是“执行中”状态。<\/p><p>我们进一步分析第二、第三个采样点上，Web 容器各线程的执行堆栈。我们发现，虽然下层处理的页面（JSP）各有不同，但是顶层处于运行中的代码都一样：<\/p><h5 id=\"img013\">图 13. 执行堆栈<\/h5><img alt=\"图 13 执行堆栈\" src=\"/sunshine_new/images/负934160391/img013.png\" width=\"550\" /><p>基本上所有的 Web 容器线程都在等待 REST 请求的网络返回。根据前面描述的简化后的系统结构图，可以推断所有线程都在等候搜索服务器的处理结果。这是作者根据对系统结构的理解进行的判断，如果读者在实际问题分析过程中无法确定，可以使用 netstat 进行网络监控，根据 HTTP 链接的建立情况进一步确认。<\/p><p>下一步，我们再比较搜索服务器端的三个时间点上的 Javacores 文件。结果是类似的，同样第二个和第三个采样点上 Web 容器的所有线程都进入了假死（HANG）状态：<\/p><h5 id=\"img014\">图 14. 三个采样点比较结果<\/h5><img alt=\"图 14 三个采样点比较结果\" src=\"/sunshine_new/images/负934160391/img014.png\" width=\"279\" /><p>我们再来看看搜索服务器端处于“执行中”的线程都在干什么。基本上所有执行堆栈的顶端都在执行如下代码：<\/p><h5 id=\"img015\">图 15. 执行堆栈代码<\/h5><img alt=\"图 15 执行堆栈代码\" src=\"/sunshine_new/images/负934160391/img015.png\" width=\"553\" /><p>经过代码分析，我们发现这是搜索服务器端在通过 REST 回调 WC 应用服务器，获取 BCS（BusinessConextService）相关的数据。<\/p><p>这样的调用关系为什么会导致逻辑上的死锁呢？关键在于对 Web 容器的线程池资源的竞争上。每个 WC 端接收到的请求在处理过程中需要占用 Web 容器的线程池的一个线程资源，而这个处理逻辑在处理过程中请求了搜索服务器端，又通过搜索服务器端回调到 WC 端，这就需要占用 Web 容器的线程池的另一个线程资源。<\/p><p>这个逻辑关系可以简化为图 16：<\/p><h5 id=\"img016\">图 16. 简化逻辑关系图<\/h5><img alt=\"图 16 简化逻辑关系图\" src=\"/sunshine_new/images/负934160391/img016.png\" width=\"309\" /><p>在应用服务器的 Web 容器线程池资源上，通过搜索服务器的回调形成了一个闭环。这类似于标准的“哲学家就餐问题”，如果所有的请求都占用了第一个线程资源，而请求第二个线程资源，那么所有的线程都会阻塞在这个状态上，形成死锁。要解决这个线程死锁问题，必须消除这个资源占用上的闭环。可以采取的方案包括消除从 Search 端的 REST 回调，建立一个独立的线程池专门负责处理 Search 端的回调，等等。<\/p><h3 id=\"major8\">寻找性能瓶颈<\/h3><p>除了分析逻辑死锁问题外，Javacore 分析也可以用于寻找性能瓶颈。一般来说，寻找代码逻辑中的性能瓶颈，需要对代码的执行路径进行 Profiling（执行统计分析）。Profiling 工具一般有两种。能够提供完整执行堆栈的工具一般都是侵入式的，运行开销很高，并不适于在高负载的生产环境中使用。基于采样（sampling）的工具运行开销很小，但通常都不提供完整的执行堆栈。这里其实可以把 Javacore 分析当作辅助的 Profiling 工具来用。每个 Javacore 都提供了在某一时刻正在运行的代码的执行堆栈，这可以看作一个采样点。如果多做几次采样点，那么根据这些 Javacore 数据就可以进行一个执行路径的粗略 Profiling（不过总体采样点数量比真正的 Profiling 工具少很多）。<\/p><p>我们仍以一个 WC 产品测试过程中遇到的问题为例介绍这种分析方法。<\/p><p>我们在某个产品开发的版本测试过程中发现，搜索结果页面（SearchResultDisplay）的性能比前一个版本下降了很多。为了找出性能下降的原因，我们对该页面进行了单场景压力测试。当系统性能进入稳定状态后，我们在 WC 应用服务器端做了 Javacore 数据采样。<\/p><p>同样，我们的入口线程仍是 Web 容器的线程。这里要解决的是性能下降问题（系统 CPU 占用率很高），而不是逻辑死锁问题。所以我们关注的重点是同一次采样内部线程之间的横向比较，而不是多次采样之间的横向比较，所以只需要用到 TMDA 的线程分析功能，而不需要使用线程比较功能。<\/p><p>如果关注于执行堆栈的顶部代码，我们发现 Web 容器各线程的执行状况比较分散，似乎没有什么规律。但是如果从执行堆栈的底部往上看，就会发现某些规律。这里我们发现在 Web 容器的 25 个线程（等于线程池的大小）中，有一半以上的执行堆栈在执行如下图 17 代码：<\/p><h5 id=\"img017\">图 17. 执行代码<\/h5><img alt=\"图 17 执行代码\" src=\"/sunshine_new/images/负934160391/img017.png\" width=\"553\" /><p>由于这是单场景压力测试，基本上所有的 Web 容器线程都在执行相同的 JSP：SearchBasedCategoryPage。如果这个 JSP 里面没有明显的性能瓶颈，那么 Web 容器的 25 个线程应该随机运行在这个 JSP 的不同代码逻辑之中。我们实际观察到的现象则是有一半以上的线程都在执行如下代码：<\/p><p>com/ibm/commerce/infrastructure/facade/client/AbstractInfrastructureFacadeClient.getOnlineStore<\/p><p>为了排除代码执行随机性的影响，我们又在随后的系统执行过程中多做了几次采样，仍然得到了类似的结果。<\/p><p>这就表示该代码有可能是整个 JSP 逻辑中的性能瓶颈（当然还不能完全确定）。另一方面，通过与前一个版本的 Javacore 进行对比分析，发现前一版本的 Javacore 中并没有出现该代码。这说明该代码是当前版本新引入的代码。通过进一步的代码分析发现，这是在当前版本中新加入的一段处理客户定制逻辑的新代码。我们屏蔽了该端代码后，重新进行了性能测试，发现性能基本上可以恢复到前一版本的水平。因此最终可以确定是这段代码导致了当前版本的性能下降问题。<\/p><p>如何解决这类性能问题呢？首先应该是评估原始的实现逻辑，是否需要在每一个页面请求的处理过程中执行这段逻辑。如果不需要，则可以直接屏蔽该代码段。如果这一段逻辑必须在每一个页面请求中执行，则可以考虑引入适当的缓存机制，降低重复执行时的开销。<\/p><p>这种分析方法也可以用于在客户生产系统中快速定位整个系统的性能瓶颈。生产系统执行的页面请求是多种多样的，通常情况下，在生产系统上做 Javacore 应该找不到什么规律。反之，如果多次采样可以发现系统在高负载运行状态下，Web 容器线程的执行堆栈存在某些规律，比如：大部分线程都在执行目录页面（CategoryDisplay）显示。而页面访问统计的结果显示，目录页面的访问频率并不比其他页面高很多。这种情况下就很有可能在 CategoryDisplay 页面有性能瓶颈。下一步就可以进行单场景的压力测试来进一步寻找 CategoryDisplay 页面逻辑中的性能瓶颈。<\/p><p>如果能将 Javacore 分析的结果，与其他基于采样的 Profiling 工具的分析结果相结合，则更容易快速找到代码中的性能瓶颈。<\/p><CMA ID: 975726><Site ID: 10><XSLT stylesheet used to transform this file: dw-document-html-7.0.xsl>\r\n\r\n\r\n<\/div>\r\n<\/div>\r\n","createTime":"2014-06-26 00:00:00","deployTime":"2014-06-26 00:00:00","id":0,"intro":"随着电子商务应用的广泛应用和用户体验度的提升，对一个生产环境的突发问题的快速诊断和解决以及系统恢复变得越来越关键。一般情况下，我们会有一定的监控，恢复的流程和手段，包括搜集相应的信息并进行相应的分析。本文中会着重介绍一下如何分析 Javacores（Javadumps）来诊断出线程挂起，死锁，资源争抢等资源瓶颈等问题，并以一个 WC 线程死锁的案例来帮助大家分析理解 Javacore，从而确定相应的解决方案。","keyword":"","recommend":false,"source":"http://www.ibm.com/developerworks/cn/websphere/library/techarticles/1406_tuzy_javacore/1406_tuzy_javacore.html","title":"通过 Javacore 诊断线程挂起等性能问题","typeId":0,"updateTime":"2014-06-26 00:00:00"}
{"author":"","clickNumber":0,"content":"\r\n<div class=\"ibm-columns\">\r\n<div class=\"ibm-col-1-1\">\r\n\r\n<h2 id=\"major1\">前言<\/h2><p>本文是对使用 IBM 内容管理系统为平台的广东农信银行客户后督系统的分析和介绍，以及对大数据量和高吞吐的基于 DB2 数据库的 IBM Content\n                Manager\n                系统的一些设计上的分析以及一些实际问题的解决，系统在调优后性能和吞吐量满足的客户的需求，可以作为类似系统的参考，但是要注意，每一个系统都有自己独特的需求和实际情况，本文无法涵盖您在系统建设过程中的所有问题，欢迎联系我们做进一步探讨。另外，将来实际系统中在数据量达到一定量级时，可能会碰到新的难题，我们希望能和客户一起协作解决并将经验分享给大家。第\n                2 部分，我们将着重介绍实例问题和分析解决的办法供类似系统参考。<\/p><h2 id=\"major2\">对于实例系统中出现的与性能和高并发相关的关键问题的分析和解决<\/h2><p>在客户的实际后督生产系统中，在系统工程师的努力下，经过了对网络、存储、DB2、WAS、TSM 和 CM\n                的调优以后，依旧在高吞吐和为此设计的高并发的系统中发现了两个棘手的问题，严重影响了性能，并造成了一些 CM 孤儿数据 (Orphan data)\n                很难被处理，这些问题虽然不一定会在每个系统中都出现，但一旦出现解决起来耗时耗力，在客户和 IBM\n                支持人员的协作下，问题得到了圆满的解决，本文借此机会感谢所有参与解决这些问题的客户和 IBM\n                支持人员，并将问题和分析解决的思路共享出来，可以供有类似问题的高吞吐高并发内容管理系统参考。<\/p><h3 id=\"major3\">问题一. 启用迁移后资源数据库占用 CPU 达到\n                100%<\/h3><p>此时 I/O，网络资源都很充足，根据对动态 SQL 语句的监控，发现大量并发操作会执行同一条语句。<\/p><h5 id=\"listing1\">清单 1. 造成 CPU100%问题的 SQL<\/h5><div class=\"codesection\"><pre class=\"displaycode\">Statement : SELECT TRANSACTIONID FROM RMTRANSACTIONS WHERE (( OBJ_LIBRARYID = ? AND OBJ_ITEMID = ? AND\nOBJ_VERSION =? AND OBJ_COLLID = ? ) OR ( OBJ_TMP_ITEMID = ?\nAND OBJ_TMP_VERSION = ? AND OBJ_TMP_COLLID = ? )) AND TRANSACTIONID&lt;&gt;?<\/pre><\/div><p>此语句的访问计划 (Access plan) 虽然使用了如下的索引 TRAN_ID_X1，但是访问的行数巨大并造成了巨量的逻辑读，经过分析是造成\n                CPU 资源占用过大的根本原因。<\/p><h5 id=\"listing2\">清单 2. 调优前访问计划<\/h5><div class=\"codesection\"><pre class=\"displaycode\">Optimizer Plan:\n Rows \n Operator \n (ID) \n Cost \n 0 \n n/a \n RETURN \n ( 1) \n 0.015443 \n | \n 0 \n n/a \n FETCH \n ( 2) \n 0.015443 \n / \\\n 0 0 \n n/a n/a \n IXSCAN Table: \n ( 3) RM2ADMIN \n 0.0150991 RMTRANSACTIONS \n | \n 0 \n Index: \n RM2ADMIN \n TRAN_ID_X1<\/pre><\/div><p>分析 RMTRANSACTIONS 表可以发现此表是 VOLATILE 类型的表，并且有三个索引：<\/p><ul class=\"ibm-bullet-list\"><li> 主键索引<\/li><\/ul><p>包含 (OBJ_COLLID, OBJ_ITEMID, OBJ_VERSION, OBJ_LIBRARYID, TRANSACTION_DATE)\n                字段。<\/p><ul class=\"ibm-bullet-list\"><li> 索引 TRAN_TMP_ID_X0<\/li><\/ul><p>包含 (OBJ_TMP_COLLID, OBJ_TMP_ITEMID, OBJ_TMP_VERSION) 字段。<\/p><ul class=\"ibm-bullet-list\"><li> 索引 TRAN_ID_X1<\/li><\/ul><p>包含 (TRANSACTIONID, TRANSACTION_DATE, PROCESSTIMEOUT) 字段。<\/p><p>根据清单 1 内动态 SQL 语句的写法，访问执行计划可能使用两种路径，路径 1 就是现在清单 2 中使用的索引 TRAN_ID_X1，路径 2\n                就是在或 (or) 条件中使用主键索引和索引 TRAN_TMP_ID_X0。由于 RMTRANSACTIONS 表是 VOLATILE\n                类型的表，VOLATILE 代表这个表是变动非常频繁的表，统计信息已经不能正确反映实际的数据量，DB2\n                在表的查询时候只要有满足条件的索引，会忽略统计信息，优先使用索引，这个表的特点就是资源数据库有事务发生时候会记录相应的事务记录，事务结束后会删除相应的记录，所以一般情况下记录很少或者为\n                0，当打包迁移发生时，会在短时间内有大量事务产生，记录数可能在 0 到几万条之间频繁变化，非常符合 VOLATILE\n                表的特性，而且这三个索引都有期望的 SQL 语句会经常使用，索引的设计和定义也没有问题。那么问题出在哪呢？<\/p><p>我们结合迁移的场景仔细分析这个 SQL 语句，会发现，索引 TRAN_ID_X1(TRANSACTIONID, TRANSACTION_DATE,\n                PROCESSTIMEOUT) 影响的查询条件是 TRANSACTIONID&lt;&gt;?，业务的含义是寻找有没有其他的\n                TRANSACTIONID 和现在要使用的是否有相同的，对于一个迁移事务，对应的表内应该没有相同的 TRANSACTIONID\n                或者至多一条，所以在这个&lt;&gt;? 的条件中，将会在索引扫描后对基础表做全表扫描去匹配剩下的条件 (比如 OBJ_ITEMID)\n                等，这样一来，使用这个索引的结果就是做了一次索引的全扫描加上全表扫描，这样就会造成大量的行读，这样我们就分析出来错误的根本原因是在客户的现场环境中对于\n                RMTRANSACTIONS 这张 VOLATILE 表没有找到最优的访问计划，实际上数据分析的结果应该是选用路径 2\n                的访问计划，这样索引扫描的结果应该是几乎为 0 的记录数，也就基本没有任何表扫描。<\/p><p>由于是 VOLATILE 表，此表本身统计信息长期为 0 不具备参考价值，优化器有可能会根据系统的各个条件选取路径 1 或者路径\n                2，我们测试的系统中都选择了高效的路径 2，但是客户的实际系统中还是有一定的可能选择路径 1，即使选用路径 1\n                这个问题也不一定都能暴漏出来，只有迁移的并发吞吐达到一定的量级 (比如每秒迁移超过 1000) 才可能会呈现出来，DB2\n                本身也对这种极少可能发生的访问路径选取异常设计了解决方案。问题分析出来以后，剩下的就是使用 DB2 提供的 OPTPROFILE 的方案去强制为清单\n                1 的 SQL 指定路径 2 的索引方案。<\/p><p>下面是建立 OPTPROFILE 的步骤：<\/p><ol type=\"1\"><li> 创建 SYSTOOLS.OPT_PROFILE 表 <div class=\"codesection\"><pre class=\"displaycode\">db2 connect to rmdb\ndb2 \"call sysinstallobjects('opt_profiles', 'c', '', '')\"<\/pre><\/div><\/li><li> 创建 PMR35104.PROF1.xml，包含 SQL 的 GUIDELINE。 <div class=\"codesection\"><pre class=\"displaycode\">&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;\n&lt;OPTPROFILE VERSION=\"9.1.0.0\"&gt;\n&lt;STMTPROFILE ID=\"PMR35104\"&gt;\n&lt;STMTKEY &gt;\n&lt;![CDATA[\nSELECT TRANSACTIONID FROM RMTRANSACTIONS WHERE \n(( OBJ_LIBRARYID = ? AND OBJ_ITEMID = ? AND OBJ_VERSION = ? AND \nOBJ_COLLID = ? ) OR ( OBJ_TMP_ITEMID = ? AND OBJ_TMP_VERSION = ? AND\nOBJ_TMP_COLLID = ? )) AND TRANSACTIONID&lt;&gt;?\n]]&gt;\n&lt;/STMTKEY&gt;\n&lt;OPTGUIDELINES&gt;&lt;IXOR TABID=\"Q1\"/&gt;&lt;/OPTGUIDELINES&gt;\n&lt;/STMTPROFILE&gt;\n&lt;/OPTPROFILE&gt;<\/pre><\/div><\/li><li> 创建文件 profiledata，内容为\"PMR35104\",\"PROF1\",\"PMR35104.PROF1.xml\" <div class=\"codesection\"><pre class=\"displaycode\">vi profiledata\n\"PMR35104\",\"PROF1\",\"PMR35104.PROF1.xml\"<\/pre><\/div><\/li><li> 将 profiledata 装载到 systools.opt_profile 表中； <div class=\"codesection\"><pre class=\"displaycode\">import from profiledata of del modified by lobsinfile replace into systools.opt_profile;<\/pre><\/div><\/li><li> 检查 SQL 语句是否走了新的索引。 <div class=\"codesection\"><pre class=\"displaycode\">--RMADMIN 用户登录系统：\ndb2stop force\ndb2start\ndb2 connect to rmdb\ndb2 set current optimization profile PMR35104.PROF1\ndb2 \"set current explain mode explain\"\ndb2 \"SELECT TRANSACTIONID FROM RMTRANSACTIONS WHERE((OBJ_LIBRARYID = ? AND OBJ_ITEMID =\n? AND OBJ_VERSION = ? AND OBJ_COLLID = ?) OR (OBJ_TMP_ITEMID = ? AND OBJ_TMP_VERSION\n= ? AND OBJ_TMP_COLLID = ?)) AND TRANSACTIONID&lt;&gt;?\"\ndb2 \"set current explain mode no\"\ndb2exfmt -d rmdb1 -1 -o db2exfmt_alan_exfmt_opt.out<\/pre><\/div><\/li><\/ol><p>检查 db2exfmt_alan_exfmt_opt.out 文件，查看执行计划是否如清单 3 所示。<\/p><h5 id=\"listing3\">清单 3. 调优后访问计划<\/h5><div class=\"codesection\"><pre class=\"displaycode\"> Rows \n RETURN\n ( 1)\n Cost \n I/O \n |\n 0 \n FETCH \n ( 2)\n 0.0326346 \n 0 \n /----+----\\\n 0 0 \n RIDSCN TABLE: RM1ADMIN\n ( 3) RMTRANSACTIONS\n 0.0322871 Q1\n 0 \n /------+------\\\n 0 0 \n SORT SORT \n ( 4) ( 6)\n 0.0164133 0.0164133 \n 0 0 \n | |\n 0 0 \n IXSCAN IXSCAN\n ( 5) ( 7)\n 0.0153824 0.0153824 \n 0 0 \n | |\n 0 0 \n INDEX: SYSIBM INDEX: RM1ADMIN\n SQL130130132712470 TRAN_TMP_ID_X0\n Q1 Q1<\/pre><\/div><p>从清单 3 左下部分中我们可以看到，查询的访问计划已经转而使用我们希望的主键索引和索引 TRAN_TMP_ID_X0 做索引查询。<\/p><p>由于资源数据库的应用是部署在 WAS 上的，在 DB2 服务端设置完后，需要对 WAS 端进行设置，使得 WAS 连接数据库的应用使用\n                PMR35104.PROF1。<\/p><h5 id=\"img001\">图 1. WAS 应用 OPTPROFILE<\/h5><img alt=\"图 1. WAS 应用 OPTPROFILE\" src=\"/sunshine_new/images/586795776/img001.png\" width=\"583\" /><p>添加定制属性：<\/p><p>属性名：optimizationProfile <\/p><p>属性值：PMR35104.PROF1<\/p><p>定制完成后，需要重启 WAS 服务器。<\/p><p>结论：在使用了 DB2 的 OPTPROFILE 的方法之后，进行测试后发现开启单个 WAS 集群应用服务器后数据库服务器的 CPU 使用率在\n                5%左右，4 个应用服务器同时启动后，CPU 使用率大约在 20%左右，网络的吞吐量能达到 400-500MB/秒, 迁移数量每个应用服务器都为\n                800 笔/秒左右，完全能满足客户的业务需求。<\/p><h3 id=\"major4\">问题二. CM 装载存在孤儿数据<\/h3><p>如前文所述，客户系统中每天白天需要装载 400 万图片项，有 10 台客户端上载程序同时工作上传，每台客户机有 10 个进程同时上载，也就是总共有\n                100 个进程同时上载文档图片，并且使用 4 组 WAS ND 集群服务器，每个集群包含 4\n                个节点。在批量上载过程中，每导入几千万的数据，总会有一些孤儿数据产生，经过分析，这些孤儿数据产生的原因是，产生问题的几条数据，每条数据对于同一个上载任务，有时间很近的两条上载任务向资源服务器发出请求，虽然由于主键约束系统会拒绝其中的一条，但实际进入的一条时间戳会产生不一致，检验工具会把这条数据标记为孤儿数据。经过诊断分析，CM\n                本身不会对同一条上载记录做重复上载命令，最终认定是由于 RM 使用集群，IHS 使用安装时默认的转发功能导致，建议将 IHS\n                上的重新转发功能取消。具体表现为同一个请求在一个节点上执行超时（默认为 60 秒），IHS\n                可能将该请求转发不同的节点上，而不同节点上的数据信息不一致，导致 CM 报错并产生脏数据（包括孤儿数据）。对 WAS 的具体修改如下：<\/p><ol type=\"1\"><li> 修改 IHS 的配置文件 plugin-cfg.xml，将其中的 ServerIOTimeout=\"60\"\n                    、PostBufferSize=\"64\"修改为 ServerIOTimeout=\"300\"\n                    、PostBufferSize=\"0\"。这样设置表示，IHS 上的请求在 300 秒内没有收到 WAS\n                    的响应，不会自动进行转发，会报超时错误。<\/li><li> 修改 WAS 应用服务器的 ServerIOTimeout 参数（读/写超时）的值为 0，即读写超时时不转发请求。 <h5 id=\"img002\">图 2. WAS 修改读写超时<\/h5><img alt=\"图 2. WAS 修改读写超时\" src=\"/sunshine_new/images/586795776/img002.png\" width=\"553\" /><\/li><li> 修改 CM 库数据库 ICMNLSDB 的 ICMSTSYSCONTROL.MAXTXDURATION 字段，默认是 86400（24\n                    小时），将其修改为较小值，IBM 建议不低于 7200 (2 小时)。该值表示 CM 事务执行的间隔等待时间。（update\n                    ICMSTSYSCONTROL set MAXTXDURATION = 7200 where LIBRARYSERVERID =\n                    1）<\/li><\/ol><p>结论：通过优化后的性能测试验证，该设置起效，CM 多线程并发装载再没有出现脏数据。<\/p><h2 id=\"major5\">小结<\/h2><p>通过本文第 2 部分的介绍，我们可以了解 CM 高吞吐高并发实例系统中几个特殊疑难问题的分析和解决方法。<\/p><h2 id=\"major6\">特别感谢<\/h2><p>特别感谢广东农信杨韶宁经理、苏汉槟经理对项目和文章的巨大支持和帮助，并对 IBM\n                参与此项目设计和问题解决的徐军、纪海、李永亮、陈宁、刘健、殷卓、胡金培、沈鑫等同事表示感谢。<\/p><h2 id=\"major7\">免责声明<\/h2><p>本文中任何带有主观性的陈述都只代表本书作者个人的观点，不代表 IBM\n                公司的官方立场。本文是对某个银行客户实例系统的分析和介绍，可以作为类似系统的参考，但是要注意，每一个系统都有自己独特的需求和实际情况，本文并不能提供适应这些系统通用模式，各个系统还是要根据自己的需求去设计架构模型和实现。<\/p><CMA ID: 975346><Site ID: 10><XSLT stylesheet used to transform this file: dw-document-html-7.0.xsl>\r\n\r\n\r\n<\/div>\r\n<\/div>\r\n","createTime":"2014-06-26 00:00:00","deployTime":"2014-06-26 00:00:00","id":0,"intro":"大数据量和高吞吐是银行内容管理系统长期设计的核心问题，本文通过内容管理系统在农信银行后督系统的设计和实现实例 (基于 DB2V97 数据库)，描述对于内容管理系统如何针对每天大约 400 万个图片、可能存放 15 年达到 2PB 文件规模的大数据量系统进行数据模型设计、表分区以及压缩的具体设计实现，以及系统在高并发下一些实际问题的处理，系统上线后吞吐量和性能得到了客户的认可，可以为类似的银行系统提供重要的参考。","keyword":"","recommend":false,"source":"http://www.ibm.com/developerworks/cn/data/library/bd-1406-bankimagedesign-part2/index.html","title":"银行影像内容大数据系统的设计以及实例问题分析，第 2 部分: 实例问题分析篇","typeId":0,"updateTime":"2014-06-26 00:00:00"}
{"author":"","clickNumber":0,"content":"\r\n<div class=\"ibm-columns\">\r\n<div class=\"ibm-col-1-1\">\r\n\r\n<h2 id=\"major1\">前言<\/h2><p>本文是对使用 IBM 内容管理系统为平台的广东农信银行客户后督系统的分析和介绍，以及对大数据量和高吞吐的基于 DB2 数据库的 IBM Content\n                Manager\n                系统的一些设计上的分析以及一些实际问题的解决，系统在调优后性能和吞吐量满足的客户的需求，可以作为类似系统的参考，但是要注意，每一个系统都有自己独特的需求和实际情况，本文无法涵盖您在系统建设过程中的所有问题，欢迎联系我们做进一步探讨。另外，将来实际系统中在数据量达到一定量级时，可能会碰到新的难题，我们希望能和客户一起协作解决并将经验分享给大家。第一部分,\n                我们将着重介绍系统背景需求以及设计。<\/p><h2 id=\"major2\">中英文术语对照表/缩略语<\/h2><p>IBM 内容管理系统：英文名 IBM Content Manager，简称 CM。<\/p><p>广东农信影像化事后监督系统：简称广东农信后督系统。<\/p><p>库数据库：英文名 Library server database，简称 LSDB。<\/p><p>资源数据库：英文名 Resource manager database，简称 RMDB。<\/p><p>资源管理应用程序：英文名 Resource manager application，简称 RMApp。<\/p><p>项类型：英文名 Itemtype。<\/p><p>资源项类型：英文名 Resource itemtype。<\/p><p>文档项类型：英文名 Document itemtype。<\/p><p>项：英文名 Item。<\/p><p>项级别：英文名 Item Level。<\/p><p>访问控制列表：英文名 Access control list，简称 ACL。<\/p><p>本地索引：英文名 Local index。<\/p><p>表分区分离：英文名 Detach partition。<\/p><p>级联目录：英文名 Hierarchical folder。<\/p><h2 id=\"major3\">系统及架构简述<\/h2><p>IBM\n                内容管理系统，是一套基于数据与内容的企业级整体行业解决方案平台，它能够帮助企业快速地解决复杂的问题，在当今瞬息万变的市场环境中更快速地制定高效的决策。客户可以利用\n                IBM\n                内容管理系统产品方便的做到：对各种原始票据、凭证、档案、影像等海量的非结构化数据的存储和管理；数据的生命周期管理；并且可以支持基于内容的分析与查找，高级案例管理，和流行的社交内容管理。<\/p><p>广东农信影像化事后监督系统是提供给全省各农合机构事后监督中心和网点使用，是监督各项业务处理的正确性、合规性、真实性和完整性，及时发现各种核算差错事故，暴露业务核算中发生的各种违章、违纪、违法行为，完善业务操作风险控制体系，实现差错处理的电子化流转，实现凭证的电子化管理的一整套管理系统。系统主要包括影像处理、重点监督、再监督、风险预警、差错处理流程管理，实物档案流程管理等功能，使用\n                IBM 内容管理平台实现对影像数据存储的生命周期管理，满足用户对大数据量历史影像数据的实时在线调阅需求。<\/p><p>经过前期的数据收集和业务估算，广东农信后督系统全省上线后，日均凭证影像张数将达到 400 万张，最近 60\n                天的凭证影像经常会发生调整、修改信息、整改差错的业务操作。而从系统建设层面考虑，日均 400\n                万张的凭证影像将导致系统的记录数和数据量非常庞大，需要考虑多个影像文件打包成一个大文件后部份读取的可能性，恰好 CM\n                的聚合迁移支持这种打包操作。如果按照会计档案需保管十五年的要求，广东农信后督系统影像文件的总存储空间将达到\n                2PB，为保证数据的读取效率同时兼顾项目建设成本，广东农信规划了如下的后督系统影像文件总体存储策略：<\/p><table border=\"0\" cellpadding=\"0\" cellspacing=\"0\" class=\"ibm-data-table\"><thead xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"><tr><th><strong>存储宿主<\/strong><\/th><th> 后督系统<br /> （10 台文件服务器） <\/th><th> CM 在线<br /> （LBOSDATA） <\/th><th> CM 近线<br /> （CM TSM 存储卷） <\/th><th> CM 离线<br /> （CM TSM 磁带卷） <\/th><\/tr><\/thead><tbody xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"><tr><td><code><strong>存储介质<\/strong><\/code><\/td><td> SAN 存储 <\/td><td> NAS 存储 <\/td><td> NAS 存储 <\/td><td> 磁带库 <\/td><\/tr><tr><td><strong>存储期限<\/strong><\/td><td> 60 天 <\/td><td> 7 天 <\/td><td> 22 个月 <\/td><td> 如果按照会计档案需保管十五年的要求，那么 CM 离线数据的存储期限将达到 13 年 <\/td><\/tr><tr><td><strong>存储模式<\/strong><\/td><td> 同一日期同一网点同一柜员几百张影像形成的一个大数据包 <\/td><td> 具体一张一张的影像 <\/td><td> CM 聚合迁移形成的 300 张影像一个文件的大数据包 <\/td><td> CM 聚合迁移形成的 300 张影像一个文件的大数据包 <\/td><\/tr><\/tbody><\/table><p>根据广东农信后督系统的实际使用需求，广东农信还规划了影像数据的生命周期管理时间窗口要求，具体为：后督系统影像文件装载至 CM（两个小时）? CM\n                影像文件迁移至 TSM（两个小时）? TSM 存储卷迁移至磁带卷（四个小时）。<\/p><p>针对广东农信后督系统影像文件的总体存储策略和影像数据生命周期管理的时间窗口要求，结合后督系统、CM 内容管理平台的扩展性（除了 CM\n                的索引库不能扩展，其他都可以扩展），加上 IBM 工程师的指导，广东农信设计了满足此高吞吐大数据量的 CM 系统架构。<\/p><p>具体为：<\/p><p>CM 数据库服务器采用 HA(High Available) 架构，每个数据库服务器节点包含 1 个库数据库和 4\n                个资源数据库、每个资源数据库对应的资源管理应用程序采用 WAS cluster 架构，保证资源管理应用程序的并发性和扩展性，每个 WAS\n                cluster 由一个 Dmgr 管理并分配 2 台物理服务器，每个物理服务器节点下有两个应用服务器，这样对于每个 WAS cluster\n                共四个应用服务器。同时，整套 CM 系统内部采用万兆网连接，TSM(Tivoli Storage Manager) 服务器也采用 HA\n                架构，确保影像数据生命周期管理的时间窗口要求以及高可用要求。下图 1 展示了一个内容管理系统比较通用基于 AIX 的 HA 系统架构图 (包含多个\n                RM 和 RMApp)：<\/p><h5 id=\"img001\">图 1. 系统架构图<\/h5><img alt=\"图 1. 系统架构图\" src=\"/sunshine_new/images/309913341/img001.png\" width=\"581\" /><h2 id=\"major4\">数据模型的选型以及表分区的设计<\/h2><p>根据计算，广东农信后督系统如果满负荷上线，大约每天需要装载 400 万条数据，每月 1.1 亿，每年约 13 亿数据，IBM\n                内容管理系统的一些表会相应的有这个数量级的记录，如此大的表会带来可能的一些问题，比如维护 (备份、Runstats、Reorg 等)\n                时间长等。另外当数据量达到一定的量级时，整个系统也可能会有一定的性能下降。我们要从数据模型设计以及数据库逻辑物理设计上尽量降低这种发生的可能性，或者能支持更大量的数据，比如银监会要求的\n                15 年数据。首先，我们根据业务的需要去设计数据模型，以下是几点可供参考的考虑：<\/p><ul class=\"ibm-bullet-list\"><li> 选择合适的项类型<\/li><\/ul><p>内容管理系统支持两种主要带文件的项类型：资源项类型和文档项类型。资源项类型相对简单，每个项只能带一个文件，但是相对文档项类型来说，每一个资源项类型可以减少操作至少\n                2 张大表，相对应的在超过 10\n                亿的海量数据量的系统来说，同样的设计，装载和其他业务的效率会更高，也更能节省空间，同时降低维护时间，所以对于海量数据的系统，如果能满足业务需求，我们更建议使用资源项类型存放扫描的文件。另外，对于需要建立多个类似项类型的设计，建议把一些共用的属性先建立一个属性组存放起来，这样能更方便的建立项类型。<\/p><ul class=\"ibm-bullet-list\"><li> 资源数据库均衡负载设计<\/li><\/ul><p>对于多个营业网点的数据，有时候为了便于管理，希望通过一定的机制把不同的营业网点的数据通过不同的资源管理应用程序导入到不同的资源数据库里，这样便于权限管理和分担一定的负载。我们可以把库数据库的默认存储设置为用户级别，如图\n                2 所示，然后为每一个营业网点或网点组建立一个装载用户，为每一个装载用户设置一个默认的 Collection\n                和相应的默认项访问控制列表，然后对于新建的项类型，选择使用项级别的检查级别，并使用用户默认 ACL 检查 (User’s default\n                ACL)，参考图 3，然后用相应的用户做装载数据，就可以控制数据装载在不同的资源数据库。<\/p><ul class=\"ibm-bullet-list\"><li> 建立合适索引<\/li><\/ul><p>对于业务查询常用的属性项，需要建立相应的索引以加快查询和获取数据的速度。<\/p><ul class=\"ibm-bullet-list\"><li> 减少不必要的关系<\/li><\/ul><p>如果没有需求，可以不建立目录、连接、引用、级联目录等复杂的关系，这些都会影响将来可能会实现的表分区分离的可能性。<\/p><ul class=\"ibm-bullet-list\"><li> 文件聚合迁移到 TSM<\/li><\/ul><p>如果对文件没有修改的需求，并且都是最大几兆的小文件，大数据影像系统可以考虑使用 CM\n                提供的聚合迁移功能，聚合迁移会将文件按照打包大小的设置进行打包后迁移到 TSM 中，会大大减少过量小文件产生的网络问题和 TSM\n                服务器的压力，并大大降低 TSM 数据库的数据量和维护成本。<\/p><h5 id=\"img002\">图 2. 库数据库默认存储设置<\/h5><img alt=\"图 2. 库数据库默认存储设置\" src=\"/sunshine_new/images/309913341/img002.jpg\" width=\"581\" /><h5 id=\"img003\">图 3. 项级别 ACL 检查以及用户默认 ACL 设置<\/h5><img alt=\"图 3. 项级别 ACL 检查以及用户默认 ACL 设置\" src=\"/sunshine_new/images/309913341/img003.png\" width=\"554\" /><p>另外，对于可预见的大表将来的使用和维护，我们建议使用 DB2V97FP1 以上的表分区方案，好处是可以更好的分时间段存放数据，更灵活的分配物理资源\n                (盘阵等)，同时可以利用 DB2V97FP1\n                之后支持的表分区中的本地索引减少维护的时间空间，对于业务模型合适的系统，将来甚至可以做到将超过一定时间不常用或者只读的数据从在线业务系统之中分离出去，然后导入到另一个内容管理系统中，降低在线系统的数据量。对于表分区的设计，我们已经有相应的白皮书和文章\n                    (请参考<a href=\"#_参考资源_(resources)\">参考资源<\/a>)\n                做了系统的介绍，本文这里只介绍一下广东农信的现在应用的实例，也就是在 CM843 系统里对于一个只包含一个资源项类型的实例系统的表分区设计。<\/p><ol type=\"1\"><li> 首先找到固定的大表 <p>固定的大表包括库数据库的 ICMSTITEMS001001 和资源数据库的 RMOBJECTS\n                    表。<\/p><\/li><li> 其次找可能的大表 <p>对于激活了历史版本文档的设计，库数据库需要增加大表 ICMSTITEMVER001001\n                        表，对于使用的连接关系的表 (比如使用了目录文档结构) 需要增加大表 ICMSTLINKS001001\n                        表，如果使用了文档类型的项类型，需要增加大表 ICMUT00300001 表和 ICMRI001001\n                        表，如果使用了级联目录关系，那么需要增加大表 ICMSTHLINKS 表。<\/p><\/li><li> 动态表名的大表 <p>下面介绍一下如何找到一个具体项类型元数据实例表。<\/p><div class=\"codesection\"><pre class=\"displaycode\">--取得 Itemtype ID，假设项类型名字是 ITNAME1\nselect keywordcode from icmstnlskeywords where keywordclass=2 and keywordname ='\nITNAME1'\n--取得 ComponentType ID\nselect * from icmstcompdefs where itemtypeid = '1004';<\/pre><\/div><p>注意：1004 应该是第一步取得的值，请用实际值替换。假如 COMPONENTTYPEID 实际值是 1007，项组件类型实例表就为\n                        ICMUT01007001。有几个 COMPONENTTYPEID，就对应有几张 ICMUT0XXXX001 表，其中 XXXX 为\n                        COMPONENTTYPEID。<\/p><\/li><li> 表分区分区频率设计 <p>根据内容管理系统数据库的特点，上述大表都有包含有时间戳的 ITEMID 字段或者类似字段，以及 DB2\n                        对表分区键选取按时间分区的建议，我们可以选取 ITEMID\n                        或者类似的字段作为表分区的分区键，表分区可以按一定时间间隔分区，比如按月分区、按季度分区、按年分区等，对于一个月有 1\n                        亿数据量的系统来说，我们可以选取一个月一个分区的设计。<\/p><\/li><li> 表分区初始分区以及结束分区的考虑\n                        <p>分区并不是无限的，所以总会有开始分区并且有结束分区，那么我们又希望结束分区不要包含太多时间段的数据，那么最好先和客户沟通一个第一次做表分区的时间段，比如客户希望系统至少运行\n                        10 年，以 2013 年 1 月到 2022 年 12 月为例，我们先要为 0-2013 年 1 月 1 日 (不包含结束日期)\n                        建立初始分区，这个初始分区包含内容管理系统的一些初始数据和可能的临时数据，假设命名为\n                        PSTART。然后中间是每个月一个分区一直建立到 2023 年 1 月 1 日 (同样不包含结束日期)，最后需要建立一个结束分区\n                        (如名字为 PEND) 从 2023 年 1 月 1 日一直到 MAX(最大时间)\n                        作为封尾分区。需要注意的是，如果在系统使用年限接近到达第一次划分预期的结尾时间时，比如提前 1 年的 2021\n                        年底选取业务空闲时期停止业务，分离现有封尾分区 PEND, 创建新的 5\n                        年或者其他年数的表分区，然后用新的预期系统最终使用时间一直到 MAX 重新封尾。<\/p><\/li><li> 表分区中用户自定义的索引设计\n                        <p>如果用户的数据模型中需要对一些字段做检索，最好使用系统管理客户端去为这些字段建立相应的索引，这样索引内就会自动加入\n                        ITEMID\n                        作为索引的一部分，这样就可以使用本地索引，这样会对分区维护和性能对会有好处。如果用户想自己使用数据库命令为数据模型的相关实例表建立自己的索引，应该在\n                        IBM 服务团队的支持下进行，对于表分区的情况，建议尽量在索引定义中加入 ITEMID\n                    字段，当然具体情况需要具体分析。<\/p><\/li><li> 表及索引压缩\n                        <p>对于有海量数据的表，在做表分区的同时可以考虑做表的压缩，也可以考虑同时压缩索引，这样会降低磁盘的使用空间，对于瓶颈主要在\n                        I/O 而 CPU 资源充足的系统，表压缩也会以牺牲一定量 CPU 资源的情况下减少 I/O\n                        占用，理论上会产生一定好的效果，实际情况，应该根据性能测试是否满足客户需要去决定最终的方案。<\/p><\/li><li> 表空间及缓冲池设计\n                        <p>为表分区的数据和索引分别建立独立的表空间和缓冲池。为索引建立单独的缓冲池好处是，对于海量数据调整数据表空间所在的缓冲池无法调优的情况下，单独调整需要内存较小的索引表空间所在的缓冲池，可能会有比较好的效果。另外即使使用了条带化的磁盘阵列作为数据库物理存储，已经可以做到将数据打散到不同的磁盘已达到\n                        I/O 并行访问的效果，我们还是建议为数据和索引建立不同的表空间\n                        (组)，这样方便维护和管理，比如可以对每年或者每季度的表分区建立一个或几个数据表空间，为所有大表的索引每年建立一个表空间。<\/p><\/li><\/ol><h2 id=\"major5\">ICMSTITEMS001001 表分区示例<\/h2><p>我们下面以库数据库里存放所有项基本信息的大表 ICMSTITEMS001001 表为例介绍按月分表分区 (2013 年和 2014 年共 2 年)\n                的示例，其他大表的表分区可以类似去设计和撰写。<\/p><p>首先，创建存储过程 SET_CONSTRAINTS 可以暂时不检查外键，便于数据表重建。<\/p><div class=\"codesection\"><pre class=\"displaycode\">db2 connect to icmnlsdb user icmadmin using icmadmin\ndb2 Ctd@ -vf set_constraints.sql<\/pre><\/div><p>其次，为 ICMSTITEMS001001\n                所在的库数据库增大部分缓冲池，并增加一个索引单独使用的缓冲池。注意下列所有缓冲区具体每个缓冲区的大小需要根据你系统实际可以分配给库数据库的内存大小去调整。<\/p><div class=\"codesection\"><pre class=\"displaycode\">--为数据表空间调整现有 bufferpool\nALTER BUFFERPOOL ICMLSMAINBP32 IMMEDIATE SIZE 120000;\nALTER BUFFERPOOL ICMLSFREQBP4 IMMEDIATE SIZE 32768;\nALTER BUFFERPOOL ICMLSVOLATILEBP4 IMMEDIATE SIZE 65536;\n--增加新的 bufferpool 为了索引表空间\nCREATE BUFFERPOOL ICMLSIDXBP32 SIZE 60000 PAGESIZE 32 K<\/pre><\/div><p>第三，为 ICMSTITEMS001001 表及其他类似的大表创建单独数据表空间，每年都会用一个表空间存放。表数据将会存放到\n                LSSTPART20YY(YY 表示年号的后两位，下同) 表空间，索引将会存放在 LSIDXPART20YY 表空间。<\/p><div class=\"codesection\"><pre class=\"displaycode\">--为所有非 2013，2014 年数据建立默认数据表空间\nCREATE LARGE TABLESPACE LSSTPART\n PAGESIZE 32 K MANAGED BY DATABASE\n USING (FILE '/home/db2inst1/db2inst1/ICMNLSDB/LSSTPART' 100M)\n AUTORESIZE YES MAXSIZE NONE \n EXTENTSIZE 32\n BUFFERPOOL ICMLSMAINBP32;\n--建立 2013 年以及 2014 年数据表空间\nCREATE LARGE TABLESPACE LSSTPART2013\n PAGESIZE 32 K MANAGED BY DATABASE\n USING (FILE '/home/db2inst1/db2inst1/ICMNLSDB/LSSTPART2013' 10G)\n AUTORESIZE YES MAXSIZE NONE \n EXTENTSIZE 32\n BUFFERPOOL ICMLSMAINBP32;\nCREATE LARGE TABLESPACE LSSTPART2014\n PAGESIZE 32 K MANAGED BY DATABASE\n USING (FILE '/home/db2inst1/db2inst1/ICMNLSDB/LSSTPART2014' 10G)\n AUTORESIZE YES MAXSIZE NONE \n EXTENTSIZE 32\n BUFFERPOOL ICMLSMAINBP32;\n--为所有非 2013，2014 年索引建立默认索引表空间\nCREATE LARGE TABLESPACE LSIDXPART\n PAGESIZE 32 K MANAGED BY DATABASE\n USING (FILE '/home/db2inst1/db2inst1/ICMNLSDB/LSIDXPART' 1G)\n AUTORESIZE YES MAXSIZE NONE \n EXTENTSIZE 32\n BUFFERPOOL ICMLSIDXBP32;\n--建立 2013 年以及 2014 年索引表空间\nCREATE LARGE TABLESPACE LSIDXPART2013\n PAGESIZE 32 K MANAGED BY DATABASE\n USING (FILE '/home/db2inst1/db2inst1/ICMNLSDB/LSIDXPART2013' 1G)\n AUTORESIZE YES MAXSIZE NONE \n EXTENTSIZE 32\n BUFFERPOOL ICMLSIDXBP32;\nCREATE LARGE TABLESPACE LSIDXPART2014\n PAGESIZE 32 K MANAGED BY DATABASE\n USING (FILE '/home/db2inst1/db2inst1/ICMNLSDB/LSIDXPART2014' 1G)\n AUTORESIZE YES MAXSIZE NONE \n EXTENTSIZE 32\n BUFFERPOOL ICMLSIDXBP32;<\/pre><\/div><p>第四，生成 ICMSTITEMS001001 分区前表的定义。<\/p><div class=\"codesection\"><pre class=\"displaycode\">db2look -d icmnlsdb -i icmadmin -w icmadmin -e -t ICMSTITEMS001001 -o items_part.sql<\/pre><\/div><p>第五，修改 items_part.sql，为每个表每个月建立表分区，总共创建到 2014 年底共 2 年的表分区。修改后的代码见附件\n                items_part.sql。<\/p><p>以此为范例，我们可以类似的为所有需要分区的表定义和设计不同分区年数，分区使用的缓冲池，表空间以及分区频率等。<\/p><h2 id=\"major6\">小结<\/h2><p>通过本系列第 1 部分的介绍，我们可以了解到如下知识：<\/p><ol type=\"1\"><li> 银行后督实例系统的业务需求和大数据量高吞吐以及相关性能的非业务需求。<\/li><li> 应对实例系统的高吞吐的系统架构和数据模型设计。<\/li><li> 应对实例系统的大数据量数据的表分区的设计和示例。<\/li><\/ol><p>通过本系列第 1 部分介绍的方案及设计，可以对高吞吐大数据方面有要求的 CM 系统的设计有所帮助。在接下来的<a href=\"http://www.ibm.com/developerworks/cn/data/library/bd-1406-bankimagedesign-part2/index.html\">第 2\n                部分<\/a>里面，我们将着重介绍一些高吞吐高并发 CM 系统中出现的一些问题的分析和解决方法。<\/p><h2 id=\"major7\">特别感谢<\/h2><p>特别感谢广东农信杨韶宁经理、苏汉槟经理对项目和文章的巨大支持和帮助，并对 IBM\n                参与此项目设计和问题解决的徐军、纪海、李永亮、陈宁、刘健、殷卓、胡金培、沈鑫等同事表示感谢。<\/p><h2 id=\"major8\">免责声明<\/h2><p>本文中任何带有主观性的陈述都只代表本书作者个人的观点，不代表 IBM\n                公司的官方立场。本文是对某个银行客户实例系统的分析和介绍，可以作为类似系统的参考，但是要注意，每一个系统都有自己独特的需求和实际情况，本文并不能提供适应这些系统通用模式，各个系统还是要根据自己的需求去设计架构模型和实现。<\/p><CMA ID: 975350><Site ID: 10><XSLT stylesheet used to transform this file: dw-document-html-7.0.xsl>\r\n<h2 id=\"download\">下载<\/h2><table class=\"ibm-data-table&#10;                    dw-download-table\" cellpadding=\"0\" cellspacing=\"0\" border=\"0\"><thead><tr><th scope=\"col\">描述<\/th><th scope=\"col\">名字<\/th><th scope=\"col\">大小<\/th><\/tr><\/thead><tbody><tr><th scope=\"row\" class=\"ibm-table-row\">set_constraints.sql<\/th><td nowrap=\"nowrap\"><a href=\"http://www.ibm.com/developerworks/apps/download/index.jsp?contentid=975350&amp;filename=set_constraints.sql&amp;method=http&amp;locale=zh_CN\">set_constraints.sql<\/a><\/td><td nowrap=\"nowrap\">2k<\/td><\/tr><tr><th scope=\"row\" class=\"ibm-table-row\">items_part.sql<\/th><td nowrap=\"nowrap\"><a href=\"http://www.ibm.com/developerworks/apps/download/index.jsp?contentid=975350&amp;filename=items_part.sql&amp;method=http&amp;locale=zh_CN\">items_part.sql<\/a><\/td><td nowrap=\"nowrap\">6k<\/td><\/tr><\/tbody><\/table>\r\n\r\n<\/div>\r\n<\/div>\r\n","createTime":"2014-06-26 00:00:00","deployTime":"2014-06-26 00:00:00","id":0,"intro":"大数据量和高吞吐是银行内容管理系统长期设计的核心问题，本文通过内容管理系统在农信银行后督系统的设计和实现实例 (基于 DB2V97 数据库)，描述对于内容管理系统如何针对每天大约 400 万个图片、可能存放 15 年达到 2PB 文件规模的大数据量系统进行数据模型设计、表分区以及压缩的具体设计实现，以及系统在高并发下一些实际问题的处理，系统上线后吞吐量和性能得到了客户的认可，可以为类似的银行系统提供重要的参考。","keyword":"","recommend":false,"source":"http://www.ibm.com/developerworks/cn/data/library/bd-1406-bankimagedesign-part1/index.html","title":"银行影像内容大数据系统的设计以及实例问题分析，第 1 部分: 设计篇","typeId":0,"updateTime":"2014-06-26 00:00:00"}
{"author":"","clickNumber":0,"content":"\r\n<div class=\"ibm-columns\">\r\n<div class=\"ibm-col-1-1\">\r\n\r\n<h2 id=\"1.IBM’sinvestmentinLinux|outline\">IBM 对 Linux 的投资<\/h2><p>您可能已经听说过 IBM Watson。如果没有，请 <a href=\"https://www.ibm.com/smarterplanet/us/en/ibmwatson/\">了解一下 IBM\n                    Watson<\/a>，因为它真的是一项突破性的技术成就。通过汇总来自 <em>The Atlantic<\/em> 文章的一些想法，IBM\n                    估计，Watson 每秒可以处理多达 6 千万页的文本。而这些文本只是普通的、简单的文字。它完全是非结构化的数据，目前 IT\n                    系统需要处理的现有信息中大约 80％ 都是这样的数据。令人惊奇的是，无论是演讲还是手写笔记的口述，Watson\n                    几乎可以理解任何自由形式的信息源。它实际上可以学习，而且学得相当快。最初，它被用来打败 Jeopardy\n                    的冠军，现在它被定位用于协助患者的医疗诊断、改善客户服务、创作新的厨师食谱和其他一些有趣的、以前无法克服的挑战。其中一些挑战显然极为重要，而另一些只是有趣和具有挑战性的应用程序，它们很可能在未来具有高度的战略意义。Watson 独特的<em>适应<\/em> 能力是：当绝对数据量与它的处理能力不匹配时，它会摇头。   <\/p><p>当涉及比特和字节时，Watson 是什么？当然，它是一系列聪明的软件组件的集合，具有创新的算法，但底层硬件基础架构是什么呢？您知道它是一台 IBM 计算机，但具体来说，它是一台 IBM Power Systems&#8482; 服务器。更具体地讲，它在运行 Linux on Power。 <\/p><p>所以，问题就变成，如果该组合可用于创建 Watson，那么它能做到我要求它做的事吗？<\/p><p>首先，IBM 对 Linux on Power 有多重视？IBM 非常重视 Linux on Power，以至于在 2013 年 9 月承诺对其投资 10 亿美元。该投资主要针对 Linux&#174; 和开源工作负载解决方案，IBM 在过去十年中还有对一系列广泛的开放计划进行了大量投资。重要的是要知道一点，它不只是来自 IBM 的投资。这是来自 IBM 的 Power Systems 品牌的专项投资。 然而，重要的是要注意，单靠资金并不能让计划成功。从经验丰富的资源获得技能是必需的，IBM 已经重新分配很多有高度积极性的销售和技术资源，完全集中于 Linux 和 Power，以及他们可以共同处理的解决方案。IBM 也销售软件 - 许多软件。您可以相信，大多数的软件在 Linux on Power 上都可以运行。您可以进一步假设这些应用程序已经过优化，可以在该平台上非常高效地运行。<\/p><p>让我们来看看一些具体细节。<\/p><p>IBM 销售的每一台 Power Systems 服务器都可以运行 Linux。事实上，IBM 销售的每一台服务器都可以运行 Linux，包括 Red Hat 和 SUSE。需要明确的是，这里所说的 Linux 与在 x86 上运行的 Linux 相同。其构建源与 x86 相同，按相同的时间表交付，并在同一时间获得支持。是什么使得它在 Power 上表现<em>更好<\/em> 呢？我们将在后面详细讨论这一点，但我们要讨论的是一些基本概念，比如性能、可靠性、虚拟化和价格。IBM 认为，这些基本概念是具有吸引力的优势 - 因此该承诺也是。<\/p><p>IBM 还在哪些其他方面对 Linux 进行了投资呢？<\/p><p>我们在美国、欧洲和亚洲建立了人员配备齐整的 <a href=\"https://www.ibm.com/linux/ltc/\"><strong>Linux 技术中心<\/strong><\/a>，为客户、独立软件供应商 (ISV)、系统集成商和托管服务提供商提供了大量的资源。在这些中心提供的服务包括技术讲座、培训、移植和迁移帮助、基准测试，等等。<\/p><p>IBM 还创建了工具和流程，支持 Linux 使用 IBM Power 技术。这样的例子有：<\/p><p><a href=\"https://www.ibm.com/developerworks/community/wikis/home?lang=en#!/wiki/W51a7ffcf4dfd_4b40_9d82_446ebc23c550/page/IBM Advance Toolchain for PowerLinux Documentation\"><strong>Advance Toolchain<\/strong><\/a>：是一套开源开发工具和运行时库，使用户可以充分利用 IBM Power 硬件特性。由 IBM 捆绑、测试和支持硬件<\/p><p><a href=\"https://www-304.ibm.com/webapp/set2/sas/f/lopdiags/sdklop.html\"><strong>Software Development Kit (SDK)<\/strong><\/a>：是在单一 GUI 环境中的重要 Linux 和 IBM 工具的集成。它包括代码扫描器，在从 x86 到 Power 的移植期间提出修改建议，以提高性能（免费）。<\/p><p><a href=\"https://www.ibm.com/linux/migrate.html\"><strong>Migration Factory<\/strong><\/a>：当迁移到 Linux 时，具有细致的、经过测试的流程的可信合作伙伴是一个重要要求。IBM 已经历过使用 <em>The Migration Factory<\/em> 将数千客户迁移到 IBM 系统上的 Linux。它使用 25 年来精心提炼的五步流程，帮助客户迁移到运行任何受支持操作系统（包括 Linux）的 IBM 系统上。<\/p><p>Watson 的基础架构以 Power 750 服务器为基础。这是一个可以直接融合在我们的 Power Systems 系列中的产品。您可以在以下图表中看到详细的产品，并且可以确信，在其中一个服务器上运行的任何应用程序可以在任何一个这些服务器上运行。 <\/p><h5 id=\"N100B3\">图 1. IBM POWER7 产品组合<\/h5><img alt=\"IBM POWER7 产品组合\" src=\"/sunshine_new/images/31848298/image001.jpg\" width=\"576\" /><p>IBM 的 Power 部门坚信，他们能够利用这一产品组合满足任何客户的要求。请了解其多样性：  <\/p><ul class=\"ibm-bullet-list\"><li>低成本的向外扩展服务器，比如 Power 710 和 Power 720<\/li><li>仅限 Linux 的服务器（专用于 Linux），比如 7R1 和 7R2<\/li><li>具有无与伦比的性能的高端企业服务器，类似于 Power 780 和 Power 795<\/li><\/ul><p>值得一提的最后一个方面是，IBM 对开源社区的贡献水平。这可能让很多人感到惊讶，但以下是由那些专注于 Linux 的公司所完成的更改（<em>贡献<\/em>）数量的部分列表。 <\/p><p><strong>(2005-2012)<\/strong><\/p><h5 id=\"N100D7\">表 1. 公司对 Linux 的贡献<\/h5><table border=\"0\" cellpadding=\"0\" cellspacing=\"0\" class=\"ibm-data-table\" summary=\"\"><thead xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"><tr><td style=\"text-align:left; vertical-align:top\"><strong>公司名称<\/strong><\/td><td style=\"text-align:left; vertical-align:top\"><strong>更改数量<\/strong><\/td><td style=\"text-align:left; vertical-align:top\"><strong>占总数的百分比<\/strong><\/td><\/tr><\/thead><tbody xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"><tr><td style=\"text-align:left; vertical-align:top\">\n无（个人）\n<\/td><td style=\"text-align:left; vertical-align:top\">\n46,982\n<\/td><td style=\"text-align:left; vertical-align:top\">\n17.9%\n<\/td><\/tr><tr><td style=\"text-align:left; vertical-align:top\">\nRedHat\n<\/td><td style=\"text-align:left; vertical-align:top\">\n31,261\n<\/td><td style=\"text-align:left; vertical-align:top\">\n11.9%\n<\/td><\/tr><tr><td style=\"text-align:left; vertical-align:top\">\nNovell\n<\/td><td style=\"text-align:left; vertical-align:top\">\n16,738\n<\/td><td style=\"text-align:left; vertical-align:top\">\n6.4%\n<\/td><\/tr><tr><td style=\"text-align:left; vertical-align:top\">\nIntel\n<\/td><td style=\"text-align:left; vertical-align:top\">\n16,219\n<\/td><td style=\"text-align:left; vertical-align:top\">\n6.2%\n<\/td><\/tr><tr><td style=\"text-align:left; vertical-align:top\"><strong>IBM<\/strong><\/td><td style=\"text-align:left; vertical-align:top\"><strong>16,073<\/strong><\/td><td style=\"text-align:left; vertical-align:top\"><strong>6.1%<\/strong><\/td><\/tr><tr><td style=\"text-align:left; vertical-align:top\">\nUnknown\n<\/td><td style=\"text-align:left; vertical-align:top\">\n13,342\n<\/td><td style=\"text-align:left; vertical-align:top\">\n5.1%\n<\/td><\/tr><tr><td style=\"text-align:left; vertical-align:top\">\nConsultant\n<\/td><td style=\"text-align:left; vertical-align:top\">\n7,986\n<\/td><td style=\"text-align:left; vertical-align:top\">\n3.0%\n<\/td><\/tr><tr><td style=\"text-align:left; vertical-align:top\">\nOracle\n<\/td><td style=\"text-align:left; vertical-align:top\">\n5,542\n<\/td><td style=\"text-align:left; vertical-align:top\">\n2.1%\n<\/td><\/tr><tr><td style=\"text-align:left; vertical-align:top\">\nAcademia\n<\/td><td style=\"text-align:left; vertical-align:top\">\n3,421\n<\/td><td style=\"text-align:left; vertical-align:top\">\n1.3%\n<\/td><\/tr><tr><td style=\"text-align:left; vertical-align:top\">\nNokia\n<\/td><td style=\"text-align:left; vertical-align:top\">\n3,272\n<\/td><td style=\"text-align:left; vertical-align:top\">\n1.2%\n<\/td><\/tr><tr><td style=\"text-align:left; vertical-align:top\">\nFujitsu\n<\/td><td style=\"text-align:left; vertical-align:top\">\n3,156\n<\/td><td style=\"text-align:left; vertical-align:top\">\n1.2%\n<\/td><\/tr><tr><td style=\"text-align:left; vertical-align:top\">\nTexas Instruments\n<\/td><td style=\"text-align:left; vertical-align:top\">\n2,982\n<\/td><td style=\"text-align:left; vertical-align:top\">\n1.1%\n<\/td><\/tr><tr><td style=\"text-align:left; vertical-align:top\">\nBroadcom\n<\/td><td style=\"text-align:left; vertical-align:top\">\n2,916\n<\/td><td style=\"text-align:left; vertical-align:top\">\n1.1%\n<\/td><\/tr><tr><td style=\"text-align:left; vertical-align:top\">\nLinux Foundation\n<\/td><td style=\"text-align:left; vertical-align:top\">\n2,890\n<\/td><td style=\"text-align:left; vertical-align:top\">\n1.1%\n<\/td><\/tr><tr><td style=\"text-align:left; vertical-align:top\">\nGoogle\n<\/td><td style=\"text-align:left; vertical-align:top\">\n2,620\n<\/td><td style=\"text-align:left; vertical-align:top\">\n1.0%\n<\/td><\/tr><\/tbody><\/table><p><strong>资料来源：<\/strong><a href=\"https://www.linuxfoundation.org/news-media/announcements/2012/04/linux-foundation-releases-annual-linux-development-report\">The\n    Linux Foundation Releases Annual Linux Development Report<\/a><\/p><p>如您所见，说到 IBM 对\n        Linux on Power 的承诺，并不仅仅是指 Watson。尽管 Watson 可以很好地证明 IBM\n        在这个领域可以做到的工作，但我们知道，我们还需要在其他许多应用领域中使用这种技术组合。 <\/p><h2 id=\"3.LinuxonPowerisbestpositionedtohandlecustomerworkloads|outline\">Linux on Power 最恰当的用途是处理客户工作负载<\/h2><p>让我们来看看在 <a href=\"https://www.gartner.com/newsroom/id/2304615\">Gartner 的 2013 全球 CIO\n                议程<\/a> 中被确定的一些趋势。当要求确定最优先考虑的技术时，<em>分析<\/em> 被排在首位，紧随其后的是<em>云<\/em>\n                和移动。其他来源也有一些支持数据，比如 83％ 的受访 CIO 将商业智能 (BI) 和分析列为其愿景计划的一部分，而 54％\n                。<em>大数据<\/em> 和<em>分析<\/em> 背后的技术是多种多样的，但有一个要求是一致的。您需要提供硬件来运行应用程序，并且该硬件必须能够在某些非常具体的领域中有卓越的性能。首先，这些应用程序在许多不同的地方都要求非常高的吞吐量。具体在哪里？仅举几例，处理器速度、内存带宽和 I/O 吞吐量。此外，<em>大数据<\/em> 和<em>分析<\/em> 需要线程，很多线程，并且它们对 Java&#8482; 也有很强的依赖性。一般来说，我们所谈论的是均衡的、高效的系统。<\/p><p>我们不要忘记其他一些工作负载对许多客户也很重要。电子邮件与协作（以社交和业务为中心）仍然具有战略意义。虽然电子邮件客户端组件显然越来越多地从桌面过渡到了移动设备，但后端基础架构仍然必须存在，以便支持任何形式的客户端。这些应用程序的安全性变得极为重要。迅速扩展，并与许多其他技术交互的能力也很重要。最后，是的，就像其他所有技术一样，性能是客户在这些工作负载中所寻求的东西。<\/p><p>此外，全球几乎每一个大公司都仍在使用包括企业资源规划 (ERP)、供应链和客户关系管理 (CRM) 在内的业务应用程序。这些大型系统有哪些独特的基础架构要求？我们需要能够快速创建新的环境，以便测试新的功能。我们需要能够动态调整系统资源（比如处理器、内存和 I/O），以便应付峰值期间的处理，比如财务结算和需求计划。这些应用程序也有一定的最高正常运行时间要求。最后，应用程序性能必须达到可接受的水平。<\/p><p>如果我们汇总最流行的工作负载中最重要的系统需求清单，它看起来可能会如下面的列表所示（所有这一切都发生在一个超安全的、经过成本优化的解决方案中）：<\/p><ul class=\"ibm-bullet-list\"><li>性能<\/li><li>可靠性<\/li><li>性能<\/li><li>可扩展性<\/li><li>性能<\/li><li>灵活性（我们称之为虚拟化）<\/li><\/ul><p>让我们确保能够在<em>云<\/em> 产品中得到这一切！<\/p><p>本文的标题是 “为何选择 Linux on POWER？”，这并非巧合。上述所有的应用程序都需要在某个地方运行，我们想从技术角度告诉您为什么运行 Linux 的 Power 服务器可以提供令人信服的业务用例。该业务用例的一部分考虑因素是价格，我们会讲到这一点，但让我们更深入地介绍一下 Power 技术。<\/p><h2 id=\"4.ComparingPowerwithIntel|outline\">比较 Power 与 Intel<\/h2><p>多年以来，Power 一直是面向中档数据库需求的首选平台。然而，当 IT 人员想到 Linux 时，几乎立刻就会想到 Intel? x86 平台。请花费一点时间来比较一下 Power 和 Intel 的特性。IBM 对 Power 平台感到非常自豪，该平台具有卓越的可靠性、可用性、可服护性、可扩展性，以及最重要的安全性。 <\/p><p>如果我们研究一下 Power 的特性，并将它们与 Intel 服务器的当前产品线进行比较（参见下文），就可以看到更好的功能和灵活性。此外，从成本的角度来看，Linux on Power 也极具吸引力。在本文的第 4 节中，将会更全面地介绍这一点。不过，下面的图表显示了 Power 胜于 Intel 的一些优势。<\/p><h5 id=\"N101CE\">图 2. Power 胜于 Intel 的一些优势<\/h5><img alt=\"Power 胜于 Intel 的一些优势\" src=\"/sunshine_new/images/31848298/image002.jpg\" width=\"850\" height=\"510\" /><p><a href=\"#N101D6\" class=\"ibm-popup-link\" onclick=\"ibmweb.overlay.show('N101D6',this);return false;\">点击查看大图<\/a><\/p><div id=\"N101D6\" class=\"dw-sidefile-overlay ibm-common-overlay ibm-overlay-alt-two\"><div class=\"ibm-head\"><p><a href=\"#close\" class=\"ibm-common-overlay-close\">关闭 [x]<\/a><\/p><\/div><div class=\"ibm-body\"><div class=\"ibm-main\"><div class=\"ibm-title\"><h2>图 2. Power 胜于 Intel 的一些优势<\/h2><\/div><div class=\"ibm-container ibm-alternate\"><div class=\"ibm-container-body\"><img alt=\"Power 胜于 Intel 的一些优势\" src=\"/sunshine_new/images/31848298/image002.jpg\" width=\"1410\" /><\/div><\/div><\/div><\/div><div class=\"ibm-footer\"><><\/div><\/div><p>在服务器中，Power 对 Intel 有三个特定的优势：<\/p><ul class=\"ibm-bullet-list\"><li><strong>性能<\/strong> C Power 利用多达 256 个高性能核心及每核心四个线程，可支持全系列服务器。Intel 销售的系统规模较小，现有产品最多 60 个核心，每核心两个线程，它们要求更多热量、散热和管理。<\/li><\/ul><ul class=\"ibm-bullet-list\"><li><strong>虚拟化<\/strong> C IBM PowerVM&#174; 是市场上惟一可以夸口零安全漏洞的虚拟机管理程序。没有其他基于 x86 的虚拟机管理程序声称可以做到这一点。PowerVM 驻留在固件中，因此，减少了时延，并支持更高的硬件整体利用率。<\/li><\/ul><ul class=\"ibm-bullet-list\"><li><strong>弹性<\/strong> C 因为 Power 是由设计了 IBM 大型机这一非常可靠的系统的同一团队设计的，内置了同样的弹性，实现更长的正常运行时间，并保证在一个日历年内有 99.997％ 的正常运行时间。Intel 无法提供接近于此数据的弹性。Power 硬件是自我修复的，并且通过实时分区迁移 (LPM) 等特性，无需任何停机时间就能完成最关键的更新。x86 服务器目前不具备同样的任务关键型弹性特点。<\/li><\/ul><p>IBM 在 20 年来一直不断按 Power 路线图前进，生产出了革命性的、最先进的处理器和晶体管技术。研究与开发可带来行业领先的创新，它们仍是 IBM 的投资重点。Power 继续有明确和详细的技术路线图。<\/p><p>Power 芯片的最新版本已经内置了加密功能，以及硬件事务内存的加速器。硬件事务内存使得 Power 服务器能够以更高的性能运行高度线程化的 Java 工作负载。<\/p><p>Power 还具有超强的内存和缓存性能。具有三级缓存和每个内存插槽两条通道，Power 为要求高内部带宽的工作负载提供了卓越的性能。<\/p><p>x86 服务器的激增往往会导致以下客户挑战：<\/p><ul class=\"ibm-bullet-list\"><li>提高系统管理成本<\/li><li>过度的能源使用和热量问题<\/li><li>电源和冷却基础架构不足<\/li><li>暴涨的软件成本<\/li><li>不断增长的人力成本<\/li><li>更多莫名其妙的故障<\/li><li>更多计划外停机<\/li><li>安全性降低<\/li><li>极少自动化，没有灵活性<\/li><\/ul><p>Power 服务器的安全性获得了增强，并且没有安全漏洞，这使得 IT 管理人员能够避免安全漏洞所带来的昂贵后果，比如：  <\/p><ul class=\"ibm-bullet-list\"><li>加强现有的 IT 安全性，并开展更多培训<\/li><li>联系其记录可能已暴露的那些人<\/li><li>监控受影响的那些人的信用<\/li><li>可能遭受财务损失的人所采取的法律行动<\/li><li>对公司/品牌声誉的损害<\/li><li>电子邮件黑名单  <\/li><li>对股价的影响<\/li><li>夺回市场地位的成本<\/li><\/ul><h3 id=\"N1021C\">定价<\/h3><p>关于 Linux 的一个常见的??说法是，它等同于 x86 或商品硬件 - 为什么会考虑在 Power 上运行 Linux？一般的看法是，在 Power 上运行 Linux 过于昂贵。 <\/p><p>正如前面所提到的，所有 Power 服务器都可以运行 Linux。然而，IBM 推出了仅使用 Linux 的单、双、四插槽服务器，分别是 IBM PowerLinux&#8482; 7R1、7R2 和 7R4，它们以具有竞争力的价格点为客户提供面向 Linux 的另一个可靠的替代平台。请看下面的图表。如果考虑采购总成本 (TCA)，其中包括服务器目录价、虚拟化、Linux 操作系统升级和支持目录价，Power 服务器上的 Linux 的 TCA 定价如果不是更便宜，至少也应该与 Intel x86 选项相当。<\/p><h5 id=\"N10228\">图 3. 比较面向 Linux 的 Power 与 Intel x86 的 TCA 定价<\/h5><img alt=\"比较面向 Linux 的 Power 与 Intel x86 的 TCA 定价\" src=\"/sunshine_new/images/31848298/image003.jpg\" width=\"720\" /><h5 id=\"N10235\">图 4. IBM PowerLinux 7R2 定价比较（以美元为单位）<\/h5><img alt=\"IBM PowerLinux 7R2 定价比较（以美元为单位）\" src=\"/sunshine_new/images/31848298/image004.jpg\" width=\"817\" /><p>除了 TCA 之外，还要考虑其他成本因素。让我们比较适用于 Power 与 x86 的虚拟化功能；具体来说是比较 PowerVM 与 VMware。如图 5 所示，PowerVM 提供了卓越的性能和价值，为客户提供的虚拟化特性更灵活、更具扩展性、更安全。客户为什么要在乎这些好处？它在成本方面有什么意义？请注意，PowerVM 灵活地配置虚拟处理器和内存，并且每个虚拟机的虚拟处理器的数量仅受限于物理服务器上的可用核心的数量。对比之下，VMware 在分配处理器和内存资源方面的灵活性有限，并且存在每插槽 32 个虚拟处理器的硬限制。这句话的意思是说，使用 PowerVM 部署的客户可以根据<em>他们的<\/em> 需要灵活地修改自己的系统配置。在当今的世界里，IT 需求是多变和动态的。PowerVM 让客户可以随需求的变化来调整自己的服务器环境。此外，PowerVM 卓越的可扩展性特征可以帮助客户将更多工作负载整合到一台服务器上。PowerVM 客户不需要购买额外的物理服务器来适应不断扩大的或新的工作负载，他们可以在一台服务器中运行更多的工作负载，这极大地提高整体系统利用率。PowerVM 让客户能够少花钱多办事。由于使用了更少的物理服务器，所以节省了电源和散热、数据中心机架空间和管理等成本。软件许可成本也是一个主要因素。大多数商业应用软件都是按核心数量发放许可的。如果可以用更少的核心完成更多工作，那么可以直接减少软件的许可费用，许可费用在 IT 预算中可能占比较大的比例。接下来，让我们探讨一下安全领域。PowerVM 被集成到 Power 虚拟机管理程序中，而且 <a href=\"https://cve.mitre.org/cgi-bin/cvekey.cgi?keyword=PowerVM\"><em>报告零漏洞<\/em><\/a>。与之对比，VMware <a href=\"https://cve.mitre.org/cgi-bin/cvekey.cgi?keyword=VMware\">报告了 561 个漏洞<\/a>。想象一下这种情况：系统有若干台主机，如果虚拟机管理程序很容易出现安全方面的问题，在其上运行的所有主机都将处于危险之中。这可能意味着对客户的业务造成严重影响，例如，停机时间。最后，如??果单独考虑虚拟化许可成本，您会注意到，PowerVM 许可对 VMWare 非常有竞争力。<\/p><h5 id=\"N10250\">图 5. 比较 PowerVM for IBM PowerLinux 与 VMWare（以美元为单位）<\/h5><img alt=\"比较 PowerVM for IBM PowerLinux 与 VMWare（以美元为单位）\" src=\"/sunshine_new/images/31848298/image005.jpg\" width=\"707\" /><p>在 2013 年第四季度，IBM 发布了两个额外的公告，这使得 IBM PowerLinux 成为对客户更具吸引力的选择。这些公告介绍了 Power Integrated Facility for Linux (IFL) 和所有 IBM PVU 许可的软件产品的更低处理器价值单元 (PVU)，适用于运行 Linux 的所有 Power 核心。 <\/p><p><a href=\"https://www.ibm.com/common/ssi/cgi-bin/ssialias?infotype=an&amp;subtype=ca&amp;appname=gpateam&amp;supplier=897&amp;letternum=ENUS113-178\">Power IFL<\/a> 是一个企业级 Power 产品，用于在大型企业中整合并集成 Linux 应用程序与 IBM AIX&#174; 和 IBM i 应用程序及数据。拥有 Power 770、780 或 795 服务器的客户可以通过<em>按需容量<\/em>（使用激活密钥增加额外的处理器和内存资源，不需要中断）增加 Linux 工作负载容量。借助 4 核心，32 GB 内存捆绑，该产品可扩展到 32 插槽。它适用于在现有企业 Power 服务器上具有不活跃容量的企业客户。客户不需要购买额外的基于 x86 的服务器来运行 Linux 工作负载，他们现在只需在现有的 Power 服务器上激活非活跃资源，激活资源不需要停机。客户可以享受 Power 企业服务器中固有的性能、安全性和可用性，同时以新的低价格简化 Linux 工作负载的采购。因为不必将额外的设备添加到数据中心，Power IFL 允许客户缩短产品上市时间。您只需输入一个密钥就可以激活所需的资源。通过使用 IFL，客户可以信心十足地将应用程序和数据放在一起，同时减少延迟并最大限度地提高利用率。<\/p><h5 id=\"N10269\">图 6. Power IFL 定价<\/h5><img alt=\"Power IFL 定价\" src=\"/sunshine_new/images/31848298/image006.jpg\" width=\"345\" /><p>第二个公告是为在运行 Linux 的所有 Power 核心上的所有 PVU 许可的软件产品降低 IBM Software Group PVU。PVU 是用于在分布式处理器技术上区分软件许可的度量单位。对于 Linux on POWER，IBM Software Group PVU 统一为每核心 70 PVU，即使是最大的 Power 服务器也一样。与此相比，对于 4 插槽和更大的 Intel 服务器是每核心 100 至 120 个 <a href=\"https://www.ibm.com/software/lotus/passportadvantage/pvu_licensing_for_customers.html\">PVU<\/a>。由于软件许可在解决方案采购中可能是最大的成本（远远高于服务器成本），在 Linux on Power 上运行此类工作负载可能会有显著的成本节约<\/p><p>Power 运行 Linux 过于昂贵的说法是不成立的。它不仅在 TCA 定价方面具有竞争力，而且还提供了客户认为比商品解决方案更卓越的特性。<\/p><p>这里是一个 <a href=\"https://www.youtube.com/watch?v=jDJSssGp9O8\">由领先的研究公司 Solitaire Interglobal Ltd 制作的基于事实的分析视频<\/a>。在这段视频中，Solitaire 比较了 x86 架构与 IBM Power Systems，并解释了为什么下一代应用程序的基础应该是 IBM Power：<\/p><h3 id=\"N10283\">技能<\/h3><p>IBM 自 1999 年以来一直是 Linux 的积极参与者，并且是针对 Linux 的全球领先的商业贡献者之一。在 2013 年，IBM Power 部又投资了十亿美元，以支持 Linux 和开源工作负载的解决方案。这项投资包括在世界各地开放新的 Power Systems Linux Center 和创新中心。<a href=\"https://www.ibm.com/systems/power/software/linux/centers/\">Power Systems Linux Center<\/a> 向全世界各地的 Linux 开发人员开放。这些地点包括中国北京、德克萨斯州奥斯汀、纽约州纽约市、日本东京和法国蒙彼利埃。Linux 中心使开发人员可以使用 Linux 和最新的 IBM Power 服务器来构建和部署新的应用程序。在中心的资源包括量身定做的客户简介、Linux 培训工作坊、移植援助，以及动手协助开发人员了解如何利用 Power 功能并优化性能。IBM 创新中心是致力于帮助 ISV 的最先进设施。<a href=\"https://www.ibm.com/partnerworld/wps/servlet/ContentHandler/isv_com_tsp_iic_overview\">创新中心<\/a> 提供的服务包括架构设计和实现咨询、移植、迁移、测试服务、应用程序集成和概??念证明的支持，以及最新技术的专业知识。<\/p><p>作为 IBM 对 Linux on Power 的承诺的一个例子，IBM 有专门负责支持客户和 ISV 使用 PowerLinux 的团队。此外，IBM 拥有 <a href=\"https://www.ibm.com/linux/ltc/\">Linux Technology Center (LTC)<\/a>，这是 IBM 的开源软件开发人员团队，他们与 Linux 开源开发社区合作。LTC 作为 Linux 技术竞争力中心，并且负责 IBM 的 Linux Distribution 合作伙伴的技术联络。 <\/p><p>IBM 也提供了其他许多社区资源。假设您需要 IBM 帮助您移植应用程序。IBM 拥有一个 <a href=\"https://www.ibm.com/partnerworld/wps/servlet/ContentHandler/isv_com_dvm_techval_chiphopper\">Chiphopper 计划<\/a>，即 IBM Systems Application Advantage for Linux。这个计划让 IBM 内部相应的资源与您和您的团队协同工作，评估潜在的移植挑战，并协助移植。另一个 IBM 计划是 <a href=\"https://www.ibm.com/systems/power/migratetoibm/path.html\">Migration Factory<\/a>。IBM Migration Factory 可以帮助您制定迁移路线图，估算迁移工作量，并为迁移定制一个业务用例。如果您需要一个用于测试的平台，但没有服务器访问权限，IBM 提供了 <a href=\"https://www.ibm.com/partnerworld/wps/servlet/ContentHandler/stg_com_sys_power-development-platform\">Power Development Platform<\/a>，它之前被称为虚拟借用程序。该计划提供对 IBM 硬件的免费远程访问。最后，IBM 拥有 Linux on <a href=\"https://www.ibm.com/developerworks/community/wikis/home?lang=en#!/wiki/W51a7ffcf4dfd_4b40_9d82_446ebc23c550\">PowerLinux 社区维基<\/a>，这是您的一站式商店，在这里，您可以找到有益的常见问题解答、视频演示、最佳实践、入门指南，并访问 Linux on Power 论坛。在讨论区发布的问题或讨论点被自动转发给整个 Linux on Power 开发团队，让您可以通过我们的专家挖掘最深的 Linux on Power 技术知识。<\/p><p>IBM 已经专门针对 Linux on Power 开发了工具，以提供额外的价值。其中一个工具是 <a href=\"https://www-304.ibm.com/webapp/set2/sas/f/lopdiags/installtools/home.html\">IBM Installation Toolkit for PowerLinux<\/a>。它包括流行工作负载的 Simplified Setup Tool、基于 Linux on Power 专家经验的调优，以及安装超过 20 个可靠性、可用性和可服务性和生产力工具。其他工具包括 SDK 和 Advance Toolchain。所有这些工具都是免费提供的，并专门针对 Power 进行了优化。<\/p><p>无论您是客户、业务合作伙伴还是 ISV，IBM 都拥有团队和资源可以帮助满足您和您所有的 Linux on Power 需求。<\/p><h2 id=\"5.Customerexamples|outline\">客户示例<\/h2><h3 id=\"N102B7\">北卡罗来纳州立大学 (NCSU)  - 大数据 - 帮助企业解决真实的信息问题<\/h3><p>在 <a href=\"https://www.youtube.com/watch?v=j6CjWVHcyEk\">视频<\/a> 中，研究人员 Michael Kowolenko 博士讨论了 IBM 在 PowerLinux 上基于云的<em>大数据<\/em> 和分析解决方案如何帮助 NCSU 建议企业进行具有高影响力的投资<\/p><p>NC State Center of Innovation Management Studies 希望教导学生如何解决复杂的业务问题，并为企业提供可操作的信息，从而帮助提高其底线。他们用作例子的企业拥有许多不同形式的数据源。 <\/p><p>他们需要一个硬件平台，该平台不但能够跟上数据量，并且不会因非常复杂的查询而陷入困境，并让学生和企业能够基于准确的输出做出正确的决策。他们也希望计算机科学系运行系统的那些人可以变得很轻松。于是，他们选择了 Linux on Power。使用多个 IBM 软件产品（Big Insights、Content Analytics、IBM SPSS&#174; 和 IBM DB2&#174;），他们能够极大地提高学生的能力，解决将影响这些企业的底线的问题。从 x86 平台迁移到 Power 平台，索引的运行从 72-96 个小时缩短到 14 个小时。<\/p><h3 id=\"N102CD\">Watson 在 MD Anderson 帮助癌症的诊断<\/h3><p><a href=\"https://www.youtube.com/watch?v=6g6VJa9Y6no\">MD Anderson Hospital 的 Lynda Chin 教授<\/a> 进行了以下讨论：通过使用 Watson，他们能够创建一个应用程序，大大加快对癌症患者的诊断和治疗。<\/p><p>IBM Watson 技术目前部署在得克萨斯州休斯敦的 MD Anderson Hospital，帮助完成各种癌症的诊断和治疗。<\/p><p>Watson 让从业者能够访问来自他们过去从未想过的来源的信息和数据。他们现在不再被孤立于自己的诊所中，而是可以拥有来自全球各地的数据源的瞬时信息，从而更好地治疗和诊断他们的患者。<\/p><p>Watson 解决了如今如何用药的基础挑战。<\/p><ul class=\"ibm-bullet-list\"><li>获得优质护理<\/li><li>医生短缺<\/li><li>缺乏标准化<\/li><li>访问成本<\/li><li>采用率不足<\/li><li>效率低下的知识共享和交流<\/li><\/ul><p>究其核心，Watson 是一个在 Linux on Power 系统上运行的 Hadoop 集群。<\/p><h2 id=\"6.Summary|outline\">结束语<\/h2><p>我们希望可以让您确信，IBM 非常重视 Linux on Power。我们对此技术的投资应该清楚说明了这一点。其中包括：在 2013 年的年中承诺十亿美元的额外投资，包括许多新的、专职的、以 Linux 为中心的人员，继续致力于构建那些使用和完善 Linux on Power 的应用程序。我们还希望，我们已经消除了有关此产品组合的一些常见误解。首先，Linux on POWER 与 x86 使用<strong>相同<\/strong> 的 Linux。其次，在 Power 上运行 Linux 并不会花费更多成本。事实上，在大多数情况下，在 Power 上运行它的采购总成本和总拥有成本将会更低，有时这种优势会非常明显。最后，Linux 在 x86 上肯定不会运行得<em>更好<\/em>。IBM POWER&#174; 处理器和周绕它的服务器基础架构是无与伦比的，他们能够提供最快的系统总吞吐量，最高水平的可靠性和安全性。<\/p><a id=\"OLE_LINK1\"><\/a><p>如果您有任何疑问或想更深入了解在本文中所讨论的任何主题的信息，您可以与作者取得联系。Grace、Ann 和 Mark 都是在 IBM 内新成立的组织中的成员，其主要任务是作为技术大使，对 Power 上运行的 Linux 的各个方面提供支持。组织中的这些和其他资源被重点用在 Linux 环境中蓬勃发展的应用程序和计划上，比如<em>大数据<\/em> 和<em>分析<\/em>。本文的作者们确定了基于 Power 的最优架构的规模和设计、解释设计，并提供了竞争硬件提供商同等规模的设计，建立从替代平台移植的路径，并对客户和 ISV 进行底层技术教育。<\/p><h2 id=\"7.Resources|outline\">参考资料<\/h2><ul class=\"ibm-bullet-list\"><li><a href=\"https://www.ibm.com/systems/power/software/linux/powerlinux/7r1/\">Power 7R1 虚拟参观<\/a><\/li><li><a href=\"https://www.ibm.com/systems/power/software/linux/powerlinux/7r2/\">Power 7R2 虚拟参观<\/a><\/li><\/ul><CMA ID: 975608><Site ID: 10><XSLT stylesheet used to transform this file: dw-document-html-7.0.xsl>\r\n\r\n\r\n<\/div>\r\n<\/div>\r\n","createTime":"2014-06-25 00:00:00","deployTime":"2014-06-25 00:00:00","id":0,"intro":"在 IBM? Power? 硬件上运行基于 Linux 的应用程序可以提供性能、可靠性和安全性的强大组合。在本文中，您将了解 IBM Power Systems? 可以提供的许多战略优势，而且您可能会对各种部署的低成本感到惊讶。了解 IBM 用于改善 Linux 体验的工具，并全面理解 IBM 对 Linux on POWER 的未来承诺。","keyword":"","recommend":false,"source":"http://www.ibm.com/developerworks/cn/linux/l-linux-on-power/index.html","title":"为何选择 Linux on Power？","typeId":0,"updateTime":"2014-06-25 00:00:00"}
{"author":"","clickNumber":0,"content":"\r\n<div class=\"ibm-columns\">\r\n<div class=\"ibm-col-1-1\">\r\n\r\n<p>人类的认知就是对建模的研究。显然，不是所有的模型都是图形化的，但毫无疑问 C 没有建模人类便无法推理论证。<\/p><p>模型是关于某个事物或一组事物的抽象，在模型中我们忽略对我们希望得到回答的问题无关，又或者对我们希望能得到支持的推理论证（reasoning）来说无关重要的细节。这使得我们可以只关注于与我们手头的分析或问题相关的细节。<\/p><p>例如，考虑图 1 中所展示的办公椅。一张椅子的模型是由什么构成的呢？<\/p><h5 id=\"fig1\">图 1. 椅子的模型<\/h5><img alt=\"椅子的图像\" src=\"/sunshine_new/images/负1682945015/image001.png\" width=\"556\" /><p>当然，这取决于您想回答的问题。如果您想去组装椅子，那您的模型就是由椅子的各个部分和安装指导构成的。如果您想依据风水来设计一个办公区域，那您就需要考虑颜色和风格了。如果您是零售商，您则会关注于成本和利用率了。这些都是合理的模型，取决于您想要执行的推理论证是什么。<\/p><div class=\"dw-sidebar ibm-inset\"><p>在您创建一个有用的模型之前，您应当清晰识别您想要回答的问题，以及您想要支持的推理论证。<\/p><\/div><p>本条建议的要点就是在您创建一个有用的模型之前，您应当清晰识别您想要回答的问题，以及您想要支持的论证。您应当清晰地 C 在您构建模型之前 C 回答以下问题：<\/p><ul class=\"ibm-bullet-list\"><li>为什么我要构建这个模型？（Why am I constructing the model?）<\/li><li>这个模型的范围是什么？（What is the scope of this model?）<\/li><li>谁是这个模型的消费者？（Who are the consumers of this model?）<\/li><li>关于这个模型这些消费者会问些什么样的问题？（What questions are the consumers likely to ask of this model?）<\/li><li>基于什么样的推理论证这些消费者会要使用这个模型？（With what reasoning are the consumers going to use this model?）<\/li><\/ul><p>这些问题中的每一个问题都可以得到一个或多个模型图。例如，如果我想要构建一个系统架构模型，我或许会对上述问题给出以下回答：<\/p><p>我构建这个模型用来推理论证系统的大规模片断，推理论证这些元素所分配到的需求，推理论证在这些元素之间接口的定义，推理系统的机械、电子以及软件工程等准则的职责分配情况。<\/p><h3 id=\"0.1.Scope|outline\">范围<\/h3><p>模型的范围（scope）就是系统工程架构，包括大规模多学科的部分（子系统）以及它们的接口。它还包括了追溯链接（trace link）来回溯到需求模型和前溯到工程特定模型（机械、电子及软件等部分）。<\/p><p><strong>模型的消费者包括：<\/strong><\/p><ul class=\"ibm-bullet-list\"><li>系统工程师（System engineer）<\/li><li>系统安全工程师（System safety engineer）<\/li><li>系统可靠性工程师（System reliability engineer）<\/li><li>安保分析师（Security analyst）<\/li><li>需求分析师（Requirements analyst）<\/li><li>机械工程师（Mechanical engineer）<\/li><li>电子工程师（Electronic engineer）<\/li><li>软件工程师（Software engineer）<\/li><\/ul><p><strong>问题包括：<\/strong><\/p><ul class=\"ibm-bullet-list\"><li>有哪些子系统？（What are the subsystems?）<\/li><li>分配到各个子系统的需求情况怎样？（How are requirements allocated to subsystems?）<\/li><li>在子系统之间有哪些的接口？（What are the interfaces between the subsystems?）<\/li><li>系统在可能存在的失败状态下是否安全？（Is the system safe in the presence of likely failures?）<\/li><li>重要的系统功能的可靠性怎样？（What is the reliability of the important system functions?）<\/li><li>有哪些资产必须处在安全策略的保护之下？（What are the assets that must be protected by security countermeasures?）<\/li><li>有哪些安全威胁和系统漏洞？（What are the security threats and the points of system vulnerability?）<\/li><li>有哪些需求是分配给机械（或电子及软件）部分的设计的？（What requirements are allocated to mechanical (or electrical or software)design?）<\/li><li>在软件和电子部分之间有哪些接口？（What are the interfaces between the software and the electronics?）<\/li><\/ul><p><strong>部分必须解决的推理论证（reasoning）：<\/strong><\/p><ul class=\"ibm-bullet-list\"><li>对错误树分析分割集合（对风险的表现有贡献的错误集合）的分析（Analysis of the fault tree analysis cut sets (sets of faults that contribute to the manifestation of a hazard)）<\/li><li>演示所有能由设计所覆盖的需求（Demonstration that all requirements are covered by the design）<\/li><li>演示所有满足某个需求的所有设计元素（Demonstration that design elements are all present to meet a requirement）<\/li><li>验证一个系统是否满足既定目标的测试用例（Test cases required to verify a system is fit for purpose）<\/li><\/ul><CMA ID: 975610><Site ID: 10><XSLT stylesheet used to transform this file: dw-document-html-7.0.xsl>\r\n\r\n\r\n<\/div>\r\n<\/div>\r\n","createTime":"2014-06-25 00:00:00","deployTime":"2014-06-25 00:00:00","id":0,"intro":"系统工程师正在响应要求更严格采用 UML 及 SysML 标准的需求。这些标准很复杂，而且既没有提供指导如何才是最佳建模技巧来使用这些建模语言有效定义需求和架构，也没有指导如何使用建模来演示交易案例，并且也没有系统工程所需的各种分析方法。Douglass 博士曾在几百个项目上提供过超过 30 年的咨询。在这一面向基于模型系统工程的十大建模建议清单里，他分享了他的观点及深度经验。","keyword":"","recommend":false,"source":"http://www.ibm.com/developerworks/cn/rational/top-10-modeling-hints-system-engineers-02/index.html","title":"系统工程的十大建模建议: #9 所有模型都是抽象，但只有一部分是有用的","typeId":0,"updateTime":"2014-06-25 00:00:00"}
{"author":"","clickNumber":0,"content":"\r\n<div class=\"ibm-columns\">\r\n<div class=\"ibm-col-1-1\">\r\n\r\n<p>在创建需求规格说明（Requirements Specification）这一工作中做得好并不像看起来的那么容易。非常难，事实上在过去的 35 年里，我还没有看到过一份需求规格说明是完全没有缺陷的。需求规格说明通常是使用“将来时”语句的文本文档。这种方式自身就有很多根本性的问题。<\/p><p>首先，文本（text），即便非常完美地表述，仍然会是含糊的，并且容易导致多种理解。非常难以用自然语言来清晰表达意思。这使得自然语言非常适合用于诗歌，而不适合用在技术规格说明中。<br /><br /><strong>备注<\/strong>：我确实曾经尝试使用 UML 状态机（state machine）来写作诗歌，但事实证明这不是一个很好的选择。<\/p><p>更进一步，也非常难以确保规格说明是完整的，并且您没有遗漏任何东西。您涵盖了系统必须操作的所有案例、情况以及环境了吗？所有的性能和其他服务要求的质量又如何？包括所有错误和例外情况了吗？<\/p><p>论证相当大数目的需求之间的一致性甚至更加困难。在一部有着数百页的规格说明里，一致性是一个棘手的问题。<\/p><p>通常此类的规格说明在交给工程师团队进行设计和开发之前是如何被验证的？大多数情况，要么是根本没有验证过（这是由于冗长的系统检验及验证周期使各种问题直到项目结束仍有待解决），要么是通过时间长得令人难以忍受的结对评审（peer review）来进行验证。<\/p><p>这一<em>问题<\/em>出在文本化需求（requirements-as-text）本质上是不可验证的。<em>解决办法<\/em>是创建模型化需求（requirements-as-model）。<\/p><p>设想一个简单的用例，一个交通灯控制系统的“夜间低流量模式”（Evening Low Volume Mode）。主干道交通灯闪烁黄灯，而次级道路交通灯闪烁红灯。图 1 显示了一个上述的简单需求集合，可以作为可执行状态机（executable state machine）进行模拟，发送消息给其环境中的各个参与者（Actor）：主干道行人（primary road pedestrians，PP）、次级道路行人（secondary road pedestrians，SP）、主干道直行车辆（primary through traffc vehicles，PV）、主干道转向车辆（primary turn traffic vehicles，PtV）、次级道路直行车辆（secondary through traffic vehicles，SV）以及次级道路转向车辆（secondary turn traffic vehicles，StV）。图片还显示了如何增加追踪链接到状态机元素上，来显示该元素所代表的需求。<\/p><h5 id=\"fig1\">图 1. “夜间低流量模式”的简单用例状态机<\/h5><img alt=\"用例状态机\" src=\"/sunshine_new/images/负277062886/image001.png\" width=\"608\" /><p>这一模型的首要好处是它是可执行的。它可以被用来探索不同的情形、不同的上下文、不同的值以及到达事件的次序。当然图 1 中的状态机确实非常简单。然而可以考虑该交通灯控制系统一个更复杂的“固定循环模式”（Fixed Cycle Mode）需求集合：<\/p><ul class=\"ibm-bullet-list\"><li><strong>用例<\/strong>：固定循环模式\n      <ul class=\"ibm-bullet-list\"><li>交叉路口包括一个主干道和次级道路<\/li><li>每一条道路都包括直行车道和左转向车道<\/li><li>直行车道，对于同一条道路的双方向，同时激发；<\/li><li>转向车道，对于同一条道路的双方向，同时激发；<\/li><li>直行车道信号灯仅仅在“红-绿-黄-红”循环中进行激发。其它的道路信号灯则在该道路允许通行时保持在红灯（以及“停止步行”灯）上；<\/li><li><strong>转向车道<\/strong>仅仅在有车辆到达转向车道时激发；否则它们一直保持红灯；<ul class=\"ibm-bullet-list\"><li>在<em>下一次<\/em>直行车道将要被正常激发时，转向车道会先于直行车道激发并让直行车道保持红灯直到转向循环完成；<\/li><li>双向的转向车道会走“红-绿-黄-红”循环。在此循环完成后，直行车道才允许循环到绿灯；<\/li><li>一旦某一次转向车道循环被处理过，就需要下一次有转向车辆到达才会再次激发此循环；<\/li><\/ul><\/li><li><strong>人行道信号灯<\/strong>一直保持“停止步行”状态直到“行人到达按钮”被按下才会被激发；<ul class=\"ibm-bullet-list\"><li>在<em>下一次<\/em>直行车道变绿灯时，该道路的人行道信号灯会执行以下循环：<ul class=\"ibm-bullet-list\"><li>停止步行<\/li><li>步行<\/li><li>闪烁“停止步行”<\/li><li>停止步行<\/li><\/ul><\/li><li>仅仅在人行道信号灯变成“停止步行”后，直行车道才会循环到黄灯上。<\/li><\/ul><\/li><\/ul><\/li><\/ul><p>这还不是一个很复杂的用例，但让人感兴趣的许多不同场景都可以在其中构想出来，这包括了多种组合：车辆在直行车道、转向车道上，以及人行道等等。这一用例的状态机在图 2 中展示，不琐碎也不明显。所有感兴趣的情况和场景都被考虑到。这一模型的执行允许您探索不同事件、条件及值的组合，来确保系统在所有时间里都是正确的。<\/p><h5 id=\"fig2\">图 2. “固定循环模式”的用例状态机<\/h5><img alt=\"用例状态机\" src=\"/sunshine_new/images/负277062886/image002.png\" width=\"664\" /><p>作为该类用例功能性分析的一个常见的结果，缺失的需求会被识别出来。它们随后会被添加到文本规格说明中，并被链接到模型规格说明的元素上。这就得到了更好的需求；需求也更加的完整、正确、清晰和精确。<\/p><CMA ID: 975616><Site ID: 10><XSLT stylesheet used to transform this file: dw-document-html-7.0.xsl>\r\n\r\n\r\n<\/div>\r\n<\/div>\r\n","createTime":"2014-06-25 00:00:00","deployTime":"2014-06-25 00:00:00","id":0,"intro":"Bruce Douglass 向您展示如何使需求更完整、正确、清晰和精确。","keyword":"","recommend":false,"source":"http://www.ibm.com/developerworks/cn/rational/top-10-modeling-hints-system-engineers-04/index.html","title":"系统工程的十大建模建议: #7 需求模型帮助您避免早期的昂贵缺陷","typeId":0,"updateTime":"2014-06-25 00:00:00"}
{"author":"","clickNumber":0,"content":"\r\n<div class=\"ibm-columns\">\r\n<div class=\"ibm-col-1-1\">\r\n\r\n<p>本条建议是我在业界所见过的，关于最常见的（错误）使用建模技术人尽皆知的抱怨：轻量级、不精确、不正确和不可维护的模型，对分析支持的功用很少，而且几乎无法回答关于利益关注的任何问题。您也许已经感觉到我对这种方式的建模毫无兴趣。我倾向于“高保真”（\"high-fidelity\"）模型。这些模型（在其范围和目的内）是完整、精确、正确和清晰的；而且是可验证的（一些有关的东西我们将会在后续的第 1 条建议中探讨）。<\/p><p>让我澄清一下：建模的价值依赖于我们在考虑模型的目的和范围的前提下，能<em>完整、清晰和精确<\/em>地进行验证的能力。餐巾纸模型（\"napkin model\"，因经常被手绘在触手可及的物体表面而得名），是一种最常见的使用 UML 或 SysML 的方式。但是以这种方式来使用模型，类似于使用约摸大概的弹道学参数来为导弹编程。导弹确实会击中某处地面目标，差别在于哪儿？如果您正好处在导弹弹道轨迹末端的弹着点上，这差别就大了。<\/p><h5 id=\"fig1\">图 1. 餐巾纸模型是不精确的<\/h5><img alt=\"在餐巾纸上草绘建模\" src=\"/sunshine_new/images/负332721833/image001.jpg\" width=\"850\" /><p><strong>注解：<\/strong>因为这是一个餐巾纸模型，没有存储库在模型之下确保它与您口袋中可能存在的其他餐巾纸模型在语义陈述上的一致性。<\/p><p>关于这一模型您可能存有的疑问包括：<\/p><ul class=\"ibm-bullet-list\"><li>这一模型尝试去描绘什么？（What is this model trying to depict?）<\/li><li>这些就是 Student 类或 Seminar 类所具有的<em>所有<\/em>属性吗？（Are those <em>all<\/em> the attributes of Student or Seminar?）<\/li><li>属性的数据类型及合适的子范围是什么？（What are the data types and appropriate subranges for the attributes?）<\/li><li>各个操作（operation）的参数和返回值是什么？（What are the parameters and return values of the operations?）<\/li><li>如何确定一次研讨会（Seminar）的合格性？需要什么信息来确定这一点？（How do you determine eligibility for a seminar? What information is needed to determine that?）<\/li><li>这些元素如何创建？它们如何彼此链接在一起？它们如何被销毁？（How are these elements created? How are they linked together? How are they destroyed?）<\/li><li>您如何界定一场研讨会是冷场还是满座？需要什么信息来界定？<code>MaxNumber:unsigned int<\/code> 属性是否缺失？（How can you tell if a seminar is empty or full? What information is needed for that? Is the <code>MaxNumber:unsigned int<\/code> attribute missing?）<\/li><li>所有的属性都有默认值吗？（Are there any default values for the attributes?）<\/li><\/ul><p>似乎听起来我像是把餐巾纸模型置于万劫不复的境地。但这并不完全正确。我认为餐巾纸模型是<em>开启<\/em>对话的一种很好的方式。在您接下来回答关于系统的结构和行为的问题和原因时，您可以将模型从“纸巾模型”转化为“高保真模型”。当模型是用具备实时模型存储库的建模工具来管理的话，这很容易做到。如果工具支持模型验证的话，则更加容易了，例如某些高端工具，Rational Rhapsody。<\/p><p>最差的情形是，不精确的思考会得到一个失败的系统。在我眼里，这是无法接受的。<\/p><CMA ID: 975612><Site ID: 10><XSLT stylesheet used to transform this file: dw-document-html-7.0.xsl>\r\n\r\n\r\n<\/div>\r\n<\/div>\r\n","createTime":"2014-06-25 00:00:00","deployTime":"2014-06-25 00:00:00","id":0,"intro":"不要基于草拟在餐巾纸上的不精确思考开始构建一个风险大容易失败的系统。Bruce Douglass 系统工程的十大建模建议系列的第 8 条帮助您从轻量级模型转型到高保真模型。","keyword":"","recommend":false,"source":"http://www.ibm.com/developerworks/cn/rational/top-10-modeling-hints-system-engineers-03/index.html","title":"系统工程的十大建模建议: #8 餐巾纸模型是开始对话最好的方式，但也绝对是结束对话最糟糕的方式。","typeId":0,"updateTime":"2014-06-25 00:00:00"}
{"author":"","clickNumber":0,"content":"\r\n<div class=\"ibm-columns\">\r\n<div class=\"ibm-col-1-1\">\r\n\r\n<h2 id=\"2.引言：|outline\">引言<\/h2><p>随着虚拟化技术日新月异的变化，一个物理服务器可以划分出大量的虚拟资源，同时管理众多的物理和虚拟资源显然成为一个庞大工程，也大大增加了实验室管理员的工作难度和强度。众所周知，ISD\n    是一个跨平台管理工具，它简化了复杂的物理和虚拟系统的管理方式，并且通过使用行业标准，同时支持在 IBM 和非 IBM 的 x86 平台上的多种操作系统和虚拟化技术。但是现在一个典型的企业级数据中心通常有超过 5000 的资源，而单独的一个 ISD 最多支持管理 5000 个资源，这必须使用多个 ISD 来进行管理。这时需要一个能够充当中央集权的数据中心来管理这些 ISD。在 ISD 6.2 版本中出现了这样的功能：HMS，它为被管理的 ISD 和普通的资源提供了一个可以显示所有数据信息的统一视图。<\/p><h2 id=\"3.名词解释：|outline\">名词解释：<\/h2><p><strong>Global Server:<\/strong> 一个能够管理其他 ISD，驱动被管理 ISD 的远程资源，帮助在分层管理环境中建立集权管理关系的 ISD。<\/p><p><strong>Domain server:<\/strong> 在分层管理环境中被 Global Server 管理的 ISD。<\/p><p><strong>REST:<\/strong> 在分层管理环境中，REST 是 Global Server 和 Domain Servers 之间通信的协议。任何一个被 Global server 管理的 Domain server 都有 REST 协议。<\/p><p><strong>Hierarchical Management:<\/strong> 分层管理是在 ISD 6.2 中一个新的功能，它能够使 Global server 发现并且管理其他的 domain server，然后建立集权管理关系。<\/p><p><strong>Hierarchical Management Server<\/strong><strong> (<\/strong><strong>HMS<\/strong><strong>):<\/strong>是 Global Server 的另一个名称。<\/p><p><strong>Launch-in-context:<\/strong> global server 利用它来查看在远程被管理系统上的任务。可以通过右键点击远程被管理系统或者选择这个被远程管理的系统，然后点击操作按钮，您可以看到可用的任务。当您选择了一个任务，global server 打开一个新的浏览器窗口或者一个便签，然后利用已有的凭证登陆到管理这个远程系统的 domain server，最后在 domain server 上执行这个被选择的任务。这整个过程被称为一个任务的 launch-in-context.<\/p><p><strong>Remote managed resource:<\/strong> 任意被 domain server 管理的资源。<\/p><p><strong>Remote managed system:<\/strong> 任意被 domain server 管理的系统。<\/p><p><strong>Reference Mep (RefMep):<\/strong> 在分层管理环境中，一个 RefMep 表示在 global server 上的一个远程被管理系统。RefMep 充当了一个在 domain server 端的真实 Mep 代理。<\/p><h2 id=\"4.HMS 概述：|outline\">HMS 概述：<\/h2><ol type=\"1\"><li>HMS 是在 ISD 6.2 版本的时候推出的一个新功能，用它来实现分层管理，并且使它成为一个中央集权的数据中心。当一个 ISD 被激活了 HMS 功能以后，它将被作为一个全局服务器(Global Server) 通过 REST 协议去管理一个或者多个普通的 ISD 服务器，通常称之为局部服务器(Domain Server)，和被这些局部服务器管理的服务器上所有数据和状态信息，同时全局服务器仍然具有一个普通 ISD 的功能。下面图 1 展示了它们之间的层次关系：<\/li><\/ol><h5 id=\"N10098\">图 1. 全局服务器与局部服务器层次关系<\/h5><img alt=\"全局服务器与局部服务器层次关系\" src=\"/sunshine_new/images/负174265209/image003.jpg\" width=\"554\" /><p>    图 1 中，位于最上面名为 IBM System Director Global Server 是已激活 HMS 功能的 ISD，我们称之为全局服务器（Global Server）。它通过 Rest 协议管理下面的 IBM System Director Server Node，即局部服务器（Domain Server）。<\/p><ol type=\"1\"><li>HMS 能通过管理多个 domain server 管理最多 10,000 个资源。<\/li><li>使用 HMS 的好处：<ol class=\"ibm-alpha-list\" type=\"a\"><li>单个的 ISD 最多能管理 5,000 个远程资源，而使用 Global server 能够帮助管理多个 ISD，并且让它们像一个数据中心。<\/li><li>当一个企业用多个 ISD 去管理不同类型服务器、运用不同的安全策略，不同的应用服务或者操作系统的时候，HMS 就能够提供一个完整的数据中心视图。<\/li><li>当一个数据中心用多个系统管理应用，HMS 能够单点控制所有的应用。<\/li><\/ol><\/li><\/ol><h2 id=\"5.开启/关闭 HMS 功能：|outline\">开启/关闭 HMS 功能：<\/h2><h3 id=\"N100B8\">开启 HMS 功能<\/h3><p>1. 通过 ISD 界面开启 HMS 功能。如图 2。<\/p><ol class=\"ibm-alpha-list\" type=\"a\"><li>在 ISD 的左边导航控制板选择<strong>设置<\/strong>，然后点击<strong>服务器首选项<\/strong>。<\/li><li>在服务器首选项页面找到<strong>分层管理<\/strong>，然后选择上<strong>启用对多个 Systems Director Server 的管理<\/strong>。<\/li><li>点击<strong>应用<\/strong>按钮。<\/li><\/ol><h5 id=\"N100D8\">图 2. 开启 HMS<\/h5><img alt=\"开启 HMS\" src=\"/sunshine_new/images/负174265209/image005.jpg\" width=\"554\" /><p>2. 通过命令行开启 HMS 功能<\/p><p>通过 SSH 或者 telnet 协议登陆到 ISD，运行命令：smcli hms/confighms Ce<\/p><p>同时可以通过命令：smcli hms/confighms Cs 查看 ISD 中 HMS 的状态是否开启。<\/p><p>开启 HMS 功能之后，通过 Global Server 发现另外一个 ISD， 等发现完成以后能在被发现的 ISD 的属性页面看到它拥有的协议里面有 REST 协议。 这是被发现的 ISD 作为一个 Domain Server 的明显标记。<\/p><h3 id=\"N100EB\">关闭 HMS 功能<\/h3><p>目前只能通过以下命令将 Global server 还原成普通的 ISD。<\/p><p>Smcli hms/confighms Cd<\/p><h2 id=\"6.HMS 支持的功能 |outline\">HMS 支持的功能<\/h2><h3 id=\"N100F9\">发现 Domain server<\/h3><p>在运用 Global server 去管理 domain server 之前，必需在 global server 端先发现 domain server。<\/p><p>发现 domain server 和发现其他资源的过程一样。只是在发现之前，要确保 HMS 已经在 Global server 端开启并且 HMS 没有在将要作为 domain server 的 ISD 上开启。<\/p><p>当发现结束以后，您能在 Global server 上面通过图标<img alt=\"\" src=\"/sunshine_new/images/负174265209/image006.gif\" width=\"16\" />分辨出这是一个 domain server。<\/p><p>此外，在 domain server 的协议属性里面将包含 REST 协议。<\/p><h3 id=\"N1010E\">请求 domain server 的管理访问权<\/h3><p>当 domain server 的发现结束后，执行下面步骤来获得每个 domain server 的管理访问权。<\/p><ol class=\"ibm-alpha-list\" type=\"a\"><li>在 ISD 的资源控制面板，选择<strong>资源浏览器<\/strong>。<\/li><li>点击<strong>domain server<\/strong>。<\/li><li>右键点击 domain server，然后选择<strong>安全<\/strong> --&gt; <strong>请求管理访问权<\/strong>。然后请求管理访问权页面就会出现。<\/li><\/ol><p>Note: 当右键点击 domain server，如果看到的是请求访问权而不是请求管理访问权，说明 domain server 在发现的时候没有通过 REST 协议。这时，需要重新发现 domain server。<\/p><ol class=\"ibm-alpha-list\" type=\"a\"><li>输入正确的用户名和密码，然后点击<strong>申请权限按钮<\/strong>。这个被开启的 domain server 和被它管理的所有系统都会被列在 Global server 里面。<\/li><\/ol><p>Note：也可以通过命令 smcli accesssy 去请求管理访问权。<\/p><h3 id=\"N10136\">请求访问权/撤销访问权<\/h3><p>Global server 能够请求和撤销被 Domain server 管理资源的访问权。这些任务在 global server 上被触发，而不需要打开新的浏览窗口。尽管这些任务在 Global server 上能够看见并且执行，但实际上请求/撤销访问权是在 domain server 上面执行的。<\/p><h3 id=\"N1013D\">利用 web 界面在被管理的资源上执行任务<\/h3><p>当 HMS 成功配置以后，可以通过 Global server 的 web 界面在被管理的远程资源上去查看和执行交互式任务。<\/p><p>局限：Global server 只能在远程被管理的资源上执行交互式的任务。一个非交互式的任务必须在 domain server 上面执行。通过 domain server 在远程被管理资源上激活和被安排好的任务不能够通过 global server 查看到。<\/p><h3 id=\"N10146\">在多个远程被管理的资源上发起任务<\/h3><p>只有被选中的远程被管理资源在同一个 domain server 上，才能够通过 global server 在多个远程被管理的资源上执行任务。<\/p><p>从控制台去鉴定 domain server 管理的远程被管理资源，执行以下步骤：<\/p><ol type=\"1\"><li>在 ISD web 界面的导航区域选择<strong>资源浏览器<\/strong>，然后任意选择一个组，在点击<strong>操作按钮<\/strong> &gt; <strong>列<\/strong>。<\/li><li>从可用的列中选择拥有的节点，点击<strong>添加<\/strong>按钮，然后点击<strong>确定<\/strong>按钮。一个名为<strong>拥有的 Domain server<\/strong>的新列将显示 Domain server 的名字和被它管理的所有远程资源。<\/li><li>在同一个 Domain server 上选择一个或者多个远程被管理的资源，右键点击其中的任意一个然后查看它们共同支持的任务。如果这些远程被管理的资源来自不同的 domain server，那么没有任何任务可用。<\/li><li>选择任何一个任务。这个任务将在一个新的浏览器标签打开。<\/li><\/ol><h3 id=\"N1016B\">不利用 launch-in-context 来执行任务<\/h3><p>以下任务可以不通过 launch-in-context 模式在 global server 端执行：<\/p><ol type=\"1\"><li>资源浏览器<\/li><li>请求访问权<\/li><li>验证链接<\/li><\/ol><p>这些任务不需要在 global server 打开一个新的浏览器窗口就能直接在一个远程被管理的系统上执行。<\/p><h3 id=\"N1017C\">在远程被管理系统上安装 ISD 插件<\/h3><p>在 domain server 上面安装 ISD 插件时，可以在 global server 执行交互式的任务通过 launch-in-context 来完成。<\/p><h3 id=\"N10183\">利用 web 界面在 domain server 上执行任务<\/h3><p>只有安全任务能够通过 global server 的 web 界面直接在 domain server 执行。其他的任务要在远程被管理资源上执行都必需通过 launch-in-context 的形式。<\/p><p>一旦 domain server 被发现和管理，将会在 global server 上面出现两个新的远程被管理资源：一个操作系统和一个服务器。这两个远程被管理资源代表了本地的 domain server。<\/p><h3 id=\"N1018C\">从 global server 执行 CLI 命令<\/h3><p>Global server 支持有限的 CLI 命令，它们包括：安全任务，组合状态类的任务的 CLI 命令才能过通过 Global server 在远程被管理的机子上面运行。<\/p><p>从 global server 在 domain server 上执行非交互的任务 CLI 是不支持的。<\/p><h3 id=\"N10195\">从 Global server 升级 domain server<\/h3><p>您必须在每一台 domain server 上面执行升级任务，同样在 global server 也是。<\/p><p>可用的升级包在 global server 端，也只能用来对 global server 升级，不能将这些升级包用于 domain server 升级。<\/p><p>但是您可以通过 launch-in-context 的方式在 global server 端给 domain server 和他们管理的远程系统进行升级。<\/p><h3 id=\"N101A0\">通过 Global server 在远程被管理系统上面安装代理程序<\/h3><p>您可以安装一个代理程序在远程被管理的系统上面通过 <em>发行版本管理<\/em>―&gt;<em>代理程序<\/em> 的 launch-in-context 任务。如果这样做，您还必须导入这个代理程序的安装包并且确保它在 domain server 上面是可用的。<\/p><h2 id=\"7.HMS 图标展示：|outline\">HMS 图标展示：<\/h2><p>在激活了 HMS 功能的 ISD 的 GUI 界面上会出现很多新的图标以区分这些服务器是由全局服务器管理。这些图标如图 3 所示：<\/p><h5 id=\"N101BC\">图 3. 各种图标及含义<\/h5><table border=\"0\" cellpadding=\"0\" cellspacing=\"0\" class=\"ibm-data-table\" summary=\"\"><thead xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"><tr><th style=\"text-align:center; vertical-align:top\">\nIcon\n<\/th><th style=\"text-align:center; vertical-align:top\">\nMeaning\n<\/th><\/tr><\/thead><tbody xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"><tr><td style=\"text-align:center; vertical-align:top\"><img alt=\"\" src=\"/sunshine_new/images/负174265209/image008.gif\" width=\"33\" /><\/td><td style=\"text-align:center; vertical-align:top\">\nDomain Server：在分层管理环境中被 Global Server 管理的 ISD。\n<\/td><\/tr><tr><td style=\"text-align:center; vertical-align:top\"><img alt=\"\" src=\"/sunshine_new/images/负174265209/image009.gif\" width=\"40\" /><\/td><td style=\"text-align:center; vertical-align:top\">\nBlade Center：刀片服务器\n<\/td><\/tr><tr><td style=\"text-align:center; vertical-align:top\"><br /><img alt=\"\" src=\"/sunshine_new/images/负174265209/image010.gif\" width=\"40\" /><\/td><td style=\"text-align:left; vertical-align:top\">\nCluster：集群就是由一些互相连接在一起的计算机构成的一个并行或分布式系统，从外部来看，它们仅仅是一个系统，对外提供统一的服务。\n<\/td><\/tr><tr><td style=\"text-align:center; vertical-align:top\"><img alt=\"\" src=\"/sunshine_new/images/负174265209/image011.gif\" width=\"40\" /><\/td><td style=\"text-align:center; vertical-align:top\">\nDevice：指物理设备\n<\/td><\/tr><tr><td style=\"text-align:center; vertical-align:top\"><img alt=\"\" src=\"/sunshine_new/images/负174265209/image012.gif\" width=\"40\" /><\/td><td style=\"text-align:center; vertical-align:top\">\nHost：包含的资源是由虚拟服务器构成。\n<\/td><\/tr><tr><td style=\"text-align:center; vertical-align:top\"><img alt=\"\" src=\"/sunshine_new/images/负174265209/image013.gif\" width=\"40\" /><\/td><td style=\"text-align:center; vertical-align:top\">\nOperating System：操作系统\n<\/td><\/tr><tr><td style=\"text-align:center; vertical-align:top\"><img alt=\"\" src=\"/sunshine_new/images/负174265209/image014.gif\" width=\"40\" /><\/td><td style=\"text-align:center; vertical-align:top\">\nPrinter：打印机设备\n<\/td><\/tr><tr><td style=\"text-align:center; vertical-align:top\"><img alt=\"\" src=\"/sunshine_new/images/负174265209/image015.gif\" width=\"40\" /><\/td><td style=\"text-align:center; vertical-align:top\">\nSwitch：指物理交换机\n<\/td><\/tr><tr><td style=\"text-align:center; vertical-align:top\"><img alt=\"\" src=\"/sunshine_new/images/负174265209/image016.gif\" width=\"41\" /><\/td><td style=\"text-align:center; vertical-align:top\"><br />\nVirtual Device：指虚拟的设备\n<\/td><\/tr><tr><td style=\"text-align:center; vertical-align:top\"><img alt=\"\" src=\"/sunshine_new/images/负174265209/image017.gif\" width=\"40\" /><\/td><td style=\"text-align:center; vertical-align:top\">\nVirtual Server：虚拟的服务器\n<\/td><\/tr><tr><td style=\"text-align:center; vertical-align:top\"><img alt=\"\" src=\"/sunshine_new/images/负174265209/image018.gif\" width=\"40\" /><\/td><td style=\"text-align:center; vertical-align:top\">\nVirtual Switch：虚拟的交换机\n<\/td><\/tr><tr><td style=\"text-align:center; vertical-align:top\"><img alt=\"\" src=\"/sunshine_new/images/负174265209/image019.gif\" width=\"38\" /><\/td><td style=\"text-align:center; vertical-align:top\">\nVirtual Card：泛指各种虚拟的卡，比如网卡\n<\/td><\/tr><\/tbody><\/table><h2 id=\"8.总结：|outline\">总结：<\/h2><p>在本文中，我们展示了 ISD 使用分层管理来满足客户集中管理的需求, 从而为用户提供更加灵活和高效的分层管理解决方案。这个功能可以应用 AIX, Unix, Linux 和 Windows 的平台上。<\/p><CMA ID: 975209><Site ID: 10><XSLT stylesheet used to transform this file: dw-document-html-7.0.xsl>\r\n\r\n\r\n<\/div>\r\n<\/div>\r\n","createTime":"2014-06-25 00:00:00","deployTime":"2014-06-25 00:00:00","id":0,"intro":"本文将展示 Hierarchical Management Server (HMS) 是什么，如何开启、关闭，它拥有哪些能力和介绍新出现的图标以及含义。HMS 是 IBM Systems Director (ISD) version 6.2 新增加的一个功能。通过本文的介绍您将对 HMS 的基本功能、使用以及新出现的图标有一个深刻的理解。","keyword":"","recommend":false,"source":"http://www.ibm.com/developerworks/cn/aix/library/1406_liupan_isd/index.html","title":"概述 IBM Systems Director 里对不同平台的分级管理","typeId":0,"updateTime":"2014-06-25 00:00:00"}
{"author":"","clickNumber":0,"content":"\r\n<div class=\"ibm-columns\">\r\n<div class=\"ibm-col-1-1\">\r\n\r\n<h2 id=\"1.背景介绍 |outline\">背景介绍<\/h2><p>UCM：Unified Changed Management 的缩写 ，统一变更管理模式，是 IBM Rational 提出的用于管理软件开发过程（包括从需求到版本发布）中所有变更的\"最佳实践\"流程。UCM 通过抽象层次的提升简化了软件开发，从而使得软件开发团队从更高的层次根据活动（activity）来管理变更。通过 UCM，一个开发活动可以自动地同其变更集（封装了所有用于实现该活动的项目工件）相关联，这样避免了管理人员手动跟踪所有文件变更。<\/p><p>在介绍 UCM ClearCase 的 CMI 集成功能之前，需要了解一下几个概念，这些会在后面的操作时经常提到<\/p><p>Activity： Activity 是 ClearCase UCM 模式中的一个概念，通过变更集 (Change Set) 跟踪完成一项开发任务所引起的所有配置项的变更。Check Out、Check In、Add to Source Control 等引起配置项发生变化的操作住 UCM 下必须关联到一个 Activity。<\/p><p>Stream： UCM 的概念，项目开发的主干，类似 Base ClearCase 里的 Branch 概念。有集成流和开发流两种，每个开发流都是集成流的一个分支，在开发流上完成工作后，再提交到集成流上，然后在集成流上做成 Build。<\/p><p>Provider：所要集成的产品如 CLM 里的 RTC、CQ，这些 Server 本身提供 OSLC 功能的的集成接口，Provider 不仅限于 Rational 自身产品还包括将能扩展集成的任何第三方产品，只要此 Server 提供 OSLC 接口功能和相应的 Driver 库。此 Driver 库用来 ClearCase 集成时动态加载。<\/p><p>Task：是 Provider 里的一条记录，主要针对 RTC 的一条工作项，包含 Task ID 和 Task 描述等，每个 ClearCase 元素的集成信息都关联到相应的 Provider 的一条 Task，如果是 CQ 就是相应的一条 Record，语义上和 RTC 的 task 类似，也有 Record ID。<\/p><h2 id=\"2.UCMClearCaseCMI 原理及目前状态 |outline\">UCM ClearCase CMI 原理及目前状态<\/h2><p>ClearCase UCM 的集成在 ClearCase 以前的版本就有，ClearCase UCM 和 ClearQuest 的集成作为配置管理变更管理工具一直帮助客户实现整个软件周期的管理，当时由于 Rational 关于软件生命周期的管理的产品有限，ClearCase 的集成主要针对 ClearQuest 单个产品解决方案，这就造成 ClearCase 的集成操作多针对 ClearQuest 一个产品的特性，源代码中很多针对 ClearQuest 定制的专有代码，随着 Rational 产品的丰富以及更新换代，ClearCase 在面对新产品的集成无法继续为每个产品都提供一个集成方案，这样一个统一的集成方案的需求迫在眉睫，而 CMI 正是这个需求的产物，它提供了统一的集成接口，并动态加载需要集成产品的驱动库和实现 OSLC 数据访问功能的产品实现交互，OSLC 是 IBM 产品都遵循的一个数据访问服务交互模式。几乎所有产品都提供 OSLC 的访问和交互功能。从此，ClearCase 里的源代码将不会以后针对相应产品的功能的特殊描述，取而代之的是用户自己定义的产品 Provider 的名字，CMI 后台通过客户指定的 Provider 的名字来动态加载相应的驱动库（由集成产品提供，接口一致），然后查找 provider 的配置地址来实现具体的集成操作。 <\/p><p>新的集成方案 CMI 定义了统一的，标准化的接口，需要集成的产品只需要实现 Interface，双方通过此接口定义的一些方法来通信，此类似于 JDBC/ODBC driver 解决和产品数据库连接和操作的思想。<\/p><p>使用体验上实现了 pluggable 的使用 CMI 的功能，CMI 的具体命令和 ClearCase 自身的命令集成在一起，并添加了关于 CMI 的相关参数和命令，这对于已经数量掌握 ClearCase 的管理员来说很容易理解和上手。<\/p><p>如果用户启用了 CMI 的功能意味着在常规的 check in/out 等操作后还要执行把新版本信息关联到 Provider 的具体 Task 里，这里添加了事务管理概念，使得本身的 check in/out 操作和集成操作在一个事务管理内，任何一个操作失败将导致整个事务操作失败，保证 ClearCase 和 Provider 端的一致。<\/p><p>    通过在 version、branch、stream 上添加一个简单属性 TaskID@ProviderName， \"@\"符号区分符后面是所集成的 server 名字，前面是这个 server 的相关记录的 ID.整个集成过程都围绕着这个接口信息通过 OSLC 的方式以 URL 访问 CLM 应用来调用和跟踪变更。<\/p><p>    可以同时和多个产品 Server 实现集成，一次 check in/out.多个产品同时记录相关联的涉及的代码变更。<\/p><p>    新的 CMI 集成方案和传统的方法具备了共同的特性：<\/p><p>    1.通过会话 session 机制实现批处理和 server 交互。<\/p><p>    2.通过队列机制处理交互阻塞。<\/p><p>    3.保持 ClearCase 管理的代码状态和 server 状态一致，有一定的容错性。<\/p><p>    4.自动关联和自动解关联。<\/p><p>    在 ClearCase V7.1.2.9 及 V8.0.0.6 以上版本中，ClearCase 实现了 CMI 与 CLM 的集成，如下所示：<\/p><p>UCM ClearCase/ClearQuest/RTC 通过 CMI 进行集成；<\/p><p>BASE ClearCase/ClearQuest/RTC 通过 CMI 进行集成；<\/p><p>RTC - CTE 通过 CMI 方式进行集成；<\/p><p>RTC - Visual Studio 通过 CMI 方式进行集成；<\/p><p>CCRC CLI (rcleartool) 基于 CMI 的增强。<\/p><p>    本篇文章通过具体例子，详细介绍如何使用 CMI 来实现 UCM ClearCase 与 ClearQuest 以及 RTC 的集成。<\/p><h2 id=\"3.准备工作 |outline\">准备工作<\/h2><p>    在进行例子之前，我们需要安装一些 Rational 的软件，包括 ClearCase8.0.0.8 以上版本，同时需要已经配置好的 ClearQuest 服务器以及 RTC 服务器，并创建样例数据。在我们引入的例子中，我们使用了的版本如下：<\/p><p>Rational ClearCase 以及 ClearQuest 8.0.0.9版本<\/p><p>Rational Jazz Team Server Version: 4.0.4 M1版本<\/p><h2 id=\"4.使用 UCMClearCase 通过 CMI 和 ClearQuest 集成 |outline\">使用 UCM ClearCase 通过 CMI 和 ClearQuest 集成<\/h2><p>步骤一：准备将要集成的 UCM ClearCase，CQ provider 的环境<\/p><p>UCM ClearCase 的 CMI 集成和 Base ClearCase 的集成都需要通过 OSLC，所以我们得首先使 Schema 支持 OSLC，如图 1-4 所示：<\/p><h5 id=\"N100B4\">图 1. 在 ClearQuest Designer 中为当前 CQ\n    Schema 添加 OSLC 补丁包<\/h5><img alt=\"在 ClearQuest Designer 中为当前 CQ Schema 添加 OSLC 补丁包\" src=\"/sunshine_new/images/1029467712/image003.jpg\" width=\"575\" /><h5 id=\"N100C0\">图 2. 选择当前最高版本 OSLC 补丁包<\/h5><img alt=\"选择当前最高版本 OSLC 补丁包\" src=\"/sunshine_new/images/1029467712/image005.jpg\" width=\"576\" /><h5 id=\"N100CC\">图 3. 指定需要支持 OSLC 的 Record\n    Types<\/h5><img alt=\"指定需要支持 OSLC 的 Record Types\" src=\"/sunshine_new/images/1029467712/image007.jpg\" width=\"581\" /><h5 id=\"N100D8\">图 4. 更新 ClearQuest 用户 DB<\/h5><img alt=\"更新 ClearQuest 用户 DB\" src=\"/sunshine_new/images/1029467712/image009.jpg\" width=\"582\" /><p>以上操作是为了在要集成的 Provider Server 准备环境和数据，并让 Provider 提供 OSLC 访问接口。此过程和 Base ClearCase 的环境准备类似。<\/p><p>步骤二：准备 UCM CMI 的集成环境<\/p><p>本文演示的集成操作都是在 RHEL 6.3 i386 GNU/Linux 平台上进行。命令行方式是 ClearCase 管理员经常使用、最快捷的 clearcase 操作方式。本文通过命令行的方式来详细介绍基于 CMI 的 UCM ClearCase 和 ClearQuest 集成的具体操作,帮助用户更深入的理解 ClearCase 的 CMI 功能。<\/p><p>首先，我们需要通过 ClearCase 命令创建基于 UCM 的 Project，为 CC 和 CQ Server 集成做好准备。<\/p><h5 id=\"N100EC\">图 5.\n    创建存储 view 和 vob 的 storage 库<\/h5><img alt=\"创建存储 view 和 vob 的 storage 库\" src=\"/sunshine_new/images/1029467712/image011.jpg\" width=\"602\" /><h5 id=\"N100FA\">图 6. 创建 ucm\n    project 需要的 VOB<\/h5><img alt=\"创建 ucm project 需要的 VOB\" src=\"/sunshine_new/images/1029467712/image013.jpg\" width=\"601\" /><p>如图所示，下面开始创建 ucm project、PVOB 和 element VOB 所需要的 component，并在这个 PVOB 上创建集成流、集成视图，开发流以及开发视图。<\/p><h5 id=\"N10106\">图 7. 创建所需 component，并在 project\n    VOB 上创建集成/开发流及相应视图<\/h5><img alt=\"创建所需 component，并在 project VOB 上创建集成/开发流及相应视图\" src=\"/sunshine_new/images/1029467712/image015.jpg\" width=\"624\" /><p>以上步骤是用 UCM 来做版本管理的必备程序。<\/p><p>UCM 的概念和原理这里不再详细介绍，简单的说它是在 base 基础上形成的统一变更管理模式，UCM 通过抽象层次的提升简化了软件开发，从而使得软件开发团队从更高的层次根据活动（activity）来管理变更（change set）。<\/p><p>步骤三 ClearCase CMI 相关的配置工作。<\/p><h5 id=\"N10118\">图 8. VOB 添加 CMI 所必须的属性<\/h5><img alt=\"VOB 添加 CMI 所必须的属性\" src=\"/sunshine_new/images/1029467712/image017.jpg\" width=\"602\" /><p>从 V8.0.0.7 起，ClearCase 本地客户端( cleartool 和 native GUIs)支持基于 CMI 的 UCM-CQ 集成。ClearCase 与 ClearQuest 通过 OSLC 接口进行交互<\/p><p>以下范例完成在 project vob 里创需要集成的 Provider Server。下面语句在所要集成的 VOB 里创建一个名字为 CQPROV 的 Provider Server，并自动关联到 VOB 属性里。<\/p><h5 id=\"N10128\">图 9.\n    为 VOB 创建连接 CQ 的 Provider<\/h5><img alt=\"为 VOB 创建连接 CQ 的 Provider\" src=\"/sunshine_new/images/1029467712/image019.jpg\" width=\"602\" /><p><code>mkcmprovider<\/code>相关参数介绍如下。<\/p><p>-<code>vob<\/code>：指定需要使用 CMI 与 CLM 集成的 vob；<\/p><p>-<code>type<\/code>：当前所创建的 CMI Provider 类型，由于是与 CQ 集成，因此值为\"cmcq\"；<\/p><p>-<code>ver<\/code>：CMI 功能版本号，值为\"v1_0\" ；<\/p><p>-<code>desc<\/code>：当前 CMI Provider 描述信息；<\/p><p>-<code>connection<\/code>：provider server 提供的 OSLC URL 地址，格式为：baseurl:http://ip/cqweb/oslc；<\/p><p><code>CQPROV<\/code>是我们所创建的 CMI Provider 的名字<\/p><p>这里的-ver 和-type 是特定的 provider 类型，CMI 需要这两个信息加载相应的驱动库，如果填写错误将导致无法找到相应的 provider 错误。 CMI 会验证 connection 地址的正确性，如果未通过验证，将报 URI 地址无法访问错误。<\/p><p>此操作必须在 Vob 里创建完 Provider 信息后，否则就会报找不到相应 Provider 的错误。<\/p><p>如果是采用 UCM 集成，需要在 stream 引用此 provider，并将 provider 与 stream 上的 activity 做关联。如果是采用 base 集成,需要在 branch 上引用此 provider，并将 provider 与 branch 里的具体 element 版本做关联。UCM ClearCase 与 ClearQuest 集成独特之处在于：在 activity 上关联集成的 provider，如 CQ，RTC 的 server 信息后，在这个 activity 下所有的 version 更改信息就会传到 Server Provider 端。UCM 的集成粒度比 Base 要大，不需在单个文件上做关联，当然这种关联也是通过从配置信息里自动获取并打上标签属性，无需手动参与。<\/p><h5 id=\"N1015B\">图 10.\n    在 Vob 里的 Stream 上引用在 Vob 里定义的 Provider 信息<\/h5><img alt=\"在 Vob 里的 Stream 上引用在 Vob 里定义的 Provider 信息\" src=\"/sunshine_new/images/1029467712/image021.jpg\" width=\"602\" /><p>Activityformat 属性定义了 activity 格式。因此在 mkact 命令创建 activity 时将默认使用此格式，自动创建 activity 名字，除非你重新指定所要创建的 activity 名字。<\/p><p>enable 属性用于确定是否启用 ClearCase 与 provider 的集成，如果不想再和这个 provider 集成，可以设置属性 enable 为 false。<\/p><p>validate 属性用于确定这个 provider 的某个 task 必须和 ClearCase 的 activity 有关联，就是 ClearCase vob 里的 activity 必须关联到此 provider 的某个 task。后面的文章会详细讲解这里的逻辑规则以及错误处理。<\/p><p>最后通过 lsprovider 命令检查在 vob 和 stream 上的 provider 配置是否正确，在配置之前也可以先 lsprovider 查看是否有人已经配置，以免重复配置。<\/p><p>如果需要更改这个 provider 的相关配置，可以在创建命令行里添加 \"-replace\"参数。具体的，请运行<code>cleartool mkcmprovider Chelp<\/code>获得相关命令使用帮助。<\/p><p>步骤四：对应之前创建的 Provider，创建所需的 CQ 认证属性<\/p><p>通过\" <code>cmiregister add -cq -name CQPROV -userdb CQWAN -dbset CQWAN -username admin<\/code>\" 命令创建对应之前创建的 Provider 所需的 CQ 认证属性，从而记录连接 CQ 所需要的登陆信息；添加完成后，可以通过\"<code>cmiregister list<\/code>\"命令来进行查看。<\/p><h5 id=\"N1017F\">图 11. 创建并记录链接 CQ 的登录信息：<\/h5><img alt=\"创建并记录链接 CQ 的登录信息：\" src=\"/sunshine_new/images/1029467712/image023.jpg\" width=\"619\" /><p>步骤五：通过 Cleartool mkact 创建 activity，并为当前的 ClearCase 操作与 ClearQuest record 相关联，如下图 12,13 所示。<\/p><p>Activity 是 ClearCase UCM 模式中的一个概念，通过变更集 (Change Set) 跟踪完成一项开发任务所引起的所有配置项的变更。在 UCM 模式下，所有的 Check Out 、 Check In 、 Add to Source Control 等引起配置项发生变化的操作必须关联到一个 Activity。<\/p><p>用户在任何时候要向控制 vob 添加资源或修改已经处于 vob 控制之下的资源，都必须将操作与某个 UCM 活动相关联。<\/p><p>我们在 stream 上创建 activity 的同时，可以创建此 activity 关联的 provider 的 taskid。实例：<\/p><div class=\"codesection\"><pre class=\"displaycode\">cleartool mkact -nc -tasks CQWAN00000001@CQPROV lzhao_act2<\/pre><\/div><p>mkact 相关参数介绍如下：<\/p><p>-tasks 参数是专门为做 UCM 集成加入的。CQWAN00000001 就是 provider CQPROV 的一个 defect id。此创建过程会验证 ClearQuest server provider 和 defect id 信息的正确性，如果不存在会报错，但是 activity 仍然能创建成功，就是没有关联到相关 ClearQuest server。<\/p><p>Lzhao_act2 是将创建的活动名称。如果不指定名称，根据前面的设置，系统将自动创建格式为 ACT_%task-id_%stream-name 的活动。<\/p><p>然后可以用 <code>cleartool lsact -l Sample_act<\/code> 去确认此 activity 已关联到相应的 provider 和 taskid，如下图书所示：<\/p><h5 id=\"N101A2\">图 12. 创建 Activity，通过命令将 CC activity 与 CQ\n    Record 做关联<\/h5><img alt=\"创建 Activity，通过命令将 CC activity 与 CQ Record 做关联\" src=\"/sunshine_new/images/1029467712/image025.jpg\" width=\"665\" /><p>通过 <code>cleartool settask<\/code> 命令可设定默认关联的 Provider 的 Task 信息，这样你在每次 check in/out 操作时，CMI 会根据此设定的信息来和 Provider 集成。如下图所示：<\/p><h5 id=\"N101B3\">图 13.\n    为 activity 设定默认关联 provider 的 task 信息<\/h5><img alt=\"为 activity 设定默认关联 provider 的 task 信息\" src=\"/sunshine_new/images/1029467712/image026.jpg\" width=\"668\" /><p>RedHat 系统里 Root 目录下的.ccas_current_tasks 记录了默认的集成信息，你可以手动在这文件里添加，也可以用 cleartool settask 命令来添加。<\/p><p>如上图实例：.ccase_current_tasks 中包含两个 view 和 provider 的集成信息，一个是 rtcprovider，另一个是 CQPROV。cmi_view 是在 Base Vob 里创建的 view，int_view 实在 UCM Vob 里创建的 view。<\/p><p><code>settask Cnone<\/code> 用于清空默认的 task 集成信息。<\/p><p>当然如果愿意，我们可以将 activity 与 provider 的更多 task 相关联。此 activity 的 changeset 会自动更新到所有相关联的 server 上。在 Server Provider 端，一条记录可以关联到几个 activity 或变更的版本。<\/p><p>UCM CMI 集成为 cleartool setact 增加了一个-tasks 的参数，允许用户为将要工作的 activity 指定若干具体的 task。如<\/p><div class=\"codesection\"><pre class=\"displaycode\">cleartool setact -tasks CQWAN00000001@CQPROV,CQWAN00000002@CQPROV<\/pre><\/div><p>另外，UCM CMI 集成增加了如下命令：<\/p><div class=\"codesection\"><pre class=\"displaycode\">cleartool chact -tasks {-add_task task-selector[,...] |\n                    -remove_task task-selector[,...] | -rmall}\n                    activity-selector[,...]<\/pre><\/div><p>允许用户同时增加或删除此 activity 关联的 tasks。可以同时用 -remove_task task1, -add_task task2 来替换 activity 的 task，也可以 -task -rmall 来删除所有 activity 关联的 provider 信息。如下图所示<\/p><h5 id=\"N101D7\">图 14.\n    为 activity 设定关联 provider 的多个 task<\/h5><img alt=\"为 activity 设定关联 provider 的多个 task\" src=\"/sunshine_new/images/1029467712/image028.jpg\" width=\"666\" /><p>此 activity act2 已经有了关联的 task CQWAN00000001@CQPROV，运行命令 <code>cleartool chact -tasks -add_task CQWAN00000002@CQPROV -remove_task CQWAN00000001@CQPROV act2.<\/code><\/p><p>在 CQ Provider 端，CQWAN00000001 关联的 activity 被删除了，同时此 activity 关联到了 CQWAN00000002@CQPROV 上。此例也可以看到基于 UCM 和基于 Base 的 ClearCase 集成的不同之处，基于 Base 的 CMI 集成关联的是改动的源代码版本信息，而基于 UCM 的 CMI 集成关联的是 activity 信息。<\/p><p>当这个 activity 创建成功，并且关联到 CQ Provider CQPROV 的记录 CQWAN00000001，就可以在 CQ 页面上看到所关联的变更集包含了刚才我们创建的 activity，如图所示：<\/p><h5 id=\"N101EB\">图 15. 在 CQ\n    Web 中查看指定 Record 对应的 CC 中变更信息<\/h5><img alt=\"在 CQ Web 中查看指定 Record 对应的 CC 中变更信息\" src=\"/sunshine_new/images/1029467712/image030.jpg\" width=\"619\" /><p>步骤六：删除 UCM ClearCase 与 ClearQuest 的集成信息，如下图 16,17 所示。<\/p><p>删除 activity 的操作将同时会把所有关联到此 activity 的 provider Server 的集成信息一同删掉,此操作逻辑包含了操作<\/p><div class=\"codesection\"><pre class=\"displaycode\">cleartool chact Crmall<\/pre><\/div><p>如下图所示：当操作 rmact 时，所关联的 provider server 响应时间会稍有等待，原因是 CMI 后台会联系 Provider Server 提交解关联（disassociation）操作。完成后再执行删除 ClearCase 端的 activity 的操作，最后返回删除成功信息。<\/p><h5 id=\"N10201\">图 16. 删除所创建的 activity，此操作将删除关联到 provider 的 CQ\n    Recorder<\/h5><img alt=\"删除所创建的 activity，此操作将删除关联到 provider 的 CQ Recorder\" src=\"/sunshine_new/images/1029467712/image032.jpg\" width=\"504\" /><p>如果需要删除此 provider 的相关配置，可以通过 rmprovider 命令去删除。删除时，该命令通知并需要你确认：你对此 vob 上 provider 的更改会导致和 stream（UCM）或 branch（Base）的配置不一致，需要同时手动更改在 stream 或 branch 上关于此 provider 的配置。就是说你在上级 vob 上更改的集成 provider 信息不会自动更新到相关的 stream（UCM）或 branch（Base）上，需要手动去更新，并且相关 type 和 version 的值必须准确。ClearCase 后台程序将根据你输入的值去需找相应的驱动库，从而为后面的删除操作做准备。<\/p><p>通过 rmprovider 去删除在 vob，stream，brtype 上配置的 provider 信息。如下图所示：<\/p><div class=\"codesection\"><pre class=\"displaycode\">Usage: rmprovider {-vob vob-selector | -replica replica-selector |\n-brtype brtype-selector | -stream stream-selector} provider_name<\/pre><\/div><h5 id=\"N10215\">图 17.\n    删除在 vob 和 stream 上配置的 provider 信息<\/h5><img alt=\"删除在 vob 和 stream 上配置的 provider 信息\" src=\"/sunshine_new/images/1029467712/image034.jpg\" width=\"637\" /><h2 id=\"5.使用 UCMClearCase 通过 CMI 和 RTC 集成（TBD）|outline\">使用 UCM ClearCase 通过 CMI 和 RTC 集成 （TBD）<\/h2><p>由于 RTC 本身已经支持 OSLC，因此当我们需要实现 Base ClearCase 与 RTC 集成时，只需要配置特定的针对 RTC 的 CMI Provider 即可。<\/p><p>从 V8.0.0.7 起，ClearCase 本地客户端( cleartool 和 native GUIs)支持基于 CMI 的 UCM ClearCase 与 RTC 集成。在配置集成前，ClearCase 管理员需要配置集成相关的 VOBs 和 UCM streams。步骤如下所示：<\/p><p>步骤一：安装 CLM jazz 平台并在 RTC 创建样例项目。<\/p><h5 id=\"N1022C\">图 18. RTC 样例工作项<\/h5><img alt=\"RTC 样例工作项\" src=\"/sunshine_new/images/1029467712/image036.jpg\" width=\"616\" /><p>我们创建了几个样例工作项主要有 ID 和 Summary 信息。<\/p><p>步骤二：通过\"Cleartool mkattype\"命令，为指定的 VOB 添加 CMI 所必需的 attrType 属性 CC_CMI_PROVIDERS。如图 19\n    所示：<\/p><h5 id=\"N1023C\">图 19. 为 VOB 添加 CMI 所必须的属性<\/h5><img alt=\"为 VOB 添加 CMI 所必须的属性\" src=\"/sunshine_new/images/1029467712/image037.jpg\" width=\"613\" /><p>步骤三：通过\"Cleartool mkcmprovider -vob\"命令创建对应于 RTC 的 Provider，该 Provider 用于保存当前所需要集成的 RTC 提供服务的 OSLC 地址信息 baseUrl；同时通过\"Cleartool mkcmprovider -stream\"命令为指定的 VOB 及其 stream 添加 CMI 进行查询时所需的 queryUri 相对地址，如图 20，21 所示:<\/p><p>以下范例完成在 project vob 里创需要集成的 Provider Server。下面语句在所要集成的 VOB 里创建一个名字为 RTCPROVU 的 Provider Server，并自动关联到 VOB 属性里。<\/p><h5 id=\"N1024C\">图 20.\n    为 VOB 创建连接 RTC 的 Provider<\/h5><img alt=\"为 VOB 创建连接 RTC 的 Provider\" src=\"/sunshine_new/images/1029467712/image039.jpg\" width=\"617\" /><p><code>mkcmprovider<\/code>相关参数介绍如下。<\/p><p>-<code>vob<\/code>：指定需要使用 CMI 与 CLM 集成的 vob；<\/p><p>-<code>type<\/code>：当前所创建的 CMI Provider 类型，由于是与 RTC 集成，因此值为\"cmrtc\"；<\/p><p>-<code>ver<\/code>：CMI 功能版本号，值为\"v1_0\" ；<\/p><p>-<code>desc<\/code>：当前 CMI RTC Provider 描述信息；<\/p><p>-<code>connection<\/code>：provider server 提供的 OSLC URL 地址，格式为：baseurl:http://ip:port/ccm<\/p><p>RTCPROVU 是我们所创建的 CMI Provider 的名字<\/p><p>这里的-ver 和-type 是特定的 provider 类型，CMI 需要这两个信息加载相应的驱动库，如果填写错误将导致无法找到相应的 provider 错误。 CMI 会验证 connection 地址的正确性，如果未通过验证，将报 URI 地址无法访问错误。<\/p><p>此操作必须在 Vob 里创建完 Provider 信息后，否则就会报找不到相应 Provider 的错误。<\/p><p>如果是采用 UCM 集成，需要在 stream 引用此 provider，并将 provider 与 stream 上的 activity 做关联。UCM ClearCase 与 RTC 集成独特之处在于：在 activity 上关联集成的 RTC server provider 信息后，在这个 activity 下所有的 version 更改信息就会传到 Server Provider 端。<\/p><h5 id=\"N1027D\">图 21.\n    在 Vob 里的 Stream 上引用在 Vob 里定义的 Provider 信息<\/h5><img alt=\"在 Vob 里的 Stream 上引用在 Vob 里定义的 Provider 信息\" src=\"/sunshine_new/images/1029467712/image041.jpg\" width=\"618\" /><p>Activityformat 属性定义了 activity 格式。因此在 mkact 命令创建 activity 时将默认使用此格式，自动创建 activity 名字，除非你重新指定所要创建的 activity 名字。<\/p><p>enable 属性用于确定是否启用 ClearCase 与 provider 的集成，如果不想再和这个 provider 集成，可以设置属性 enable 为 false。<\/p><p>validate 属性用于确定这个 provider 的某个 task 必须和 RTC 的 activity 有关联，就是 ClearCase vob 里的 activity 必须关联到此 provider 的某个 work item。<\/p><p>最后通过 lsprovider 命令检查在 vob 和 stream 上的 provider 配置是否正确，在配置之前也可以先 lsprovider 查看是否有人已经配置，以免重复配置。<\/p><p>如果需要更改这个 provider 的相关配置，可以在创建命令行里添加 \"-replace\"参数。具体的，请运行<code>cleartool mkcmprovider Chelp<\/code>获得相关命令使用帮助。<\/p><p>步骤四：通过\"cmiregister add\"命令创建对于 RTC 的连接属性<\/p><p>通过\" <code>cmiregister add -cq -name RTCPROVU -username UD0001 -password ec11ipse<\/code>\" 命令创建对应之前创建的 Provider 所需的 RTC 认证属性，从而记录连接 RTC 所需要的登陆信息；添加完成后，可以通过\"cmiregister list\"命令来进行查看。<\/p><h5 id=\"N1029D\">图 22. 创建并记录链接 RTC 的登录信息：<\/h5><img alt=\"创建并记录链接 RTC 的登录信息：\" src=\"/sunshine_new/images/1029467712/image043.jpg\" width=\"608\" /><p>步骤五：创建 activity，并为当前的 ClearCase 操作与 RTC work item 相关联。<\/p><p>Activity 是 ClearCase UCM 模式中的一个概念，通过变更集 (Change Set) 跟踪完成一项开发任务所引起的所有配置项的变更。在 UCM 模式下，所有的 Check Out 、 Check In 、 Add to Source Control 等引起配置项发生变化的操作必须关联到一个 Activity。下图 23,24 演示如何创建 activity 并与 RTC 的 WI 相关联。<\/p><p>用户在任何时候要向控制 vob 添加资源或修改已经处于 vob 控制之下的资源，都必须将操作与某个 UCM 活动相关联。我们在 stream 上创建 activity 的同时，可以创建此 activity 关联的 provider 的 taskid。<\/p><h5 id=\"N102AF\">图 23. 创建 Activity 并将 Activity 与 RTC work\n    item 做关联<\/h5><img alt=\"创建 Activity 并将 Activity 与 RTC work item 做关联\" src=\"/sunshine_new/images/1029467712/image045.jpg\" width=\"617\" /><p>此处 100 就是 provider RTCPROVU 的一个 work item id。此创建过程会验证 RTC server provider 和 work item id 信息的正确性，如果不存在会报错，但是 activity 仍然能创建成功，就是没有关联到相关 RTC server。<\/p><p>ACT_100_DEV_STREAM 是 ClearCase 创建的活动名称。由于没有指定 activity 名称，根据前面的设置，系统将自动创建格式为 ACT_%task-id_%stream-name 的活动。<\/p><p>上述步骤配置完毕，用户就可以通过 cleartool co/ci/mkelem 等命令实现对 ClearCase VOB 元素的各种操作。<\/p><h5 id=\"N102C1\">图 24. 检查 CC 变更与 RTC\n    Wi 工作项的关联<\/h5><img alt=\"检查 CC 变更与 RTC Wi 工作项的关联\" src=\"/sunshine_new/images/1029467712/image047.jpg\" width=\"617\" /><p>根据上面图 21 的设置，当我们创建与 WI 相关联的 activity 时，如果没有指定 activity 名称，系统将根据缺省的 activityFormat 来命名新创建的 activity。也可以将一个 activity 与多个 RTC 中的 WI 相关联。如下图 25 所示。<\/p><h5 id=\"N102CF\">图 25.\n    Activity 与多个 RTC 中多个 WI 相关联<\/h5><img alt=\"Activity 与多个 RTC 中多个 WI 相关联\" src=\"/sunshine_new/images/1029467712/image049.jpg\" width=\"618\" /><p>这样我们就完成了 UCM Clearcase 与 RTC 通过 CMI 实现集成的操作。<\/p><h2 id=\"6.结论 |outline\">结论<\/h2><p>本文介绍如何通过使用 Rational&#174; ClearCase CM 来实现 UCM ClearCase 与 ClearQuest 及 RTC 的集成。希望通过本文，能为使用 Rational&#174; ClearCase 的用户在处理和 CLM 集成需求方面有一定的参考，并对基于 CMI UCM 集成逻辑比较复杂的命令使用方法给出范例和建议，帮助用户更好地使用 CMI 功能。<\/p><CMA ID: 975576><Site ID: 10><XSLT stylesheet used to transform this file: dw-document-html-7.0.xsl>\r\n\r\n\r\n<\/div>\r\n<\/div>\r\n","createTime":"2014-06-25 00:00:00","deployTime":"2014-06-25 00:00:00","id":0,"intro":"ClearCase 和其他产品的传统集成方法是当需要和一个产品集成就做一套针对性方案，和每个产品的集成配置操作复杂而不高效，源代码中涉及很多集成产品的逻辑，这样导致扩展性不好，源代码难以维护。新的集成方案采用的是可插拔式，动态加载，通过统一的定制好的规则接口和新产品的通信，ClearCase 的源代码无需任何改动，就可以方便快捷的和第三方产品集成，而且配置，使用都很简单，这种简易的集成特性，拓展了 ClearCase 在其他领域的应用。本系列通过具体的例子详细介绍了如何通过使用 CMI 实现 UCM ClearCase 与 ClearQuest 及 RTC 的集成，展现 ClearCase 在 UCM 下强大的集成功能和易用性。","keyword":"","recommend":false,"source":"http://www.ibm.com/developerworks/cn/rational/1406_zhaoliang_ccclm1/index.html","title":"通过 CMI 实现 UCM ClearCase 和 CLM 的集成","typeId":0,"updateTime":"2014-06-25 00:00:00"}
{"author":"","clickNumber":0,"content":"\r\n<div class=\"ibm-columns\">\r\n<div class=\"ibm-col-1-1\">\r\n\r\n<h2 id=\"1.Introduction|outline\">简介<\/h2><p>在开发要安装在 IBM PureApplication System、IBM SmartCloud Orchestrator 或 IBM\n                Workload Deployer\n                上的虚拟应用程序模式工作负载时，您会遇到您的插件需要管理产品二进制文件的情形。产品二进制文件可能是您自己的，或者来自 IBM、SAP&#174; 或\n                Oracle&#174;\n                等第三方供应商。在本文中，您将看到可用于管理产品二进制文件的不同战略，了解您的插件如何访问和安装这些二进制文件。您还将了解这些不同战略的相对优势和劣势。<\/p><h2 id=\"2.Strategiestomanageproductbinaries|outline\">管理产品二进制文件的战略<\/h2><p>管理产品二进制文件的战略可分为以下几类：<\/p><ul class=\"ibm-bullet-list\"><li>使用 Storehouse 存储库<\/li><li>使用共享服务存储库服务器<\/li><\/ul><h2 id=\"3.UsingtheStorehouserepository|outline\">使用 Storehouse 存储库<\/h2><p>Storehouse 存储库包含系统工件、虚拟应用程序模式工作负载工件、虚拟应用程序模式部署运行时工件，以及虚拟应用程序模式故障排除工件。您可以使用\n                Storehouse Browser 查看存储在 Storehouse 存储库中的工件。<\/p><p>在 IBM Workload Deployer 和 IBM PureApplication System 中，您可以导航到\n                    <strong>Workload console &gt; System &gt; Storehouse Browser<\/strong>\n                来找到 Storehouse Browser。在 IBM SmartCloud Orchestrator 中，可以导航到\n                    <strong>SmartCloud Orchestrator console &gt; Administration &gt;\n                    Storehouse Browser<\/strong> 来找到 Storehouse Browser。只有拥有查看 System 菜单（或\n                Administration 菜单）的权限的用户才能查看 Storehouse Browser。图 1 展示了 Storehouse Browser\n                的典型内容。<\/p><h5 id=\"N10094\">图 1. Storehouse Browser<\/h5><img alt=\"Storehouse Browser\" src=\"/sunshine_new/images/负233051470/images/figure1.jpg\" width=\"850\" height=\"437\" /><p><a href=\"#N10098\" class=\"ibm-popup-link\" onclick=\"ibmweb.overlay.show('N10098',this);return false;\">点击查看大图<\/a><\/p><div id=\"N10098\" class=\"dw-sidefile-overlay ibm-common-overlay ibm-overlay-alt-two\"><div class=\"ibm-head\"><p><a href=\"#close\" class=\"ibm-common-overlay-close\">关闭 [x]<\/a><\/p><\/div><div class=\"ibm-body\"><div class=\"ibm-main\"><div class=\"ibm-title\"><h2>图 1. Storehouse Browser<\/h2><\/div><div class=\"ibm-container ibm-alternate\"><div class=\"ibm-container-body\"><img alt=\"Storehouse Browser\" src=\"/sunshine_new/images/负233051470/images/figure1.jpg\" width=\"1200\" /><\/div><\/div><\/div><\/div><div class=\"ibm-footer\"><><\/div><\/div><p>您可以使用 Storehouse 存储库来存储产品二进制文件。在工作负载部署期间，虚拟应用程序模式可以从 Storehouse\n                下载二进制文件，然后在虚拟机上安装和配置它们。要将产品二进制文件上传到 Storehouse，您可以采用以下技术之一：<\/p><ul class=\"ibm-bullet-list\"><li>使用 cURL 上传二进制文件。<\/li><li>使用您的模式类型上传二进制文件。<\/li><li>使用不同的二进制上传模式类型来上传二进制文件。<\/li><\/ul><p>上述每种技术各有优点和缺点。以下各节将介绍如何使用上述 3 种技术。通过将二进制文件 rhel_rpm.tgz 上传到以下 Storehouse\n                存储库位置，我们将演示上述技术：<code>/admin/files/Sample/Common/<\/code>。<\/p><h3 id=\"N100AB\">使用 cURL 上传二进制文件<\/h3><p>对于这项技术，您将使用 cURL 实用程序将一个二进制文件上传到 Storehouse 存储库，如清单 1 所示。清单 1\n                中的代码将文件上传到该位置，如图 2 所示。<\/p><h5 id=\"fig2\">图 2. Storehouse Browser 中的文件位置<\/h5><img alt=\"Storehouse Browser 中的文件位置\" src=\"/sunshine_new/images/负233051470/images/figure2.jpg\" width=\"495\" height=\"629\" /><p><a href=\"#N100B7\" class=\"ibm-popup-link\" onclick=\"ibmweb.overlay.show('N100B7',this);return false;\">点击查看大图<\/a><\/p><div id=\"N100B7\" class=\"dw-sidefile-overlay ibm-common-overlay ibm-overlay-alt-two\"><div class=\"ibm-head\"><p><a href=\"#close\" class=\"ibm-common-overlay-close\">关闭 [x]<\/a><\/p><\/div><div class=\"ibm-body\"><div class=\"ibm-main\"><div class=\"ibm-title\"><h2>图 2. Storehouse Browser 中的文件位置<\/h2><\/div><div class=\"ibm-container ibm-alternate\"><div class=\"ibm-container-body\"><img alt=\"Storehouse Browser 中的文件位置\" src=\"/sunshine_new/images/负233051470/images/figure2.jpg\" width=\"700\" /><\/div><\/div><\/div><\/div><div class=\"ibm-footer\"><><\/div><\/div><p>此技术的优点包括：<\/p><ul class=\"ibm-bullet-list\"><li>与其他两种技术相比，它相对简单一些。<\/li><li>它不需要其他任何工件或代码来上传二进制文件。<\/li><\/ul><p>此技术的限制包括：<\/p><ul class=\"ibm-bullet-list\"><li>cURL 的一些特征在上传的文件大小上是有限制的。<\/li><li>此方法可能不适合 PureApplication System。<\/li><\/ul><p>此外，您需要管理员权限才能将文件上传到存储库。<\/p><h5 id=\"listing1\">使用 cURL\n                上传产品二进制文件。<\/h5><div class=\"codesection\"><pre class=\"displaycode\">#Upload file to storehouse under /admin/files/Sample/Common.\ncurl -v -u <em>&lt;user&gt;<\/em>:<em>&lt;password&gt;<\/em> -k -X PUT --data-binary @rhel_rpm.tar.tgz -H \"Content-Type:\napplication/octet-stream\" https://<em>&lt;server_name&gt;<\/em>/storehouse/admin/files/Sample/Common/ rhel_rpm.tgz\n#Give full access to the current user and group Everyone to download the file.\ncurl -v -i -u <em>&lt;user&gt;<\/em>:<em>&lt;password&gt;<\/em> -k -X POST -H \"Content-Type: application/json\" \n-X POST -d \"{\\\"AccessRights\\\":{\\\"$USER\\\":\\\"F\\\",\\\"_group_:Everyone\\\":\\\"\nF\\\"}}\" https://<em>&lt;server_name&gt;<\/em>/storehouse/admin/files/Sample/Common/rhel_rpm.tgz?meta<\/pre><\/div><p>如果在 PureApplication System 上使用此技术，文件会上传到\n                Storehouse，但您可能无法将它下载到您的虚拟应用程序模式中，因为您无法将组访问控制（如上面第二个 curl 命令所示）设置为\n                “Everyone”。<\/p><h3 id=\"N100E6\">使用您的模式类型上传二进制文件<\/h3><p>对于此技术，您需要使用包含您的虚拟应用程序模式插件的模式类型来包装二进制文件。如果使用任何归档文件解压工具打开一个构建的模式类型，效果如图 3\n                所示。归档文件包含一个 patterntypes 文件夹（其中包含一个归档文件格式的模式类型项目）和一个 plugins\n                文件夹（其中包含一个归档文件格式的插件项目。将此模式类型安装到 Workload Deployer、PureApplication System 或\n                SmartCloud Orchestrator 中后，patterntypes 文件夹的内容存储在 Storehouse 存库中的\n                “/admin/patterntypes” 下，plugins 文件夹的内容存储在 Storehouse 存储库中的\n                “/admin/plugins” 下。<\/p><h5 id=\"N100EE\">图 3. 展开的已构建好的模式类型归档文件<\/h5><img alt=\"展开的已构建好的模式类型归档文件\" src=\"/sunshine_new/images/负233051470/images/figure3.jpg\" width=\"800\" /><p>现在您已经知道了 Storehouse 存储库的工作原理，为了将二进制文件\n                <code>rhel_rpm.tgz 放在 /admin/files/Sample/Common<\/code> 下，您需要一个名为\n                <code>files/Sample/Common<\/code> 的额外文件夹，其中包含已构建的模式类型归档文件中的文件\n                <code>rhel_rpm.tgz<\/code>，如图 4 所示。安装这种修改的模式类型时，二进制文件会存储在 Storehouse 存储库中的\n                <code>/admin/files/Sample/Common<\/code> 下，如 <a href=\"#fig2\">图 2<\/a>\n                所示。<\/p><h5 id=\"N1010A\">图 4. 包含二进制文件的扩展的已修改模式类型归档文件<\/h5><img alt=\"包含二进制文件的扩展的已修改模式类型归档文件\" src=\"/sunshine_new/images/负233051470/images/figure4.jpg\" width=\"550\" /><p>为了帮助您按图 4 所示打包二进制文件，我们在本文的 “下载” 部分提供了一个名为 <a href=\"#download\">addStorehouseFiles.xml<\/a> 的 Ant 构建文件。可在 IBM Workload Deployer\n                Eclipse PDK 环境中运行这个实用程序。要使用此实用程序，可打开您的 IBM Workload Deployer Eclipse PDK\n                环境，并将此 Ant 文件放在您的模式类型项目下，如图 5 所示。您还应该创建一个名为\n                    <strong>storehouse/files<\/strong> 的文件夹，如图 5 所示。子文件夹文件对应于图 4 中显示的 files\n                文件夹。<\/p><p>在使用 <strong>IBM Pattern toolkit &gt; build<\/strong> 构建模式类型后，右键单击\n                    <strong>addStorehouseFiles.xml<\/strong> 并选择 <strong>Run As &gt; Ant\n                    Build<\/strong>。Ant 脚本会解压归档文件\n                <code>/patterntype_project/export/built_pattern_type_version.tgz<\/code>，该文件是在模式构建步骤中创建的。它将该文件夹重新压缩到\n                <code>/patterntype_project/storehouse<\/code> 下。在使用示例 Ant 脚本之前，编辑\n                    <strong>addStorehouseFiles.xml<\/strong> 并更改 patternTypeFile\n                属性的值，以反映您的模式类型名称和版本。<\/p><h5 id=\"N10131\">图 5. 包含 addStorehouseFiles.xml 实用程序的模式类型 PDK\n                    项目<\/h5><img alt=\"包含 addStorehouseFiles.xml 实用程序的模式类型 PDK 项目\" src=\"/sunshine_new/images/负233051470/images/figure5.jpg\" width=\"708\" height=\"246\" /><p><a href=\"#N10135\" class=\"ibm-popup-link\" onclick=\"ibmweb.overlay.show('N10135',this);return false;\">点击查看大图<\/a><\/p><div id=\"N10135\" class=\"dw-sidefile-overlay ibm-common-overlay ibm-overlay-alt-two\"><div class=\"ibm-head\"><p><a href=\"#close\" class=\"ibm-common-overlay-close\">关闭 [x]<\/a><\/p><\/div><div class=\"ibm-body\"><div class=\"ibm-main\"><div class=\"ibm-title\"><h2>图 5. 包含 addStorehouseFiles.xml 实用程序的模式类型 PDK\n                    项目<\/h2><\/div><div class=\"ibm-container ibm-alternate\"><div class=\"ibm-container-body\"><img alt=\"包含 addStorehouseFiles.xml 实用程序的模式类型 PDK 项目\" src=\"/sunshine_new/images/负233051470/images/figure5.jpg\" width=\"1000\" /><\/div><\/div><\/div><\/div><div class=\"ibm-footer\"><><\/div><\/div><p>使用此技术的优点包括：<\/p><ul class=\"ibm-bullet-list\"><li>您可上传您想要的任意大小的文件。如果使用工作负载控制台用户界面安装该模式，您拥有 2GB 的限制。对于大于 2 GB 的大小，可使用工作负载\n                    CLI 环境。<\/li><li>您可以将二进制文件和相关插件打包并作为单个实体进行传送。<\/li><\/ul><p>如果使用此技术，在从系统删除模式类型时，会从 Storehouse 存储库删除二进制文件。这会导致以下限制：<\/p><ul class=\"ibm-bullet-list\"><li>如果二进制文件非常大，那么每次更新模式类型的功能元素时都会花很多时间和网络资源。<\/li><li>如果希望跨模式类型共享同某个二进制文件，则必须保留用来将二进制文件上传到系统中的模式类型，即使您不需要它。<\/li><\/ul><p>您需要获得管理员权限才能上传模式类型。要使用此技术，您必须是管理员组的成员。<\/p><h3 id=\"N1014A\">使用不同的二进制上传模式类型来上传二进制文件<\/h3><p>为了解决上述限制，可将二进制文件与包含虚拟应用程序模式的功能性工件的模式类型分离。使用此技术，无需让一种模式类型同时包含二进制文件和虚拟应用程序模式插件，您会有两种模式类型。第一种模式类型仅包含二进制文件，第二种模式类型包含您的虚拟应用程序模式插件。您将按照创建上一节中的模式类型的方式创建该模式类型。惟一的不同是，此模式类型没有任何虚拟应用程序模式插件。图\n                6 演示了一个仅包含示例二进制文件的模式类型。将二进制文件与虚拟应用程序模式插件分离后，可与功能性工件独立地管理二进制文件。<\/p><h5 id=\"N10152\">图 6. 展开的仅包含二进制文件的模式类型<\/h5><img alt=\"展开的仅包含二进制文件的模式类型\" src=\"/sunshine_new/images/负233051470/images/figure6.jpg\" width=\"750\" /><p>使用此技术的优点包括：<\/p><ul class=\"ibm-bullet-list\"><li>可跨模式类型共享二进制文件。<\/li><li>可彼此独立地更新和管理二进制文件和模式的功能性方面。<\/li><\/ul><p>您仍然需要获得管理员权限才能上传模式类型。要使用此技术，您必须是管理员组的成员。<\/p><h2 id=\"4.DownloadingbinaryfilesfromtheStorehouserepository|outline\">从 Storehouse 存储库下载二进制文件<\/h2><p>现在您已经将二进制文件上传到 Storehouse 存储库，我们看看如何将这些文件下载到虚拟应用程序模式实例所创建的\n                VM。您可以使用部件生命周期脚本中的虚拟应用程序模式 maestro 框架从 Storehouse 存储库下载文件。有关虚拟应用程序模式\n                maestro 框架和部件生命周期脚本的详细信息，请参阅本文的 <a href=\"#resources\">参考资料<\/a> 部分。<\/p><p>清单 2 演示了如何从 Storehouse 存储库下载二进制文件。在调用 maestro.filesurl 后，会以 HTTP URL 格式返回\n                <code>/admin/files<\/code> 的位置。然后您可以将文件位置附加到这个 URL，使用 maestro.downloadx\n                方法下载该文件并将它提取到您想要的位置。将文件下载到虚拟应用程序模式虚拟机后，就可以开始安装和配置二进制文件。<\/p><h5 id=\"listing2\">清单 2. 从 Storehouse\n                存储库下载文件<\/h5><div class=\"codesection\"><pre class=\"displaycode\">def downloadBinaries():\n\tlogger.debug(\"enter downloadBinaries\")\n\tfileName = 'Sample/Common/rhel_rpm.tgz'\n\tinstallerUrl = urlparse.urljoin(maestro.filesurl, fileName)   \n\tdownloadPath = '/home/virtuser'    \n\tlogger.debug('download ' + installerUrl)\n\tmaestro.downloadx(installerUrl, downloadPath)\n\tlogger.debug(\"exit downloadBinaries\")<\/pre><\/div><p>在本文中，我们提供了 <a href=\"#download\">示例代码<\/a> 来展示如何创建一个仅包含二进制文件的模式类型\n                (patterntype.binaryonly)，以及如何创建一个同时包含二进制文件和功能性插件（patterntype.storehouseupload\n                和 plugin.storehouseupload）的模式类型。<\/p><h2 id=\"5.Usingthesharedservicerepositoryserver|outline\">使用共享服务存储库服务器<\/h2><p>共享服务是预定义的虚拟应用程序模式，可由同一个云组中的多个工作负载部署共享，这些工作负载包括虚拟应用程序、虚拟系统和虚拟设备。每个云组仅允许共享服务的一个实例。有关共享服务和如何开发共享服务的更多细节，请参阅\n                    <a href=\"#resources\">参考资料<\/a> 部分。<\/p><p>您可以创建一个可托管您的工作负载需要的二进制文件的共享服务存储库服务器。共享服务存储库服务器可公开一些必要的接口，以便需要二进制文件的虚拟应用程序模式工作负载能够使用公开的接口连接到存储库服务器，并下载合适的文件。<\/p><p>在本文中，我们提供了一个 <a href=\"#download\">示例共享服务存储库服务器<\/a>（用作一个 NFS\n                服务器）和一个虚拟应用程序模式工作负载客户端（使用 NFS\n                挂载下载二进制文件）。在部署时，为共享服务存储库服务器分配了存储二进制文件所需的磁盘大小。共享服务存储库服务器还提供了一个部署后操作，可用于使用\n                HTTP 协议从外部系统上传必要的二进制文件。图 7 演示了这个部署后操作的视图。<\/p><h5 id=\"N10194\">图 7. 共享服务器操作的视图<\/h5><img alt=\"共享服务器操作的视图\" src=\"/sunshine_new/images/负233051470/images/figure7.jpg\" width=\"708\" height=\"282\" /><p><a href=\"#N10198\" class=\"ibm-popup-link\" onclick=\"ibmweb.overlay.show('N10198',this);return false;\">点击查看大图<\/a><\/p><div id=\"N10198\" class=\"dw-sidefile-overlay ibm-common-overlay ibm-overlay-alt-two\"><div class=\"ibm-head\"><p><a href=\"#close\" class=\"ibm-common-overlay-close\">关闭 [x]<\/a><\/p><\/div><div class=\"ibm-body\"><div class=\"ibm-main\"><div class=\"ibm-title\"><h2>图 7. 共享服务器操作的视图<\/h2><\/div><div class=\"ibm-container ibm-alternate\"><div class=\"ibm-container-body\"><img alt=\"共享服务器操作的视图\" src=\"/sunshine_new/images/负233051470/images/figure7.jpg\" width=\"1000\" /><\/div><\/div><\/div><\/div><div class=\"ibm-footer\"><><\/div><\/div><p>Workload Deployer、PureApplication System 和 SmartCloud Orchestrator\n                共享服务基础架构提供了一个注册表，其中包含已部署的共享服务的信息。客户端可在这个注册表中查询它想要使用的共享服务的信息。在示例中，存储库服务器通过此注册表向客户端公开它的主机名和\n                NFS 挂载端点。清单 3 演示了如何使用 RegistryProvider\n                接口向共享服务注册表提供信息。共享服务存储库服务器中一个有趣的存储库客户端，然后可在它的生命周期脚本中使用 maesro.registry\n                框架，从注册表获取共享服务服务器主机名和 NFS 端点，从 NFS 端点复制必要的二进制文件。清单 4\n                演示了存储库客户端如何从服务器公开的注册表获得详细信息。<\/p><h5 id=\"listing3\">清单 3.\n                    向注册表提供共享服务存储库服务器信息的代码<\/h5><div class=\"codesection\"><pre class=\"displaycode\">public class SampleSharedServiceRegistryProvider implements RegistryProvider {\n  private static final String CLASS_NAME =\n   SampleSharedServiceRegistryProvider.class.getCanonicalName();\n  private static Logger logger = Logger.getLogger(CLASS_NAME);\n  public final String LOCAL_BINARIES_REPOS_PATH=\"/shared_repository\";\n  public JSONArtifact getRegistry(String clientVersion,\n    Map&lt;String, JSONObject&gt; deploymentInfo) throws HttpException {\n    String METHOD = \"getRegistry\";\n    JSONObject registry = new JSONObject();\n    JSONObject deploymentDoc = deploymentInfo.get\n        (RegistryProviderConstants.DEPLOYMENT_DOC);\n    logger.logp(Level.FINE, CLASS_NAME, METHOD, \"enter getRegistry \");\n    //get instance ip addresses and return in the registry\n    if(deploymentDoc != null){\n      JSONObject instances = (JSONObject) deploymentDoc.get(\"instances\");\n      if (null != instances) {\n\tfor (Object key : instances.keySet()) {\n\t String keystr = (String)key;\n\t if(keystr.startsWith(\"SampleSharedService\")){\n           <strong>Object ipAddr = ((JSONObject) instances.get(key)).get(\"public-ip\");\n                       String ip = (String)ipAddr;\n                       registry.put(\"serviceHost\", ip);<\/strong>\n\t }\n        }\n      }\n     }\n     <strong>registry.put(\"mountPoint\", LOCAL_BINARIES_REPOS_PATH);<\/strong>\n     logger.logp(Level.FINE, CLASS_NAME, METHOD,\n         \"getRegistry exit. Registry return=\"+registry);\n     return registry;\n  }\n}<\/pre><\/div><h5 id=\"listing4\">清单 4.\n                    从注册表检索共享服务存储库服务器信息的客户端代码<\/h5><div class=\"codesection\"><pre class=\"displaycode\"># Retrieve info on SharedService (IP) so we know where to go\nregInfo = maestro.registry.getRegistry(<em>\"sampleMediaService\"<\/em>, <em>\"1.0\"<\/em>)\nserviceHost = regInfo[<em>'serviceHost'<\/em>]\nmountPoint = regInfo[<em>'mountPoint'<\/em>]<\/pre><\/div><p>此方法的优点在于，如果不希望通过 Storehouse\n                共享二进制文件，那么您可以拥有自己的二进制存储库服务器。因为我们使用了共享服务注册表作为查找目录，所以要求二进制文件的客户端与提供二进制文件的服务器之间的交互是松散耦合的。<\/p><p>使用共享服务存储库服务器的主要限制是，您只能为每个云组下载一种类型的共享服务。因此，云组中的所有部署必须共享同一个存储库服务器。此外，还有共享服务服务器开发和部署的其他开销。要安装和部署共享服务服务器，您需要获得管理员权限。<\/p><h2 id=\"6.Workingwiththesamples|outline\">用例<\/h2><p>以下 <a href=\"#download\">示例模式类型<\/a>（包含源代码）可用于本文：<\/p><ul class=\"ibm-bullet-list\"><li>patterntype.binaryonly-1.0.0.0.tgz<\/li><li>patterntype.storehouseupload-1.0.0.0.tgz<\/li><li>ptype.installsharedservice-1.0.0.0.tgz<\/li><\/ul><h3 id=\"N101D3\">使用 Storehouse 存储库的示例<\/h3><p>安装 <strong>patterntype.binaryonly-1.0.0.0.tgz <\/strong> 或\n                    <strong>patterntype.storehouseupload-1.0.0.0.tgz<\/strong> 时，您会看到一个名为\n                “/admin/files/Sample/Common/ rhel_rpm.tgz” 的文件被添加到 Storehouse 中，如 <a href=\"#fig2\">图 2<\/a> 所示。<\/p><p>除此之外，通过使用\n                <strong>patterntype.storehouseupload-1.0.0.0.tgz<\/strong>，您可以创建一个示例虚拟应用程序模式，如图\n                8 所示。部署此虚拟应用程序模式时，它会将上传到 Storehouse 中的文件下载并解压到虚拟机上的\n                    <strong>/home/virtuser/binaries<\/strong> 中。虚拟应用程序模式使用了 <a href=\"#listing2\">清单 2<\/a> 中所示的代码来下载该文件。<\/p><h3 id=\"N101F0\">上传大型二进制文件的技巧<\/h3><p>如果使用 Workload 控制台或 SmartCloud Orchestrator 控制台用户界面来安装模式类型，那么您将<em>无法<\/em>\n                安装大于 2 GB 的模式类型。无法使用控制台浏览器接口将大型二进制文件导入 Storehouse 中。要克服此限制，需要使用 CLI API\n                安装模式类型。您可以执行以下步骤来从命令行安装模式类型：<\/p><ol type=\"1\"><li>打开一个命令提示符，并更改到模式类型归档文件所在的目录。<\/li><li>从 IBM Workload Deployer、IBM PureApplication System 或 IBM SmartCloud\n                    Orchestrator 系统下载 <strong>CLI 压缩文件<\/strong>。然后将它解压到\n                        <strong>/pathToCli<\/strong> 下。<\/li><\/ol><p>从命令行运行以下命令，具体情况取决于您的 IBM 云解决方案：<\/p><div class=\"codesection\"><pre class=\"displaycode\">/pathToCli/pure.cli/bin/pure -h IPAS_IP -u &lt;user&gt; -p &lt;pwd&gt;<\/pre><\/div><p>或者<\/p><div class=\"codesection\"><pre class=\"displaycode\">/pathToCli/deployer.cli/bin/deployer -h IPAS_IP -u &lt;user&gt; -p &lt;pwd&gt;<\/pre><\/div><p>返回到 CLI 提示符后，运行以下命令： <\/p><div class=\"codesection\"><pre class=\"displaycode\">deployer.patterntypes.create('YourPatternType-1.0.0.0.tgz')<\/pre><\/div><h5 id=\"N10216\">图 8. 使用 patterntype.storehouseupload\n                    创建的虚拟应用程序<\/h5><img alt=\"使用 patterntype.storehouseupload 创建的虚拟应用程序\" src=\"/sunshine_new/images/负233051470/images/figure8.jpg\" width=\"850\" height=\"613\" /><p><a href=\"#N1021A\" class=\"ibm-popup-link\" onclick=\"ibmweb.overlay.show('N1021A',this);return false;\">点击查看大图<\/a><\/p><div id=\"N1021A\" class=\"dw-sidefile-overlay ibm-common-overlay ibm-overlay-alt-two\"><div class=\"ibm-head\"><p><a href=\"#close\" class=\"ibm-common-overlay-close\">关闭 [x]<\/a><\/p><\/div><div class=\"ibm-body\"><div class=\"ibm-main\"><div class=\"ibm-title\"><h2>图 8. 使用 patterntype.storehouseupload\n                    创建的虚拟应用程序<\/h2><\/div><div class=\"ibm-container ibm-alternate\"><div class=\"ibm-container-body\"><img alt=\"使用 patterntype.storehouseupload 创建的虚拟应用程序\" src=\"/sunshine_new/images/负233051470/images/figure8.jpg\" width=\"1200\" /><\/div><\/div><\/div><\/div><div class=\"ibm-footer\"><><\/div><\/div><h3 id=\"N1021F\">使用共享服务存储库模式类型的示例<\/h3><p>安装和启用模式类型 <strong>ptype.installsharedservice-1.0.0.0.tgz<\/strong>\n                后，部署共享服务，使用为您的二进制存储库提供的磁盘大小作为输入。部署共享服务后，必须使用 Virtual Application Console\n                中提供的部署后操作，在共享服务存储库中填充二进制文件。为此，共享服务运行后，选择运行的共享服务实例并单击\n                    <strong>Manage<\/strong> 按钮。Virtual Application Console 将会打开。在 Virtual\n                Application Console 中选择 <strong> Operations &gt; Media\n                Service<\/strong>。您会看到如图 7 所示的两个可用操作。使用第二个操作 <strong>Import file via\n                    HTTP<\/strong> 来填充二进制存储库。如果有多个文件，那么可以运行此操作多次。<\/p><p>要测试共享服务存储库，可根据模式类型 <strong>sample.installsharedservice 1.0<\/strong>\n                来创建和部署一个虚拟应用程序模式，如图 9 所示。上一节已经介绍过，虚拟应用程序模式从注册表获取以下共享服务存储库细节、共享服务存储库 IP 和\n                NFS 挂载点（参见 <a href=\"#listing4\">清单 4<\/a> 中的代码）。客户端可使用此代码挂载端点和下载二进制文件。<\/p><h5 id=\"N1023C\">图 9. 使用 sample.installsharedservice\n                    创建的虚拟应用程序<\/h5><img alt=\"使用 sample.installsharedservice 创建的虚拟应用程序\" src=\"/sunshine_new/images/负233051470/images/figure9.jpg\" width=\"850\" height=\"617\" /><p><a href=\"#N10240\" class=\"ibm-popup-link\" onclick=\"ibmweb.overlay.show('N10240',this);return false;\">点击查看大图<\/a><\/p><div id=\"N10240\" class=\"dw-sidefile-overlay ibm-common-overlay ibm-overlay-alt-two\"><div class=\"ibm-head\"><p><a href=\"#close\" class=\"ibm-common-overlay-close\">关闭 [x]<\/a><\/p><\/div><div class=\"ibm-body\"><div class=\"ibm-main\"><div class=\"ibm-title\"><h2>图 9. 使用 sample.installsharedservice\n                    创建的虚拟应用程序<\/h2><\/div><div class=\"ibm-container ibm-alternate\"><div class=\"ibm-container-body\"><img alt=\"使用 sample.installsharedservice 创建的虚拟应用程序\" src=\"/sunshine_new/images/负233051470/images/figure9.jpg\" width=\"1200\" /><\/div><\/div><\/div><\/div><div class=\"ibm-footer\"><><\/div><\/div><h2 id=\"7.Conclusion|outline\">结束语<\/h2><p>在本文中，您了解了各种管理要在您的虚拟应用程序模式工作负载中使用的二进制文件的技术。您还了解了这些技术的相对优点和限制。基于这些优点和限制，管理二进制文件的最佳选择是使用\n                Storehouse 存储库。将二进制文件上传到 Storehouse 存储库的最佳技术是使用一种仅包含二进制文件的专门的模式类型。<\/p><h3 id=\"N1024C\">致谢<\/h3><p>感谢 IBM 的 <strong>Jim Riordan <\/strong> 帮助完成共享服务存储库技术的概念。<\/p><CMA ID: 975183><Site ID: 10><XSLT stylesheet used to transform this file: dw-document-html-7.0.xsl>\r\n<h2 id=\"download\">下载<\/h2><table class=\"ibm-data-table&#10;                    dw-download-table\" cellpadding=\"0\" cellspacing=\"0\" border=\"0\"><thead><tr><th scope=\"col\">描述<\/th><th scope=\"col\">名字<\/th><th scope=\"col\">大小<\/th><\/tr><\/thead><tbody><tr><th scope=\"row\" class=\"ibm-table-row\">代码样例<\/th><td nowrap=\"nowrap\"><a href=\"http://www.ibm.com/developerworks/apps/download/index.jsp?contentid=975183&amp;filename=code_sample.zip&amp;method=http&amp;locale=zh_CN\">code_sample.zip<\/a><\/td><td nowrap=\"nowrap\">76KB<\/td><\/tr><\/tbody><\/table>\r\n\r\n<\/div>\r\n<\/div>\r\n","createTime":"2014-06-23 00:00:00","deployTime":"2014-06-23 00:00:00","id":0,"intro":"虚拟应用程序模式是 IBM? PureApplication? System、IBM SmartCloud? Orchestrator 和 IBM Workload Deployer 中使用的一种云工作负载部署模型。在开发虚拟应用程序模式插件期间，您会遇到需要管理和安装产品二进制文件的情形。在本文中，您将了解各种管理产品二进制文件的技术。","keyword":"","recommend":false,"source":"http://www.ibm.com/developerworks/cn/cloud/library/cl-ps-aim1401-binariespureapp/index.html","title":"在虚拟应用程序模式工作负载中管理产品二进制文件","typeId":0,"updateTime":"2014-06-23 00:00:00"}
{"author":"","clickNumber":0,"content":"\r\n<div class=\"ibm-columns\">\r\n<div class=\"ibm-col-1-1\">\r\n\r\n<a id=\"OLE_LINK17\"><\/a><h2 id=\"1.背景介绍 |outline\">背景介绍<\/h2><p>前面文章具体介绍了如何使用 Base Clear Case，UCM Clear Case 和 RTC、CQ 等 Rationa CLM 产品通过 CMI 来集成，但这些集成操作都是按照最佳实践并面向单个文件的集成，其实每一步此操作都和其他操作相关联，并且和其他元素的集成信息相关联，这里有着复杂的业务逻辑关系，CMI 的后台也执行了多次的验证来确定此操作满足 CMI 的集成规则。这些规则一部分继承了传统集成方案的业务规则，同时又为了以后扩展到其他产品的集成而新建了一些规则。它们都是通过每个需要集成的 Provider（定义请参考上篇）的各自配置属性，和这些 Provider 如何配置在 Clear Case 端的在开发分支，Vob 库及流上共同来约束集成的操作。对这些规则以及配置方法的数量掌握有利于再出现操作错误时及时更改，保持 Clear Case 端和集成的 Provider Server 的数据一致性。<\/p><h2 id=\"1.Base/UCMClearCaseCMI 集成规则原理 |outline\">Base/UCM Clear Case CMI 集成规则原理<\/h2><p>    软件的开发管理有一套成熟的规则流程，对于软件的集成，在总结和集成产品的特点和最佳实践时也有一套集成规则，对于这些规则每个 CMI 使用者都应该详细了解，并能熟练使用，由于产生了新的 CMI 集成功能，又用的新的方法来实现规则约束，所以就需要在此详细介绍 CMI 的那些属性和配置决定了哪些功能和规则，新 CMI 的规则依据配置信息的具体属性来约束不同的集成操作，并且定义了操作出错后如何处理，回滚和提示信息，如何根据提示信息处理自己的误操作，这些集成规则贯穿于使用 CMI 的集成功能呢的整个生命周期。<\/p><p>本篇文章并没有详细叙述 CMI 的集成方法，而是着重于集成操作规则，通过具体例子来详细介绍使用 CMI 集成所要遵循的规则，以及出错的处理。<\/p><h2 id=\"1.准备工作 |outline\">准备工作<\/h2><p>    在进行例子之前，我们需要安装一些 Rational 的软件，包括 Clear Case 8.0.0.8 以上版本，同时需要已经配置好的 ClearQuest 服务器以及 RTC 服务器，并创建样例数据。在我们引入的例子中，我们使用了的版本如下：<\/p><p><strong>Rational Clear Case<\/strong><strong>以及 ClearQuest 8.0.0.9<\/strong>版本<\/p><p><strong>Rational Jazz Team Server Version: 4.0.4 M1<\/strong>版本<\/p><p><strong>规则 1：<\/strong>对于 Clear Case 7.0 版本默认是不开启 CMI 功能的，而对于 Clear Case 8.0 及以上是默认开启 CMI 功能<\/p><p>对于 Clear Case 7.0 如果要使用新的 CMI 功能，在 windows 操作系统下就需要 Clear Case 的安装目录 CC_Home\\Clear Case\\config 下新建 cmi 文件夹，然后创建文件 cmi.conf 并添加文本：<\/p><p>                             cmiEnabled=true<\/p><p>Windows 下默认的路径是：C:\\Program Files\\IBM\\RationalSDLC\\Clear Case\\config<\/p><p>Linux 下默认路径是：         /opt/ibm/RationalSDLC/Clear Case/config<\/p><p>CMI 功能的开启与关闭采用插拔方式，可以及时通过重置 cmiEnabled 属性来开关，由于 Clear Case 8.0 是默认开启的，如果要关闭需要在上述路径上是\n    cmiEnabled=false。另一种方式是设置所要集成的 Provider（所要集成的产品 Server）的 enable 属性为\n    false，后面会详细描述，不过第二种方式只针对单个集成的 Provider，如果要全部关掉，建议第一种方式，看的出来新的 CMI 功能的开启关闭很灵活，通过命令行更方便。<\/p><p><strong>规则 2<\/strong><strong>：<\/strong>RTC 的一个工作项或 CQ 的一个缺陷只能和 Clear Case 的一个 Activity 活动关联，如果一个 Activity 已经关联此工作项或缺陷，其他 Activity 将无法再关联此工作项或缺陷<strong>。<\/strong><\/p><h5 id=\"N10092\">图 1. 在另一个活动上关联同一个 Task<\/h5><img alt=\"在另一个活动上关联同一个 Task\" src=\"/sunshine_new/images/负1153016377/image003.jpg\" width=\"643\" /><a id=\"OLE_LINK2\"><\/a><a id=\"OLE_LINK1\"><\/a><p>如图 1 所示，lzhao_act2 已经关联这个缺陷CQWAN00000002@CQPROV，如果用 cleartool chact 命令使另外一个活动 lzhao_act1 关联此缺陷将会报错。这说明如果我们修正一个缺陷或完成一个工作项，在 UCM Clear Case 有且仅有一个活动（Activity）和此相关。<\/p><p><strong>规则 3：<\/strong>当使用 Base Clear Case 的集成，如果您在工作的分支上包含了所要集成的 Provider 信息，意味着您在此分支下创建的新的文件版本都必须关联到此 Provider 的一条记录，对于 RTC 就是新的版本必须关联到 RTC 的一个工作项，而对于 CQ，新的版本必须关联到 CQ 的一个缺陷，如图 2 所示：<\/p><p>我们工作的分支 main 上包含了两个 Provider 信息\"rtcprovider\"和\"CQPROV\"，而我们更改的文件 2.c 仅含有关联到 RTC Provider 的工作项 22，当我们修改完此文件要做 check in 操作时，CMI 会检测您在此分支上创建的 Provider 是否都有至少一条信息关联到此文件的新版本，如果没有将提示错误信息。为了解决这个错误，要么不做 CQPROV 的集成即在 Branch 中删除此 Provider 信息，要么在这个更改的文件使用命令来添加一个关联工作项:<\/p><div class=\"codesection\"><pre class=\"displaycode\">    Cleartool chtask -add_task CQWAN00000002@CQPROV 2.c<\/pre><\/div><p>使 2.c 关联到了所有在 Branch 上已有的 Provider 的记录，然后 check in 操作会成功，并且新的 2.c 的版本将在所有关联的 Provider 的页面中显示出来。<\/p><h5 id=\"N100B4\">图 2. Check in\n    验证版本的 Provider 信息<\/h5><img alt=\"Check in 验证版本的 Provider 信息\" src=\"/sunshine_new/images/负1153016377/image005.jpg\" width=\"693\" /><p><strong>规则 4<\/strong>：如果 Clear Case 端工作的流上已经有了集成的 Provider 信息并且 enable 和 validate 都为 true，当我们创建活动时必须有参数-tasks 来设定此活动和流上哪一个 Provider 关联，如果没设置就会报错，如下图所示：在创建活动 lzhao_act2 时由于没有用-tasks 设置关联属性将会提示此活动没有关联 Provider，但此活动仍然被创建。<\/p><h5 id=\"N100C4\">图 3. 活动 Activity 需要关联 Task<\/h5><img alt=\"活动 Activity 需要关联 Task\" src=\"/sunshine_new/images/负1153016377/image007.jpg\" width=\"696\" /><p><strong>规则 5：<\/strong>用 cleartool mkact 创建带有多个 Provider 的关联关系的活动时，如果其中某个 Provider 配置错误无法创建，CMI 将报告此 Provider 错误，其他通过逻辑检查的关联将创建成功，同时活动的创建也成功。<\/p><h5 id=\"N100D4\">图 4.\n    活动 Activity 更改 Task 操作支持多任务<\/h5><img alt=\"活动 Activity 更改 Task 操作支持多任务\" src=\"/sunshine_new/images/负1153016377/image009.jpg\" width=\"660\" /><p>如上所示，我们创建一个活动同时关联 Provider CQPROV 的两个缺陷 CQWAN00000006@CQPROV 和 CQWAN000000099@CQPROV，而后一个缺陷在 Provider 不存在，或者没创建或者已经关闭，CMI 就会提示这个关联无法创建成功，但是活动仍被创建并且关联到了那个已有的缺陷。<\/p><p><strong>规则 6：<\/strong>如果 provider 的 enable 设置为 true，mkact Ctasks 中的 provider 信息是正确的，activity 会被创建然后也会关联，如果 tasks 的 provider 验证未通过如 enable=false，或 provider 的 url 地址验证无效，或者 provider 里不存在此缺陷，则无法创建集成关联关系，但 activity 仍会被创建，只是没有属性\"CMI Associated tasks\"。如果此属性的值为空，CMI 不会显示这个活动上的属性，即您用 cleartool lsactivity 命令将无法得到这个属性值。<\/p><h5 id=\"N100E6\">图 5.\n    创建无法关联 Provider 信息的活动<\/h5><img alt=\"创建无法关联 Provider 信息的活动\" src=\"/sunshine_new/images/负1153016377/image011.jpg\" width=\"652\" /><p>如上图所示，关联的 provider PROV3 并没有在 stream 和 vob 里配置，所以 CMI 找不到此 provider 信息，即使 provider 信息找到了，如果 provider 的 OSLC URL 配置不正确也会报错，但我们发现 CMI 仍提示 activity lzhao_act4 被创建。只是 CMI_Associated_Tasks 属性值为空，并提示没有和 Provider 关联成功，在此 activity 上做的任何操作也不会显示在 CQ Provider 的缺陷中。<\/p><p>设想另外一种场景，如果用户不想和此 provider 在做集成操作，我们可以用-replace -enable false 来\"关掉\"stream 上配置的 provider 信息，即关闭在此 provider 的 CMI 集成功能，再尝试在新创建的 activity 上并关联此 provider，由于此 provider 没有被激活(enable = false)但此 activity 仍然被创建，即使 Provider 配置信息都是正确的但结果仍然和上面一样，没有关联到 provider。<\/p><p><strong>规则 7：<\/strong>如果某个 Provider 的 validate 是 true，就说明某个 activity 必须包含一个关于此 Provider 的一个缺陷，否则 Clear Case 操作命令会报错无法执行。<\/p><h5 id=\"N100FA\">图 6.\n    活动 Activity 上删除唯一的关联 Task<\/h5><img alt=\"活动 Activity 上删除唯一的关联 Task\" src=\"/sunshine_new/images/负1153016377/image013.jpg\" width=\"664\" /><p>如图所示，我们在用 cleartool chact -tasks -remove_task 去删除关联的信息将会报错，告诉此 activity 必须关联一个此 Provider 含有的一个缺陷。属性 validate 可以更好的理解为需要工作的活动 actvity 必须关联此缺陷。这就保证了在 Provider CQ 端肯定能找到关于修正此缺陷所进行的活动及进展。<\/p><p><strong>规则 8：<\/strong>当 provider 的 enable=false 意味着用户不想使用和这个 provider 的集成，则 validate 属性将不再起作用，那么关于这个 provider 的任何集成操作将报错。只有在 enable 为 true 时，validate 的属性设置才有效。如果 validate 为 false 则说明在 CQ Provider 里的缺陷不必在 Clear Case 端找到相应的活动。所以当我们把 enable 为 true 而 validate 为 false 时，就可以删除关联到此活动的 Provider 信息。如下图所示，此 activity 关联了 Task CQWAN00000002@CQPROV，通过 lsprovider 发现此 Provider 配置属性 enable 为 true，validate 为 false，意味着可以删除此 Task，随后运行 chact 删掉此 task 成功，同时因为 enable 为 true，CQ Provider 端关联的 Clear Case 的信息也会被删除。<\/p><h5 id=\"N1010C\">图 7. 配置属性决定操作规则<\/h5><img alt=\"配置属性决定操作规则\" src=\"/sunshine_new/images/负1153016377/image015.jpg\" width=\"693\" /><p><strong>规则 9：<\/strong>对于 chact -tasks -remove_task 命令，当此 activity 关联多个 provider 时, 如果其中某些 provider 的属性 enable 为 true 并且 validate 也为 true 意味着这个 provider 在这个 activity 上不能被删除，用户会得到此 provider 必须在 activity 上存在关联关系的警告。对于一个 activity 关联多个 provider 情况，如果其中某些 provider 的属性配置允许让这个 provider 被删除，那么 CMI 的 chact -tasks -remove_tasks -add_tasks 功能支持兼容性操作，即在一次操作命令中能删除的就删除成功，不能删除将提示具体错误信息。如下图所示：<\/p><p>我们使用了两个 Server 作为集成的 Provider，其中 CQPROV 的 validate 属性为 false，而 rtcprovider 为 true，它们的 enable 都为 true，说明都开启了集成功能。然后我们创建了一个活动包含这两个关联信息，其中 CQPROV 关联到其缺陷 CQWAN00000002 而 rtcprovider 关联到其工作项 4432.当我们尝试删除这个活动的所有关联信息时。由于 rtcprovider 的 validate 属性为真，说明这个活动必须关联此 Provider 的一个工作项，而另一个 CQPROV 的 validate 属性为假，所以可以删除关于此 Provider 的缺陷，从结果得知，CMI 提示了错误信息并且删除了 CQPROV 的缺陷关联。<\/p><h5 id=\"N1011F\">图 8.\n    在活动 Activity 上删除关联的 Task<\/h5><img alt=\"在活动 Activity 上删除关联的 Task\" src=\"/sunshine_new/images/负1153016377/image017.jpg\" width=\"682\" /><p>由于 enable 都是真，两个 Provider Server 端关联 Clear Case 的活动信息也会对应更新。由于 rtcprovider 的关联没有被删除，所以如下图所示 rtcprovider 仍保留这关于此活动的关联信息。<\/p><h5 id=\"N1012D\">图 9. RTC 里验证关联的活动<\/h5><img alt=\"RTC 里验证关联的活动\" src=\"/sunshine_new/images/负1153016377/image019.jpg\" width=\"520\" /><p><strong>规则 10：<\/strong>如果 provider 的属性 enable=true，validate=false，那么 rmprovider 可以删除 Clear Case 的集成属性，并且运行 disassociation 去关联操作，在 provider 端删除代码关联信息并显示命令成功。如果 enable 和 validate 都是 false，rmprovider 将只更新 Clear Case 的集成信息，cq/rtc 的 provider 信息会需要更新，显示命令成功。<\/p><h5 id=\"N1013D\">图 10. 运行删除操作前的属性<\/h5><img alt=\"运行删除操作前的属性\" src=\"/sunshine_new/images/负1153016377/image021.jpg\" width=\"763\" height=\"510\" /><p><a href=\"#N10144\" class=\"ibm-popup-link\" onclick=\"ibmweb.overlay.show('N10144',this);return false;\">点击查看大图<\/a><\/p><div id=\"N10144\" class=\"dw-sidefile-overlay ibm-common-overlay ibm-overlay-alt-two\"><div class=\"ibm-head\"><p><a href=\"#close\" class=\"ibm-common-overlay-close\">关闭 [x]<\/a><\/p><\/div><div class=\"ibm-body\"><div class=\"ibm-main\"><div class=\"ibm-title\"><h2>图 10. 运行删除操作前的属性<\/h2><\/div><div class=\"ibm-container ibm-alternate\"><div class=\"ibm-container-body\"><img alt=\"运行删除操作前的属性\" src=\"/sunshine_new/images/负1153016377/image021.jpg\" width=\"954\" /><\/div><\/div><\/div><\/div><div class=\"ibm-footer\"><><\/div><\/div><p>如上图所示，CQPROV 由于 validate 被改成 false，则不同于规则 5 的情况，删除将不再检验，并提示删除成功，Clear Case 和 CQ provider 端都删掉了互相关联信息。<\/p><p>如果我们通过 replace 操作使 enable 也为 false，Clear Case 端的操作返回速度将很快成功如图所示：<\/p><h5 id=\"N1014E\">图 11. 活动 Activity 的解关联操作<\/h5><img alt=\"活动 Activity 的解关联操作\" src=\"/sunshine_new/images/负1153016377/image023.jpg\" width=\"650\" /><p>由于 provider 没有激活集成即 enable=false，底层操作将不和 provider 通信，所以仅在 Clear Case 本地操作，而 provider cq 上的关联信息仍然没有更改，此 activity 仍然关联在 provider 上。如下图所示：<\/p><h5 id=\"N1015C\">图 12. RTC 里验证操作结果<\/h5><img alt=\"RTC 里验证操作结果\" src=\"/sunshine_new/images/负1153016377/image025.jpg\" width=\"579\" /><p><strong>规则 11：<\/strong>对于 rmactivity 操作，如果使用 CMI，将不同于 chactivity 命令, 此命令总会成功，同时如果配置的 Provider 的属性 enable 为 true 将更新 Clear Case 和 CQ provider 两端的集成信息，如果 enable 为 false 将只更新 Clear Case 端的信息。<\/p><h5 id=\"N1016C\">图 13.\n    活动 Activity 的删除活动 Activity 操作<\/h5><img alt=\"活动 Activity 的删除活动 Activity 操作\" src=\"/sunshine_new/images/负1153016377/image027.jpg\" width=\"728\" height=\"460\" /><p><a href=\"#N10173\" class=\"ibm-popup-link\" onclick=\"ibmweb.overlay.show('N10173',this);return false;\">点击查看大图<\/a><\/p><div id=\"N10173\" class=\"dw-sidefile-overlay ibm-common-overlay ibm-overlay-alt-two\"><div class=\"ibm-head\"><p><a href=\"#close\" class=\"ibm-common-overlay-close\">关闭 [x]<\/a><\/p><\/div><div class=\"ibm-body\"><div class=\"ibm-main\"><div class=\"ibm-title\"><h2>图 13.\n    活动 Activity 的删除活动 Activity 操作<\/h2><\/div><div class=\"ibm-container ibm-alternate\"><div class=\"ibm-container-body\"><img alt=\"活动 Activity 的删除活动 Activity 操作\" src=\"/sunshine_new/images/负1153016377/image027.jpg\" width=\"910\" /><\/div><\/div><\/div><\/div><div class=\"ibm-footer\"><><\/div><\/div><p>    如上图所示，此 activity 关联两个 provider 的 task，其中 CQPROV 的 enable 和 validate 都是 true，如果使用 chact 命令删除此 task 关联，将如规则 5 所示，报错不会被删除，而如果用 rmactivity 命令，将无视规则约束，结果 activity 和此 activity 的 task 都会被删除，同时 CQ provider 也会随之更新。<\/p><h2 id=\"1.结论 |outline\">结论<\/h2><p>本文在您了解了如何使用 Configuration management Interface 来实现 UCM Clear Case 与 ClearQuest 及 RTC 的集成的基础上详细介绍了集成操作中所要遵循的一些规则，这些规则一些来自于 Clear Case UCM 集成的最佳实践，一些来自于 CMI 的一些配置属性，这些配置属性影响了活动（UCM）或分支（Branch）的增删改。Clear Case 集成 CMI 的 log 文件都保存在以下路径的 cmi_log 文件里。<\/p><p>Windows：<\/p><p>C:\\Program Files\\IBM\\RationalSDLC\\Clear Case\\var\\log（Clear Case 默认安装路径）<\/p><p>Linux：  <\/p><p>/var/adm/atria/log<\/p><p>您可以查看此 log 文件了解详细运行日志和报错信息。<\/p><p>希望通过本文，用户在使用 CMI 集成时作为参考，并帮助用户了解操作错误的原因以及如何修复。<\/p><CMA ID: 975222><Site ID: 10><XSLT stylesheet used to transform this file: dw-document-html-7.0.xsl>\r\n\r\n\r\n<\/div>\r\n<\/div>\r\n","createTime":"2014-06-23 00:00:00","deployTime":"2014-06-23 00:00:00","id":0,"intro":"本文总结了 UCM ClearCase CMI 的 11 条常用规则和错误解决方法。在您完成前文的阅读后，了解了 CMI 在 Base/UCM 的使用后，需要注意在使用中必须遵循一些最佳实践的 CMI 规则。这些规则是基于了 Rational ClearCase 等 CLM 产品特性，以及软件生命周期的最佳实践，并描述了 CMI 通过哪些配置属性来约束这些规则，以及这些规则没有被遵从时报错信息和处理。供您在使用 CMI 完成集成功能时作参考。","keyword":"","recommend":false,"source":"http://www.ibm.com/developerworks/cn/rational/1406_zhaoliang_ccclm2/index.html","title":"Rational ClearCase 通过 CMI 和 CLM 产品集成的规则描述","typeId":0,"updateTime":"2014-06-23 00:00:00"}
